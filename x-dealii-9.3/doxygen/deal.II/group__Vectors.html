<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/group__Vectors.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Vector classes</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.3.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.3.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#enumval-members">Enumerator</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a> &#124;
<a href="#friend-members">Friends</a>  </div>
  <div class="headertitle">
<div class="title">Vector classes<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Vector classes:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__Vectors.svg" width="727" height="388"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__Exceptions"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html">Exceptions and assertions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockVector.html">BlockVector&lt; Number &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structis__serial__vector_3_01BlockVector_3_01Number_01_4_01_4.html">is_serial_vector&lt; BlockVector&lt; Number &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structIsBlockVector.html">IsBlockVector&lt; VectorType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">internal::BlockVectorIterators::Iterator&lt; BlockVectorType, Constness &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockVectorBase.html">BlockVectorBase&lt; VectorType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html">LinearAlgebra::CUDAWrappers::Vector&lt; Number &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector&lt; Number &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinternal_1_1LinearOperatorImplementation_1_1ReinitHelper.html">internal::LinearOperatorImplementation::ReinitHelper&lt; Vector &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinternal_1_1LinearOperatorImplementation_1_1ReinitHelper_3_01LinearAlgebra_1_1distributed_1_1Vector_3_01Number_01_4_01_4.html">internal::LinearOperatorImplementation::ReinitHelper&lt; LinearAlgebra::distributed::Vector&lt; Number &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1LinearOperatorImplementation_1_1ReinitHelper_3_01LinearAlgebra_1_1distributed_4a1282d020cabbaffebe5b90bd62626f.html">internal::LinearOperatorImplementation::ReinitHelper&lt; LinearAlgebra::distributed::Vector&lt; Number &gt; &gt;::has_get_mpi_communicator&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1LinearOperatorImplementation_1_1ReinitHelper_3_01LinearAlgebra_1_1distributed_67b8e913192f170b93a7d6978fef4153.html">internal::LinearOperatorImplementation::ReinitHelper&lt; LinearAlgebra::distributed::Vector&lt; Number &gt; &gt;::has_locally_owned_domain_indices&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1LinearOperatorImplementation_1_1ReinitHelper_3_01LinearAlgebra_1_1distributed_a829601ff1c9c5ad3f8c378622c2df1c.html">internal::LinearOperatorImplementation::ReinitHelper&lt; LinearAlgebra::distributed::Vector&lt; Number &gt; &gt;::has_locally_owned_range_indices&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1LinearOperatorImplementation_1_1ReinitHelper_3_01LinearAlgebra_1_1distributed_8ff2d397caecf464466c13ccb129a90d.html">internal::LinearOperatorImplementation::ReinitHelper&lt; LinearAlgebra::distributed::Vector&lt; Number &gt; &gt;::has_initialize_dof_vector&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1Vector.html">LinearAlgebra::Vector&lt; Number &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockVector.html">PETScWrappers::MPI::BlockVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector&lt; Number &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector_1_1FunctorTemplate.html">LinearAlgebra::ReadWriteVector&lt; Number &gt;::FunctorTemplate&lt; Functor &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1EpetraWrappers_1_1Vector.html">LinearAlgebra::EpetraWrappers::Vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1TpetraWrappers_1_1Vector.html">LinearAlgebra::TpetraWrappers::Vector&lt; Number &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html">Vector&lt; Number &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structis__serial__vector_3_01Vector_3_01Number_01_4_01_4.html">is_serial_vector&lt; Vector&lt; Number &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVectorOperation.html">VectorOperation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gad801fdb88f327a64805e0cd9d333d499"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gad801fdb88f327a64805e0cd9d333d499">BlockVector&lt; Number &gt;::BaseClass</a> = <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &gt;</td></tr>
<tr class="separator:gad801fdb88f327a64805e0cd9d333d499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8da0f24e108bcfde98dbcb07d528bff9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga8da0f24e108bcfde98dbcb07d528bff9">BlockVector&lt; Number &gt;::BlockType</a> = typename <a class="el" href="group__Exceptions.html#gaeb971802cf05add5cf1c26338ce77a9b">BaseClass::BlockType</a></td></tr>
<tr class="separator:ga8da0f24e108bcfde98dbcb07d528bff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5623a846ef43840761d167225ff55143"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga5623a846ef43840761d167225ff55143">BlockVector&lt; Number &gt;::value_type</a> = typename <a class="el" href="group__Exceptions.html#ga6055b029c116fd1fd580bfab2d4234ae">BaseClass::value_type</a></td></tr>
<tr class="separator:ga5623a846ef43840761d167225ff55143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4fddb03f96ed446025baa7bc84bfc76"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaf4fddb03f96ed446025baa7bc84bfc76">BlockVector&lt; Number &gt;::real_type</a> = typename <a class="el" href="group__Exceptions.html#gab62c4ac95c3782bb2236bf67038adc20">BaseClass::real_type</a></td></tr>
<tr class="separator:gaf4fddb03f96ed446025baa7bc84bfc76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88285af62463c49b442057968eadc85e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga88285af62463c49b442057968eadc85e">BlockVector&lt; Number &gt;::pointer</a> = typename <a class="el" href="group__Exceptions.html#gaebed52638e6b26f5f18adec8a2437852">BaseClass::pointer</a></td></tr>
<tr class="separator:ga88285af62463c49b442057968eadc85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga701db0b299b39b8e7e696908b4b533d6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga701db0b299b39b8e7e696908b4b533d6">BlockVector&lt; Number &gt;::const_pointer</a> = typename <a class="el" href="group__Exceptions.html#ga46a99911c512a1a08d5c5e237986d765">BaseClass::const_pointer</a></td></tr>
<tr class="separator:ga701db0b299b39b8e7e696908b4b533d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18701503f179ce207fe5a4a802446588"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga18701503f179ce207fe5a4a802446588">BlockVector&lt; Number &gt;::reference</a> = typename <a class="el" href="group__Exceptions.html#ga9a15d476a8495a66f32508943c91294f">BaseClass::reference</a></td></tr>
<tr class="separator:ga18701503f179ce207fe5a4a802446588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c1278cafe161bf9a17ccb0e3e785963"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga0c1278cafe161bf9a17ccb0e3e785963">BlockVector&lt; Number &gt;::const_reference</a> = typename <a class="el" href="group__Exceptions.html#ga490c8bf68dceb08dc60c2a3e0c6bf2a2">BaseClass::const_reference</a></td></tr>
<tr class="separator:ga0c1278cafe161bf9a17ccb0e3e785963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0855e15b27a3f125629272a1b969920"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gab0855e15b27a3f125629272a1b969920">BlockVector&lt; Number &gt;::size_type</a> = typename <a class="el" href="group__Exceptions.html#ga5c50677a9f39b52e75474f172059ed45">BaseClass::size_type</a></td></tr>
<tr class="separator:gab0855e15b27a3f125629272a1b969920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99f27555dfea7b98585d12d963cb4c29"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga99f27555dfea7b98585d12d963cb4c29">BlockVector&lt; Number &gt;::iterator</a> = typename <a class="el" href="group__Exceptions.html#ga38316f0d1b9b1e4fa4dc3e0b4e15655e">BaseClass::iterator</a></td></tr>
<tr class="separator:ga99f27555dfea7b98585d12d963cb4c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1f781c26e3c31336f49bfea8f142018"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaf1f781c26e3c31336f49bfea8f142018">BlockVector&lt; Number &gt;::const_iterator</a> = typename <a class="el" href="group__Exceptions.html#ga84ecd5753f1f75fbe1fa76e7ec72b3d8">BaseClass::const_iterator</a></td></tr>
<tr class="separator:gaf1f781c26e3c31336f49bfea8f142018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1bcff6afb8cf43ac20e2cb12005472b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaa1bcff6afb8cf43ac20e2cb12005472b">internal::BlockVectorIterators::Iterator&lt; BlockVectorType, Constness &gt;::size_type</a> = <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td></tr>
<tr class="separator:gaa1bcff6afb8cf43ac20e2cb12005472b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabec7bbc4933bcd638ccb1aaf652dd4e8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gabec7bbc4933bcd638ccb1aaf652dd4e8">internal::BlockVectorIterators::Iterator&lt; BlockVectorType, Constness &gt;::value_type</a> = typename std::conditional&lt; Constness, const typename BlockVectorType::value_type, typename BlockVectorType::value_type &gt;::type</td></tr>
<tr class="separator:gabec7bbc4933bcd638ccb1aaf652dd4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c81e1ee0ea6ba9bbc812a704d45669e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga9c81e1ee0ea6ba9bbc812a704d45669e">internal::BlockVectorIterators::Iterator&lt; BlockVectorType, Constness &gt;::iterator_category</a> = std::random_access_iterator_tag</td></tr>
<tr class="separator:ga9c81e1ee0ea6ba9bbc812a704d45669e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8cb3bf4001514075bff8361519b6046"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gad8cb3bf4001514075bff8361519b6046">internal::BlockVectorIterators::Iterator&lt; BlockVectorType, Constness &gt;::difference_type</a> = std::ptrdiff_t</td></tr>
<tr class="separator:gad8cb3bf4001514075bff8361519b6046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf093a52ba95924c752c078ef1f94e923"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaf093a52ba95924c752c078ef1f94e923">internal::BlockVectorIterators::Iterator&lt; BlockVectorType, Constness &gt;::reference</a> = typename BlockVectorType::reference</td></tr>
<tr class="separator:gaf093a52ba95924c752c078ef1f94e923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69afde293e371e48b3328b2bc7778cc9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga69afde293e371e48b3328b2bc7778cc9">internal::BlockVectorIterators::Iterator&lt; BlockVectorType, Constness &gt;::pointer</a> = <a class="el" href="group__Vectors.html#gabec7bbc4933bcd638ccb1aaf652dd4e8">value_type</a> *</td></tr>
<tr class="separator:ga69afde293e371e48b3328b2bc7778cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d181875a1af61daa02e34ccb0862e0b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga9d181875a1af61daa02e34ccb0862e0b">internal::BlockVectorIterators::Iterator&lt; BlockVectorType, Constness &gt;::dereference_type</a> = typename std::conditional&lt; Constness, <a class="el" href="group__Vectors.html#gabec7bbc4933bcd638ccb1aaf652dd4e8">value_type</a>, typename BlockVectorType::BlockType::reference &gt;::type</td></tr>
<tr class="separator:ga9d181875a1af61daa02e34ccb0862e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6cb619cadbaa9635f3cc6dba1d3b923"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gac6cb619cadbaa9635f3cc6dba1d3b923">internal::BlockVectorIterators::Iterator&lt; BlockVectorType, Constness &gt;::BlockVector</a> = typename std::conditional&lt; Constness, const BlockVectorType, BlockVectorType &gt;::type</td></tr>
<tr class="separator:gac6cb619cadbaa9635f3cc6dba1d3b923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f13f25da5172afa079df9d2804cef98"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga2f13f25da5172afa079df9d2804cef98">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::BaseClass</a> = <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt; &gt;</td></tr>
<tr class="separator:ga2f13f25da5172afa079df9d2804cef98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga976be8dace145bc740fc4b5eaa08ecfc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga976be8dace145bc740fc4b5eaa08ecfc">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::BlockType</a> = typename <a class="el" href="group__Exceptions.html#gaeb971802cf05add5cf1c26338ce77a9b">BaseClass::BlockType</a></td></tr>
<tr class="separator:ga976be8dace145bc740fc4b5eaa08ecfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a43b405989a623b76a92efe2dfa5e39"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga0a43b405989a623b76a92efe2dfa5e39">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::value_type</a> = typename <a class="el" href="group__Exceptions.html#ga6055b029c116fd1fd580bfab2d4234ae">BaseClass::value_type</a></td></tr>
<tr class="separator:ga0a43b405989a623b76a92efe2dfa5e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab99352244c902251dcd351118e7c468a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gab99352244c902251dcd351118e7c468a">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::real_type</a> = typename <a class="el" href="group__Exceptions.html#gab62c4ac95c3782bb2236bf67038adc20">BaseClass::real_type</a></td></tr>
<tr class="separator:gab99352244c902251dcd351118e7c468a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc2cd36158818c25e48e79bc9f27827e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gafc2cd36158818c25e48e79bc9f27827e">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::pointer</a> = typename <a class="el" href="group__Exceptions.html#gaebed52638e6b26f5f18adec8a2437852">BaseClass::pointer</a></td></tr>
<tr class="separator:gafc2cd36158818c25e48e79bc9f27827e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae230c8ce0c95764c28d22176b8bd396a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gae230c8ce0c95764c28d22176b8bd396a">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::const_pointer</a> = typename <a class="el" href="group__Exceptions.html#ga46a99911c512a1a08d5c5e237986d765">BaseClass::const_pointer</a></td></tr>
<tr class="separator:gae230c8ce0c95764c28d22176b8bd396a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae30d22265b642d73ed2ced13942ebb52"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gae30d22265b642d73ed2ced13942ebb52">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::reference</a> = typename <a class="el" href="group__Exceptions.html#ga9a15d476a8495a66f32508943c91294f">BaseClass::reference</a></td></tr>
<tr class="separator:gae30d22265b642d73ed2ced13942ebb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4bf062593cccb0f3f8c3daca8d77f6f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gab4bf062593cccb0f3f8c3daca8d77f6f">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::const_reference</a> = typename <a class="el" href="group__Exceptions.html#ga490c8bf68dceb08dc60c2a3e0c6bf2a2">BaseClass::const_reference</a></td></tr>
<tr class="separator:gab4bf062593cccb0f3f8c3daca8d77f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa000c54aa3fc182e5f05422233af7257"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaa000c54aa3fc182e5f05422233af7257">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::size_type</a> = typename <a class="el" href="group__Exceptions.html#ga5c50677a9f39b52e75474f172059ed45">BaseClass::size_type</a></td></tr>
<tr class="separator:gaa000c54aa3fc182e5f05422233af7257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f9a7abde54c56cd458765868a4a6da3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga6f9a7abde54c56cd458765868a4a6da3">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::iterator</a> = typename <a class="el" href="group__Exceptions.html#ga38316f0d1b9b1e4fa4dc3e0b4e15655e">BaseClass::iterator</a></td></tr>
<tr class="separator:ga6f9a7abde54c56cd458765868a4a6da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae404965061ae3d6eb991582f3c492e36"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gae404965061ae3d6eb991582f3c492e36">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::const_iterator</a> = typename <a class="el" href="group__Exceptions.html#ga84ecd5753f1f75fbe1fa76e7ec72b3d8">BaseClass::const_iterator</a></td></tr>
<tr class="separator:gae404965061ae3d6eb991582f3c492e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae018e039c0ca78a063c6a075be461283"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gae018e039c0ca78a063c6a075be461283">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::memory_space</a> = MemorySpace</td></tr>
<tr class="separator:gae018e039c0ca78a063c6a075be461283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca4439cf261c308591c649e442d097ea"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaca4439cf261c308591c649e442d097ea">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::value_type</a> = Number</td></tr>
<tr class="separator:gaca4439cf261c308591c649e442d097ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5c3b93ed114bc9795c0e3b3d5902393"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gae5c3b93ed114bc9795c0e3b3d5902393">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::pointer</a> = <a class="el" href="group__Vectors.html#gaca4439cf261c308591c649e442d097ea">value_type</a> *</td></tr>
<tr class="separator:gae5c3b93ed114bc9795c0e3b3d5902393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84413e605d193829856edbaa9d75b57b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga84413e605d193829856edbaa9d75b57b">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::const_pointer</a> = const <a class="el" href="group__Vectors.html#gaca4439cf261c308591c649e442d097ea">value_type</a> *</td></tr>
<tr class="separator:ga84413e605d193829856edbaa9d75b57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35abed3e6b898142990cecf00e8387da"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga35abed3e6b898142990cecf00e8387da">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::iterator</a> = <a class="el" href="group__Vectors.html#gaca4439cf261c308591c649e442d097ea">value_type</a> *</td></tr>
<tr class="separator:ga35abed3e6b898142990cecf00e8387da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a990da0f1e95dd6004fbf0cf711c53d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga4a990da0f1e95dd6004fbf0cf711c53d">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::const_iterator</a> = const <a class="el" href="group__Vectors.html#gaca4439cf261c308591c649e442d097ea">value_type</a> *</td></tr>
<tr class="separator:ga4a990da0f1e95dd6004fbf0cf711c53d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2ae1224f3b1fbee6cc8ffa59901d6c8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gae2ae1224f3b1fbee6cc8ffa59901d6c8">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::reference</a> = <a class="el" href="group__Vectors.html#gaca4439cf261c308591c649e442d097ea">value_type</a> &amp;</td></tr>
<tr class="separator:gae2ae1224f3b1fbee6cc8ffa59901d6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1aa37d6cce7c7fe31452d2bae09dc7ba"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga1aa37d6cce7c7fe31452d2bae09dc7ba">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::const_reference</a> = const <a class="el" href="group__Vectors.html#gaca4439cf261c308591c649e442d097ea">value_type</a> &amp;</td></tr>
<tr class="separator:ga1aa37d6cce7c7fe31452d2bae09dc7ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga301cc0a1214a6aeb04bb4e1dd06a8dfc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::size_type</a> = <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td></tr>
<tr class="separator:ga301cc0a1214a6aeb04bb4e1dd06a8dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34599939674e79cdc3808bb074bcf0ee"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga34599939674e79cdc3808bb074bcf0ee">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::real_type</a> = typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#ga34599939674e79cdc3808bb074bcf0ee">real_type</a></td></tr>
<tr class="separator:ga34599939674e79cdc3808bb074bcf0ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81ab101056e685ef358597528a48ccb7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga81ab101056e685ef358597528a48ccb7">LinearAlgebra::Vector&lt; Number &gt;::size_type</a> = <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td></tr>
<tr class="separator:ga81ab101056e685ef358597528a48ccb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad23ad800e8a9a3bc7c4867c6ae884d19"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gad23ad800e8a9a3bc7c4867c6ae884d19">LinearAlgebra::Vector&lt; Number &gt;::value_type</a> = typename <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#gad23ad800e8a9a3bc7c4867c6ae884d19">value_type</a></td></tr>
<tr class="separator:gad23ad800e8a9a3bc7c4867c6ae884d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7e6eda86837a55c4972c1b7d68b333f"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:gac7e6eda86837a55c4972c1b7d68b333f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gac7e6eda86837a55c4972c1b7d68b333f">parallel::distributed::BlockVector</a> = <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;</td></tr>
<tr class="separator:gac7e6eda86837a55c4972c1b7d68b333f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78ebbb3c3d63dcb5c40a1484ad4d4aea"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga78ebbb3c3d63dcb5c40a1484ad4d4aea">LinearAlgebra::ReadWriteVector&lt; Number &gt;::value_type</a> = Number</td></tr>
<tr class="separator:ga78ebbb3c3d63dcb5c40a1484ad4d4aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cbec4e320847462189ff8f4add8453c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga4cbec4e320847462189ff8f4add8453c">LinearAlgebra::ReadWriteVector&lt; Number &gt;::pointer</a> = <a class="el" href="group__Vectors.html#ga78ebbb3c3d63dcb5c40a1484ad4d4aea">value_type</a> *</td></tr>
<tr class="separator:ga4cbec4e320847462189ff8f4add8453c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaad8d2c9cecb03b6591a69888ec82272"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaaad8d2c9cecb03b6591a69888ec82272">LinearAlgebra::ReadWriteVector&lt; Number &gt;::const_pointer</a> = const <a class="el" href="group__Vectors.html#ga78ebbb3c3d63dcb5c40a1484ad4d4aea">value_type</a> *</td></tr>
<tr class="separator:gaaad8d2c9cecb03b6591a69888ec82272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e28f8f12865657afed81936ca9308ac"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga5e28f8f12865657afed81936ca9308ac">LinearAlgebra::ReadWriteVector&lt; Number &gt;::iterator</a> = <a class="el" href="group__Vectors.html#ga78ebbb3c3d63dcb5c40a1484ad4d4aea">value_type</a> *</td></tr>
<tr class="separator:ga5e28f8f12865657afed81936ca9308ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac39936b0017c60e97d2c6643b612d970"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gac39936b0017c60e97d2c6643b612d970">LinearAlgebra::ReadWriteVector&lt; Number &gt;::const_iterator</a> = const <a class="el" href="group__Vectors.html#ga78ebbb3c3d63dcb5c40a1484ad4d4aea">value_type</a> *</td></tr>
<tr class="separator:gac39936b0017c60e97d2c6643b612d970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dc45e1e3848cddf1720a752c4b24345"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga6dc45e1e3848cddf1720a752c4b24345">LinearAlgebra::ReadWriteVector&lt; Number &gt;::reference</a> = <a class="el" href="group__Vectors.html#ga78ebbb3c3d63dcb5c40a1484ad4d4aea">value_type</a> &amp;</td></tr>
<tr class="separator:ga6dc45e1e3848cddf1720a752c4b24345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccc60ec8f2057ba2a6a5482a3c2c93f4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaccc60ec8f2057ba2a6a5482a3c2c93f4">LinearAlgebra::ReadWriteVector&lt; Number &gt;::const_reference</a> = const <a class="el" href="group__Vectors.html#ga78ebbb3c3d63dcb5c40a1484ad4d4aea">value_type</a> &amp;</td></tr>
<tr class="separator:gaccc60ec8f2057ba2a6a5482a3c2c93f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc1437e8371646dcca5b74c01dc064a4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gadc1437e8371646dcca5b74c01dc064a4">LinearAlgebra::ReadWriteVector&lt; Number &gt;::size_type</a> = <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td></tr>
<tr class="separator:gadc1437e8371646dcca5b74c01dc064a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1c0cad1a0b23c477db4c97ba895b038"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaf1c0cad1a0b23c477db4c97ba895b038">LinearAlgebra::ReadWriteVector&lt; Number &gt;::real_type</a> = typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#gaf1c0cad1a0b23c477db4c97ba895b038">real_type</a></td></tr>
<tr class="separator:gaf1c0cad1a0b23c477db4c97ba895b038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf239d5c3249bbed95fbabec1d17b9827"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaf239d5c3249bbed95fbabec1d17b9827">Vector&lt; Number &gt;::value_type</a> = Number</td></tr>
<tr class="separator:gaf239d5c3249bbed95fbabec1d17b9827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f7ef5265cbcae4d30f7e3fcde61a7f9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga8f7ef5265cbcae4d30f7e3fcde61a7f9">Vector&lt; Number &gt;::pointer</a> = <a class="el" href="group__Vectors.html#gaf239d5c3249bbed95fbabec1d17b9827">value_type</a> *</td></tr>
<tr class="separator:ga8f7ef5265cbcae4d30f7e3fcde61a7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a1be85b8a5e0669f9034cf8e4421a11"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga0a1be85b8a5e0669f9034cf8e4421a11">Vector&lt; Number &gt;::const_pointer</a> = const <a class="el" href="group__Vectors.html#gaf239d5c3249bbed95fbabec1d17b9827">value_type</a> *</td></tr>
<tr class="separator:ga0a1be85b8a5e0669f9034cf8e4421a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb8006e49918faaffeccd151669d0934"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gacb8006e49918faaffeccd151669d0934">Vector&lt; Number &gt;::iterator</a> = <a class="el" href="group__Vectors.html#gaf239d5c3249bbed95fbabec1d17b9827">value_type</a> *</td></tr>
<tr class="separator:gacb8006e49918faaffeccd151669d0934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31d7e7b4278a3fa08a6e5ceec3deb0fb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga31d7e7b4278a3fa08a6e5ceec3deb0fb">Vector&lt; Number &gt;::const_iterator</a> = const <a class="el" href="group__Vectors.html#gaf239d5c3249bbed95fbabec1d17b9827">value_type</a> *</td></tr>
<tr class="separator:ga31d7e7b4278a3fa08a6e5ceec3deb0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadace73f5502652dce7656ae891ddcc43"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gadace73f5502652dce7656ae891ddcc43">Vector&lt; Number &gt;::reference</a> = <a class="el" href="group__Vectors.html#gaf239d5c3249bbed95fbabec1d17b9827">value_type</a> &amp;</td></tr>
<tr class="separator:gadace73f5502652dce7656ae891ddcc43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b7a89720422deb00992571e3e7cf1ce"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga3b7a89720422deb00992571e3e7cf1ce">Vector&lt; Number &gt;::const_reference</a> = const <a class="el" href="group__Vectors.html#gaf239d5c3249bbed95fbabec1d17b9827">value_type</a> &amp;</td></tr>
<tr class="separator:ga3b7a89720422deb00992571e3e7cf1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5927fb109e04d1d4988dae5c910fc32d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga5927fb109e04d1d4988dae5c910fc32d">Vector&lt; Number &gt;::size_type</a> = <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td></tr>
<tr class="separator:ga5927fb109e04d1d4988dae5c910fc32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02452a5983fd0e8c956ab9278213bd2c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga02452a5983fd0e8c956ab9278213bd2c">Vector&lt; Number &gt;::real_type</a> = typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#ga02452a5983fd0e8c956ab9278213bd2c">real_type</a></td></tr>
<tr class="separator:ga02452a5983fd0e8c956ab9278213bd2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga327cd3179fb6078605a14b772a0dc20d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga327cd3179fb6078605a14b772a0dc20d">LinearAlgebra::VectorSpaceVector&lt; Number &gt;::value_type</a> = Number</td></tr>
<tr class="separator:ga327cd3179fb6078605a14b772a0dc20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42c84b64cfafc72e8eef6e284bf899dc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga42c84b64cfafc72e8eef6e284bf899dc">LinearAlgebra::VectorSpaceVector&lt; Number &gt;::size_type</a> = <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td></tr>
<tr class="separator:ga42c84b64cfafc72e8eef6e284bf899dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ec199439799ef30b1845bda4cbe8d43"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga6ec199439799ef30b1845bda4cbe8d43">LinearAlgebra::VectorSpaceVector&lt; Number &gt;::real_type</a> = typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#ga6ec199439799ef30b1845bda4cbe8d43">real_type</a></td></tr>
<tr class="separator:ga6ec199439799ef30b1845bda4cbe8d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga40c50779cd14ba89bbf0bd9b4561964c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> { <br />
&#160;&#160;<a class="el" href="group__Vectors.html#gga40c50779cd14ba89bbf0bd9b4561964ca9c7dc8036a5632e9ed2a183c3c2812e6">VectorOperation::unknown</a>
, <a class="el" href="group__Vectors.html#gga40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>
, <a class="el" href="group__Vectors.html#gga40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>
, <a class="el" href="group__Vectors.html#gga40c50779cd14ba89bbf0bd9b4561964ca5e8042e5d04399d125cb923eda7a8d8b">VectorOperation::min</a>
, <br />
&#160;&#160;<a class="el" href="group__Vectors.html#gga40c50779cd14ba89bbf0bd9b4561964caaae8b002691d4887ce68ecf3e785c13e">VectorOperation::max</a>
<br />
 }</td></tr>
<tr class="separator:ga40c50779cd14ba89bbf0bd9b4561964c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8e45553e4f28aa527bf2554cd027d08e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga8e45553e4f28aa527bf2554cd027d08e">BlockVector&lt; Number &gt;::BlockVector</a> (const unsigned int <a class="el" href="group__Exceptions.html#ga3a0d11493903975ee387841aa3cb5fc4">n_blocks</a>=0, const <a class="el" href="group__Vectors.html#gab0855e15b27a3f125629272a1b969920">size_type</a> block_size=0)</td></tr>
<tr class="separator:ga8e45553e4f28aa527bf2554cd027d08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78986a9eadec7f2be667dbcb3fa6add5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga78986a9eadec7f2be667dbcb3fa6add5">BlockVector&lt; Number &gt;::BlockVector</a> (const <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:ga78986a9eadec7f2be667dbcb3fa6add5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98949dda578d30c3c61a598b3f698a24"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga98949dda578d30c3c61a598b3f698a24">BlockVector&lt; Number &gt;::BlockVector</a> (<a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:ga98949dda578d30c3c61a598b3f698a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e2ba6b81105354a3786ab5756dd889b"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:ga5e2ba6b81105354a3786ab5756dd889b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga5e2ba6b81105354a3786ab5756dd889b">BlockVector&lt; Number &gt;::BlockVector</a> (const <a class="el" href="classBlockVector.html">BlockVector</a>&lt; OtherNumber &gt; &amp;v)</td></tr>
<tr class="separator:ga5e2ba6b81105354a3786ab5756dd889b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43e4fb44c3389c26f45a0c08282f07bd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga43e4fb44c3389c26f45a0c08282f07bd">BlockVector&lt; Number &gt;::BlockVector</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;v)</td></tr>
<tr class="separator:ga43e4fb44c3389c26f45a0c08282f07bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00bf81924e022728fc6870cc7340b08e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga00bf81924e022728fc6870cc7340b08e">BlockVector&lt; Number &gt;::BlockVector</a> (const std::vector&lt; <a class="el" href="group__Vectors.html#gab0855e15b27a3f125629272a1b969920">size_type</a> &gt; &amp;block_sizes)</td></tr>
<tr class="separator:ga00bf81924e022728fc6870cc7340b08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c1be582d9a0a10db6101abe60d0d1d3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga4c1be582d9a0a10db6101abe60d0d1d3">BlockVector&lt; Number &gt;::BlockVector</a> (const <a class="el" href="classBlockIndices.html">BlockIndices</a> &amp;<a class="el" href="group__Exceptions.html#gaad1e20030f38cf12a1bd73c7f2c657d4">block_indices</a>)</td></tr>
<tr class="separator:ga4c1be582d9a0a10db6101abe60d0d1d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4a4befcc007d8beed7e1dd91fe9c5e9"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:gad4a4befcc007d8beed7e1dd91fe9c5e9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gad4a4befcc007d8beed7e1dd91fe9c5e9">BlockVector&lt; Number &gt;::BlockVector</a> (const std::vector&lt; <a class="el" href="group__Vectors.html#gab0855e15b27a3f125629272a1b969920">size_type</a> &gt; &amp;block_sizes, const InputIterator <a class="el" href="grid__out_8cc.html#a827a345f29da7caeb588b11013869a01">first</a>, const InputIterator <a class="el" href="group__Exceptions.html#gaa2e328fa354198c4e77e9a81de88a726">end</a>)</td></tr>
<tr class="separator:gad4a4befcc007d8beed7e1dd91fe9c5e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d37feebc46fc1af1306d66f72e9f545"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga8d37feebc46fc1af1306d66f72e9f545">BlockVector&lt; Number &gt;::~BlockVector</a> () override=default</td></tr>
<tr class="separator:ga8d37feebc46fc1af1306d66f72e9f545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad581edc4d3b86a88c4277117c4fae57a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gad581edc4d3b86a88c4277117c4fae57a">BlockVector&lt; Number &gt;::compress</a> (::<a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation=::<a class="el" href="group__Vectors.html#gga40c50779cd14ba89bbf0bd9b4561964ca9c7dc8036a5632e9ed2a183c3c2812e6">VectorOperation::unknown</a>)</td></tr>
<tr class="separator:gad581edc4d3b86a88c4277117c4fae57a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ddd3ad89fdeadf962828ee0c6d74b6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga3ddd3ad89fdeadf962828ee0c6d74b6f">BlockVector&lt; Number &gt;::has_ghost_elements</a> () const</td></tr>
<tr class="separator:ga3ddd3ad89fdeadf962828ee0c6d74b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa7d25220450aed5b09fa859eec359d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockVector.html">BlockVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaaa7d25220450aed5b09fa859eec359d8">BlockVector&lt; Number &gt;::operator=</a> (const <a class="el" href="group__Vectors.html#ga5623a846ef43840761d167225ff55143">value_type</a> s)</td></tr>
<tr class="separator:gaaa7d25220450aed5b09fa859eec359d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdc66f58f974c73cfe4b26171f188b3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gabdc66f58f974c73cfe4b26171f188b3c">BlockVector&lt; Number &gt;::operator=</a> (const <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:gabdc66f58f974c73cfe4b26171f188b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e0b08637a753fbfd5c639a53f1f77f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga9e0b08637a753fbfd5c639a53f1f77f9">BlockVector&lt; Number &gt;::operator=</a> (<a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&amp;)=default</td></tr>
<tr class="separator:ga9e0b08637a753fbfd5c639a53f1f77f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfcc8e87be6276987172a0558eb89a23"><td class="memTemplParams" colspan="2">template&lt;class Number2 &gt; </td></tr>
<tr class="memitem:gabfcc8e87be6276987172a0558eb89a23"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gabfcc8e87be6276987172a0558eb89a23">BlockVector&lt; Number &gt;::operator=</a> (const <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number2 &gt; &amp;V)</td></tr>
<tr class="separator:gabfcc8e87be6276987172a0558eb89a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40dd83907896cc3ab1334d530e934692"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga40dd83907896cc3ab1334d530e934692">BlockVector&lt; Number &gt;::operator=</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:ga40dd83907896cc3ab1334d530e934692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cf7dc779cd3e07a022b43bfb87f0bfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga1cf7dc779cd3e07a022b43bfb87f0bfc">BlockVector&lt; Number &gt;::operator=</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;V)</td></tr>
<tr class="separator:ga1cf7dc779cd3e07a022b43bfb87f0bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf4d1d6c3538af95309a95da2ded758c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gadf4d1d6c3538af95309a95da2ded758c">BlockVector&lt; Number &gt;::reinit</a> (const unsigned int <a class="el" href="group__Exceptions.html#ga3a0d11493903975ee387841aa3cb5fc4">n_blocks</a>, const <a class="el" href="group__Vectors.html#gab0855e15b27a3f125629272a1b969920">size_type</a> block_size=0, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false)</td></tr>
<tr class="separator:gadf4d1d6c3538af95309a95da2ded758c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga994786648a6e71dcd0e26c8d4895659c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga994786648a6e71dcd0e26c8d4895659c">BlockVector&lt; Number &gt;::reinit</a> (const std::vector&lt; <a class="el" href="group__Vectors.html#gab0855e15b27a3f125629272a1b969920">size_type</a> &gt; &amp;block_sizes, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false)</td></tr>
<tr class="separator:ga994786648a6e71dcd0e26c8d4895659c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga143400e3263cf7d79197c8236b35956f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga143400e3263cf7d79197c8236b35956f">BlockVector&lt; Number &gt;::reinit</a> (const <a class="el" href="classBlockIndices.html">BlockIndices</a> &amp;<a class="el" href="group__Exceptions.html#gaad1e20030f38cf12a1bd73c7f2c657d4">block_indices</a>, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false)</td></tr>
<tr class="separator:ga143400e3263cf7d79197c8236b35956f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf32bbcd70be08db7bd5db4eb413dff6a"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:gaf32bbcd70be08db7bd5db4eb413dff6a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaf32bbcd70be08db7bd5db4eb413dff6a">BlockVector&lt; Number &gt;::reinit</a> (const <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number2 &gt; &amp;V, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false)</td></tr>
<tr class="separator:gaf32bbcd70be08db7bd5db4eb413dff6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91880bf03fd7fd2b6fb5d0512d4c8711"><td class="memTemplParams" colspan="2">template&lt;class BlockVector2 &gt; </td></tr>
<tr class="memitem:ga91880bf03fd7fd2b6fb5d0512d4c8711"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga91880bf03fd7fd2b6fb5d0512d4c8711">BlockVector&lt; Number &gt;::scale</a> (const BlockVector2 &amp;v)</td></tr>
<tr class="separator:ga91880bf03fd7fd2b6fb5d0512d4c8711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga159d4a8b6dc3e036c04482a661c3e5d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga159d4a8b6dc3e036c04482a661c3e5d9">BlockVector&lt; Number &gt;::swap</a> (<a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:ga159d4a8b6dc3e036c04482a661c3e5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e5f2a8ad93c314833469b89f2d6ec8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga1e5f2a8ad93c314833469b89f2d6ec8b">BlockVector&lt; Number &gt;::print</a> (std::ostream &amp;out, const unsigned int precision=3, const <a class="el" href="classbool.html">bool</a> scientific=true, const <a class="el" href="classbool.html">bool</a> across=true) const</td></tr>
<tr class="separator:ga1e5f2a8ad93c314833469b89f2d6ec8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87c16a08fe250763830f42c517f6d0ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga87c16a08fe250763830f42c517f6d0ae">BlockVector&lt; Number &gt;::block_write</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:ga87c16a08fe250763830f42c517f6d0ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9afdd3848e94d63790bc1ba1041c3560"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga9afdd3848e94d63790bc1ba1041c3560">BlockVector&lt; Number &gt;::block_read</a> (std::istream &amp;in)</td></tr>
<tr class="separator:ga9afdd3848e94d63790bc1ba1041c3560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2a64fee4774f141397d2ab5838e6b2f"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:gae2a64fee4774f141397d2ab5838e6b2f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gae2a64fee4774f141397d2ab5838e6b2f">swap</a> (<a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt; &amp;u, <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:gae2a64fee4774f141397d2ab5838e6b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ee6fdddb0ec9fb3c8d4e16abc17f6a3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4ee6fdddb0ec9fb3c8d4e16abc17f6a3"><td class="memTemplItemLeft" align="right" valign="top">static std::true_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga4ee6fdddb0ec9fb3c8d4e16abc17f6a3">IsBlockVector&lt; VectorType &gt;::check_for_block_vector</a> (const <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; T &gt; *)</td></tr>
<tr class="separator:ga4ee6fdddb0ec9fb3c8d4e16abc17f6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab8dd8f67ddc91a78389088d662711e4"><td class="memItemLeft" align="right" valign="top">static std::false_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaab8dd8f67ddc91a78389088d662711e4">IsBlockVector&lt; VectorType &gt;::check_for_block_vector</a> (...)</td></tr>
<tr class="separator:gaab8dd8f67ddc91a78389088d662711e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ec9730a429aaea74edebb4f3c346155"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga9ec9730a429aaea74edebb4f3c346155">internal::BlockVectorIterators::Iterator&lt; BlockVectorType, Constness &gt;::Iterator</a> (<a class="el" href="group__Vectors.html#gac6cb619cadbaa9635f3cc6dba1d3b923">BlockVector</a> &amp;<a class="el" href="group__Exceptions.html#gab3e8e039512e93985be6e05ec1f3a3d1">parent</a>, const <a class="el" href="group__Vectors.html#gaa1bcff6afb8cf43ac20e2cb12005472b">size_type</a> <a class="el" href="group__Exceptions.html#ga49f1c385f5da45f441e8c99724c841e1">global_index</a>)</td></tr>
<tr class="separator:ga9ec9730a429aaea74edebb4f3c346155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82cbb244c2ae9eb411fbaeeff6ab6e53"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga82cbb244c2ae9eb411fbaeeff6ab6e53">internal::BlockVectorIterators::Iterator&lt; BlockVectorType, Constness &gt;::Iterator</a> (const <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">Iterator</a>&lt; BlockVectorType, !Constness &gt; &amp;c)</td></tr>
<tr class="separator:ga82cbb244c2ae9eb411fbaeeff6ab6e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga850782f06274933fe5177fdc3b3036f7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga850782f06274933fe5177fdc3b3036f7">internal::BlockVectorIterators::Iterator&lt; BlockVectorType, Constness &gt;::Iterator</a> (const <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">Iterator</a> &amp;c)</td></tr>
<tr class="separator:ga850782f06274933fe5177fdc3b3036f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73e4d9e0541196fdaa17c604e6a648bc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga73e4d9e0541196fdaa17c604e6a648bc">internal::BlockVectorIterators::Iterator&lt; BlockVectorType, Constness &gt;::Iterator</a> (<a class="el" href="group__Vectors.html#gac6cb619cadbaa9635f3cc6dba1d3b923">BlockVector</a> &amp;<a class="el" href="group__Exceptions.html#gab3e8e039512e93985be6e05ec1f3a3d1">parent</a>, const <a class="el" href="group__Vectors.html#gaa1bcff6afb8cf43ac20e2cb12005472b">size_type</a> <a class="el" href="group__Exceptions.html#ga49f1c385f5da45f441e8c99724c841e1">global_index</a>, const <a class="el" href="group__Vectors.html#gaa1bcff6afb8cf43ac20e2cb12005472b">size_type</a> <a class="el" href="group__Exceptions.html#gaacddc3da038dc09818a82fb6648c20b3">current_block</a>, const <a class="el" href="group__Vectors.html#gaa1bcff6afb8cf43ac20e2cb12005472b">size_type</a> <a class="el" href="group__Exceptions.html#gaeb0dad5135d75b1fbe9f55830bfe30a1">index_within_block</a>, const <a class="el" href="group__Vectors.html#gaa1bcff6afb8cf43ac20e2cb12005472b">size_type</a> <a class="el" href="group__Exceptions.html#gaa285b101a92c85e9173fafc196e25902">next_break_forward</a>, const <a class="el" href="group__Vectors.html#gaa1bcff6afb8cf43ac20e2cb12005472b">size_type</a> <a class="el" href="group__Exceptions.html#gad2a921b2c7e46d80509058e86c68faa8">next_break_backward</a>)</td></tr>
<tr class="separator:ga73e4d9e0541196fdaa17c604e6a648bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabf2702b7981d15938041d8d735f3c07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">Iterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaabf2702b7981d15938041d8d735f3c07">internal::BlockVectorIterators::Iterator&lt; BlockVectorType, Constness &gt;::operator=</a> (const <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">Iterator</a> &amp;c)</td></tr>
<tr class="separator:gaabf2702b7981d15938041d8d735f3c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88e0b47ebdc4fa9741856af70c402275"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Vectors.html#ga9d181875a1af61daa02e34ccb0862e0b">dereference_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga88e0b47ebdc4fa9741856af70c402275">internal::BlockVectorIterators::Iterator&lt; BlockVectorType, Constness &gt;::operator*</a> () const</td></tr>
<tr class="separator:ga88e0b47ebdc4fa9741856af70c402275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b8ece554d2c4e233a3d715ddd5e7165"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Vectors.html#ga9d181875a1af61daa02e34ccb0862e0b">dereference_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga5b8ece554d2c4e233a3d715ddd5e7165">internal::BlockVectorIterators::Iterator&lt; BlockVectorType, Constness &gt;::operator[]</a> (const <a class="el" href="group__Vectors.html#gad8cb3bf4001514075bff8361519b6046">difference_type</a> d) const</td></tr>
<tr class="separator:ga5b8ece554d2c4e233a3d715ddd5e7165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1d778ac6c7dc073ee109f97480a1ddd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">Iterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gab1d778ac6c7dc073ee109f97480a1ddd">internal::BlockVectorIterators::Iterator&lt; BlockVectorType, Constness &gt;::operator++</a> ()</td></tr>
<tr class="separator:gab1d778ac6c7dc073ee109f97480a1ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8dd3053d6bab44623b5cdf72ae19a09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gac8dd3053d6bab44623b5cdf72ae19a09">internal::BlockVectorIterators::Iterator&lt; BlockVectorType, Constness &gt;::operator++</a> (int)</td></tr>
<tr class="separator:gac8dd3053d6bab44623b5cdf72ae19a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd53b8d73d007ba3e42003153d14d841"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">Iterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gafd53b8d73d007ba3e42003153d14d841">internal::BlockVectorIterators::Iterator&lt; BlockVectorType, Constness &gt;::operator--</a> ()</td></tr>
<tr class="separator:gafd53b8d73d007ba3e42003153d14d841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6c24849c69b440d5c002a13c07d5d95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaa6c24849c69b440d5c002a13c07d5d95">internal::BlockVectorIterators::Iterator&lt; BlockVectorType, Constness &gt;::operator--</a> (int)</td></tr>
<tr class="separator:gaa6c24849c69b440d5c002a13c07d5d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14ab0af961d4aae22b8d3947b7a0dbb3"><td class="memTemplParams" colspan="2">template&lt;bool OtherConstness&gt; </td></tr>
<tr class="memitem:ga14ab0af961d4aae22b8d3947b7a0dbb3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga14ab0af961d4aae22b8d3947b7a0dbb3">internal::BlockVectorIterators::Iterator&lt; BlockVectorType, Constness &gt;::operator==</a> (const <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">Iterator</a>&lt; BlockVectorType, OtherConstness &gt; &amp;i) const</td></tr>
<tr class="separator:ga14ab0af961d4aae22b8d3947b7a0dbb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6659c8c704fa68fb690cdff1f363218"><td class="memTemplParams" colspan="2">template&lt;bool OtherConstness&gt; </td></tr>
<tr class="memitem:gaf6659c8c704fa68fb690cdff1f363218"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaf6659c8c704fa68fb690cdff1f363218">internal::BlockVectorIterators::Iterator&lt; BlockVectorType, Constness &gt;::operator!=</a> (const <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">Iterator</a>&lt; BlockVectorType, OtherConstness &gt; &amp;i) const</td></tr>
<tr class="separator:gaf6659c8c704fa68fb690cdff1f363218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a73ea3816628cdba5ffd7e75fc811c2"><td class="memTemplParams" colspan="2">template&lt;bool OtherConstness&gt; </td></tr>
<tr class="memitem:ga6a73ea3816628cdba5ffd7e75fc811c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga6a73ea3816628cdba5ffd7e75fc811c2">internal::BlockVectorIterators::Iterator&lt; BlockVectorType, Constness &gt;::operator&lt;</a> (const <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">Iterator</a>&lt; BlockVectorType, OtherConstness &gt; &amp;i) const</td></tr>
<tr class="separator:ga6a73ea3816628cdba5ffd7e75fc811c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeff1222550319569f6d00dde93c27871"><td class="memTemplParams" colspan="2">template&lt;bool OtherConstness&gt; </td></tr>
<tr class="memitem:gaeff1222550319569f6d00dde93c27871"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaeff1222550319569f6d00dde93c27871">internal::BlockVectorIterators::Iterator&lt; BlockVectorType, Constness &gt;::operator&lt;=</a> (const <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">Iterator</a>&lt; BlockVectorType, OtherConstness &gt; &amp;i) const</td></tr>
<tr class="separator:gaeff1222550319569f6d00dde93c27871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf66ee628dd3cb921aea9eba8e21f98ab"><td class="memTemplParams" colspan="2">template&lt;bool OtherConstness&gt; </td></tr>
<tr class="memitem:gaf66ee628dd3cb921aea9eba8e21f98ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaf66ee628dd3cb921aea9eba8e21f98ab">internal::BlockVectorIterators::Iterator&lt; BlockVectorType, Constness &gt;::operator&gt;</a> (const <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">Iterator</a>&lt; BlockVectorType, OtherConstness &gt; &amp;i) const</td></tr>
<tr class="separator:gaf66ee628dd3cb921aea9eba8e21f98ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa577307394ce1c46990c0e5cbdf78d12"><td class="memTemplParams" colspan="2">template&lt;bool OtherConstness&gt; </td></tr>
<tr class="memitem:gaa577307394ce1c46990c0e5cbdf78d12"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaa577307394ce1c46990c0e5cbdf78d12">internal::BlockVectorIterators::Iterator&lt; BlockVectorType, Constness &gt;::operator&gt;=</a> (const <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">Iterator</a>&lt; BlockVectorType, OtherConstness &gt; &amp;i) const</td></tr>
<tr class="separator:gaa577307394ce1c46990c0e5cbdf78d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga920dc46d0bd64a0384a9fa3f60287fae"><td class="memTemplParams" colspan="2">template&lt;bool OtherConstness&gt; </td></tr>
<tr class="memitem:ga920dc46d0bd64a0384a9fa3f60287fae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__Vectors.html#gad8cb3bf4001514075bff8361519b6046">difference_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga920dc46d0bd64a0384a9fa3f60287fae">internal::BlockVectorIterators::Iterator&lt; BlockVectorType, Constness &gt;::operator-</a> (const <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">Iterator</a>&lt; BlockVectorType, OtherConstness &gt; &amp;i) const</td></tr>
<tr class="separator:ga920dc46d0bd64a0384a9fa3f60287fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf437ea4584dcf36bfeeb172c63b6dc9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaf437ea4584dcf36bfeeb172c63b6dc9a">internal::BlockVectorIterators::Iterator&lt; BlockVectorType, Constness &gt;::operator+</a> (const <a class="el" href="group__Vectors.html#gad8cb3bf4001514075bff8361519b6046">difference_type</a> &amp;d) const</td></tr>
<tr class="separator:gaf437ea4584dcf36bfeeb172c63b6dc9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a961f5e1a3e9dacceef15efc9958a6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga8a961f5e1a3e9dacceef15efc9958a6c">internal::BlockVectorIterators::Iterator&lt; BlockVectorType, Constness &gt;::operator-</a> (const <a class="el" href="group__Vectors.html#gad8cb3bf4001514075bff8361519b6046">difference_type</a> &amp;d) const</td></tr>
<tr class="separator:ga8a961f5e1a3e9dacceef15efc9958a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cbef2bc6d086e5203c2536265e654e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">Iterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga8cbef2bc6d086e5203c2536265e654e1">internal::BlockVectorIterators::Iterator&lt; BlockVectorType, Constness &gt;::operator+=</a> (const <a class="el" href="group__Vectors.html#gad8cb3bf4001514075bff8361519b6046">difference_type</a> &amp;d)</td></tr>
<tr class="separator:ga8cbef2bc6d086e5203c2536265e654e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b6f3aa156ff14f806e33d171d2b4a51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">Iterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga4b6f3aa156ff14f806e33d171d2b4a51">internal::BlockVectorIterators::Iterator&lt; BlockVectorType, Constness &gt;::operator-=</a> (const <a class="el" href="group__Vectors.html#gad8cb3bf4001514075bff8361519b6046">difference_type</a> &amp;d)</td></tr>
<tr class="separator:ga4b6f3aa156ff14f806e33d171d2b4a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33e1965eb91cb5e16e215e9217a71c55"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga33e1965eb91cb5e16e215e9217a71c55">internal::LinearOperatorImplementation::ReinitHelper&lt; LinearAlgebra::distributed::Vector&lt; Number &gt; &gt;::has_get_mpi_communicator&lt; T &gt;::detect</a> (...)</td></tr>
<tr class="separator:ga33e1965eb91cb5e16e215e9217a71c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2865c5f46c87f8fc63d640461516ba49"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:ga2865c5f46c87f8fc63d640461516ba49"><td class="memTemplItemLeft" align="right" valign="top">static decltype(std::declval&lt; U &gt;().get_mpi_communicator())&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga2865c5f46c87f8fc63d640461516ba49">internal::LinearOperatorImplementation::ReinitHelper&lt; LinearAlgebra::distributed::Vector&lt; Number &gt; &gt;::has_get_mpi_communicator&lt; T &gt;::detect</a> (const U &amp;)</td></tr>
<tr class="separator:ga2865c5f46c87f8fc63d640461516ba49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56022312fe71c8c4b958ab38d6f5db81"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga56022312fe71c8c4b958ab38d6f5db81">internal::LinearOperatorImplementation::ReinitHelper&lt; LinearAlgebra::distributed::Vector&lt; Number &gt; &gt;::has_locally_owned_domain_indices&lt; T &gt;::detect</a> (...)</td></tr>
<tr class="separator:ga56022312fe71c8c4b958ab38d6f5db81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d1b35db1ac8dde8fb4d31974c2726d7"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:ga2d1b35db1ac8dde8fb4d31974c2726d7"><td class="memTemplItemLeft" align="right" valign="top">static decltype(std::declval&lt; U &gt;().locally_owned_domain_indices())&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga2d1b35db1ac8dde8fb4d31974c2726d7">internal::LinearOperatorImplementation::ReinitHelper&lt; LinearAlgebra::distributed::Vector&lt; Number &gt; &gt;::has_locally_owned_domain_indices&lt; T &gt;::detect</a> (const U &amp;)</td></tr>
<tr class="separator:ga2d1b35db1ac8dde8fb4d31974c2726d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bc73349878445ff2166b1ab069f69eb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga3bc73349878445ff2166b1ab069f69eb">internal::LinearOperatorImplementation::ReinitHelper&lt; LinearAlgebra::distributed::Vector&lt; Number &gt; &gt;::has_locally_owned_range_indices&lt; T &gt;::detect</a> (...)</td></tr>
<tr class="separator:ga3bc73349878445ff2166b1ab069f69eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab135f50d6f101b59817a0e27bfe92092"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:gab135f50d6f101b59817a0e27bfe92092"><td class="memTemplItemLeft" align="right" valign="top">static decltype(std::declval&lt; U &gt;().locally_owned_range_indices())&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gab135f50d6f101b59817a0e27bfe92092">internal::LinearOperatorImplementation::ReinitHelper&lt; LinearAlgebra::distributed::Vector&lt; Number &gt; &gt;::has_locally_owned_range_indices&lt; T &gt;::detect</a> (const U &amp;)</td></tr>
<tr class="separator:gab135f50d6f101b59817a0e27bfe92092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41ecc6007d7fcd495df08efe4cf1e275"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga41ecc6007d7fcd495df08efe4cf1e275">internal::LinearOperatorImplementation::ReinitHelper&lt; LinearAlgebra::distributed::Vector&lt; Number &gt; &gt;::has_initialize_dof_vector&lt; T &gt;::detect</a> (...)</td></tr>
<tr class="separator:ga41ecc6007d7fcd495df08efe4cf1e275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefbebd59134c254383766e2a10bef603"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:gaefbebd59134c254383766e2a10bef603"><td class="memTemplItemLeft" align="right" valign="top">static decltype(std::declval&lt; U &gt;().initialize_dof_vector(std::declval&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number &gt; &amp; &gt;()))&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaefbebd59134c254383766e2a10bef603">internal::LinearOperatorImplementation::ReinitHelper&lt; LinearAlgebra::distributed::Vector&lt; Number &gt; &gt;::has_initialize_dof_vector&lt; T &gt;::detect</a> (const U &amp;)</td></tr>
<tr class="separator:gaefbebd59134c254383766e2a10bef603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4580b978dacc9bea5f60a3bbcc2f9f7"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename std::enable_if&lt; has_get_mpi_communicator&lt; MatrixType &gt;::value &amp;&amp;has_locally_owned_domain_indices&lt; MatrixType &gt;::value, MatrixType &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gad4580b978dacc9bea5f60a3bbcc2f9f7"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gad4580b978dacc9bea5f60a3bbcc2f9f7">internal::LinearOperatorImplementation::ReinitHelper&lt; LinearAlgebra::distributed::Vector&lt; Number &gt; &gt;::reinit_domain_vector</a> (MatrixType &amp;mat, <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number &gt; &amp;vec, <a class="el" href="classbool.html">bool</a>)</td></tr>
<tr class="separator:gad4580b978dacc9bea5f60a3bbcc2f9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3eb0b92ae4d682329e13171ec9145c1b"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename std::enable_if&lt; has_get_mpi_communicator&lt; MatrixType &gt;::value &amp;&amp;has_locally_owned_range_indices&lt; MatrixType &gt;::value, MatrixType &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3eb0b92ae4d682329e13171ec9145c1b"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga3eb0b92ae4d682329e13171ec9145c1b">internal::LinearOperatorImplementation::ReinitHelper&lt; LinearAlgebra::distributed::Vector&lt; Number &gt; &gt;::reinit_range_vector</a> (MatrixType &amp;mat, <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number &gt; &amp;vec, <a class="el" href="classbool.html">bool</a>)</td></tr>
<tr class="separator:ga3eb0b92ae4d682329e13171ec9145c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e76154cdf026cc7fd2e32d7e1de7d7b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga4e76154cdf026cc7fd2e32d7e1de7d7b">LinearAlgebra::Vector&lt; Number &gt;::Vector</a> ()=default</td></tr>
<tr class="separator:ga4e76154cdf026cc7fd2e32d7e1de7d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06fa00fc31e8865d1ba39e0e44aa7c5f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga06fa00fc31e8865d1ba39e0e44aa7c5f">LinearAlgebra::Vector&lt; Number &gt;::Vector</a> (const <a class="el" href="classLinearAlgebra_1_1Vector.html">Vector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:ga06fa00fc31e8865d1ba39e0e44aa7c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2de475367d8e8440fc32564a9178216f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga2de475367d8e8440fc32564a9178216f">LinearAlgebra::Vector&lt; Number &gt;::Vector</a> (const <a class="el" href="group__Vectors.html#ga81ab101056e685ef358597528a48ccb7">size_type</a> n)</td></tr>
<tr class="separator:ga2de475367d8e8440fc32564a9178216f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf441b2c23134f8e6e08c833f918888a2"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:gaf441b2c23134f8e6e08c833f918888a2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaf441b2c23134f8e6e08c833f918888a2">LinearAlgebra::Vector&lt; Number &gt;::Vector</a> (const InputIterator <a class="el" href="grid__out_8cc.html#a827a345f29da7caeb588b11013869a01">first</a>, const InputIterator last)</td></tr>
<tr class="separator:gaf441b2c23134f8e6e08c833f918888a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ace9efb83033bbf80d60e49d6da337d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga5ace9efb83033bbf80d60e49d6da337d">LinearAlgebra::Vector&lt; Number &gt;::reinit</a> (const <a class="el" href="group__Vectors.html#ga81ab101056e685ef358597528a48ccb7">size_type</a> <a class="el" href="group__Vectors.html#gae5f0787421df51268c993616c2d604e9">size</a>, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false) override</td></tr>
<tr class="separator:ga5ace9efb83033bbf80d60e49d6da337d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafac30b01402f08d630d9c00151eace83"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:gafac30b01402f08d630d9c00151eace83"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gafac30b01402f08d630d9c00151eace83">LinearAlgebra::Vector&lt; Number &gt;::reinit</a> (const <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt; Number2 &gt; &amp;in_vector, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false)</td></tr>
<tr class="separator:gafac30b01402f08d630d9c00151eace83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43835ffaaf2af03d72164910c82f7ce7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga43835ffaaf2af03d72164910c82f7ce7">LinearAlgebra::Vector&lt; Number &gt;::reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;locally_stored_indices, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false) override</td></tr>
<tr class="separator:ga43835ffaaf2af03d72164910c82f7ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa64c8e418f460ed9e2886b45bf982b08"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaa64c8e418f460ed9e2886b45bf982b08">LinearAlgebra::Vector&lt; Number &gt;::reinit</a> (const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false) override</td></tr>
<tr class="separator:gaa64c8e418f460ed9e2886b45bf982b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf010746729396790ea5444245bd7e87b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaf010746729396790ea5444245bd7e87b">LinearAlgebra::Vector&lt; Number &gt;::has_ghost_elements</a> () const</td></tr>
<tr class="separator:gaf010746729396790ea5444245bd7e87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70e74e5c8e76f6f1571d77b4b7f88887"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1Vector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga70e74e5c8e76f6f1571d77b4b7f88887">LinearAlgebra::Vector&lt; Number &gt;::operator=</a> (const <a class="el" href="classLinearAlgebra_1_1Vector.html">Vector</a>&lt; Number &gt; &amp;in_vector)</td></tr>
<tr class="separator:ga70e74e5c8e76f6f1571d77b4b7f88887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadf5d3c185df855c835d3e03bbb10eba"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:gaadf5d3c185df855c835d3e03bbb10eba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1Vector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaadf5d3c185df855c835d3e03bbb10eba">LinearAlgebra::Vector&lt; Number &gt;::operator=</a> (const <a class="el" href="classLinearAlgebra_1_1Vector.html">Vector</a>&lt; Number2 &gt; &amp;in_vector)</td></tr>
<tr class="separator:gaadf5d3c185df855c835d3e03bbb10eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga557ab29f95f51396ced9cd9deb2c8581"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1Vector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga557ab29f95f51396ced9cd9deb2c8581">LinearAlgebra::Vector&lt; Number &gt;::operator=</a> (const Number s) override</td></tr>
<tr class="separator:ga557ab29f95f51396ced9cd9deb2c8581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf94005df1795ba915f56cbe9689bafe1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1Vector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaf94005df1795ba915f56cbe9689bafe1">LinearAlgebra::Vector&lt; Number &gt;::operator*=</a> (const Number factor) override</td></tr>
<tr class="separator:gaf94005df1795ba915f56cbe9689bafe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2e30d0e4ce88f2def5c702abfde3647"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1Vector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gab2e30d0e4ce88f2def5c702abfde3647">LinearAlgebra::Vector&lt; Number &gt;::operator/=</a> (const Number factor) override</td></tr>
<tr class="separator:gab2e30d0e4ce88f2def5c702abfde3647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafaac1b52eb924a1e85dcc07dfe97c1e0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1Vector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gafaac1b52eb924a1e85dcc07dfe97c1e0">LinearAlgebra::Vector&lt; Number &gt;::operator+=</a> (const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V) override</td></tr>
<tr class="separator:gafaac1b52eb924a1e85dcc07dfe97c1e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7564016986f801b180919010fd5520aa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1Vector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga7564016986f801b180919010fd5520aa">LinearAlgebra::Vector&lt; Number &gt;::operator-=</a> (const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V) override</td></tr>
<tr class="separator:ga7564016986f801b180919010fd5520aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga579d6877263ae00b309422bcd6e3d307"><td class="memItemLeft" align="right" valign="top">virtual Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga579d6877263ae00b309422bcd6e3d307">LinearAlgebra::Vector&lt; Number &gt;::operator*</a> (const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V) const override</td></tr>
<tr class="separator:ga579d6877263ae00b309422bcd6e3d307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9e93ebac6f78cc400dcc1398dc07014"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gab9e93ebac6f78cc400dcc1398dc07014">LinearAlgebra::Vector&lt; Number &gt;::import</a> (const <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt; Number &gt; &amp;V, <a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation, std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1CommunicationPatternBase.html">Utilities::MPI::CommunicationPatternBase</a> &gt; communication_pattern={}) override</td></tr>
<tr class="separator:gab9e93ebac6f78cc400dcc1398dc07014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae544cbdf92826eec01c0cceeff69817a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gae544cbdf92826eec01c0cceeff69817a">LinearAlgebra::Vector&lt; Number &gt;::add</a> (const Number a) override</td></tr>
<tr class="separator:gae544cbdf92826eec01c0cceeff69817a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9468f18bddc88c38140e99961ae0c360"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga9468f18bddc88c38140e99961ae0c360">LinearAlgebra::Vector&lt; Number &gt;::add</a> (const Number a, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V) override</td></tr>
<tr class="separator:ga9468f18bddc88c38140e99961ae0c360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c4190172e7ebc876dbdcde8617813f3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga5c4190172e7ebc876dbdcde8617813f3">LinearAlgebra::Vector&lt; Number &gt;::add</a> (const Number a, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V, const Number b, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;W) override</td></tr>
<tr class="separator:ga5c4190172e7ebc876dbdcde8617813f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0e8184f5712096bc81ef553b0d3adc5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gab0e8184f5712096bc81ef553b0d3adc5">LinearAlgebra::Vector&lt; Number &gt;::sadd</a> (const Number s, const Number a, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V) override</td></tr>
<tr class="separator:gab0e8184f5712096bc81ef553b0d3adc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45e4f966a68c411aed4525ab4ebb0645"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga45e4f966a68c411aed4525ab4ebb0645">LinearAlgebra::Vector&lt; Number &gt;::scale</a> (const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;scaling_factors) override</td></tr>
<tr class="separator:ga45e4f966a68c411aed4525ab4ebb0645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb746b1de6c4efea8e2b90e28471a398"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gafb746b1de6c4efea8e2b90e28471a398">LinearAlgebra::Vector&lt; Number &gt;::equ</a> (const Number a, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V) override</td></tr>
<tr class="separator:gafb746b1de6c4efea8e2b90e28471a398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98de521b6d2dab1cf767b6abb2ca9c17"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga98de521b6d2dab1cf767b6abb2ca9c17">LinearAlgebra::Vector&lt; Number &gt;::all_zero</a> () const override</td></tr>
<tr class="separator:ga98de521b6d2dab1cf767b6abb2ca9c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88d01435c6542c25fdad43bdb6fdd421"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__Vectors.html#gad23ad800e8a9a3bc7c4867c6ae884d19">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga88d01435c6542c25fdad43bdb6fdd421">LinearAlgebra::Vector&lt; Number &gt;::mean_value</a> () const override</td></tr>
<tr class="separator:ga88d01435c6542c25fdad43bdb6fdd421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e8d6fff438ca92832676d01f8d75c4e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#gaf1c0cad1a0b23c477db4c97ba895b038">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga7e8d6fff438ca92832676d01f8d75c4e">LinearAlgebra::Vector&lt; Number &gt;::l1_norm</a> () const override</td></tr>
<tr class="separator:ga7e8d6fff438ca92832676d01f8d75c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ecec231c62d47fe3c7aba269fd8ffb8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#gaf1c0cad1a0b23c477db4c97ba895b038">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga3ecec231c62d47fe3c7aba269fd8ffb8">LinearAlgebra::Vector&lt; Number &gt;::l2_norm</a> () const override</td></tr>
<tr class="separator:ga3ecec231c62d47fe3c7aba269fd8ffb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab77a07267e7a186d7948b09396edecff"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#gaf1c0cad1a0b23c477db4c97ba895b038">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gab77a07267e7a186d7948b09396edecff">LinearAlgebra::Vector&lt; Number &gt;::linfty_norm</a> () const override</td></tr>
<tr class="separator:gab77a07267e7a186d7948b09396edecff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecfb1b3222bb8069117f3d2c707c3060"><td class="memItemLeft" align="right" valign="top">virtual Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaecfb1b3222bb8069117f3d2c707c3060">LinearAlgebra::Vector&lt; Number &gt;::add_and_dot</a> (const Number a, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;W) override</td></tr>
<tr class="separator:gaecfb1b3222bb8069117f3d2c707c3060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5f0787421df51268c993616c2d604e9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__Vectors.html#ga81ab101056e685ef358597528a48ccb7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gae5f0787421df51268c993616c2d604e9">LinearAlgebra::Vector&lt; Number &gt;::size</a> () const override</td></tr>
<tr class="separator:gae5f0787421df51268c993616c2d604e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ecb7b79933b2e2e578187960bc79950"><td class="memItemLeft" align="right" valign="top">virtual ::<a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga6ecb7b79933b2e2e578187960bc79950">LinearAlgebra::Vector&lt; Number &gt;::locally_owned_elements</a> () const override</td></tr>
<tr class="separator:ga6ecb7b79933b2e2e578187960bc79950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d3fc386b73ef25215696c1d8beaa9d8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga9d3fc386b73ef25215696c1d8beaa9d8">LinearAlgebra::Vector&lt; Number &gt;::print</a> (std::ostream &amp;out, const unsigned int precision=3, const <a class="el" href="classbool.html">bool</a> scientific=true, const <a class="el" href="classbool.html">bool</a> across=true) const override</td></tr>
<tr class="separator:ga9d3fc386b73ef25215696c1d8beaa9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fadcc595d3e7e9ba44de8c85fd7595c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga2fadcc595d3e7e9ba44de8c85fd7595c">LinearAlgebra::Vector&lt; Number &gt;::print_as_numpy_array</a> (std::ostream &amp;out, const unsigned int precision=9) const</td></tr>
<tr class="separator:ga2fadcc595d3e7e9ba44de8c85fd7595c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4d5d8410505af4a5647773a61ab70a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gac4d5d8410505af4a5647773a61ab70a2">LinearAlgebra::Vector&lt; Number &gt;::block_write</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:gac4d5d8410505af4a5647773a61ab70a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa89063bf513a89e3f6e508ff39942600"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaa89063bf513a89e3f6e508ff39942600">LinearAlgebra::Vector&lt; Number &gt;::block_read</a> (std::istream &amp;in)</td></tr>
<tr class="separator:gaa89063bf513a89e3f6e508ff39942600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3d016b943c09add2765165f4dd4aedf"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gae3d016b943c09add2765165f4dd4aedf">LinearAlgebra::Vector&lt; Number &gt;::memory_consumption</a> () const override</td></tr>
<tr class="separator:gae3d016b943c09add2765165f4dd4aedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f95e2fb7828dfe996ab38096759bcd6"><td class="memTemplParams" colspan="2">template&lt;typename Archive &gt; </td></tr>
<tr class="memitem:ga5f95e2fb7828dfe996ab38096759bcd6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga5f95e2fb7828dfe996ab38096759bcd6">LinearAlgebra::Vector&lt; Number &gt;::serialize</a> (Archive &amp;ar, const unsigned int version)</td></tr>
<tr class="separator:ga5f95e2fb7828dfe996ab38096759bcd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c695d004ca539667dca8f1f220c67da"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga3c695d004ca539667dca8f1f220c67da">LinearAlgebra::ReadWriteVector&lt; Number &gt;::FunctorTemplate&lt; Functor &gt;::FunctorTemplate</a> (<a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt; Number &gt; &amp;<a class="el" href="group__Vectors.html#gaa0c9de09db03b21ed9d6d13ee1ba3f82">parent</a>, const Functor &amp;<a class="el" href="group__Vectors.html#gaeeb220d0b08318d41b09d3c4f1337d78">functor</a>)</td></tr>
<tr class="separator:ga3c695d004ca539667dca8f1f220c67da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga626b8a89b685a551394246345ef3e0e1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga626b8a89b685a551394246345ef3e0e1">LinearAlgebra::ReadWriteVector&lt; Number &gt;::FunctorTemplate&lt; Functor &gt;::operator()</a> (const <a class="el" href="group__Vectors.html#gadc1437e8371646dcca5b74c01dc064a4">size_type</a> <a class="el" href="group__Vectors.html#ga1c0f991527a8dd09601b764e59d097fc">begin</a>, const <a class="el" href="group__Vectors.html#gadc1437e8371646dcca5b74c01dc064a4">size_type</a> <a class="el" href="group__Vectors.html#ga4dbfbf3b3c7dcb1e96174eba41f3734c">end</a>)</td></tr>
<tr class="separator:ga626b8a89b685a551394246345ef3e0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77cffd135b29b32a9d77a1bcdef4b95a"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:ga77cffd135b29b32a9d77a1bcdef4b95a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga77cffd135b29b32a9d77a1bcdef4b95a">swap</a> (<a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;u, <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:ga77cffd135b29b32a9d77a1bcdef4b95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga809f9fb92ff19a343c238f3de52416e2"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:ga809f9fb92ff19a343c238f3de52416e2"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga809f9fb92ff19a343c238f3de52416e2">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;v)</td></tr>
<tr class="separator:ga809f9fb92ff19a343c238f3de52416e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga786d97fd050d53e86d523b1b0766f568"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga786d97fd050d53e86d523b1b0766f568">LinearAlgebra::VectorSpaceVector&lt; Number &gt;::reinit</a> (const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false)=0</td></tr>
<tr class="separator:ga786d97fd050d53e86d523b1b0766f568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5dd9195f5c8988b1c8d9cd7878228cb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gae5dd9195f5c8988b1c8d9cd7878228cb">LinearAlgebra::VectorSpaceVector&lt; Number &gt;::operator=</a> (const Number s)=0</td></tr>
<tr class="separator:gae5dd9195f5c8988b1c8d9cd7878228cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02349286c5e57d29396dfac9290d302f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga02349286c5e57d29396dfac9290d302f">LinearAlgebra::VectorSpaceVector&lt; Number &gt;::operator*=</a> (const Number factor)=0</td></tr>
<tr class="separator:ga02349286c5e57d29396dfac9290d302f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga198b28b1759b52bd5df5345be6ff8868"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga198b28b1759b52bd5df5345be6ff8868">LinearAlgebra::VectorSpaceVector&lt; Number &gt;::operator/=</a> (const Number factor)=0</td></tr>
<tr class="separator:ga198b28b1759b52bd5df5345be6ff8868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b581c9b2dd4a55c2a5998e62b195bd9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga8b581c9b2dd4a55c2a5998e62b195bd9">LinearAlgebra::VectorSpaceVector&lt; Number &gt;::operator+=</a> (const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V)=0</td></tr>
<tr class="separator:ga8b581c9b2dd4a55c2a5998e62b195bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61e201954ade41d8b8ba290e5841efb2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga61e201954ade41d8b8ba290e5841efb2">LinearAlgebra::VectorSpaceVector&lt; Number &gt;::operator-=</a> (const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V)=0</td></tr>
<tr class="separator:ga61e201954ade41d8b8ba290e5841efb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c05d3725740bda0feab10c660582669"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga0c05d3725740bda0feab10c660582669">LinearAlgebra::VectorSpaceVector&lt; Number &gt;::import</a> (const <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt; Number &gt; &amp;V, <a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation, std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1CommunicationPatternBase.html">Utilities::MPI::CommunicationPatternBase</a> &gt; communication_pattern={})=0</td></tr>
<tr class="separator:ga0c05d3725740bda0feab10c660582669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe15b048b316e02c2c88644713f9bda8"><td class="memItemLeft" align="right" valign="top">virtual Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gabe15b048b316e02c2c88644713f9bda8">LinearAlgebra::VectorSpaceVector&lt; Number &gt;::operator*</a> (const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V) const =0</td></tr>
<tr class="separator:gabe15b048b316e02c2c88644713f9bda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dbc94fab7a9b8490941588107b5d27b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga3dbc94fab7a9b8490941588107b5d27b">LinearAlgebra::VectorSpaceVector&lt; Number &gt;::add</a> (const Number a)=0</td></tr>
<tr class="separator:ga3dbc94fab7a9b8490941588107b5d27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d989f75097f8bb45e5297a262ed941d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga5d989f75097f8bb45e5297a262ed941d">LinearAlgebra::VectorSpaceVector&lt; Number &gt;::add</a> (const Number a, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V)=0</td></tr>
<tr class="separator:ga5d989f75097f8bb45e5297a262ed941d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc8bff328d603ccb5978a6b7d6543c8c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gabc8bff328d603ccb5978a6b7d6543c8c">LinearAlgebra::VectorSpaceVector&lt; Number &gt;::add</a> (const Number a, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V, const Number b, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;W)=0</td></tr>
<tr class="separator:gabc8bff328d603ccb5978a6b7d6543c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f8a5799eb407e559540aae082f9ec87"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga8f8a5799eb407e559540aae082f9ec87">LinearAlgebra::VectorSpaceVector&lt; Number &gt;::sadd</a> (const Number s, const Number a, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V)=0</td></tr>
<tr class="separator:ga8f8a5799eb407e559540aae082f9ec87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27c492ff183de02d4f75f3d152c6f0ac"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga27c492ff183de02d4f75f3d152c6f0ac">LinearAlgebra::VectorSpaceVector&lt; Number &gt;::scale</a> (const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;scaling_factors)=0</td></tr>
<tr class="separator:ga27c492ff183de02d4f75f3d152c6f0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga344fbb1ede704fb7b14e6e60048e9da3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga344fbb1ede704fb7b14e6e60048e9da3">LinearAlgebra::VectorSpaceVector&lt; Number &gt;::equ</a> (const Number a, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V)=0</td></tr>
<tr class="separator:ga344fbb1ede704fb7b14e6e60048e9da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c03a20480770e68f0d4e1e6456e78eb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga8c03a20480770e68f0d4e1e6456e78eb">LinearAlgebra::VectorSpaceVector&lt; Number &gt;::all_zero</a> () const =0</td></tr>
<tr class="separator:ga8c03a20480770e68f0d4e1e6456e78eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3e11175ad9c308d796d72aa0fc6b44b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__Vectors.html#ga327cd3179fb6078605a14b772a0dc20d">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gab3e11175ad9c308d796d72aa0fc6b44b">LinearAlgebra::VectorSpaceVector&lt; Number &gt;::mean_value</a> () const =0</td></tr>
<tr class="separator:gab3e11175ad9c308d796d72aa0fc6b44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ad9146f2c4a36cc762456b4cba21b4c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__Vectors.html#ga6ec199439799ef30b1845bda4cbe8d43">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga6ad9146f2c4a36cc762456b4cba21b4c">LinearAlgebra::VectorSpaceVector&lt; Number &gt;::l1_norm</a> () const =0</td></tr>
<tr class="separator:ga6ad9146f2c4a36cc762456b4cba21b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d4822289e1415f1bf35c84c4b7ee292"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__Vectors.html#ga6ec199439799ef30b1845bda4cbe8d43">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga2d4822289e1415f1bf35c84c4b7ee292">LinearAlgebra::VectorSpaceVector&lt; Number &gt;::l2_norm</a> () const =0</td></tr>
<tr class="separator:ga2d4822289e1415f1bf35c84c4b7ee292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf84f65fc1f6ebc21534271c42c33d159"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__Vectors.html#ga6ec199439799ef30b1845bda4cbe8d43">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaf84f65fc1f6ebc21534271c42c33d159">LinearAlgebra::VectorSpaceVector&lt; Number &gt;::linfty_norm</a> () const =0</td></tr>
<tr class="separator:gaf84f65fc1f6ebc21534271c42c33d159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89ae394fb53af7daf23705d5992f9f11"><td class="memItemLeft" align="right" valign="top">virtual Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga89ae394fb53af7daf23705d5992f9f11">LinearAlgebra::VectorSpaceVector&lt; Number &gt;::add_and_dot</a> (const Number a, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;W)=0</td></tr>
<tr class="separator:ga89ae394fb53af7daf23705d5992f9f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6207efeaeff0d0f321b35d29d58e8df2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga6207efeaeff0d0f321b35d29d58e8df2">LinearAlgebra::VectorSpaceVector&lt; Number &gt;::compress</a> (<a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>)</td></tr>
<tr class="separator:ga6207efeaeff0d0f321b35d29d58e8df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79b24c9cc50ac00221c89466a021c62a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__Vectors.html#ga42c84b64cfafc72e8eef6e284bf899dc">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga79b24c9cc50ac00221c89466a021c62a">LinearAlgebra::VectorSpaceVector&lt; Number &gt;::size</a> () const =0</td></tr>
<tr class="separator:ga79b24c9cc50ac00221c89466a021c62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47e92627a68a0a778490b5694af4212b"><td class="memItemLeft" align="right" valign="top">virtual ::<a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga47e92627a68a0a778490b5694af4212b">LinearAlgebra::VectorSpaceVector&lt; Number &gt;::locally_owned_elements</a> () const =0</td></tr>
<tr class="separator:ga47e92627a68a0a778490b5694af4212b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fcac5e46eb6bc858f1715e30db75031"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga1fcac5e46eb6bc858f1715e30db75031">LinearAlgebra::VectorSpaceVector&lt; Number &gt;::print</a> (std::ostream &amp;out, const unsigned int precision=3, const <a class="el" href="classbool.html">bool</a> scientific=true, const <a class="el" href="classbool.html">bool</a> across=true) const =0</td></tr>
<tr class="separator:ga1fcac5e46eb6bc858f1715e30db75031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4760b791f71d963298a5d49917f46555"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga4760b791f71d963298a5d49917f46555">LinearAlgebra::VectorSpaceVector&lt; Number &gt;::memory_consumption</a> () const =0</td></tr>
<tr class="separator:ga4760b791f71d963298a5d49917f46555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c9fca8ab72a89a97a9b8ebc84c7d03e"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga2c9fca8ab72a89a97a9b8ebc84c7d03e">LinearAlgebra::VectorSpaceVector&lt; Number &gt;::~VectorSpaceVector</a> ()=default</td></tr>
<tr class="separator:ga2c9fca8ab72a89a97a9b8ebc84c7d03e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42433961867fd78582a867ba7f68bd01"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:ga42433961867fd78582a867ba7f68bd01"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga42433961867fd78582a867ba7f68bd01">LinearAlgebra::set_zero_mean_value</a> (<a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;vector)</td></tr>
<tr class="separator:ga42433961867fd78582a867ba7f68bd01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2a64fee4774f141397d2ab5838e6b2f"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:gae2a64fee4774f141397d2ab5838e6b2f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gae2a64fee4774f141397d2ab5838e6b2f">swap</a> (<a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt; &amp;u, <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:gae2a64fee4774f141397d2ab5838e6b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77cffd135b29b32a9d77a1bcdef4b95a"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:ga77cffd135b29b32a9d77a1bcdef4b95a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga77cffd135b29b32a9d77a1bcdef4b95a">swap</a> (<a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;u, <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:ga77cffd135b29b32a9d77a1bcdef4b95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga809f9fb92ff19a343c238f3de52416e2"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:ga809f9fb92ff19a343c238f3de52416e2"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga809f9fb92ff19a343c238f3de52416e2">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;v)</td></tr>
<tr class="separator:ga809f9fb92ff19a343c238f3de52416e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gaf1aa9207795db77aaa6d5d0f23e8dbe7"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaf1aa9207795db77aaa6d5d0f23e8dbe7">IsBlockVector&lt; VectorType &gt;::value</a></td></tr>
<tr class="separator:gaf1aa9207795db77aaa6d5d0f23e8dbe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b58ae27edeb2cbb96a5a2496109154b"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga4b58ae27edeb2cbb96a5a2496109154b">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::communication_block_size</a> = 20</td></tr>
<tr class="separator:ga4b58ae27edeb2cbb96a5a2496109154b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42953ed0dea7466b965c0da21def4b4e"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga42953ed0dea7466b965c0da21def4b4e">internal::LinearOperatorImplementation::ReinitHelper&lt; LinearAlgebra::distributed::Vector&lt; Number &gt; &gt;::has_get_mpi_communicator&lt; T &gt;::value</a></td></tr>
<tr class="separator:ga42953ed0dea7466b965c0da21def4b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0788317f13f611a302fa6209598b62c7"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga0788317f13f611a302fa6209598b62c7">internal::LinearOperatorImplementation::ReinitHelper&lt; LinearAlgebra::distributed::Vector&lt; Number &gt; &gt;::has_locally_owned_domain_indices&lt; T &gt;::value</a></td></tr>
<tr class="separator:ga0788317f13f611a302fa6209598b62c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8932910bed82ab3389eb8f5b43c7e7a"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaa8932910bed82ab3389eb8f5b43c7e7a">internal::LinearOperatorImplementation::ReinitHelper&lt; LinearAlgebra::distributed::Vector&lt; Number &gt; &gt;::has_locally_owned_range_indices&lt; T &gt;::value</a></td></tr>
<tr class="separator:gaa8932910bed82ab3389eb8f5b43c7e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01ac428a1c72c6a8d18aab0a6ed8e130"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga01ac428a1c72c6a8d18aab0a6ed8e130">internal::LinearOperatorImplementation::ReinitHelper&lt; LinearAlgebra::distributed::Vector&lt; Number &gt; &gt;::has_initialize_dof_vector&lt; T &gt;::value</a></td></tr>
<tr class="separator:ga01ac428a1c72c6a8d18aab0a6ed8e130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0c9de09db03b21ed9d6d13ee1ba3f82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaa0c9de09db03b21ed9d6d13ee1ba3f82">LinearAlgebra::ReadWriteVector&lt; Number &gt;::FunctorTemplate&lt; Functor &gt;::parent</a></td></tr>
<tr class="separator:gaa0c9de09db03b21ed9d6d13ee1ba3f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeeb220d0b08318d41b09d3c4f1337d78"><td class="memItemLeft" align="right" valign="top">const Functor &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaeeb220d0b08318d41b09d3c4f1337d78">LinearAlgebra::ReadWriteVector&lt; Number &gt;::FunctorTemplate&lt; Functor &gt;::functor</a></td></tr>
<tr class="separator:gaeeb220d0b08318d41b09d3c4f1337d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friend-members"></a>
Friends</h2></td></tr>
<tr class="memitem:ga879f896329da9659f538e8dc9d386087"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:ga879f896329da9659f538e8dc9d386087"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga879f896329da9659f538e8dc9d386087">LinearAlgebra::Vector&lt; Number &gt;::Vector</a></td></tr>
<tr class="separator:ga879f896329da9659f538e8dc9d386087"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">6: Mixed stuff</h2></td></tr>
<tr class="memitem:ga3f1e1f118b38f6731b99f2f5bed7cd18"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga3f1e1f118b38f6731b99f2f5bed7cd18">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::partitioner</a></td></tr>
<tr class="separator:ga3f1e1f118b38f6731b99f2f5bed7cd18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3654b450369a501269a65e8fe917ef7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga3654b450369a501269a65e8fe917ef7b">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::allocated_size</a></td></tr>
<tr class="separator:ga3654b450369a501269a65e8fe917ef7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e986decf5878ef8fc13c691910bf263"><td class="memItemLeft" align="right" valign="top">mutable ::<a class="el" href="structMemorySpace_1_1MemorySpaceData.html">MemorySpace::MemorySpaceData</a>&lt; Number, MemorySpace &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga2e986decf5878ef8fc13c691910bf263">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::data</a></td></tr>
<tr class="separator:ga2e986decf5878ef8fc13c691910bf263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa22a8f4e80c1fe4ff79779dcda71a0b9"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt;::<a class="el" href="classparallel_1_1internal_1_1TBBPartitioner.html">parallel::internal::TBBPartitioner</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaa22a8f4e80c1fe4ff79779dcda71a0b9">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::thread_loop_partitioner</a></td></tr>
<tr class="separator:gaa22a8f4e80c1fe4ff79779dcda71a0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c7e2584032a7c664c2c28c0436cd6ce"><td class="memItemLeft" align="right" valign="top">mutable ::<a class="el" href="structMemorySpace_1_1MemorySpaceData.html">MemorySpace::MemorySpaceData</a>&lt; Number, MemorySpace &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga2c7e2584032a7c664c2c28c0436cd6ce">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::import_data</a></td></tr>
<tr class="separator:ga2c7e2584032a7c664c2c28c0436cd6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf41fb0de7a379de6c6a58801bd93827b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaf41fb0de7a379de6c6a58801bd93827b">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::vector_is_ghosted</a></td></tr>
<tr class="separator:gaf41fb0de7a379de6c6a58801bd93827b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae53eaaa25a65ca1ce774e713dd37154c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; MPI_Request &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gae53eaaa25a65ca1ce774e713dd37154c">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::compress_requests</a></td></tr>
<tr class="separator:gae53eaaa25a65ca1ce774e713dd37154c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada6604e63e86194c350e0c1ab9d70387"><td class="memItemLeft" align="right" valign="top">std::vector&lt; MPI_Request &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gada6604e63e86194c350e0c1ab9d70387">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::update_ghost_values_requests</a></td></tr>
<tr class="separator:gada6604e63e86194c350e0c1ab9d70387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2ca9ef90490cbf818d17fcca54a76f2"><td class="memItemLeft" align="right" valign="top">std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaf2ca9ef90490cbf818d17fcca54a76f2">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::mutex</a></td></tr>
<tr class="separator:gaf2ca9ef90490cbf818d17fcca54a76f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d06704d2372317ea90b5e5bd9c1dc9f"><td class="memItemLeft" align="right" valign="top">MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga4d06704d2372317ea90b5e5bd9c1dc9f">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::comm_sm</a></td></tr>
<tr class="separator:ga4d06704d2372317ea90b5e5bd9c1dc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac14c06b74acbf135ede85924e7b3d521"><td class="memTemplParams" colspan="2">template&lt;typename Number2 , typename MemorySpace2 &gt; </td></tr>
<tr class="memitem:gac14c06b74acbf135ede85924e7b3d521"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gac14c06b74acbf135ede85924e7b3d521">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::Vector</a></td></tr>
<tr class="separator:gac14c06b74acbf135ede85924e7b3d521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07c61e4419c2e58a70f3798109c14fac"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:ga07c61e4419c2e58a70f3798109c14fac"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga07c61e4419c2e58a70f3798109c14fac">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::BlockVector</a></td></tr>
<tr class="separator:ga07c61e4419c2e58a70f3798109c14fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga995b4962ed8eee92cb0db9678c2047eb"><td class="memItemLeft" align="right" valign="top">const MPI_Comm &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga995b4962ed8eee92cb0db9678c2047eb">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::get_mpi_communicator</a> () const</td></tr>
<tr class="separator:ga995b4962ed8eee92cb0db9678c2047eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57d72f160499a5f0bc289da5b5187546"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga57d72f160499a5f0bc289da5b5187546">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::get_partitioner</a> () const</td></tr>
<tr class="separator:ga57d72f160499a5f0bc289da5b5187546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1121c9b5aa9c34d0fe36486fecf08b58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga1121c9b5aa9c34d0fe36486fecf08b58">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::partitioners_are_compatible</a> (const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &amp;part) const</td></tr>
<tr class="separator:ga1121c9b5aa9c34d0fe36486fecf08b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f678da4f2dec42cd6f9bc383c0f3c11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga8f678da4f2dec42cd6f9bc383c0f3c11">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::partitioners_are_globally_compatible</a> (const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &amp;part) const</td></tr>
<tr class="separator:ga8f678da4f2dec42cd6f9bc383c0f3c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga662fd533f2cae84a902e7a587fc6f36c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga662fd533f2cae84a902e7a587fc6f36c">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::set_ghost_state</a> (const <a class="el" href="classbool.html">bool</a> ghosted) const</td></tr>
<tr class="separator:ga662fd533f2cae84a902e7a587fc6f36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad16bd935d90fe664309c52be1615bd4b"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classArrayView.html">ArrayView</a>&lt; const Number &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gad16bd935d90fe664309c52be1615bd4b">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::shared_vector_data</a> () const</td></tr>
<tr class="separator:gad16bd935d90fe664309c52be1615bd4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f9fec5521e69ebd55f8d7dac02cf610"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga9f9fec5521e69ebd55f8d7dac02cf610">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::add_local</a> (const Number a, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:ga9f9fec5521e69ebd55f8d7dac02cf610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7b56c7dbbe54762d35b9f536e9d9c76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gac7b56c7dbbe54762d35b9f536e9d9c76">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::sadd_local</a> (const Number s, const Number a, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:gac7b56c7dbbe54762d35b9f536e9d9c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec8a0511ae8151672f9a92a699523c52"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:gaec8a0511ae8151672f9a92a699523c52"><td class="memTemplItemLeft" align="right" valign="top">Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaec8a0511ae8151672f9a92a699523c52">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::inner_product_local</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number2, MemorySpace &gt; &amp;V) const</td></tr>
<tr class="separator:gaec8a0511ae8151672f9a92a699523c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45739e3cb34a433f67b5c0e23fa5dcf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Vectors.html#ga34599939674e79cdc3808bb074bcf0ee">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga45739e3cb34a433f67b5c0e23fa5dcf7">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::norm_sqr_local</a> () const</td></tr>
<tr class="separator:ga45739e3cb34a433f67b5c0e23fa5dcf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cab16fed261f1579c11ea5c81cb0eb7"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga0cab16fed261f1579c11ea5c81cb0eb7">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::mean_value_local</a> () const</td></tr>
<tr class="separator:ga0cab16fed261f1579c11ea5c81cb0eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2df86018fd6619067a0749deb49c6288"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Vectors.html#ga34599939674e79cdc3808bb074bcf0ee">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga2df86018fd6619067a0749deb49c6288">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::l1_norm_local</a> () const</td></tr>
<tr class="separator:ga2df86018fd6619067a0749deb49c6288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6b149f392aea2068ad62632dd865e5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Vectors.html#ga34599939674e79cdc3808bb074bcf0ee">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gac6b149f392aea2068ad62632dd865e5c">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::lp_norm_local</a> (const <a class="el" href="group__Vectors.html#ga34599939674e79cdc3808bb074bcf0ee">real_type</a> p) const</td></tr>
<tr class="separator:gac6b149f392aea2068ad62632dd865e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21bc694084db3eb69bd8bb9439787131"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Vectors.html#ga34599939674e79cdc3808bb074bcf0ee">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga21bc694084db3eb69bd8bb9439787131">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::linfty_norm_local</a> () const</td></tr>
<tr class="separator:ga21bc694084db3eb69bd8bb9439787131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fb83d9dd19884023fb6c739c1958a7a"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga1fb83d9dd19884023fb6c739c1958a7a">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::add_and_dot_local</a> (const Number a, const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;V, const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;W)</td></tr>
<tr class="separator:ga1fb83d9dd19884023fb6c739c1958a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4aaa85ec1704806392274242fa705ed8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga4aaa85ec1704806392274242fa705ed8">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::clear_mpi_requests</a> ()</td></tr>
<tr class="separator:ga4aaa85ec1704806392274242fa705ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f5a3788d6c951791217cd59f8cd9fbc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga0f5a3788d6c951791217cd59f8cd9fbc">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::resize_val</a> (const <a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> new_allocated_size, const MPI_Comm &amp;<a class="el" href="group__Vectors.html#ga4d06704d2372317ea90b5e5bd9c1dc9f">comm_sm</a>=MPI_COMM_SELF)</td></tr>
<tr class="separator:ga0f5a3788d6c951791217cd59f8cd9fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga453c188166f7296fb04e52fb788d40fd"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga453c188166f7296fb04e52fb788d40fd">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::ExcVectorTypeNotCompatible</a> ()</td></tr>
<tr class="separator:ga453c188166f7296fb04e52fb788d40fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7181557daa1b267845919814c21323bb"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga7181557daa1b267845919814c21323bb">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::ExcNotAllowedForCuda</a> ()</td></tr>
<tr class="separator:ga7181557daa1b267845919814c21323bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e3eb31c0abb4a6f0832c29849017d48"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga4e3eb31c0abb4a6f0832c29849017d48">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::ExcNonMatchingElements</a> (Number arg1, Number arg2, unsigned int arg3)</td></tr>
<tr class="separator:ga4e3eb31c0abb4a6f0832c29849017d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67e3523483dc1fbe7c4d21b0b96a2be9"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga67e3523483dc1fbe7c4d21b0b96a2be9">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::ExcAccessToNonLocalElement</a> (<a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> arg1, <a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> arg2, <a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> arg3, <a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> arg4)</td></tr>
<tr class="separator:ga67e3523483dc1fbe7c4d21b0b96a2be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">3: Modification of vectors</h2></td></tr>
<tr class="memitem:gafc5ab96d5e5729daebc67f6972cf7d7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gafc5ab96d5e5729daebc67f6972cf7d7e">LinearAlgebra::ReadWriteVector&lt; Number &gt;::stored_elements</a></td></tr>
<tr class="separator:gafc5ab96d5e5729daebc67f6972cf7d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc229cf3f043c2d7ecc0ecacc2f39f2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gabc229cf3f043c2d7ecc0ecacc2f39f2e">LinearAlgebra::ReadWriteVector&lt; Number &gt;::source_stored_elements</a></td></tr>
<tr class="separator:gabc229cf3f043c2d7ecc0ecacc2f39f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaede32a438077b03a579151b0f9175fbc"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classUtilities_1_1MPI_1_1CommunicationPatternBase.html">Utilities::MPI::CommunicationPatternBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaede32a438077b03a579151b0f9175fbc">LinearAlgebra::ReadWriteVector&lt; Number &gt;::comm_pattern</a></td></tr>
<tr class="separator:gaede32a438077b03a579151b0f9175fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18f97cb8e503f790483ddaddfa768a25"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; Number[], decltype(std::free) * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga18f97cb8e503f790483ddaddfa768a25">LinearAlgebra::ReadWriteVector&lt; Number &gt;::values</a></td></tr>
<tr class="separator:ga18f97cb8e503f790483ddaddfa768a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1527d12757fb046479195b42143df76"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt;::<a class="el" href="classparallel_1_1internal_1_1TBBPartitioner.html">parallel::internal::TBBPartitioner</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaf1527d12757fb046479195b42143df76">LinearAlgebra::ReadWriteVector&lt; Number &gt;::thread_loop_partitioner</a></td></tr>
<tr class="separator:gaf1527d12757fb046479195b42143df76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c84d108d27ea3c0df7f0d8417b08f11"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:ga1c84d108d27ea3c0df7f0d8417b08f11"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga1c84d108d27ea3c0df7f0d8417b08f11">LinearAlgebra::ReadWriteVector&lt; Number &gt;::ReadWriteVector</a></td></tr>
<tr class="separator:ga1c84d108d27ea3c0df7f0d8417b08f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20d03806be45070a19e1c809819b4b74"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:ga20d03806be45070a19e1c809819b4b74"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga20d03806be45070a19e1c809819b4b74">LinearAlgebra::ReadWriteVector&lt; Number &gt;::add</a> (const std::vector&lt; <a class="el" href="group__Vectors.html#gadc1437e8371646dcca5b74c01dc064a4">size_type</a> &gt; &amp;indices, const std::vector&lt; Number2 &gt; &amp;<a class="el" href="group__Vectors.html#ga18f97cb8e503f790483ddaddfa768a25">values</a>)</td></tr>
<tr class="separator:ga20d03806be45070a19e1c809819b4b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga557e8adec1fd28216d0ebb7ca4a9b213"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:ga557e8adec1fd28216d0ebb7ca4a9b213"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga557e8adec1fd28216d0ebb7ca4a9b213">LinearAlgebra::ReadWriteVector&lt; Number &gt;::add</a> (const std::vector&lt; <a class="el" href="group__Vectors.html#gadc1437e8371646dcca5b74c01dc064a4">size_type</a> &gt; &amp;indices, const <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt; Number2 &gt; &amp;<a class="el" href="group__Vectors.html#ga18f97cb8e503f790483ddaddfa768a25">values</a>)</td></tr>
<tr class="separator:ga557e8adec1fd28216d0ebb7ca4a9b213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77cc92419018a05c262f946cef212f63"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:ga77cc92419018a05c262f946cef212f63"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga77cc92419018a05c262f946cef212f63">LinearAlgebra::ReadWriteVector&lt; Number &gt;::add</a> (const <a class="el" href="group__Vectors.html#gadc1437e8371646dcca5b74c01dc064a4">size_type</a> <a class="el" href="group__Vectors.html#gaedac815f15ee3c78363e02baa97457e0">n_elements</a>, const <a class="el" href="group__Vectors.html#gadc1437e8371646dcca5b74c01dc064a4">size_type</a> *indices, const Number2 *<a class="el" href="group__Vectors.html#ga18f97cb8e503f790483ddaddfa768a25">values</a>)</td></tr>
<tr class="separator:ga77cc92419018a05c262f946cef212f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30e936065ac760ac8ce71741374a2576"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga30e936065ac760ac8ce71741374a2576">LinearAlgebra::ReadWriteVector&lt; Number &gt;::print</a> (std::ostream &amp;out, const unsigned int precision=3, const <a class="el" href="classbool.html">bool</a> scientific=true) const</td></tr>
<tr class="separator:ga30e936065ac760ac8ce71741374a2576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2457ff17e4f00e2a964769dfcefebdb3"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga2457ff17e4f00e2a964769dfcefebdb3">LinearAlgebra::ReadWriteVector&lt; Number &gt;::memory_consumption</a> () const</td></tr>
<tr class="separator:ga2457ff17e4f00e2a964769dfcefebdb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf005c963a8c3eacb0dbcc57af085239e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaf005c963a8c3eacb0dbcc57af085239e">LinearAlgebra::ReadWriteVector&lt; Number &gt;::import</a> (const Tpetra::Vector&lt; Number, int, <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;tpetra_vector, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;locally_owned_elements, <a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation, const MPI_Comm &amp;mpi_comm, const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1CommunicationPatternBase.html">Utilities::MPI::CommunicationPatternBase</a> &gt; &amp;communication_pattern)</td></tr>
<tr class="separator:gaf005c963a8c3eacb0dbcc57af085239e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada3a3abdf4f08d06bb4fe99551ef188f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gada3a3abdf4f08d06bb4fe99551ef188f">LinearAlgebra::ReadWriteVector&lt; Number &gt;::import</a> (const Epetra_MultiVector &amp;multivector, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;locally_owned_elements, <a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation, const MPI_Comm &amp;mpi_comm, const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1CommunicationPatternBase.html">Utilities::MPI::CommunicationPatternBase</a> &gt; &amp;communication_pattern)</td></tr>
<tr class="separator:gada3a3abdf4f08d06bb4fe99551ef188f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f246ddfbf22f0f8a54274a6540228d7"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga6f246ddfbf22f0f8a54274a6540228d7">LinearAlgebra::ReadWriteVector&lt; Number &gt;::global_to_local</a> (const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> global_index) const</td></tr>
<tr class="separator:ga6f246ddfbf22f0f8a54274a6540228d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga714412eda5ff0683842db5a92947db2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga714412eda5ff0683842db5a92947db2f">LinearAlgebra::ReadWriteVector&lt; Number &gt;::resize_val</a> (const <a class="el" href="group__Vectors.html#gadc1437e8371646dcca5b74c01dc064a4">size_type</a> new_allocated_size)</td></tr>
<tr class="separator:ga714412eda5ff0683842db5a92947db2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga264014f023c96eb2bffd450ee31a8c19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1TpetraWrappers_1_1CommunicationPattern.html">TpetraWrappers::CommunicationPattern</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga264014f023c96eb2bffd450ee31a8c19">LinearAlgebra::ReadWriteVector&lt; Number &gt;::create_tpetra_comm_pattern</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;source_index_set, const MPI_Comm &amp;mpi_comm)</td></tr>
<tr class="separator:ga264014f023c96eb2bffd450ee31a8c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79499404d7d07670c72c36e065e5e060"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1EpetraWrappers_1_1CommunicationPattern.html">EpetraWrappers::CommunicationPattern</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga79499404d7d07670c72c36e065e5e060">LinearAlgebra::ReadWriteVector&lt; Number &gt;::create_epetra_comm_pattern</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;source_index_set, const MPI_Comm &amp;mpi_comm)</td></tr>
<tr class="separator:ga79499404d7d07670c72c36e065e5e060"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Information about the object</h2></td></tr>
<tr class="memitem:gab392612c190ffa0dd4daa4eea36507c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; Number &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gab392612c190ffa0dd4daa4eea36507c4">Vector&lt; Number &gt;::values</a></td></tr>
<tr class="separator:gab392612c190ffa0dd4daa4eea36507c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga566a66df753d0a75121aa84fa4164d56"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classparallel_1_1internal_1_1TBBPartitioner.html">parallel::internal::TBBPartitioner</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga566a66df753d0a75121aa84fa4164d56">Vector&lt; Number &gt;::thread_loop_partitioner</a></td></tr>
<tr class="separator:ga566a66df753d0a75121aa84fa4164d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga879f896329da9659f538e8dc9d386087"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:ga879f896329da9659f538e8dc9d386087"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga879f896329da9659f538e8dc9d386087">Vector&lt; Number &gt;::Vector</a></td></tr>
<tr class="separator:ga879f896329da9659f538e8dc9d386087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21bdbe031534857b865272b4e986b830"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga21bdbe031534857b865272b4e986b830">Vector&lt; Number &gt;::in_local_range</a> (const <a class="el" href="group__Vectors.html#ga5927fb109e04d1d4988dae5c910fc32d">size_type</a> global_index) const</td></tr>
<tr class="separator:ga21bdbe031534857b865272b4e986b830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac6b216c32fbf2cddb2466a8033ad3e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaac6b216c32fbf2cddb2466a8033ad3e6">Vector&lt; Number &gt;::locally_owned_elements</a> () const</td></tr>
<tr class="separator:gaac6b216c32fbf2cddb2466a8033ad3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81dcfa5c77bdd426603386c0844149ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Vectors.html#ga5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga81dcfa5c77bdd426603386c0844149ae">Vector&lt; Number &gt;::size</a> () const</td></tr>
<tr class="separator:ga81dcfa5c77bdd426603386c0844149ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2508c8f07d54ab6a69fba59daf6df2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Vectors.html#ga5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gad2508c8f07d54ab6a69fba59daf6df2c">Vector&lt; Number &gt;::locally_owned_size</a> () const</td></tr>
<tr class="separator:gad2508c8f07d54ab6a69fba59daf6df2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae72a04de37cc5ba8f0263809a59ec99e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gae72a04de37cc5ba8f0263809a59ec99e">Vector&lt; Number &gt;::all_zero</a> () const</td></tr>
<tr class="separator:gae72a04de37cc5ba8f0263809a59ec99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8e23a22888630c9874cbddf8bcccdf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gad8e23a22888630c9874cbddf8bcccdf5">Vector&lt; Number &gt;::is_non_negative</a> () const</td></tr>
<tr class="separator:gad8e23a22888630c9874cbddf8bcccdf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea73d2cb54e87b69a9b7cdb17ed274df"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaea73d2cb54e87b69a9b7cdb17ed274df">Vector&lt; Number &gt;::memory_consumption</a> () const</td></tr>
<tr class="separator:gaea73d2cb54e87b69a9b7cdb17ed274df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ca33f52511daa54531089f98b316458"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga0ca33f52511daa54531089f98b316458">Vector&lt; Number &gt;::has_ghost_elements</a> () const</td></tr>
<tr class="separator:ga0ca33f52511daa54531089f98b316458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab49b815c8f8e5394cd0ed96a687270c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaab49b815c8f8e5394cd0ed96a687270c">Vector&lt; Number &gt;::maybe_reset_thread_partitioner</a> ()</td></tr>
<tr class="separator:gaab49b815c8f8e5394cd0ed96a687270c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27b879d09291ecb28bb0ea39d7a181b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga27b879d09291ecb28bb0ea39d7a181b6">Vector&lt; Number &gt;::do_reinit</a> (const <a class="el" href="group__Vectors.html#ga5927fb109e04d1d4988dae5c910fc32d">size_type</a> new_size, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries, const <a class="el" href="classbool.html">bool</a> reset_partitioner)</td></tr>
<tr class="separator:ga27b879d09291ecb28bb0ea39d7a181b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">1: Basic operations</h2></td></tr>
<tr class="memitem:ga28bef4c0ba10221b1aeaf200f1bd8957"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga28bef4c0ba10221b1aeaf200f1bd8957">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::BlockVector</a> (const <a class="el" href="group__Vectors.html#gaa000c54aa3fc182e5f05422233af7257">size_type</a> num_blocks=0, const <a class="el" href="group__Vectors.html#gaa000c54aa3fc182e5f05422233af7257">size_type</a> block_size=0)</td></tr>
<tr class="separator:ga28bef4c0ba10221b1aeaf200f1bd8957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77e77142f145f27e6de83c7769fee866"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga77e77142f145f27e6de83c7769fee866">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::BlockVector</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:ga77e77142f145f27e6de83c7769fee866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e6e3a3ba2c1ad09c7b2e9bde1fd52fd"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:ga6e6e3a3ba2c1ad09c7b2e9bde1fd52fd"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga6e6e3a3ba2c1ad09c7b2e9bde1fd52fd">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::BlockVector</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; OtherNumber &gt; &amp;v)</td></tr>
<tr class="separator:ga6e6e3a3ba2c1ad09c7b2e9bde1fd52fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga632b36dc3cfbe1858681e56f985b8a8a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga632b36dc3cfbe1858681e56f985b8a8a">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::BlockVector</a> (const std::vector&lt; <a class="el" href="group__Vectors.html#gaa000c54aa3fc182e5f05422233af7257">size_type</a> &gt; &amp;block_sizes)</td></tr>
<tr class="separator:ga632b36dc3cfbe1858681e56f985b8a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6a3fe3d069769bfe44cfbb12bb8d9ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gad6a3fe3d069769bfe44cfbb12bb8d9ec">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::BlockVector</a> (const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;local_ranges, const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;ghost_indices, const MPI_Comm &amp;communicator)</td></tr>
<tr class="separator:gad6a3fe3d069769bfe44cfbb12bb8d9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae44f6a147f001ce40a3390356939cedb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gae44f6a147f001ce40a3390356939cedb">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::BlockVector</a> (const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;local_ranges, const MPI_Comm &amp;communicator)</td></tr>
<tr class="separator:gae44f6a147f001ce40a3390356939cedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga599e94513f88be426a73c5ad3162b27a"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga599e94513f88be426a73c5ad3162b27a">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::~BlockVector</a> () override=default</td></tr>
<tr class="separator:ga599e94513f88be426a73c5ad3162b27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b82aa81372ebfe22ed6968ef8317417"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga2b82aa81372ebfe22ed6968ef8317417">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::operator=</a> (const <a class="el" href="group__Vectors.html#ga0a43b405989a623b76a92efe2dfa5e39">value_type</a> s) override</td></tr>
<tr class="separator:ga2b82aa81372ebfe22ed6968ef8317417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0069a784bc60ecfc7d87075927b4b086"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga0069a784bc60ecfc7d87075927b4b086">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::operator=</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a> &amp;V)</td></tr>
<tr class="separator:ga0069a784bc60ecfc7d87075927b4b086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga631ced4f5e83bbf22ece66c4ee1ea301"><td class="memTemplParams" colspan="2">template&lt;class Number2 &gt; </td></tr>
<tr class="memitem:ga631ced4f5e83bbf22ece66c4ee1ea301"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga631ced4f5e83bbf22ece66c4ee1ea301">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::operator=</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number2 &gt; &amp;V)</td></tr>
<tr class="separator:ga631ced4f5e83bbf22ece66c4ee1ea301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0806d02bb7a443ef28e810d1f4fe7381"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga0806d02bb7a443ef28e810d1f4fe7381">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::operator=</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:ga0806d02bb7a443ef28e810d1f4fe7381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaccfcceeeb6f47176b448d72945a112d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaaccfcceeeb6f47176b448d72945a112d">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::operator=</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockVector.html">PETScWrappers::MPI::BlockVector</a> &amp;petsc_vec)</td></tr>
<tr class="separator:gaaccfcceeeb6f47176b448d72945a112d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f521396d68256f73799da5a1460fdf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga3f521396d68256f73799da5a1460fdf7">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::operator=</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;trilinos_vec)</td></tr>
<tr class="separator:ga3f521396d68256f73799da5a1460fdf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7833e60852b449291aa16fcfc5b3d600"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga7833e60852b449291aa16fcfc5b3d600">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::reinit</a> (const <a class="el" href="group__Vectors.html#gaa000c54aa3fc182e5f05422233af7257">size_type</a> num_blocks, const <a class="el" href="group__Vectors.html#gaa000c54aa3fc182e5f05422233af7257">size_type</a> block_size=0, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false)</td></tr>
<tr class="separator:ga7833e60852b449291aa16fcfc5b3d600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad74c8e31c81f8ef46b26d3c958125f22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gad74c8e31c81f8ef46b26d3c958125f22">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::reinit</a> (const std::vector&lt; <a class="el" href="group__Vectors.html#gaa000c54aa3fc182e5f05422233af7257">size_type</a> &gt; &amp;N, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false)</td></tr>
<tr class="separator:gad74c8e31c81f8ef46b26d3c958125f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9ebeba63b750246591e48b468e3e737"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:gab9ebeba63b750246591e48b468e3e737"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gab9ebeba63b750246591e48b468e3e737">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::reinit</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number2 &gt; &amp;V, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false)</td></tr>
<tr class="separator:gab9ebeba63b750246591e48b468e3e737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga852d132f4827ec54f9583013a536761b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga852d132f4827ec54f9583013a536761b">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::compress</a> (::<a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation) override</td></tr>
<tr class="separator:ga852d132f4827ec54f9583013a536761b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec81b97d7e38d836457bfbc7b2f20226"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaec81b97d7e38d836457bfbc7b2f20226">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::update_ghost_values</a> () const</td></tr>
<tr class="separator:gaec81b97d7e38d836457bfbc7b2f20226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9e0cf1c878130c12b0c16cad8da0610"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gae9e0cf1c878130c12b0c16cad8da0610">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::zero_out_ghosts</a> () const</td></tr>
<tr class="separator:gae9e0cf1c878130c12b0c16cad8da0610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa205bf18350c2095d459c75edfa622db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaa205bf18350c2095d459c75edfa622db">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::zero_out_ghost_values</a> () const</td></tr>
<tr class="separator:gaa205bf18350c2095d459c75edfa622db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ac470622adef2b2aec45be681112de3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga0ac470622adef2b2aec45be681112de3">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::has_ghost_elements</a> () const</td></tr>
<tr class="separator:ga0ac470622adef2b2aec45be681112de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga872d9c74afd697767a824cdd69135ba4"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:ga872d9c74afd697767a824cdd69135ba4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga872d9c74afd697767a824cdd69135ba4">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::add</a> (const std::vector&lt; <a class="el" href="group__Vectors.html#gaa000c54aa3fc182e5f05422233af7257">size_type</a> &gt; &amp;indices, const ::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; OtherNumber &gt; &amp;values)</td></tr>
<tr class="separator:ga872d9c74afd697767a824cdd69135ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1f222571d59cc48f9d505fc7ba4d8dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gac1f222571d59cc48f9d505fc7ba4d8dd">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::sadd</a> (const Number s, const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:gac1f222571d59cc48f9d505fc7ba4d8dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga809ec1490fd39c130932290aae65355c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga809ec1490fd39c130932290aae65355c">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::all_zero</a> () const override</td></tr>
<tr class="separator:ga809ec1490fd39c130932290aae65355c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7df34df7e744cbfdb5cec39176821cf1"><td class="memItemLeft" align="right" valign="top">virtual Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga7df34df7e744cbfdb5cec39176821cf1">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::mean_value</a> () const override</td></tr>
<tr class="separator:ga7df34df7e744cbfdb5cec39176821cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab588b3e1883730aff30b5408fcf22298"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Vectors.html#gab99352244c902251dcd351118e7c468a">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gab588b3e1883730aff30b5408fcf22298">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::lp_norm</a> (const <a class="el" href="group__Vectors.html#gab99352244c902251dcd351118e7c468a">real_type</a> p) const</td></tr>
<tr class="separator:gab588b3e1883730aff30b5408fcf22298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2072c8a6af39eb4ef8aa61e18b5864c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga2072c8a6af39eb4ef8aa61e18b5864c1">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::swap</a> (<a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:ga2072c8a6af39eb4ef8aa61e18b5864c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">2: Implementation of VectorSpaceVector</h2></td></tr>
<tr class="memitem:ga456e59ce23e0da8010f74d80875f6aa5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga456e59ce23e0da8010f74d80875f6aa5">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::reinit</a> (const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false) override</td></tr>
<tr class="separator:ga456e59ce23e0da8010f74d80875f6aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5be26d6eb72dcefdec2e2305d0e1c2e6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga5be26d6eb72dcefdec2e2305d0e1c2e6">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::operator*=</a> (const Number factor) override</td></tr>
<tr class="separator:ga5be26d6eb72dcefdec2e2305d0e1c2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4daee550e5e52be51395ca7afe42896d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga4daee550e5e52be51395ca7afe42896d">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::operator/=</a> (const Number factor) override</td></tr>
<tr class="separator:ga4daee550e5e52be51395ca7afe42896d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a97828f252550978a7525b82d1e1f92"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga4a97828f252550978a7525b82d1e1f92">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::operator+=</a> (const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V) override</td></tr>
<tr class="separator:ga4a97828f252550978a7525b82d1e1f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52fb6dc78db248d8b4749632ef52d36f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga52fb6dc78db248d8b4749632ef52d36f">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::operator-=</a> (const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V) override</td></tr>
<tr class="separator:ga52fb6dc78db248d8b4749632ef52d36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8143655154d18b0c5753b00158b2e2f1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga8143655154d18b0c5753b00158b2e2f1">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::import</a> (const <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt; &amp;V, <a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation, std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1CommunicationPatternBase.html">Utilities::MPI::CommunicationPatternBase</a> &gt; communication_pattern={}) override</td></tr>
<tr class="separator:ga8143655154d18b0c5753b00158b2e2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93f5bd0dc1f676eaf0747b580b6ca468"><td class="memItemLeft" align="right" valign="top">virtual Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga93f5bd0dc1f676eaf0747b580b6ca468">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::operator*</a> (const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V) const override</td></tr>
<tr class="separator:ga93f5bd0dc1f676eaf0747b580b6ca468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae860233e47e643eb93892aa873da9889"><td class="memTemplParams" colspan="2">template&lt;typename FullMatrixType &gt; </td></tr>
<tr class="memitem:gae860233e47e643eb93892aa873da9889"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gae860233e47e643eb93892aa873da9889">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::multivector_inner_product</a> (FullMatrixType &amp;matrix, const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number &gt; &amp;V, const <a class="el" href="classbool.html">bool</a> symmetric=false) const</td></tr>
<tr class="separator:gae860233e47e643eb93892aa873da9889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0a5a9811aff25c8dd2a242d1e309547"><td class="memTemplParams" colspan="2">template&lt;typename FullMatrixType &gt; </td></tr>
<tr class="memitem:gaa0a5a9811aff25c8dd2a242d1e309547"><td class="memTemplItemLeft" align="right" valign="top">Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaa0a5a9811aff25c8dd2a242d1e309547">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::multivector_inner_product_with_metric</a> (const FullMatrixType &amp;matrix, const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number &gt; &amp;V, const <a class="el" href="classbool.html">bool</a> symmetric=false) const</td></tr>
<tr class="separator:gaa0a5a9811aff25c8dd2a242d1e309547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeda5640c41b09bae50c6c3c6a863e289"><td class="memTemplParams" colspan="2">template&lt;typename FullMatrixType &gt; </td></tr>
<tr class="memitem:gaeda5640c41b09bae50c6c3c6a863e289"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaeda5640c41b09bae50c6c3c6a863e289">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::mmult</a> (<a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number &gt; &amp;V, const FullMatrixType &amp;matrix, const Number s=Number(0.), const Number b=Number(1.)) const</td></tr>
<tr class="separator:gaeda5640c41b09bae50c6c3c6a863e289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccecdd88bcfc805d1554fc99e8f05e38"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaccecdd88bcfc805d1554fc99e8f05e38">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::add</a> (const Number a) override</td></tr>
<tr class="separator:gaccecdd88bcfc805d1554fc99e8f05e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0b1677974de1a51cade3dea2e268dd0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gab0b1677974de1a51cade3dea2e268dd0">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::add</a> (const Number a, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V) override</td></tr>
<tr class="separator:gab0b1677974de1a51cade3dea2e268dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32a59caf6a091dc576366547bb71dc86"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga32a59caf6a091dc576366547bb71dc86">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::add</a> (const Number a, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V, const Number b, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;W) override</td></tr>
<tr class="separator:ga32a59caf6a091dc576366547bb71dc86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3515ad42ca76e04aed377d32d266daa6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga3515ad42ca76e04aed377d32d266daa6">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::add</a> (const std::vector&lt; <a class="el" href="group__Vectors.html#gaa000c54aa3fc182e5f05422233af7257">size_type</a> &gt; &amp;indices, const std::vector&lt; Number &gt; &amp;values)</td></tr>
<tr class="separator:ga3515ad42ca76e04aed377d32d266daa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a306d119c19bffc19f7d99800e5de79"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga5a306d119c19bffc19f7d99800e5de79">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::sadd</a> (const Number s, const Number a, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V) override</td></tr>
<tr class="separator:ga5a306d119c19bffc19f7d99800e5de79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b50074b32093b5471d1c7e033c0f2d6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga6b50074b32093b5471d1c7e033c0f2d6">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::scale</a> (const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;scaling_factors) override</td></tr>
<tr class="separator:ga6b50074b32093b5471d1c7e033c0f2d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8bc1dd4072504da9cbea82e6ba01180"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gad8bc1dd4072504da9cbea82e6ba01180">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::equ</a> (const Number a, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V) override</td></tr>
<tr class="separator:gad8bc1dd4072504da9cbea82e6ba01180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cdf84bbe46a886cdde6bad3a4246163"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__Vectors.html#gab99352244c902251dcd351118e7c468a">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga2cdf84bbe46a886cdde6bad3a4246163">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::l1_norm</a> () const override</td></tr>
<tr class="separator:ga2cdf84bbe46a886cdde6bad3a4246163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fceaca158b4b7b17d280c618c469228"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__Vectors.html#gab99352244c902251dcd351118e7c468a">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga8fceaca158b4b7b17d280c618c469228">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::l2_norm</a> () const override</td></tr>
<tr class="separator:ga8fceaca158b4b7b17d280c618c469228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52b4564def3f222e3c54266a61c75810"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Vectors.html#gab99352244c902251dcd351118e7c468a">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga52b4564def3f222e3c54266a61c75810">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::norm_sqr</a> () const</td></tr>
<tr class="separator:ga52b4564def3f222e3c54266a61c75810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1403274bfe2ad51433f205ae1a10b6ae"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__Vectors.html#gab99352244c902251dcd351118e7c468a">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga1403274bfe2ad51433f205ae1a10b6ae">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::linfty_norm</a> () const override</td></tr>
<tr class="separator:ga1403274bfe2ad51433f205ae1a10b6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1c44bfad65af75c21d0d23af1125414"><td class="memItemLeft" align="right" valign="top">virtual Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaf1c44bfad65af75c21d0d23af1125414">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::add_and_dot</a> (const Number a, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;W) override</td></tr>
<tr class="separator:gaf1c44bfad65af75c21d0d23af1125414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8d5be159fec545106c67bc940589fcb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__Vectors.html#gaa000c54aa3fc182e5f05422233af7257">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaf8d5be159fec545106c67bc940589fcb">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::size</a> () const override</td></tr>
<tr class="separator:gaf8d5be159fec545106c67bc940589fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga468dfbd79a0d0d614327f292ee66f76a"><td class="memItemLeft" align="right" valign="top">virtual ::<a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga468dfbd79a0d0d614327f292ee66f76a">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::locally_owned_elements</a> () const override</td></tr>
<tr class="separator:ga468dfbd79a0d0d614327f292ee66f76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb764f033c38e246091f50d0ee3f8b90"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gabb764f033c38e246091f50d0ee3f8b90">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::print</a> (std::ostream &amp;out, const unsigned int precision=3, const <a class="el" href="classbool.html">bool</a> scientific=true, const <a class="el" href="classbool.html">bool</a> across=true) const override</td></tr>
<tr class="separator:gabb764f033c38e246091f50d0ee3f8b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d9c15a88fd2789219e70fd950d211e6"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga7d9c15a88fd2789219e70fd950d211e6">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::memory_consumption</a> () const override</td></tr>
<tr class="separator:ga7d9c15a88fd2789219e70fd950d211e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ecaeebd349b3741eb385e158cba9658"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga5ecaeebd349b3741eb385e158cba9658">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::ExcVectorTypeNotCompatible</a> ()</td></tr>
<tr class="separator:ga5ecaeebd349b3741eb385e158cba9658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0160d956c8460b3c0b60e1ba597d47f5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga0160d956c8460b3c0b60e1ba597d47f5">LinearAlgebra::distributed::BlockVector&lt; Number &gt;::ExcIteratorRangeDoesNotMatchVectorSize</a> ()</td></tr>
<tr class="separator:ga0160d956c8460b3c0b60e1ba597d47f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">1: Basic Object-handling</h2></td></tr>
<tr class="memitem:ga702bf4533c5ce7e4144d3d86afb31195"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga702bf4533c5ce7e4144d3d86afb31195">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::Vector</a> ()</td></tr>
<tr class="separator:ga702bf4533c5ce7e4144d3d86afb31195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60510dc0ed5441f1875cea6800645d3c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga60510dc0ed5441f1875cea6800645d3c">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::Vector</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;in_vector)</td></tr>
<tr class="separator:ga60510dc0ed5441f1875cea6800645d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3be6c4ce529bb9b6c13eb831d0a86f55"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga3be6c4ce529bb9b6c13eb831d0a86f55">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::Vector</a> (const <a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> <a class="el" href="group__Vectors.html#ga99297a298764249d0c0b5adf9a96e1c7">size</a>)</td></tr>
<tr class="separator:ga3be6c4ce529bb9b6c13eb831d0a86f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31393977fc00f2d9c46f259330ef2a23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga31393977fc00f2d9c46f259330ef2a23">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::Vector</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;local_range, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;ghost_indices, const MPI_Comm &amp;communicator)</td></tr>
<tr class="separator:ga31393977fc00f2d9c46f259330ef2a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44feea9fec2eeab75baf051b65fa8094"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga44feea9fec2eeab75baf051b65fa8094">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::Vector</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;local_range, const MPI_Comm &amp;communicator)</td></tr>
<tr class="separator:ga44feea9fec2eeab75baf051b65fa8094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe52b52803ff7d23233e37083689b8f1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gafe52b52803ff7d23233e37083689b8f1">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::Vector</a> (const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &gt; &amp;<a class="el" href="group__Vectors.html#ga3f1e1f118b38f6731b99f2f5bed7cd18">partitioner</a>)</td></tr>
<tr class="separator:gafe52b52803ff7d23233e37083689b8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99e3faeced0e8afcf1208a6955e88ffd"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga99e3faeced0e8afcf1208a6955e88ffd">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::~Vector</a> () override</td></tr>
<tr class="separator:ga99e3faeced0e8afcf1208a6955e88ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace027311492ed2f6e07fbd74d723e3a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gace027311492ed2f6e07fbd74d723e3a9">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::reinit</a> (const <a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> <a class="el" href="group__Vectors.html#ga99297a298764249d0c0b5adf9a96e1c7">size</a>, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false)</td></tr>
<tr class="separator:gace027311492ed2f6e07fbd74d723e3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a79ca37d7f7a8cfd04f5dd61d350ae5"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:ga8a79ca37d7f7a8cfd04f5dd61d350ae5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga8a79ca37d7f7a8cfd04f5dd61d350ae5">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::reinit</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number2, MemorySpace &gt; &amp;in_vector, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false)</td></tr>
<tr class="separator:ga8a79ca37d7f7a8cfd04f5dd61d350ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7415120211cbfb0b525423f5e028791e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga7415120211cbfb0b525423f5e028791e">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;local_range, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;ghost_indices, const MPI_Comm &amp;communicator)</td></tr>
<tr class="separator:ga7415120211cbfb0b525423f5e028791e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac86885392f82f70c0acdc2cc2fe272d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gac86885392f82f70c0acdc2cc2fe272d5">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;local_range, const MPI_Comm &amp;communicator)</td></tr>
<tr class="separator:gac86885392f82f70c0acdc2cc2fe272d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a4afb6f468e902618d2f3bf41da181c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga1a4afb6f468e902618d2f3bf41da181c">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::reinit</a> (const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &gt; &amp;<a class="el" href="group__Vectors.html#ga3f1e1f118b38f6731b99f2f5bed7cd18">partitioner</a>, const MPI_Comm &amp;<a class="el" href="group__Vectors.html#ga4d06704d2372317ea90b5e5bd9c1dc9f">comm_sm</a>=MPI_COMM_SELF)</td></tr>
<tr class="separator:ga1a4afb6f468e902618d2f3bf41da181c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6c95ee056cdf27d171711cd7c8f5701"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gac6c95ee056cdf27d171711cd7c8f5701">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::reinit</a> (const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> <a class="el" href="group__Vectors.html#gabebeb6ebf3dedc1123663eae12374b06">local_size</a>, const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> ghost_size, const MPI_Comm &amp;comm, const MPI_Comm &amp;<a class="el" href="group__Vectors.html#ga4d06704d2372317ea90b5e5bd9c1dc9f">comm_sm</a>=MPI_COMM_SELF)</td></tr>
<tr class="separator:gac6c95ee056cdf27d171711cd7c8f5701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ca1b9394ef76f792c06e3d4f006b4e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga2ca1b9394ef76f792c06e3d4f006b4e1">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::swap</a> (<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;v)</td></tr>
<tr class="separator:ga2ca1b9394ef76f792c06e3d4f006b4e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb2a2d81a821ae954545ca77a89fa240"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gabb2a2d81a821ae954545ca77a89fa240">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::operator=</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;in_vector)</td></tr>
<tr class="separator:gabb2a2d81a821ae954545ca77a89fa240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad364c47c5b3b7b991490cd626c729f0b"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:gad364c47c5b3b7b991490cd626c729f0b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gad364c47c5b3b7b991490cd626c729f0b">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::operator=</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number2, MemorySpace &gt; &amp;in_vector)</td></tr>
<tr class="separator:gad364c47c5b3b7b991490cd626c729f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">2: Parallel data exchange</h2></td></tr>
<tr class="memitem:ga8a204103e550697467d933388b732bda"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga8a204103e550697467d933388b732bda">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::compress</a> (::<a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation) override</td></tr>
<tr class="separator:ga8a204103e550697467d933388b732bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a6cb7d50e02022283af53c2ae14f878"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga2a6cb7d50e02022283af53c2ae14f878">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::update_ghost_values</a> () const</td></tr>
<tr class="separator:ga2a6cb7d50e02022283af53c2ae14f878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab0c01436acde21cc2dbb5576d8f2375"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaab0c01436acde21cc2dbb5576d8f2375">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::compress_start</a> (const unsigned int communication_channel=0, ::<a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation=<a class="el" href="group__Vectors.html#gga40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>)</td></tr>
<tr class="separator:gaab0c01436acde21cc2dbb5576d8f2375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada0b48d524285ca7b302da593b3321a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gada0b48d524285ca7b302da593b3321a9">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::compress_finish</a> (::<a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation)</td></tr>
<tr class="separator:gada0b48d524285ca7b302da593b3321a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7045a29ddd2b5fb86ce56c3806e08d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gab7045a29ddd2b5fb86ce56c3806e08d3">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::update_ghost_values_start</a> (const unsigned int communication_channel=0) const</td></tr>
<tr class="separator:gab7045a29ddd2b5fb86ce56c3806e08d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab305a49968449aa44e998f4364838479"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gab305a49968449aa44e998f4364838479">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::update_ghost_values_finish</a> () const</td></tr>
<tr class="separator:gab305a49968449aa44e998f4364838479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0dc3fd03c7851d5577c159703282548"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gac0dc3fd03c7851d5577c159703282548">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::zero_out_ghosts</a> () const</td></tr>
<tr class="separator:gac0dc3fd03c7851d5577c159703282548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0242ed0c3e3664e6b4204d28a726a0b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga0242ed0c3e3664e6b4204d28a726a0b7">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::zero_out_ghost_values</a> () const</td></tr>
<tr class="separator:ga0242ed0c3e3664e6b4204d28a726a0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17719d884e60b2ad0077a03b92382975"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga17719d884e60b2ad0077a03b92382975">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::has_ghost_elements</a> () const</td></tr>
<tr class="separator:ga17719d884e60b2ad0077a03b92382975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab792ddb04b95a220e489f2d7f9eee990"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:gab792ddb04b95a220e489f2d7f9eee990"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gab792ddb04b95a220e489f2d7f9eee990">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::copy_locally_owned_data_from</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number2, MemorySpace &gt; &amp;src)</td></tr>
<tr class="separator:gab792ddb04b95a220e489f2d7f9eee990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7b743d761233b92e0ed23e6bf37a409"><td class="memTemplParams" colspan="2">template&lt;typename MemorySpace2 &gt; </td></tr>
<tr class="memitem:gaf7b743d761233b92e0ed23e6bf37a409"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaf7b743d761233b92e0ed23e6bf37a409">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::import</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace2 &gt; &amp;src, <a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation)</td></tr>
<tr class="separator:gaf7b743d761233b92e0ed23e6bf37a409"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">3: Implementation of VectorSpaceVector</h2></td></tr>
<tr class="memitem:ga7bde7122a6d05d6815f507f7cb27819a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga7bde7122a6d05d6815f507f7cb27819a">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::reinit</a> (const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false) override</td></tr>
<tr class="separator:ga7bde7122a6d05d6815f507f7cb27819a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad85b449afaa8f491f01d7670bcc48099"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gad85b449afaa8f491f01d7670bcc48099">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::operator*=</a> (const Number factor) override</td></tr>
<tr class="separator:gad85b449afaa8f491f01d7670bcc48099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16146ad677e926f3bdbed2aca3248247"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga16146ad677e926f3bdbed2aca3248247">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::operator/=</a> (const Number factor) override</td></tr>
<tr class="separator:ga16146ad677e926f3bdbed2aca3248247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3eabb34382bc0694390f97616742bcdf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga3eabb34382bc0694390f97616742bcdf">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::operator+=</a> (const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V) override</td></tr>
<tr class="separator:ga3eabb34382bc0694390f97616742bcdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga132ecfef78dfec86c1b6a5423d642ae0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga132ecfef78dfec86c1b6a5423d642ae0">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::operator-=</a> (const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V) override</td></tr>
<tr class="separator:ga132ecfef78dfec86c1b6a5423d642ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad947177e38381c4fd058876a4f27f771"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gad947177e38381c4fd058876a4f27f771">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::import</a> (const <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt; &amp;V, <a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation, std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1CommunicationPatternBase.html">Utilities::MPI::CommunicationPatternBase</a> &gt; communication_pattern={}) override</td></tr>
<tr class="separator:gad947177e38381c4fd058876a4f27f771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga829281a9ccc9f1cf9720ee5a535efd21"><td class="memItemLeft" align="right" valign="top">virtual Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga829281a9ccc9f1cf9720ee5a535efd21">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::operator*</a> (const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V) const override</td></tr>
<tr class="separator:ga829281a9ccc9f1cf9720ee5a535efd21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac029174b48a0707da587b6ce3bc25047"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gac029174b48a0707da587b6ce3bc25047">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::add</a> (const Number a) override</td></tr>
<tr class="separator:gac029174b48a0707da587b6ce3bc25047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7d70c674b55edbb3595acaedc310996"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gab7d70c674b55edbb3595acaedc310996">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::add</a> (const Number a, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V) override</td></tr>
<tr class="separator:gab7d70c674b55edbb3595acaedc310996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25d752a33b33192932b0dd8054d2c40e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga25d752a33b33192932b0dd8054d2c40e">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::add</a> (const Number a, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V, const Number b, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;W) override</td></tr>
<tr class="separator:ga25d752a33b33192932b0dd8054d2c40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga883f439a5130ebbbc15f765928a0ad92"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga883f439a5130ebbbc15f765928a0ad92">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::add</a> (const std::vector&lt; <a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> &gt; &amp;indices, const std::vector&lt; Number &gt; &amp;values)</td></tr>
<tr class="separator:ga883f439a5130ebbbc15f765928a0ad92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6376a098589519491fc452d1529f57b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaa6376a098589519491fc452d1529f57b">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::sadd</a> (const Number s, const Number a, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V) override</td></tr>
<tr class="separator:gaa6376a098589519491fc452d1529f57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacdf6bfd4533c47587ba0debe177710e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaacdf6bfd4533c47587ba0debe177710e">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::scale</a> (const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;scaling_factors) override</td></tr>
<tr class="separator:gaacdf6bfd4533c47587ba0debe177710e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43c64a6bebc56d849307ef1fcad62c23"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga43c64a6bebc56d849307ef1fcad62c23">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::equ</a> (const Number a, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V) override</td></tr>
<tr class="separator:ga43c64a6bebc56d849307ef1fcad62c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e93518655d2231061f4eb916e98a130"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__Vectors.html#ga34599939674e79cdc3808bb074bcf0ee">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga0e93518655d2231061f4eb916e98a130">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::l1_norm</a> () const override</td></tr>
<tr class="separator:ga0e93518655d2231061f4eb916e98a130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf355599021a687026ab9818efd57e82d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__Vectors.html#ga34599939674e79cdc3808bb074bcf0ee">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaf355599021a687026ab9818efd57e82d">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::l2_norm</a> () const override</td></tr>
<tr class="separator:gaf355599021a687026ab9818efd57e82d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeecc4f641fb6c425eb9f12048d7e8efd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Vectors.html#ga34599939674e79cdc3808bb074bcf0ee">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaeecc4f641fb6c425eb9f12048d7e8efd">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::norm_sqr</a> () const</td></tr>
<tr class="separator:gaeecc4f641fb6c425eb9f12048d7e8efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e7bf945225df27d522ec30f1530c0aa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__Vectors.html#ga34599939674e79cdc3808bb074bcf0ee">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga2e7bf945225df27d522ec30f1530c0aa">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::linfty_norm</a> () const override</td></tr>
<tr class="separator:ga2e7bf945225df27d522ec30f1530c0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1dc41a177aadb6a2f6d0d7c2cf41eba"><td class="memItemLeft" align="right" valign="top">virtual Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaf1dc41a177aadb6a2f6d0d7c2cf41eba">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::add_and_dot</a> (const Number a, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;W) override</td></tr>
<tr class="separator:gaf1dc41a177aadb6a2f6d0d7c2cf41eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99297a298764249d0c0b5adf9a96e1c7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga99297a298764249d0c0b5adf9a96e1c7">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::size</a> () const override</td></tr>
<tr class="separator:ga99297a298764249d0c0b5adf9a96e1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff5265a5af79342c77ac50d584c9d3e4"><td class="memItemLeft" align="right" valign="top">virtual ::<a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaff5265a5af79342c77ac50d584c9d3e4">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::locally_owned_elements</a> () const override</td></tr>
<tr class="separator:gaff5265a5af79342c77ac50d584c9d3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2218dcb909cf45f3e495ac250ea9260"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gab2218dcb909cf45f3e495ac250ea9260">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::print</a> (std::ostream &amp;out, const unsigned int precision=3, const <a class="el" href="classbool.html">bool</a> scientific=true, const <a class="el" href="classbool.html">bool</a> across=true) const override</td></tr>
<tr class="separator:gab2218dcb909cf45f3e495ac250ea9260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga493afd09167ce2c18d27252178d88c59"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga493afd09167ce2c18d27252178d88c59">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::memory_consumption</a> () const override</td></tr>
<tr class="separator:ga493afd09167ce2c18d27252178d88c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">4: Other vector operations not included in VectorSpaceVector</h2></td></tr>
<tr class="memitem:ga85d501a9f8c20d9142fe6a0f88bb12a4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga85d501a9f8c20d9142fe6a0f88bb12a4">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::operator=</a> (const Number s) override</td></tr>
<tr class="separator:ga85d501a9f8c20d9142fe6a0f88bb12a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79cb76c50ddfade06995373dfc14cdb4"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:ga79cb76c50ddfade06995373dfc14cdb4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga79cb76c50ddfade06995373dfc14cdb4">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::add</a> (const std::vector&lt; <a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> &gt; &amp;indices, const ::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; OtherNumber &gt; &amp;values)</td></tr>
<tr class="separator:ga79cb76c50ddfade06995373dfc14cdb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga428a001329c576451c1a77557212527a"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:ga428a001329c576451c1a77557212527a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga428a001329c576451c1a77557212527a">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::add</a> (const <a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> n_elements, const <a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> *indices, const OtherNumber *values)</td></tr>
<tr class="separator:ga428a001329c576451c1a77557212527a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44cbdb2b9d3612d549e544dcd11a33ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga44cbdb2b9d3612d549e544dcd11a33ed">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::sadd</a> (const Number s, const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;V)</td></tr>
<tr class="separator:ga44cbdb2b9d3612d549e544dcd11a33ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">5: Entry access and local data representation</h2></td></tr>
<tr class="memitem:gabebeb6ebf3dedc1123663eae12374b06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gabebeb6ebf3dedc1123663eae12374b06">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::local_size</a> () const</td></tr>
<tr class="separator:gabebeb6ebf3dedc1123663eae12374b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3db2bea96180138f039b9d2934534492"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga3db2bea96180138f039b9d2934534492">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::locally_owned_size</a> () const</td></tr>
<tr class="separator:ga3db2bea96180138f039b9d2934534492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8fc3d0924b59159a50ed9838d8a6592"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gae8fc3d0924b59159a50ed9838d8a6592">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::in_local_range</a> (const <a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> global_index) const</td></tr>
<tr class="separator:gae8fc3d0924b59159a50ed9838d8a6592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdcd750879bde459ccb63936c74a0e87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Vectors.html#ga35abed3e6b898142990cecf00e8387da">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gafdcd750879bde459ccb63936c74a0e87">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::begin</a> ()</td></tr>
<tr class="separator:gafdcd750879bde459ccb63936c74a0e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae038db1a3998888e469398031da2b980"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Vectors.html#ga4a990da0f1e95dd6004fbf0cf711c53d">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gae038db1a3998888e469398031da2b980">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::begin</a> () const</td></tr>
<tr class="separator:gae038db1a3998888e469398031da2b980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0a4b780b6b8fded62768da4164d2378"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Vectors.html#ga35abed3e6b898142990cecf00e8387da">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gab0a4b780b6b8fded62768da4164d2378">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::end</a> ()</td></tr>
<tr class="separator:gab0a4b780b6b8fded62768da4164d2378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga362987561884296cee4ba45f4fe85abe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Vectors.html#ga4a990da0f1e95dd6004fbf0cf711c53d">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga362987561884296cee4ba45f4fe85abe">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::end</a> () const</td></tr>
<tr class="separator:ga362987561884296cee4ba45f4fe85abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac551bfa7fd898a0a8e85f59109c091ed"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gac551bfa7fd898a0a8e85f59109c091ed">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::operator()</a> (const <a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> global_index) const</td></tr>
<tr class="separator:gac551bfa7fd898a0a8e85f59109c091ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58b7c43da3b837f4b811ad4cc813d899"><td class="memItemLeft" align="right" valign="top">Number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga58b7c43da3b837f4b811ad4cc813d899">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::operator()</a> (const <a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> global_index)</td></tr>
<tr class="separator:ga58b7c43da3b837f4b811ad4cc813d899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c497852ad2b7d6917a4b60f6c7b28bf"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga5c497852ad2b7d6917a4b60f6c7b28bf">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::operator[]</a> (const <a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> global_index) const</td></tr>
<tr class="separator:ga5c497852ad2b7d6917a4b60f6c7b28bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bc5f6e645477d457a68784b83bdf582"><td class="memItemLeft" align="right" valign="top">Number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga1bc5f6e645477d457a68784b83bdf582">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::operator[]</a> (const <a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> global_index)</td></tr>
<tr class="separator:ga1bc5f6e645477d457a68784b83bdf582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c4bc946b94f19d7e11c00f41a39db02"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga1c4bc946b94f19d7e11c00f41a39db02">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::local_element</a> (const <a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> local_index) const</td></tr>
<tr class="separator:ga1c4bc946b94f19d7e11c00f41a39db02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga397872125364fdcaf89e62f8616d7d62"><td class="memItemLeft" align="right" valign="top">Number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga397872125364fdcaf89e62f8616d7d62">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::local_element</a> (const <a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> local_index)</td></tr>
<tr class="separator:ga397872125364fdcaf89e62f8616d7d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8db545d71e642710a044554d6df060d9"><td class="memItemLeft" align="right" valign="top">Number *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga8db545d71e642710a044554d6df060d9">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::get_values</a> () const</td></tr>
<tr class="separator:ga8db545d71e642710a044554d6df060d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad49497fa8fad0250a2bd0f4a36179ff2"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:gad49497fa8fad0250a2bd0f4a36179ff2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gad49497fa8fad0250a2bd0f4a36179ff2">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::extract_subvector_to</a> (const std::vector&lt; <a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> &gt; &amp;indices, std::vector&lt; OtherNumber &gt; &amp;values) const</td></tr>
<tr class="separator:gad49497fa8fad0250a2bd0f4a36179ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb9494a9258d9f0b06b97550921c5e0e"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:gaeb9494a9258d9f0b06b97550921c5e0e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaeb9494a9258d9f0b06b97550921c5e0e">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::extract_subvector_to</a> (ForwardIterator indices_begin, const ForwardIterator indices_end, OutputIterator values_begin) const</td></tr>
<tr class="separator:gaeb9494a9258d9f0b06b97550921c5e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ed7dc1d792f9344f1c8720e5f639351"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga5ed7dc1d792f9344f1c8720e5f639351">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::all_zero</a> () const override</td></tr>
<tr class="separator:ga5ed7dc1d792f9344f1c8720e5f639351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64f0fddbf542f0e6ff6344e0fa7d55f9"><td class="memItemLeft" align="right" valign="top">virtual Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga64f0fddbf542f0e6ff6344e0fa7d55f9">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::mean_value</a> () const override</td></tr>
<tr class="separator:ga64f0fddbf542f0e6ff6344e0fa7d55f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bf8c57a134cf1c5f27dab3a5cc1edf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Vectors.html#ga34599939674e79cdc3808bb074bcf0ee">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga8bf8c57a134cf1c5f27dab3a5cc1edf5">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;::lp_norm</a> (const <a class="el" href="group__Vectors.html#ga34599939674e79cdc3808bb074bcf0ee">real_type</a> p) const</td></tr>
<tr class="separator:ga8bf8c57a134cf1c5f27dab3a5cc1edf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">1: Basic Object-handling</h2></td></tr>
<tr class="memitem:gaa019c2aa2c09503086bcb0604679f2ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaa019c2aa2c09503086bcb0604679f2ba">LinearAlgebra::ReadWriteVector&lt; Number &gt;::ReadWriteVector</a> ()</td></tr>
<tr class="separator:gaa019c2aa2c09503086bcb0604679f2ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e113f1d04f1faebde287699f2d4585c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga0e113f1d04f1faebde287699f2d4585c">LinearAlgebra::ReadWriteVector&lt; Number &gt;::ReadWriteVector</a> (const <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt; Number &gt; &amp;in_vector)</td></tr>
<tr class="separator:ga0e113f1d04f1faebde287699f2d4585c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f57e4d076b7772b7ba15928070c2315"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga0f57e4d076b7772b7ba15928070c2315">LinearAlgebra::ReadWriteVector&lt; Number &gt;::ReadWriteVector</a> (const <a class="el" href="group__Vectors.html#gadc1437e8371646dcca5b74c01dc064a4">size_type</a> <a class="el" href="group__Vectors.html#ga0e20857fed96063ebd2d3edaea1082bf">size</a>)</td></tr>
<tr class="separator:ga0f57e4d076b7772b7ba15928070c2315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3ebd721f36c364d3207672265406469"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gad3ebd721f36c364d3207672265406469">LinearAlgebra::ReadWriteVector&lt; Number &gt;::ReadWriteVector</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;locally_stored_indices)</td></tr>
<tr class="separator:gad3ebd721f36c364d3207672265406469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad19d8a267b3b5d99e324cf5b448c6cde"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gad19d8a267b3b5d99e324cf5b448c6cde">LinearAlgebra::ReadWriteVector&lt; Number &gt;::~ReadWriteVector</a> () override=default</td></tr>
<tr class="separator:gad19d8a267b3b5d99e324cf5b448c6cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaee2ea7c671f9ece558b081b0d104295"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaaee2ea7c671f9ece558b081b0d104295">LinearAlgebra::ReadWriteVector&lt; Number &gt;::reinit</a> (const <a class="el" href="group__Vectors.html#gadc1437e8371646dcca5b74c01dc064a4">size_type</a> <a class="el" href="group__Vectors.html#ga0e20857fed96063ebd2d3edaea1082bf">size</a>, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false)</td></tr>
<tr class="separator:gaaee2ea7c671f9ece558b081b0d104295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0aa62727797cde32d9dafb4dbcdd107f"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:ga0aa62727797cde32d9dafb4dbcdd107f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga0aa62727797cde32d9dafb4dbcdd107f">LinearAlgebra::ReadWriteVector&lt; Number &gt;::reinit</a> (const <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt; Number2 &gt; &amp;in_vector, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false)</td></tr>
<tr class="separator:ga0aa62727797cde32d9dafb4dbcdd107f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa5d0c1a26755df4f451091e051a5277"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaaa5d0c1a26755df4f451091e051a5277">LinearAlgebra::ReadWriteVector&lt; Number &gt;::reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;locally_stored_indices, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false)</td></tr>
<tr class="separator:gaaa5d0c1a26755df4f451091e051a5277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa96d95c60ec7a4ba186c7aa4e762d05c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaa96d95c60ec7a4ba186c7aa4e762d05c">LinearAlgebra::ReadWriteVector&lt; Number &gt;::reinit</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;trilinos_vec)</td></tr>
<tr class="separator:gaa96d95c60ec7a4ba186c7aa4e762d05c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga245371b4cfb447d8f39fcfd4646c5435"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:ga245371b4cfb447d8f39fcfd4646c5435"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga245371b4cfb447d8f39fcfd4646c5435">LinearAlgebra::ReadWriteVector&lt; Number &gt;::apply</a> (const Functor &amp;func)</td></tr>
<tr class="separator:ga245371b4cfb447d8f39fcfd4646c5435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed3562c39eaa838680a68cd85ffd81fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaed3562c39eaa838680a68cd85ffd81fa">LinearAlgebra::ReadWriteVector&lt; Number &gt;::swap</a> (<a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:gaed3562c39eaa838680a68cd85ffd81fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62ce4785132ec1e65de894c7e6198bc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga62ce4785132ec1e65de894c7e6198bc3">LinearAlgebra::ReadWriteVector&lt; Number &gt;::operator=</a> (const <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt; Number &gt; &amp;in_vector)</td></tr>
<tr class="separator:ga62ce4785132ec1e65de894c7e6198bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a983cd43825afc39d1466a6d468d18c"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:ga0a983cd43825afc39d1466a6d468d18c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt; Number &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga0a983cd43825afc39d1466a6d468d18c">LinearAlgebra::ReadWriteVector&lt; Number &gt;::operator=</a> (const <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt; Number2 &gt; &amp;in_vector)</td></tr>
<tr class="separator:ga0a983cd43825afc39d1466a6d468d18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga699aa5c6cb9dad6bd0b93f0e744f74c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga699aa5c6cb9dad6bd0b93f0e744f74c4">LinearAlgebra::ReadWriteVector&lt; Number &gt;::operator=</a> (const Number s)</td></tr>
<tr class="separator:ga699aa5c6cb9dad6bd0b93f0e744f74c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01a417b8d7b2c5858f49cdc4c663779f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga01a417b8d7b2c5858f49cdc4c663779f">LinearAlgebra::ReadWriteVector&lt; Number &gt;::import</a> (const ::<a class="el" href="classLinearAlgebra_1_1Vector.html">Vector</a>&lt; Number &gt; &amp;vec, <a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation, const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1CommunicationPatternBase.html">Utilities::MPI::CommunicationPatternBase</a> &gt; &amp;communication_pattern={})</td></tr>
<tr class="separator:ga01a417b8d7b2c5858f49cdc4c663779f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcfcb11452e35b004342be5e52353566"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gabcfcb11452e35b004342be5e52353566">LinearAlgebra::ReadWriteVector&lt; Number &gt;::import</a> (const <a class="el" href="classLinearAlgebra_1_1Vector.html">LinearAlgebra::Vector</a>&lt; Number &gt; &amp;vec, <a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation, const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1CommunicationPatternBase.html">Utilities::MPI::CommunicationPatternBase</a> &gt; &amp;communication_pattern={})</td></tr>
<tr class="separator:gabcfcb11452e35b004342be5e52353566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47547164f123faf9f035ba7dbca7c656"><td class="memTemplParams" colspan="2">template&lt;typename MemorySpace &gt; </td></tr>
<tr class="memitem:ga47547164f123faf9f035ba7dbca7c656"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga47547164f123faf9f035ba7dbca7c656">LinearAlgebra::ReadWriteVector&lt; Number &gt;::import</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">distributed::Vector</a>&lt; Number, MemorySpace &gt; &amp;vec, <a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation, const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1CommunicationPatternBase.html">Utilities::MPI::CommunicationPatternBase</a> &gt; &amp;communication_pattern={})</td></tr>
<tr class="separator:ga47547164f123faf9f035ba7dbca7c656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9df1826dfefe6f66fe9cdfce6798e1f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga9df1826dfefe6f66fe9cdfce6798e1f2">LinearAlgebra::ReadWriteVector&lt; Number &gt;::import</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;petsc_vec, <a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation, const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1CommunicationPatternBase.html">Utilities::MPI::CommunicationPatternBase</a> &gt; &amp;communication_pattern={})</td></tr>
<tr class="separator:ga9df1826dfefe6f66fe9cdfce6798e1f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf957a87754a8daf166f1092a6df45cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gacf957a87754a8daf166f1092a6df45cb">LinearAlgebra::ReadWriteVector&lt; Number &gt;::import</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;trilinos_vec, <a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation, const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1CommunicationPatternBase.html">Utilities::MPI::CommunicationPatternBase</a> &gt; &amp;communication_pattern={})</td></tr>
<tr class="separator:gacf957a87754a8daf166f1092a6df45cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ae6b0675de89b62f36bd72a55183eec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga4ae6b0675de89b62f36bd72a55183eec">LinearAlgebra::ReadWriteVector&lt; Number &gt;::import</a> (const <a class="el" href="classLinearAlgebra_1_1TpetraWrappers_1_1Vector.html">TpetraWrappers::Vector</a>&lt; Number &gt; &amp;tpetra_vec, <a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation, const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1CommunicationPatternBase.html">Utilities::MPI::CommunicationPatternBase</a> &gt; &amp;communication_pattern={})</td></tr>
<tr class="separator:ga4ae6b0675de89b62f36bd72a55183eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ec5fe3bd8abc4eb3da40c1bb3918d2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga4ec5fe3bd8abc4eb3da40c1bb3918d2c">LinearAlgebra::ReadWriteVector&lt; Number &gt;::import</a> (const <a class="el" href="classLinearAlgebra_1_1EpetraWrappers_1_1Vector.html">EpetraWrappers::Vector</a> &amp;epetra_vec, <a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation, const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1CommunicationPatternBase.html">Utilities::MPI::CommunicationPatternBase</a> &gt; &amp;communication_pattern={})</td></tr>
<tr class="separator:ga4ec5fe3bd8abc4eb3da40c1bb3918d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae7b535ae7de6290b381a421aed5e0ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaae7b535ae7de6290b381a421aed5e0ad">LinearAlgebra::ReadWriteVector&lt; Number &gt;::import</a> (const <a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html">CUDAWrappers::Vector</a>&lt; Number &gt; &amp;cuda_vec, <a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation, const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1CommunicationPatternBase.html">Utilities::MPI::CommunicationPatternBase</a> &gt; &amp;communication_pattern={})</td></tr>
<tr class="separator:gaae7b535ae7de6290b381a421aed5e0ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e20857fed96063ebd2d3edaea1082bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Vectors.html#gadc1437e8371646dcca5b74c01dc064a4">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga0e20857fed96063ebd2d3edaea1082bf">LinearAlgebra::ReadWriteVector&lt; Number &gt;::size</a> () const</td></tr>
<tr class="separator:ga0e20857fed96063ebd2d3edaea1082bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedac815f15ee3c78363e02baa97457e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Vectors.html#gadc1437e8371646dcca5b74c01dc064a4">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaedac815f15ee3c78363e02baa97457e0">LinearAlgebra::ReadWriteVector&lt; Number &gt;::n_elements</a> () const</td></tr>
<tr class="separator:gaedac815f15ee3c78363e02baa97457e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0d3b0776e02bb473ecc785b3c4f89cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Vectors.html#gadc1437e8371646dcca5b74c01dc064a4">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gab0d3b0776e02bb473ecc785b3c4f89cf">LinearAlgebra::ReadWriteVector&lt; Number &gt;::locally_owned_size</a> () const</td></tr>
<tr class="separator:gab0d3b0776e02bb473ecc785b3c4f89cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaee475607463efff722ce083b6cd4f7d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaaee475607463efff722ce083b6cd4f7d">LinearAlgebra::ReadWriteVector&lt; Number &gt;::get_stored_elements</a> () const</td></tr>
<tr class="separator:gaaee475607463efff722ce083b6cd4f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c0f991527a8dd09601b764e59d097fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Vectors.html#ga5e28f8f12865657afed81936ca9308ac">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga1c0f991527a8dd09601b764e59d097fc">LinearAlgebra::ReadWriteVector&lt; Number &gt;::begin</a> ()</td></tr>
<tr class="separator:ga1c0f991527a8dd09601b764e59d097fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4138913e659866ebba5801a88167270"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Vectors.html#gac39936b0017c60e97d2c6643b612d970">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gac4138913e659866ebba5801a88167270">LinearAlgebra::ReadWriteVector&lt; Number &gt;::begin</a> () const</td></tr>
<tr class="separator:gac4138913e659866ebba5801a88167270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dbfbf3b3c7dcb1e96174eba41f3734c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Vectors.html#ga5e28f8f12865657afed81936ca9308ac">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga4dbfbf3b3c7dcb1e96174eba41f3734c">LinearAlgebra::ReadWriteVector&lt; Number &gt;::end</a> ()</td></tr>
<tr class="separator:ga4dbfbf3b3c7dcb1e96174eba41f3734c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab61f02fa9f52e7aa88d56310c6c0176a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Vectors.html#gac39936b0017c60e97d2c6643b612d970">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gab61f02fa9f52e7aa88d56310c6c0176a">LinearAlgebra::ReadWriteVector&lt; Number &gt;::end</a> () const</td></tr>
<tr class="separator:gab61f02fa9f52e7aa88d56310c6c0176a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">2: Data-Access</h2></td></tr>
<tr class="memitem:ga233998157aa2acdbde9717aec827ccbf"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga233998157aa2acdbde9717aec827ccbf">LinearAlgebra::ReadWriteVector&lt; Number &gt;::operator()</a> (const <a class="el" href="group__Vectors.html#gadc1437e8371646dcca5b74c01dc064a4">size_type</a> global_index) const</td></tr>
<tr class="separator:ga233998157aa2acdbde9717aec827ccbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a325d56a1d1c7f8db022eb442867d34"><td class="memItemLeft" align="right" valign="top">Number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga4a325d56a1d1c7f8db022eb442867d34">LinearAlgebra::ReadWriteVector&lt; Number &gt;::operator()</a> (const <a class="el" href="group__Vectors.html#gadc1437e8371646dcca5b74c01dc064a4">size_type</a> global_index)</td></tr>
<tr class="separator:ga4a325d56a1d1c7f8db022eb442867d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71445351bd4b9dfb4ff0c1c516658fe6"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga71445351bd4b9dfb4ff0c1c516658fe6">LinearAlgebra::ReadWriteVector&lt; Number &gt;::operator[]</a> (const <a class="el" href="group__Vectors.html#gadc1437e8371646dcca5b74c01dc064a4">size_type</a> global_index) const</td></tr>
<tr class="separator:ga71445351bd4b9dfb4ff0c1c516658fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9cf2035df2a9ba8777c80ffe4c1a914"><td class="memItemLeft" align="right" valign="top">Number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaf9cf2035df2a9ba8777c80ffe4c1a914">LinearAlgebra::ReadWriteVector&lt; Number &gt;::operator[]</a> (const <a class="el" href="group__Vectors.html#gadc1437e8371646dcca5b74c01dc064a4">size_type</a> global_index)</td></tr>
<tr class="separator:gaf9cf2035df2a9ba8777c80ffe4c1a914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe49ac3785c3ed8cdf2c2200c9dd3b94"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:gabe49ac3785c3ed8cdf2c2200c9dd3b94"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gabe49ac3785c3ed8cdf2c2200c9dd3b94">LinearAlgebra::ReadWriteVector&lt; Number &gt;::extract_subvector_to</a> (const std::vector&lt; <a class="el" href="group__Vectors.html#gadc1437e8371646dcca5b74c01dc064a4">size_type</a> &gt; &amp;indices, std::vector&lt; Number2 &gt; &amp;<a class="el" href="group__Vectors.html#ga18f97cb8e503f790483ddaddfa768a25">values</a>) const</td></tr>
<tr class="separator:gabe49ac3785c3ed8cdf2c2200c9dd3b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae3387187c82a78eabb153f0d7bf1af4"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:gaae3387187c82a78eabb153f0d7bf1af4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaae3387187c82a78eabb153f0d7bf1af4">LinearAlgebra::ReadWriteVector&lt; Number &gt;::extract_subvector_to</a> (ForwardIterator indices_begin, const ForwardIterator indices_end, OutputIterator values_begin) const</td></tr>
<tr class="separator:gaae3387187c82a78eabb153f0d7bf1af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga722901ebee9fe3e68a29549ca30259a8"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga722901ebee9fe3e68a29549ca30259a8">LinearAlgebra::ReadWriteVector&lt; Number &gt;::local_element</a> (const <a class="el" href="group__Vectors.html#gadc1437e8371646dcca5b74c01dc064a4">size_type</a> local_index) const</td></tr>
<tr class="separator:ga722901ebee9fe3e68a29549ca30259a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7a1d6b3129693772cc2ae757d1f3c36"><td class="memItemLeft" align="right" valign="top">Number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaa7a1d6b3129693772cc2ae757d1f3c36">LinearAlgebra::ReadWriteVector&lt; Number &gt;::local_element</a> (const <a class="el" href="group__Vectors.html#gadc1437e8371646dcca5b74c01dc064a4">size_type</a> local_index)</td></tr>
<tr class="separator:gaa7a1d6b3129693772cc2ae757d1f3c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Basic object handling</h2></td></tr>
<tr class="memitem:ga5424155269bd22011e9ff796e0c77e69"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga5424155269bd22011e9ff796e0c77e69">Vector&lt; Number &gt;::Vector</a> ()</td></tr>
<tr class="separator:ga5424155269bd22011e9ff796e0c77e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55f3a1869eafb7680e44c3fe5c0f6d39"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga55f3a1869eafb7680e44c3fe5c0f6d39">Vector&lt; Number &gt;::Vector</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:ga55f3a1869eafb7680e44c3fe5c0f6d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac466762a351e7d9c48c05705730070e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gac466762a351e7d9c48c05705730070e3">Vector&lt; Number &gt;::Vector</a> (<a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&amp;v) noexcept=default</td></tr>
<tr class="separator:gac466762a351e7d9c48c05705730070e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b9f407c4064e4d83796c5f5149aa1c0"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:ga9b9f407c4064e4d83796c5f5149aa1c0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga9b9f407c4064e4d83796c5f5149aa1c0">Vector&lt; Number &gt;::Vector</a> (const <a class="el" href="classVector.html">Vector</a>&lt; OtherNumber &gt; &amp;v)</td></tr>
<tr class="separator:ga9b9f407c4064e4d83796c5f5149aa1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb43a268341d826272c4255b46b4b14b"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:gafb43a268341d826272c4255b46b4b14b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gafb43a268341d826272c4255b46b4b14b">Vector&lt; Number &gt;::Vector</a> (const std::initializer_list&lt; OtherNumber &gt; &amp;v)</td></tr>
<tr class="separator:gafb43a268341d826272c4255b46b4b14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6478b634eb646ffaa11f6f82b91d92a9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga6478b634eb646ffaa11f6f82b91d92a9">Vector&lt; Number &gt;::Vector</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html">PETScWrappers::VectorBase</a> &amp;v)</td></tr>
<tr class="separator:ga6478b634eb646ffaa11f6f82b91d92a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bb6efe58ff7587ec88b542fe705bba6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga1bb6efe58ff7587ec88b542fe705bba6">Vector&lt; Number &gt;::Vector</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;v)</td></tr>
<tr class="separator:ga1bb6efe58ff7587ec88b542fe705bba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2de475367d8e8440fc32564a9178216f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga2de475367d8e8440fc32564a9178216f">Vector&lt; Number &gt;::Vector</a> (const <a class="el" href="group__Vectors.html#ga5927fb109e04d1d4988dae5c910fc32d">size_type</a> n)</td></tr>
<tr class="separator:ga2de475367d8e8440fc32564a9178216f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf441b2c23134f8e6e08c833f918888a2"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:gaf441b2c23134f8e6e08c833f918888a2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaf441b2c23134f8e6e08c833f918888a2">Vector&lt; Number &gt;::Vector</a> (const InputIterator <a class="el" href="grid__out_8cc.html#a827a345f29da7caeb588b11013869a01">first</a>, const InputIterator last)</td></tr>
<tr class="separator:gaf441b2c23134f8e6e08c833f918888a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a2ad8f9f15b0fa4b207fe053c81c050"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga9a2ad8f9f15b0fa4b207fe053c81c050">Vector&lt; Number &gt;::~Vector</a> () override=default</td></tr>
<tr class="separator:ga9a2ad8f9f15b0fa4b207fe053c81c050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8740c5534b6dbc31f4f1503a5e2a10a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga8740c5534b6dbc31f4f1503a5e2a10a3">Vector&lt; Number &gt;::compress</a> (::<a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation=::<a class="el" href="group__Vectors.html#gga40c50779cd14ba89bbf0bd9b4561964ca9c7dc8036a5632e9ed2a183c3c2812e6">VectorOperation::unknown</a>) const</td></tr>
<tr class="separator:ga8740c5534b6dbc31f4f1503a5e2a10a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4a4dbef7dd65ef8ad35ae56b57d7c05"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gac4a4dbef7dd65ef8ad35ae56b57d7c05">Vector&lt; Number &gt;::reinit</a> (const <a class="el" href="group__Vectors.html#ga5927fb109e04d1d4988dae5c910fc32d">size_type</a> N, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false)</td></tr>
<tr class="separator:gac4a4dbef7dd65ef8ad35ae56b57d7c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99737189c3f716cf97cb1aba667ff7b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga99737189c3f716cf97cb1aba667ff7b2">Vector&lt; Number &gt;::grow_or_shrink</a> (const <a class="el" href="group__Vectors.html#ga5927fb109e04d1d4988dae5c910fc32d">size_type</a> N)</td></tr>
<tr class="separator:ga99737189c3f716cf97cb1aba667ff7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabae296943fe1f9cc5ada1d98761d0a19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gabae296943fe1f9cc5ada1d98761d0a19">Vector&lt; Number &gt;::apply_givens_rotation</a> (const std::array&lt; Number, 3 &gt; &amp;csr, const <a class="el" href="group__Vectors.html#ga5927fb109e04d1d4988dae5c910fc32d">size_type</a> i, const <a class="el" href="group__Vectors.html#ga5927fb109e04d1d4988dae5c910fc32d">size_type</a> k)</td></tr>
<tr class="separator:gabae296943fe1f9cc5ada1d98761d0a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4724e0d85120bda42159be96c493a702"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:ga4724e0d85120bda42159be96c493a702"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga4724e0d85120bda42159be96c493a702">Vector&lt; Number &gt;::reinit</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;V, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false)</td></tr>
<tr class="separator:ga4724e0d85120bda42159be96c493a702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9818314bd7dc4e66849559f429e06151"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga9818314bd7dc4e66849559f429e06151">Vector&lt; Number &gt;::swap</a> (<a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:ga9818314bd7dc4e66849559f429e06151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e835da7c35928e87f425f41ba30c2f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga9e835da7c35928e87f425f41ba30c2f1">Vector&lt; Number &gt;::operator=</a> (const Number s)</td></tr>
<tr class="separator:ga9e835da7c35928e87f425f41ba30c2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cd12a193b97aa945190a9ce19a81e18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga5cd12a193b97aa945190a9ce19a81e18">Vector&lt; Number &gt;::operator=</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:ga5cd12a193b97aa945190a9ce19a81e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5aba516443a99330968b4dbda6d12ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gae5aba516443a99330968b4dbda6d12ac">Vector&lt; Number &gt;::operator=</a> (<a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&amp;v) noexcept=default</td></tr>
<tr class="separator:gae5aba516443a99330968b4dbda6d12ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa40c43480e8d2c50d0bb0a13421b7264"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:gaa40c43480e8d2c50d0bb0a13421b7264"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaa40c43480e8d2c50d0bb0a13421b7264">Vector&lt; Number &gt;::operator=</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;v)</td></tr>
<tr class="separator:gaa40c43480e8d2c50d0bb0a13421b7264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b25ae266b150f897762592e56e5e649"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga5b25ae266b150f897762592e56e5e649">Vector&lt; Number &gt;::operator=</a> (const <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:ga5b25ae266b150f897762592e56e5e649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75e25dfec5386326daa1e3a7eea06c6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga75e25dfec5386326daa1e3a7eea06c6c">Vector&lt; Number &gt;::operator=</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html">PETScWrappers::VectorBase</a> &amp;v)</td></tr>
<tr class="separator:ga75e25dfec5386326daa1e3a7eea06c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d21d0e4ddcd2e645180487745e56692"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga4d21d0e4ddcd2e645180487745e56692">Vector&lt; Number &gt;::operator=</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;v)</td></tr>
<tr class="separator:ga4d21d0e4ddcd2e645180487745e56692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a226204eb09ef133f124ad2137c17f4"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:ga7a226204eb09ef133f124ad2137c17f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga7a226204eb09ef133f124ad2137c17f4">Vector&lt; Number &gt;::operator==</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;v) const</td></tr>
<tr class="separator:ga7a226204eb09ef133f124ad2137c17f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga082ee1076dfadf9933073247e56e80c7"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:ga082ee1076dfadf9933073247e56e80c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga082ee1076dfadf9933073247e56e80c7">Vector&lt; Number &gt;::operator!=</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;v) const</td></tr>
<tr class="separator:ga082ee1076dfadf9933073247e56e80c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Scalar products, norms and related operations</h2></td></tr>
<tr class="memitem:ga2371854d97a2f717da3170b72e2a58e8"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:ga2371854d97a2f717da3170b72e2a58e8"><td class="memTemplItemLeft" align="right" valign="top">Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga2371854d97a2f717da3170b72e2a58e8">Vector&lt; Number &gt;::operator*</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;V) const</td></tr>
<tr class="separator:ga2371854d97a2f717da3170b72e2a58e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad5a995087a003f81fa5b74513e13677"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Vectors.html#ga02452a5983fd0e8c956ab9278213bd2c">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaad5a995087a003f81fa5b74513e13677">Vector&lt; Number &gt;::norm_sqr</a> () const</td></tr>
<tr class="separator:gaad5a995087a003f81fa5b74513e13677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33d47f6cd8a2b9ec62f133e7d303b745"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga33d47f6cd8a2b9ec62f133e7d303b745">Vector&lt; Number &gt;::mean_value</a> () const</td></tr>
<tr class="separator:ga33d47f6cd8a2b9ec62f133e7d303b745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaa8fc05dd5a8a8f9560a5de096ebb4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Vectors.html#ga02452a5983fd0e8c956ab9278213bd2c">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaeaa8fc05dd5a8a8f9560a5de096ebb4e">Vector&lt; Number &gt;::l1_norm</a> () const</td></tr>
<tr class="separator:gaeaa8fc05dd5a8a8f9560a5de096ebb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ee1b8309a7a9ecf109c8a7116733ef8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Vectors.html#ga02452a5983fd0e8c956ab9278213bd2c">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga8ee1b8309a7a9ecf109c8a7116733ef8">Vector&lt; Number &gt;::l2_norm</a> () const</td></tr>
<tr class="separator:ga8ee1b8309a7a9ecf109c8a7116733ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga708e76373444e3b1d12dbee72f5d32b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Vectors.html#ga02452a5983fd0e8c956ab9278213bd2c">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga708e76373444e3b1d12dbee72f5d32b9">Vector&lt; Number &gt;::lp_norm</a> (const <a class="el" href="group__Vectors.html#ga02452a5983fd0e8c956ab9278213bd2c">real_type</a> p) const</td></tr>
<tr class="separator:ga708e76373444e3b1d12dbee72f5d32b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f6b7f7afb05aaff7e1ab8f9942b6dae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Vectors.html#ga02452a5983fd0e8c956ab9278213bd2c">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga9f6b7f7afb05aaff7e1ab8f9942b6dae">Vector&lt; Number &gt;::linfty_norm</a> () const</td></tr>
<tr class="separator:ga9f6b7f7afb05aaff7e1ab8f9942b6dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3659971dfc5e53759da2be27d702d078"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga3659971dfc5e53759da2be27d702d078">Vector&lt; Number &gt;::add_and_dot</a> (const Number a, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;W)</td></tr>
<tr class="separator:ga3659971dfc5e53759da2be27d702d078"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Data access</h2></td></tr>
<tr class="memitem:ga46010ca9f43c93431f7ee66817e670ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Vectors.html#ga8f7ef5265cbcae4d30f7e3fcde61a7f9">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga46010ca9f43c93431f7ee66817e670ca">Vector&lt; Number &gt;::data</a> ()</td></tr>
<tr class="separator:ga46010ca9f43c93431f7ee66817e670ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24916f568e015cc783628a2c9664c666"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Vectors.html#ga0a1be85b8a5e0669f9034cf8e4421a11">const_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga24916f568e015cc783628a2c9664c666">Vector&lt; Number &gt;::data</a> () const</td></tr>
<tr class="separator:ga24916f568e015cc783628a2c9664c666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf34b888fe493ef2ed188179de69ad7ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Vectors.html#gacb8006e49918faaffeccd151669d0934">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaf34b888fe493ef2ed188179de69ad7ed">Vector&lt; Number &gt;::begin</a> ()</td></tr>
<tr class="separator:gaf34b888fe493ef2ed188179de69ad7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga710df6df8902b609158fa277f216d146"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Vectors.html#ga31d7e7b4278a3fa08a6e5ceec3deb0fb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga710df6df8902b609158fa277f216d146">Vector&lt; Number &gt;::begin</a> () const</td></tr>
<tr class="separator:ga710df6df8902b609158fa277f216d146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a2a770cb19d3e5b0b69b08ffc88184f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Vectors.html#gacb8006e49918faaffeccd151669d0934">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga7a2a770cb19d3e5b0b69b08ffc88184f">Vector&lt; Number &gt;::end</a> ()</td></tr>
<tr class="separator:ga7a2a770cb19d3e5b0b69b08ffc88184f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc9d45917e1f6cd2ba60dc4aef430ce9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Vectors.html#ga31d7e7b4278a3fa08a6e5ceec3deb0fb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gabc9d45917e1f6cd2ba60dc4aef430ce9">Vector&lt; Number &gt;::end</a> () const</td></tr>
<tr class="separator:gabc9d45917e1f6cd2ba60dc4aef430ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3af32d65459fad49b43d41ec7e848c3"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gad3af32d65459fad49b43d41ec7e848c3">Vector&lt; Number &gt;::operator()</a> (const <a class="el" href="group__Vectors.html#ga5927fb109e04d1d4988dae5c910fc32d">size_type</a> i) const</td></tr>
<tr class="separator:gad3af32d65459fad49b43d41ec7e848c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1268a6b336ee46bd8b2ac746cbe82643"><td class="memItemLeft" align="right" valign="top">Number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga1268a6b336ee46bd8b2ac746cbe82643">Vector&lt; Number &gt;::operator()</a> (const <a class="el" href="group__Vectors.html#ga5927fb109e04d1d4988dae5c910fc32d">size_type</a> i)</td></tr>
<tr class="separator:ga1268a6b336ee46bd8b2ac746cbe82643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c137f6bd56f1fad54a13a8cc46f5b12"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga5c137f6bd56f1fad54a13a8cc46f5b12">Vector&lt; Number &gt;::operator[]</a> (const <a class="el" href="group__Vectors.html#ga5927fb109e04d1d4988dae5c910fc32d">size_type</a> i) const</td></tr>
<tr class="separator:ga5c137f6bd56f1fad54a13a8cc46f5b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d7bafc88c457dbc2e7db6a533d35391"><td class="memItemLeft" align="right" valign="top">Number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga4d7bafc88c457dbc2e7db6a533d35391">Vector&lt; Number &gt;::operator[]</a> (const <a class="el" href="group__Vectors.html#ga5927fb109e04d1d4988dae5c910fc32d">size_type</a> i)</td></tr>
<tr class="separator:ga4d7bafc88c457dbc2e7db6a533d35391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae406cc28ed782932504a186ba1c5f9e8"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:gae406cc28ed782932504a186ba1c5f9e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gae406cc28ed782932504a186ba1c5f9e8">Vector&lt; Number &gt;::extract_subvector_to</a> (const std::vector&lt; <a class="el" href="group__Vectors.html#ga5927fb109e04d1d4988dae5c910fc32d">size_type</a> &gt; &amp;indices, std::vector&lt; OtherNumber &gt; &amp;<a class="el" href="group__Vectors.html#gab392612c190ffa0dd4daa4eea36507c4">values</a>) const</td></tr>
<tr class="separator:gae406cc28ed782932504a186ba1c5f9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga079ae7a1b9cf454549e0925103208cc5"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga079ae7a1b9cf454549e0925103208cc5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga079ae7a1b9cf454549e0925103208cc5">Vector&lt; Number &gt;::extract_subvector_to</a> (ForwardIterator indices_begin, const ForwardIterator indices_end, OutputIterator values_begin) const</td></tr>
<tr class="separator:ga079ae7a1b9cf454549e0925103208cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Modification of vectors</h2></td></tr>
<tr class="memitem:ga0b2abb4f2a3a722b30165373ea982a50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga0b2abb4f2a3a722b30165373ea982a50">Vector&lt; Number &gt;::operator+=</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:ga0b2abb4f2a3a722b30165373ea982a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga603f91549c76b084a88e47d8824997ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga603f91549c76b084a88e47d8824997ab">Vector&lt; Number &gt;::operator-=</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:ga603f91549c76b084a88e47d8824997ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10b0336c485e36c7b4b105dd2a926002"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:ga10b0336c485e36c7b4b105dd2a926002"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga10b0336c485e36c7b4b105dd2a926002">Vector&lt; Number &gt;::add</a> (const std::vector&lt; <a class="el" href="group__Vectors.html#ga5927fb109e04d1d4988dae5c910fc32d">size_type</a> &gt; &amp;indices, const std::vector&lt; OtherNumber &gt; &amp;<a class="el" href="group__Vectors.html#gab392612c190ffa0dd4daa4eea36507c4">values</a>)</td></tr>
<tr class="separator:ga10b0336c485e36c7b4b105dd2a926002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb5a1e611de68e9631791cebf3736c86"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:gaeb5a1e611de68e9631791cebf3736c86"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaeb5a1e611de68e9631791cebf3736c86">Vector&lt; Number &gt;::add</a> (const std::vector&lt; <a class="el" href="group__Vectors.html#ga5927fb109e04d1d4988dae5c910fc32d">size_type</a> &gt; &amp;indices, const <a class="el" href="classVector.html">Vector</a>&lt; OtherNumber &gt; &amp;<a class="el" href="group__Vectors.html#gab392612c190ffa0dd4daa4eea36507c4">values</a>)</td></tr>
<tr class="separator:gaeb5a1e611de68e9631791cebf3736c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd1770cabeceaf722763742cdc1e10ba"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:gacd1770cabeceaf722763742cdc1e10ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gacd1770cabeceaf722763742cdc1e10ba">Vector&lt; Number &gt;::add</a> (const <a class="el" href="group__Vectors.html#ga5927fb109e04d1d4988dae5c910fc32d">size_type</a> n_elements, const <a class="el" href="group__Vectors.html#ga5927fb109e04d1d4988dae5c910fc32d">size_type</a> *indices, const OtherNumber *<a class="el" href="group__Vectors.html#gab392612c190ffa0dd4daa4eea36507c4">values</a>)</td></tr>
<tr class="separator:gacd1770cabeceaf722763742cdc1e10ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b264924f2c8dc130e0be826f40e0da0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga2b264924f2c8dc130e0be826f40e0da0">Vector&lt; Number &gt;::add</a> (const Number s)</td></tr>
<tr class="separator:ga2b264924f2c8dc130e0be826f40e0da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga141369afc3169fc80597a7d70fa7b7a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga141369afc3169fc80597a7d70fa7b7a6">Vector&lt; Number &gt;::add</a> (const Number a, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V, const Number b, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;W)</td></tr>
<tr class="separator:ga141369afc3169fc80597a7d70fa7b7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae0643f15938ef8dc4727d90405cf83f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaae0643f15938ef8dc4727d90405cf83f">Vector&lt; Number &gt;::add</a> (const Number a, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:gaae0643f15938ef8dc4727d90405cf83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7126299241702719e409f59c0ec07d51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga7126299241702719e409f59c0ec07d51">Vector&lt; Number &gt;::sadd</a> (const Number s, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:ga7126299241702719e409f59c0ec07d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d2bb04de50473779d407149dec7be9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga2d2bb04de50473779d407149dec7be9f">Vector&lt; Number &gt;::sadd</a> (const Number s, const Number a, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:ga2d2bb04de50473779d407149dec7be9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f3e7e9460e7395dd67b95e61dd87d37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga4f3e7e9460e7395dd67b95e61dd87d37">Vector&lt; Number &gt;::operator*=</a> (const Number factor)</td></tr>
<tr class="separator:ga4f3e7e9460e7395dd67b95e61dd87d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4263fde23b0a636562ca9751d51b5e4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga4263fde23b0a636562ca9751d51b5e4a">Vector&lt; Number &gt;::operator/=</a> (const Number factor)</td></tr>
<tr class="separator:ga4263fde23b0a636562ca9751d51b5e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa956ed8a13546e788464672e88057b65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gaa956ed8a13546e788464672e88057b65">Vector&lt; Number &gt;::scale</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;scaling_factors)</td></tr>
<tr class="separator:gaa956ed8a13546e788464672e88057b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a3d0f3f7fb1a7d6196a0def1bacf371"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:ga0a3d0f3f7fb1a7d6196a0def1bacf371"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga0a3d0f3f7fb1a7d6196a0def1bacf371">Vector&lt; Number &gt;::scale</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;scaling_factors)</td></tr>
<tr class="separator:ga0a3d0f3f7fb1a7d6196a0def1bacf371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5feedb1e66657dcc91855748c936879a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga5feedb1e66657dcc91855748c936879a">Vector&lt; Number &gt;::equ</a> (const Number a, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;u)</td></tr>
<tr class="separator:ga5feedb1e66657dcc91855748c936879a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab59511c3b4ce9b3fe8454c8657234a25"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:gab59511c3b4ce9b3fe8454c8657234a25"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gab59511c3b4ce9b3fe8454c8657234a25">Vector&lt; Number &gt;::equ</a> (const Number a, const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;u)</td></tr>
<tr class="separator:gab59511c3b4ce9b3fe8454c8657234a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae50dd04b204d8ebf6be467c3ebe2234f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#gae50dd04b204d8ebf6be467c3ebe2234f">Vector&lt; Number &gt;::update_ghost_values</a> () const</td></tr>
<tr class="separator:gae50dd04b204d8ebf6be467c3ebe2234f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Input and output</h2></td></tr>
<tr class="memitem:ga4d43302d459c7cb6ae4b5bad13d31507"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga4d43302d459c7cb6ae4b5bad13d31507">Vector&lt; Number &gt;::print</a> (std::ostream &amp;out, const unsigned int precision=3, const <a class="el" href="classbool.html">bool</a> scientific=true, const <a class="el" href="classbool.html">bool</a> across=true) const</td></tr>
<tr class="separator:ga4d43302d459c7cb6ae4b5bad13d31507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31f18ed7d00d429247dc3127ba496e42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga31f18ed7d00d429247dc3127ba496e42">Vector&lt; Number &gt;::block_write</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:ga31f18ed7d00d429247dc3127ba496e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57d77409b8591a13d5ee10c2e705593a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga57d77409b8591a13d5ee10c2e705593a">Vector&lt; Number &gt;::block_read</a> (std::istream &amp;in)</td></tr>
<tr class="separator:ga57d77409b8591a13d5ee10c2e705593a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c9b9333d11630bf0fc82a7957e0d1c1"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ga9c9b9333d11630bf0fc82a7957e0d1c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga9c9b9333d11630bf0fc82a7957e0d1c1">Vector&lt; Number &gt;::save</a> (Archive &amp;ar, const unsigned int version) const</td></tr>
<tr class="separator:ga9c9b9333d11630bf0fc82a7957e0d1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b7a75b54cfee3d921a467f2ca126b54"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ga3b7a75b54cfee3d921a467f2ca126b54"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga3b7a75b54cfee3d921a467f2ca126b54">Vector&lt; Number &gt;::load</a> (Archive &amp;ar, const unsigned int version)</td></tr>
<tr class="separator:ga3b7a75b54cfee3d921a467f2ca126b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6121484e53939ed6ad6024141ee0cd50"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ga6121484e53939ed6ad6024141ee0cd50"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga6121484e53939ed6ad6024141ee0cd50">Vector&lt; Number &gt;::serialize</a> (Archive &amp;archive, const unsigned int version)</td></tr>
<tr class="separator:ga6121484e53939ed6ad6024141ee0cd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Here, we list all the classes that satisfy the <code>VectorType</code> concept and may be used in linear solvers (see <a class="el" href="group__Solvers.html">Linear solver classes</a>) and for matrix-vector operations. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gad801fdb88f327a64805e0cd9d333d499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad801fdb88f327a64805e0cd9d333d499">&#9670;&nbsp;</a></span>BaseClass <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#gad801fdb88f327a64805e0cd9d333d499">BaseClass</a> =  <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt;<a class="el" href="classVector.html">Vector</a>&lt;Number&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef the base class for simpler access to its own alias. </p>

<p class="definition">Definition at line <a class="el" href="block__vector_8h_source.html#l00076">76</a> of file <a class="el" href="block__vector_8h_source.html">block_vector.h</a>.</p>

</div>
</div>
<a id="ga8da0f24e108bcfde98dbcb07d528bff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8da0f24e108bcfde98dbcb07d528bff9">&#9670;&nbsp;</a></span>BlockType <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#ga8da0f24e108bcfde98dbcb07d528bff9">BlockType</a> =  typename <a class="el" href="group__Exceptions.html#gaeb971802cf05add5cf1c26338ce77a9b">BaseClass::BlockType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef the type of the underlying vector. </p>

<p class="definition">Definition at line <a class="el" href="block__vector_8h_source.html#l00081">81</a> of file <a class="el" href="block__vector_8h_source.html">block_vector.h</a>.</p>

</div>
</div>
<a id="ga5623a846ef43840761d167225ff55143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5623a846ef43840761d167225ff55143">&#9670;&nbsp;</a></span>value_type <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#ga5623a846ef43840761d167225ff55143">value_type</a> =  typename <a class="el" href="group__Exceptions.html#ga6055b029c116fd1fd580bfab2d4234ae">BaseClass::value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Import the alias from the base class. </p>

<p class="definition">Definition at line <a class="el" href="block__vector_8h_source.html#l00086">86</a> of file <a class="el" href="block__vector_8h_source.html">block_vector.h</a>.</p>

</div>
</div>
<a id="gaf4fddb03f96ed446025baa7bc84bfc76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4fddb03f96ed446025baa7bc84bfc76">&#9670;&nbsp;</a></span>real_type <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#gaf4fddb03f96ed446025baa7bc84bfc76">real_type</a> =  typename <a class="el" href="group__Exceptions.html#gab62c4ac95c3782bb2236bf67038adc20">BaseClass::real_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="block__vector_8h_source.html#l00087">87</a> of file <a class="el" href="block__vector_8h_source.html">block_vector.h</a>.</p>

</div>
</div>
<a id="ga88285af62463c49b442057968eadc85e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88285af62463c49b442057968eadc85e">&#9670;&nbsp;</a></span>pointer <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#ga88285af62463c49b442057968eadc85e">pointer</a> =  typename <a class="el" href="group__Exceptions.html#gaebed52638e6b26f5f18adec8a2437852">BaseClass::pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="block__vector_8h_source.html#l00088">88</a> of file <a class="el" href="block__vector_8h_source.html">block_vector.h</a>.</p>

</div>
</div>
<a id="ga701db0b299b39b8e7e696908b4b533d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga701db0b299b39b8e7e696908b4b533d6">&#9670;&nbsp;</a></span>const_pointer <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#ga701db0b299b39b8e7e696908b4b533d6">const_pointer</a> =  typename <a class="el" href="group__Exceptions.html#ga46a99911c512a1a08d5c5e237986d765">BaseClass::const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="block__vector_8h_source.html#l00089">89</a> of file <a class="el" href="block__vector_8h_source.html">block_vector.h</a>.</p>

</div>
</div>
<a id="ga18701503f179ce207fe5a4a802446588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18701503f179ce207fe5a4a802446588">&#9670;&nbsp;</a></span>reference <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#ga18701503f179ce207fe5a4a802446588">reference</a> =  typename <a class="el" href="group__Exceptions.html#ga9a15d476a8495a66f32508943c91294f">BaseClass::reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="block__vector_8h_source.html#l00090">90</a> of file <a class="el" href="block__vector_8h_source.html">block_vector.h</a>.</p>

</div>
</div>
<a id="ga0c1278cafe161bf9a17ccb0e3e785963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c1278cafe161bf9a17ccb0e3e785963">&#9670;&nbsp;</a></span>const_reference <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#ga0c1278cafe161bf9a17ccb0e3e785963">const_reference</a> =  typename <a class="el" href="group__Exceptions.html#ga490c8bf68dceb08dc60c2a3e0c6bf2a2">BaseClass::const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="block__vector_8h_source.html#l00091">91</a> of file <a class="el" href="block__vector_8h_source.html">block_vector.h</a>.</p>

</div>
</div>
<a id="gab0855e15b27a3f125629272a1b969920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0855e15b27a3f125629272a1b969920">&#9670;&nbsp;</a></span>size_type <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#gab0855e15b27a3f125629272a1b969920">size_type</a> =  typename <a class="el" href="group__Exceptions.html#ga5c50677a9f39b52e75474f172059ed45">BaseClass::size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="block__vector_8h_source.html#l00092">92</a> of file <a class="el" href="block__vector_8h_source.html">block_vector.h</a>.</p>

</div>
</div>
<a id="ga99f27555dfea7b98585d12d963cb4c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99f27555dfea7b98585d12d963cb4c29">&#9670;&nbsp;</a></span>iterator <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#ga99f27555dfea7b98585d12d963cb4c29">iterator</a> =  typename <a class="el" href="group__Exceptions.html#ga38316f0d1b9b1e4fa4dc3e0b4e15655e">BaseClass::iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="block__vector_8h_source.html#l00093">93</a> of file <a class="el" href="block__vector_8h_source.html">block_vector.h</a>.</p>

</div>
</div>
<a id="gaf1f781c26e3c31336f49bfea8f142018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1f781c26e3c31336f49bfea8f142018">&#9670;&nbsp;</a></span>const_iterator <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#gaf1f781c26e3c31336f49bfea8f142018">const_iterator</a> =  typename <a class="el" href="group__Exceptions.html#ga84ecd5753f1f75fbe1fa76e7ec72b3d8">BaseClass::const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="block__vector_8h_source.html#l00094">94</a> of file <a class="el" href="block__vector_8h_source.html">block_vector.h</a>.</p>

</div>
</div>
<a id="gaa1bcff6afb8cf43ac20e2cb12005472b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1bcff6afb8cf43ac20e2cb12005472b">&#9670;&nbsp;</a></span>size_type <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockVectorType , bool Constness&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">internal::BlockVectorIterators::Iterator</a>&lt; BlockVectorType, Constness &gt;::<a class="el" href="group__Vectors.html#gaa1bcff6afb8cf43ac20e2cb12005472b">size_type</a> =  <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare the type for container size. </p>

<p class="definition">Definition at line <a class="el" href="block__vector__base_8h_source.html#l00131">131</a> of file <a class="el" href="block__vector__base_8h_source.html">block_vector_base.h</a>.</p>

</div>
</div>
<a id="gabec7bbc4933bcd638ccb1aaf652dd4e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabec7bbc4933bcd638ccb1aaf652dd4e8">&#9670;&nbsp;</a></span>value_type <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockVectorType , bool Constness&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">internal::BlockVectorIterators::Iterator</a>&lt; BlockVectorType, Constness &gt;::<a class="el" href="group__Vectors.html#gabec7bbc4933bcd638ccb1aaf652dd4e8">value_type</a> =  typename std::conditional&lt;Constness, const typename BlockVectorType::value_type, typename BlockVectorType::value_type&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of the number this iterator points to. Depending on the value of the second template parameter, this is either a constant or non-const number. </p>

<p class="definition">Definition at line <a class="el" href="block__vector__base_8h_source.html#l00138">138</a> of file <a class="el" href="block__vector__base_8h_source.html">block_vector_base.h</a>.</p>

</div>
</div>
<a id="ga9c81e1ee0ea6ba9bbc812a704d45669e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c81e1ee0ea6ba9bbc812a704d45669e">&#9670;&nbsp;</a></span>iterator_category</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockVectorType , bool Constness&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">internal::BlockVectorIterators::Iterator</a>&lt; BlockVectorType, Constness &gt;::<a class="el" href="group__Vectors.html#ga9c81e1ee0ea6ba9bbc812a704d45669e">iterator_category</a> =  std::random_access_iterator_tag</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare some alias which are standard for iterators and are used by algorithms to enquire about the specifics of the iterators they work on. </p>

<p class="definition">Definition at line <a class="el" href="block__vector__base_8h_source.html#l00148">148</a> of file <a class="el" href="block__vector__base_8h_source.html">block_vector_base.h</a>.</p>

</div>
</div>
<a id="gad8cb3bf4001514075bff8361519b6046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8cb3bf4001514075bff8361519b6046">&#9670;&nbsp;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockVectorType , bool Constness&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">internal::BlockVectorIterators::Iterator</a>&lt; BlockVectorType, Constness &gt;::<a class="el" href="group__Vectors.html#gad8cb3bf4001514075bff8361519b6046">difference_type</a> =  std::ptrdiff_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="block__vector__base_8h_source.html#l00149">149</a> of file <a class="el" href="block__vector__base_8h_source.html">block_vector_base.h</a>.</p>

</div>
</div>
<a id="gaf093a52ba95924c752c078ef1f94e923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf093a52ba95924c752c078ef1f94e923">&#9670;&nbsp;</a></span>reference <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockVectorType , bool Constness&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">internal::BlockVectorIterators::Iterator</a>&lt; BlockVectorType, Constness &gt;::<a class="el" href="group__Vectors.html#gaf093a52ba95924c752c078ef1f94e923">reference</a> =  typename BlockVectorType::reference</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="block__vector__base_8h_source.html#l00150">150</a> of file <a class="el" href="block__vector__base_8h_source.html">block_vector_base.h</a>.</p>

</div>
</div>
<a id="ga69afde293e371e48b3328b2bc7778cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69afde293e371e48b3328b2bc7778cc9">&#9670;&nbsp;</a></span>pointer <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockVectorType , bool Constness&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">internal::BlockVectorIterators::Iterator</a>&lt; BlockVectorType, Constness &gt;::<a class="el" href="group__Vectors.html#ga69afde293e371e48b3328b2bc7778cc9">pointer</a> =  <a class="el" href="group__Vectors.html#gabec7bbc4933bcd638ccb1aaf652dd4e8">value_type</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="block__vector__base_8h_source.html#l00151">151</a> of file <a class="el" href="block__vector__base_8h_source.html">block_vector_base.h</a>.</p>

</div>
</div>
<a id="ga9d181875a1af61daa02e34ccb0862e0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d181875a1af61daa02e34ccb0862e0b">&#9670;&nbsp;</a></span>dereference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockVectorType , bool Constness&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">internal::BlockVectorIterators::Iterator</a>&lt; BlockVectorType, Constness &gt;::<a class="el" href="group__Vectors.html#ga9d181875a1af61daa02e34ccb0862e0b">dereference_type</a> =  typename std::conditional&lt; Constness, <a class="el" href="group__Vectors.html#gabec7bbc4933bcd638ccb1aaf652dd4e8">value_type</a>, typename BlockVectorType::BlockType::reference&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="block__vector__base_8h_source.html#l00153">153</a> of file <a class="el" href="block__vector__base_8h_source.html">block_vector_base.h</a>.</p>

</div>
</div>
<a id="gac6cb619cadbaa9635f3cc6dba1d3b923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6cb619cadbaa9635f3cc6dba1d3b923">&#9670;&nbsp;</a></span>BlockVector <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockVectorType , bool Constness&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">internal::BlockVectorIterators::Iterator</a>&lt; BlockVectorType, Constness &gt;::<a class="el" href="group__Vectors.html#gac6cb619cadbaa9635f3cc6dba1d3b923">BlockVector</a> =  typename std:: conditional&lt;Constness, const BlockVectorType, BlockVectorType&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef the type of the block vector (which differs in constness, depending on the second template parameter). </p>

<p class="definition">Definition at line <a class="el" href="block__vector__base_8h_source.html#l00162">162</a> of file <a class="el" href="block__vector__base_8h_source.html">block_vector_base.h</a>.</p>

</div>
</div>
<a id="ga2f13f25da5172afa079df9d2804cef98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f13f25da5172afa079df9d2804cef98">&#9670;&nbsp;</a></span>BaseClass <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#ga2f13f25da5172afa079df9d2804cef98">BaseClass</a> =  <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt;<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt;Number&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef the base class for simpler access to its own alias. </p>

<p class="definition">Definition at line <a class="el" href="la__parallel__block__vector_8h_source.html#l00105">105</a> of file <a class="el" href="la__parallel__block__vector_8h_source.html">la_parallel_block_vector.h</a>.</p>

</div>
</div>
<a id="ga976be8dace145bc740fc4b5eaa08ecfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga976be8dace145bc740fc4b5eaa08ecfc">&#9670;&nbsp;</a></span>BlockType <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#ga976be8dace145bc740fc4b5eaa08ecfc">BlockType</a> =  typename <a class="el" href="group__Exceptions.html#gaeb971802cf05add5cf1c26338ce77a9b">BaseClass::BlockType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef the type of the underlying vector. </p>

<p class="definition">Definition at line <a class="el" href="la__parallel__block__vector_8h_source.html#l00110">110</a> of file <a class="el" href="la__parallel__block__vector_8h_source.html">la_parallel_block_vector.h</a>.</p>

</div>
</div>
<a id="ga0a43b405989a623b76a92efe2dfa5e39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a43b405989a623b76a92efe2dfa5e39">&#9670;&nbsp;</a></span>value_type <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#ga0a43b405989a623b76a92efe2dfa5e39">value_type</a> =  typename <a class="el" href="group__Exceptions.html#ga6055b029c116fd1fd580bfab2d4234ae">BaseClass::value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Import the alias from the base class. </p>

<p class="definition">Definition at line <a class="el" href="la__parallel__block__vector_8h_source.html#l00115">115</a> of file <a class="el" href="la__parallel__block__vector_8h_source.html">la_parallel_block_vector.h</a>.</p>

</div>
</div>
<a id="gab99352244c902251dcd351118e7c468a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab99352244c902251dcd351118e7c468a">&#9670;&nbsp;</a></span>real_type <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#gab99352244c902251dcd351118e7c468a">real_type</a> =  typename <a class="el" href="group__Exceptions.html#gab62c4ac95c3782bb2236bf67038adc20">BaseClass::real_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__block__vector_8h_source.html#l00116">116</a> of file <a class="el" href="la__parallel__block__vector_8h_source.html">la_parallel_block_vector.h</a>.</p>

</div>
</div>
<a id="gafc2cd36158818c25e48e79bc9f27827e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc2cd36158818c25e48e79bc9f27827e">&#9670;&nbsp;</a></span>pointer <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#gafc2cd36158818c25e48e79bc9f27827e">pointer</a> =  typename <a class="el" href="group__Exceptions.html#gaebed52638e6b26f5f18adec8a2437852">BaseClass::pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__block__vector_8h_source.html#l00117">117</a> of file <a class="el" href="la__parallel__block__vector_8h_source.html">la_parallel_block_vector.h</a>.</p>

</div>
</div>
<a id="gae230c8ce0c95764c28d22176b8bd396a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae230c8ce0c95764c28d22176b8bd396a">&#9670;&nbsp;</a></span>const_pointer <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#gae230c8ce0c95764c28d22176b8bd396a">const_pointer</a> =  typename <a class="el" href="group__Exceptions.html#ga46a99911c512a1a08d5c5e237986d765">BaseClass::const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__block__vector_8h_source.html#l00118">118</a> of file <a class="el" href="la__parallel__block__vector_8h_source.html">la_parallel_block_vector.h</a>.</p>

</div>
</div>
<a id="gae30d22265b642d73ed2ced13942ebb52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae30d22265b642d73ed2ced13942ebb52">&#9670;&nbsp;</a></span>reference <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#gae30d22265b642d73ed2ced13942ebb52">reference</a> =  typename <a class="el" href="group__Exceptions.html#ga9a15d476a8495a66f32508943c91294f">BaseClass::reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__block__vector_8h_source.html#l00119">119</a> of file <a class="el" href="la__parallel__block__vector_8h_source.html">la_parallel_block_vector.h</a>.</p>

</div>
</div>
<a id="gab4bf062593cccb0f3f8c3daca8d77f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4bf062593cccb0f3f8c3daca8d77f6f">&#9670;&nbsp;</a></span>const_reference <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#gab4bf062593cccb0f3f8c3daca8d77f6f">const_reference</a> =  typename <a class="el" href="group__Exceptions.html#ga490c8bf68dceb08dc60c2a3e0c6bf2a2">BaseClass::const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__block__vector_8h_source.html#l00120">120</a> of file <a class="el" href="la__parallel__block__vector_8h_source.html">la_parallel_block_vector.h</a>.</p>

</div>
</div>
<a id="gaa000c54aa3fc182e5f05422233af7257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa000c54aa3fc182e5f05422233af7257">&#9670;&nbsp;</a></span>size_type <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#gaa000c54aa3fc182e5f05422233af7257">size_type</a> =  typename <a class="el" href="group__Exceptions.html#ga5c50677a9f39b52e75474f172059ed45">BaseClass::size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__block__vector_8h_source.html#l00121">121</a> of file <a class="el" href="la__parallel__block__vector_8h_source.html">la_parallel_block_vector.h</a>.</p>

</div>
</div>
<a id="ga6f9a7abde54c56cd458765868a4a6da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f9a7abde54c56cd458765868a4a6da3">&#9670;&nbsp;</a></span>iterator <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#ga6f9a7abde54c56cd458765868a4a6da3">iterator</a> =  typename <a class="el" href="group__Exceptions.html#ga38316f0d1b9b1e4fa4dc3e0b4e15655e">BaseClass::iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__block__vector_8h_source.html#l00122">122</a> of file <a class="el" href="la__parallel__block__vector_8h_source.html">la_parallel_block_vector.h</a>.</p>

</div>
</div>
<a id="gae404965061ae3d6eb991582f3c492e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae404965061ae3d6eb991582f3c492e36">&#9670;&nbsp;</a></span>const_iterator <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#gae404965061ae3d6eb991582f3c492e36">const_iterator</a> =  typename <a class="el" href="group__Exceptions.html#ga84ecd5753f1f75fbe1fa76e7ec72b3d8">BaseClass::const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__block__vector_8h_source.html#l00123">123</a> of file <a class="el" href="la__parallel__block__vector_8h_source.html">la_parallel_block_vector.h</a>.</p>

</div>
</div>
<a id="gae018e039c0ca78a063c6a075be461283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae018e039c0ca78a063c6a075be461283">&#9670;&nbsp;</a></span>memory_space</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="group__Vectors.html#gae018e039c0ca78a063c6a075be461283">memory_space</a> =  MemorySpace</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l00252">252</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="gaca4439cf261c308591c649e442d097ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca4439cf261c308591c649e442d097ea">&#9670;&nbsp;</a></span>value_type <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="group__Vectors.html#gaca4439cf261c308591c649e442d097ea">value_type</a> =  Number</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l00253">253</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="gae5c3b93ed114bc9795c0e3b3d5902393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5c3b93ed114bc9795c0e3b3d5902393">&#9670;&nbsp;</a></span>pointer <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="group__Vectors.html#gae5c3b93ed114bc9795c0e3b3d5902393">pointer</a> =  <a class="el" href="group__Vectors.html#gaca4439cf261c308591c649e442d097ea">value_type</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l00254">254</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="ga84413e605d193829856edbaa9d75b57b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84413e605d193829856edbaa9d75b57b">&#9670;&nbsp;</a></span>const_pointer <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="group__Vectors.html#ga84413e605d193829856edbaa9d75b57b">const_pointer</a> =  const <a class="el" href="group__Vectors.html#gaca4439cf261c308591c649e442d097ea">value_type</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l00255">255</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="ga35abed3e6b898142990cecf00e8387da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35abed3e6b898142990cecf00e8387da">&#9670;&nbsp;</a></span>iterator <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="group__Vectors.html#ga35abed3e6b898142990cecf00e8387da">iterator</a> =  <a class="el" href="group__Vectors.html#gaca4439cf261c308591c649e442d097ea">value_type</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l00256">256</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="ga4a990da0f1e95dd6004fbf0cf711c53d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a990da0f1e95dd6004fbf0cf711c53d">&#9670;&nbsp;</a></span>const_iterator <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="group__Vectors.html#ga4a990da0f1e95dd6004fbf0cf711c53d">const_iterator</a> =  const <a class="el" href="group__Vectors.html#gaca4439cf261c308591c649e442d097ea">value_type</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l00257">257</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="gae2ae1224f3b1fbee6cc8ffa59901d6c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2ae1224f3b1fbee6cc8ffa59901d6c8">&#9670;&nbsp;</a></span>reference <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="group__Vectors.html#gae2ae1224f3b1fbee6cc8ffa59901d6c8">reference</a> =  <a class="el" href="group__Vectors.html#gaca4439cf261c308591c649e442d097ea">value_type</a> &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l00258">258</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="ga1aa37d6cce7c7fe31452d2bae09dc7ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1aa37d6cce7c7fe31452d2bae09dc7ba">&#9670;&nbsp;</a></span>const_reference <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="group__Vectors.html#ga1aa37d6cce7c7fe31452d2bae09dc7ba">const_reference</a> =  const <a class="el" href="group__Vectors.html#gaca4439cf261c308591c649e442d097ea">value_type</a> &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l00259">259</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="ga301cc0a1214a6aeb04bb4e1dd06a8dfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">&#9670;&nbsp;</a></span>size_type <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> =  <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l00260">260</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="ga34599939674e79cdc3808bb074bcf0ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34599939674e79cdc3808bb074bcf0ee">&#9670;&nbsp;</a></span>real_type <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="group__Vectors.html#ga34599939674e79cdc3808bb074bcf0ee">real_type</a> =  typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt;Number&gt;::<a class="el" href="group__Vectors.html#ga34599939674e79cdc3808bb074bcf0ee">real_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l00261">261</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="ga81ab101056e685ef358597528a48ccb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81ab101056e685ef358597528a48ccb7">&#9670;&nbsp;</a></span>size_type <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1Vector.html">LinearAlgebra::Vector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#ga81ab101056e685ef358597528a48ccb7">size_type</a> =  <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__vector_8h_source.html#l00081">81</a> of file <a class="el" href="la__vector_8h_source.html">la_vector.h</a>.</p>

</div>
</div>
<a id="gad23ad800e8a9a3bc7c4867c6ae884d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad23ad800e8a9a3bc7c4867c6ae884d19">&#9670;&nbsp;</a></span>value_type <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1Vector.html">LinearAlgebra::Vector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#gad23ad800e8a9a3bc7c4867c6ae884d19">value_type</a> =  typename <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt;Number&gt;::<a class="el" href="group__Vectors.html#gad23ad800e8a9a3bc7c4867c6ae884d19">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__vector_8h_source.html#l00082">82</a> of file <a class="el" href="la__vector_8h_source.html">la_vector.h</a>.</p>

</div>
</div>
<a id="gac7e6eda86837a55c4972c1b7d68b333f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7e6eda86837a55c4972c1b7d68b333f">&#9670;&nbsp;</a></span>BlockVector <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Vectors.html#gac7e6eda86837a55c4972c1b7d68b333f">parallel::distributed::BlockVector</a> = typedef <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt;Number&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An implementation of block vectors based on distributed deal.II vectors. While the base class provides for most of the interface, this class handles the actual allocation of vectors and provides functions that are specific to the underlying vector type.</p>
<dl class="section note"><dt>Note</dt><dd>Instantiations for this template are provided for <code>&lt;float&gt; and &lt;double&gt;</code>; others can be generated in application programs (see the section on <a class="el" href="Instantiations.html">Template instantiations</a> in the manual).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBlockLA">Block (linear algebra)</a></dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000070">Deprecated:</a></b></dt><dd>Use <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a> instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="parallel__block__vector_8h_source.html#l00059">59</a> of file <a class="el" href="parallel__block__vector_8h_source.html">parallel_block_vector.h</a>.</p>

</div>
</div>
<a id="ga78ebbb3c3d63dcb5c40a1484ad4d4aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78ebbb3c3d63dcb5c40a1484ad4d4aea">&#9670;&nbsp;</a></span>value_type <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#ga78ebbb3c3d63dcb5c40a1484ad4d4aea">value_type</a> =  Number</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare standard types used in all containers. These types parallel those in the <code>C++</code> standard libraries <code>vector&lt;...&gt;</code> class. </p>

<p class="definition">Definition at line <a class="el" href="read__write__vector_8h_source.html#l00141">141</a> of file <a class="el" href="read__write__vector_8h_source.html">read_write_vector.h</a>.</p>

</div>
</div>
<a id="ga4cbec4e320847462189ff8f4add8453c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4cbec4e320847462189ff8f4add8453c">&#9670;&nbsp;</a></span>pointer <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#ga4cbec4e320847462189ff8f4add8453c">pointer</a> =  <a class="el" href="group__Vectors.html#ga78ebbb3c3d63dcb5c40a1484ad4d4aea">value_type</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="read__write__vector_8h_source.html#l00142">142</a> of file <a class="el" href="read__write__vector_8h_source.html">read_write_vector.h</a>.</p>

</div>
</div>
<a id="gaaad8d2c9cecb03b6591a69888ec82272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaad8d2c9cecb03b6591a69888ec82272">&#9670;&nbsp;</a></span>const_pointer <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#gaaad8d2c9cecb03b6591a69888ec82272">const_pointer</a> =  const <a class="el" href="group__Vectors.html#ga78ebbb3c3d63dcb5c40a1484ad4d4aea">value_type</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="read__write__vector_8h_source.html#l00143">143</a> of file <a class="el" href="read__write__vector_8h_source.html">read_write_vector.h</a>.</p>

</div>
</div>
<a id="ga5e28f8f12865657afed81936ca9308ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e28f8f12865657afed81936ca9308ac">&#9670;&nbsp;</a></span>iterator <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#ga5e28f8f12865657afed81936ca9308ac">iterator</a> =  <a class="el" href="group__Vectors.html#ga78ebbb3c3d63dcb5c40a1484ad4d4aea">value_type</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="read__write__vector_8h_source.html#l00144">144</a> of file <a class="el" href="read__write__vector_8h_source.html">read_write_vector.h</a>.</p>

</div>
</div>
<a id="gac39936b0017c60e97d2c6643b612d970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac39936b0017c60e97d2c6643b612d970">&#9670;&nbsp;</a></span>const_iterator <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#gac39936b0017c60e97d2c6643b612d970">const_iterator</a> =  const <a class="el" href="group__Vectors.html#ga78ebbb3c3d63dcb5c40a1484ad4d4aea">value_type</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="read__write__vector_8h_source.html#l00145">145</a> of file <a class="el" href="read__write__vector_8h_source.html">read_write_vector.h</a>.</p>

</div>
</div>
<a id="ga6dc45e1e3848cddf1720a752c4b24345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6dc45e1e3848cddf1720a752c4b24345">&#9670;&nbsp;</a></span>reference <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#ga6dc45e1e3848cddf1720a752c4b24345">reference</a> =  <a class="el" href="group__Vectors.html#ga78ebbb3c3d63dcb5c40a1484ad4d4aea">value_type</a> &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="read__write__vector_8h_source.html#l00146">146</a> of file <a class="el" href="read__write__vector_8h_source.html">read_write_vector.h</a>.</p>

</div>
</div>
<a id="gaccc60ec8f2057ba2a6a5482a3c2c93f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccc60ec8f2057ba2a6a5482a3c2c93f4">&#9670;&nbsp;</a></span>const_reference <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#gaccc60ec8f2057ba2a6a5482a3c2c93f4">const_reference</a> =  const <a class="el" href="group__Vectors.html#ga78ebbb3c3d63dcb5c40a1484ad4d4aea">value_type</a> &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="read__write__vector_8h_source.html#l00147">147</a> of file <a class="el" href="read__write__vector_8h_source.html">read_write_vector.h</a>.</p>

</div>
</div>
<a id="gadc1437e8371646dcca5b74c01dc064a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc1437e8371646dcca5b74c01dc064a4">&#9670;&nbsp;</a></span>size_type <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#gadc1437e8371646dcca5b74c01dc064a4">size_type</a> =  <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="read__write__vector_8h_source.html#l00148">148</a> of file <a class="el" href="read__write__vector_8h_source.html">read_write_vector.h</a>.</p>

</div>
</div>
<a id="gaf1c0cad1a0b23c477db4c97ba895b038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1c0cad1a0b23c477db4c97ba895b038">&#9670;&nbsp;</a></span>real_type <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#gaf1c0cad1a0b23c477db4c97ba895b038">real_type</a> =  typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt;Number&gt;::<a class="el" href="group__Vectors.html#gaf1c0cad1a0b23c477db4c97ba895b038">real_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="read__write__vector_8h_source.html#l00149">149</a> of file <a class="el" href="read__write__vector_8h_source.html">read_write_vector.h</a>.</p>

</div>
</div>
<a id="gaf239d5c3249bbed95fbabec1d17b9827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf239d5c3249bbed95fbabec1d17b9827">&#9670;&nbsp;</a></span>value_type <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#gaf239d5c3249bbed95fbabec1d17b9827">value_type</a> =  Number</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare standard types used in all containers. These types parallel those in the <code>C++</code> standard libraries <code>vector&lt;...&gt;</code> class. </p>

<p class="definition">Definition at line <a class="el" href="vector_8h_source.html#l00122">122</a> of file <a class="el" href="vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="ga8f7ef5265cbcae4d30f7e3fcde61a7f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f7ef5265cbcae4d30f7e3fcde61a7f9">&#9670;&nbsp;</a></span>pointer <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#ga8f7ef5265cbcae4d30f7e3fcde61a7f9">pointer</a> =  <a class="el" href="group__Vectors.html#gaf239d5c3249bbed95fbabec1d17b9827">value_type</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="vector_8h_source.html#l00123">123</a> of file <a class="el" href="vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="ga0a1be85b8a5e0669f9034cf8e4421a11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a1be85b8a5e0669f9034cf8e4421a11">&#9670;&nbsp;</a></span>const_pointer <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#ga0a1be85b8a5e0669f9034cf8e4421a11">const_pointer</a> =  const <a class="el" href="group__Vectors.html#gaf239d5c3249bbed95fbabec1d17b9827">value_type</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="vector_8h_source.html#l00124">124</a> of file <a class="el" href="vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="gacb8006e49918faaffeccd151669d0934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb8006e49918faaffeccd151669d0934">&#9670;&nbsp;</a></span>iterator <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#gacb8006e49918faaffeccd151669d0934">iterator</a> =  <a class="el" href="group__Vectors.html#gaf239d5c3249bbed95fbabec1d17b9827">value_type</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="vector_8h_source.html#l00125">125</a> of file <a class="el" href="vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="ga31d7e7b4278a3fa08a6e5ceec3deb0fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31d7e7b4278a3fa08a6e5ceec3deb0fb">&#9670;&nbsp;</a></span>const_iterator <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#ga31d7e7b4278a3fa08a6e5ceec3deb0fb">const_iterator</a> =  const <a class="el" href="group__Vectors.html#gaf239d5c3249bbed95fbabec1d17b9827">value_type</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="vector_8h_source.html#l00126">126</a> of file <a class="el" href="vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="gadace73f5502652dce7656ae891ddcc43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadace73f5502652dce7656ae891ddcc43">&#9670;&nbsp;</a></span>reference <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#gadace73f5502652dce7656ae891ddcc43">reference</a> =  <a class="el" href="group__Vectors.html#gaf239d5c3249bbed95fbabec1d17b9827">value_type</a> &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="vector_8h_source.html#l00127">127</a> of file <a class="el" href="vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="ga3b7a89720422deb00992571e3e7cf1ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b7a89720422deb00992571e3e7cf1ce">&#9670;&nbsp;</a></span>const_reference <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#ga3b7a89720422deb00992571e3e7cf1ce">const_reference</a> =  const <a class="el" href="group__Vectors.html#gaf239d5c3249bbed95fbabec1d17b9827">value_type</a> &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="vector_8h_source.html#l00128">128</a> of file <a class="el" href="vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="ga5927fb109e04d1d4988dae5c910fc32d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5927fb109e04d1d4988dae5c910fc32d">&#9670;&nbsp;</a></span>size_type <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#ga5927fb109e04d1d4988dae5c910fc32d">size_type</a> =  <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="vector_8h_source.html#l00129">129</a> of file <a class="el" href="vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="ga02452a5983fd0e8c956ab9278213bd2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02452a5983fd0e8c956ab9278213bd2c">&#9670;&nbsp;</a></span>real_type <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#ga02452a5983fd0e8c956ab9278213bd2c">real_type</a> =  typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt;Number&gt;::<a class="el" href="group__Vectors.html#ga02452a5983fd0e8c956ab9278213bd2c">real_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare a type that has holds real-valued numbers with the same precision as the template argument to this class. If the template argument of this class is a real data type, then real_type equals the template argument. If the template argument is a std::complex type then real_type equals the type underlying the complex numbers.</p>
<p>This alias is used to represent the return type of norms. </p>

<p class="definition">Definition at line <a class="el" href="vector_8h_source.html#l00140">140</a> of file <a class="el" href="vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="ga327cd3179fb6078605a14b772a0dc20d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga327cd3179fb6078605a14b772a0dc20d">&#9670;&nbsp;</a></span>value_type <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">LinearAlgebra::VectorSpaceVector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#ga327cd3179fb6078605a14b772a0dc20d">value_type</a> =  Number</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="vector__space__vector_8h_source.html#l00058">58</a> of file <a class="el" href="vector__space__vector_8h_source.html">vector_space_vector.h</a>.</p>

</div>
</div>
<a id="ga42c84b64cfafc72e8eef6e284bf899dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42c84b64cfafc72e8eef6e284bf899dc">&#9670;&nbsp;</a></span>size_type <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">LinearAlgebra::VectorSpaceVector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#ga42c84b64cfafc72e8eef6e284bf899dc">size_type</a> =  <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="vector__space__vector_8h_source.html#l00059">59</a> of file <a class="el" href="vector__space__vector_8h_source.html">vector_space_vector.h</a>.</p>

</div>
</div>
<a id="ga6ec199439799ef30b1845bda4cbe8d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ec199439799ef30b1845bda4cbe8d43">&#9670;&nbsp;</a></span>real_type <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">LinearAlgebra::VectorSpaceVector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#ga6ec199439799ef30b1845bda4cbe8d43">real_type</a> =  typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt;Number&gt;::<a class="el" href="group__Vectors.html#ga6ec199439799ef30b1845bda4cbe8d43">real_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="vector__space__vector_8h_source.html#l00060">60</a> of file <a class="el" href="vector__space__vector_8h_source.html">vector_space_vector.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga40c50779cd14ba89bbf0bd9b4561964c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40c50779cd14ba89bbf0bd9b4561964c">&#9670;&nbsp;</a></span>values</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga40c50779cd14ba89bbf0bd9b4561964ca9c7dc8036a5632e9ed2a183c3c2812e6"></a>unknown&#160;</td><td class="fielddoc"><p>The current operation is unknown. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09"></a>insert&#160;</td><td class="fielddoc"><p>The current operation is an insertion. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708"></a>add&#160;</td><td class="fielddoc"><p>The current operation is an addition. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga40c50779cd14ba89bbf0bd9b4561964ca5e8042e5d04399d125cb923eda7a8d8b"></a>min&#160;</td><td class="fielddoc"><p>The current operation is a minimization. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga40c50779cd14ba89bbf0bd9b4561964caaae8b002691d4887ce68ecf3e785c13e"></a>max&#160;</td><td class="fielddoc"><p>The current operation is a maximization. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="vector__operation_8h_source.html#l00040">40</a> of file <a class="el" href="vector__operation_8h_source.html">vector_operation.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga8e45553e4f28aa527bf2554cd027d08e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e45553e4f28aa527bf2554cd027d08e">&#9670;&nbsp;</a></span>BlockVector() <span class="overload">[1/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt;::<a class="el" href="classBlockVector.html">BlockVector</a> </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_blocks</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#gab0855e15b27a3f125629272a1b969920">size_type</a>&#160;</td>
          <td class="paramname"><em>block_size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor. There are three ways to use this constructor. First, without any arguments, it generates an object with no blocks. Given one argument, it initializes <code>n_blocks</code> blocks, but these blocks have size zero. The third variant finally initializes all blocks to the same size <code>block_size</code>.</p>
<p>Confer the other constructor further down if you intend to use blocks of different sizes. </p>

</div>
</div>
<a id="ga78986a9eadec7f2be667dbcb3fa6add5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78986a9eadec7f2be667dbcb3fa6add5">&#9670;&nbsp;</a></span>BlockVector() <span class="overload">[2/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt;::<a class="el" href="classBlockVector.html">BlockVector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy Constructor. Dimension set to that of <code>v</code>, all components are copied from <code>v</code>. </p>

</div>
</div>
<a id="ga98949dda578d30c3c61a598b3f698a24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98949dda578d30c3c61a598b3f698a24">&#9670;&nbsp;</a></span>BlockVector() <span class="overload">[3/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt;::<a class="el" href="classBlockVector.html">BlockVector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor. Creates a new vector by stealing the internal data of the given argument vector. </p>

</div>
</div>
<a id="ga5e2ba6b81105354a3786ab5756dd889b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e2ba6b81105354a3786ab5756dd889b">&#9670;&nbsp;</a></span>BlockVector() <span class="overload">[4/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt;::<a class="el" href="classBlockVector.html">BlockVector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockVector.html">BlockVector</a>&lt; OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor taking a <a class="el" href="classBlockVector.html">BlockVector</a> of another data type. This will fail if there is no conversion path from <code>OtherNumber</code> to <code>Number</code>. Note that you may lose accuracy when copying to a <a class="el" href="classBlockVector.html">BlockVector</a> with data elements with less accuracy.</p>
<p>Older versions of gcc did not honor the <code>explicit</code> keyword on template constructors. In such cases, it is easy to accidentally write code that can be very inefficient, since the compiler starts performing hidden conversions. To avoid this, this function is disabled if we have detected a broken compiler during configuration. </p>

</div>
</div>
<a id="ga43e4fb44c3389c26f45a0c08282f07bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43e4fb44c3389c26f45a0c08282f07bd">&#9670;&nbsp;</a></span>BlockVector() <span class="overload">[5/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt;::<a class="el" href="classBlockVector.html">BlockVector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A copy constructor taking a (parallel) Trilinos block vector and copying it into the deal.II own format. </p>

</div>
</div>
<a id="ga00bf81924e022728fc6870cc7340b08e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00bf81924e022728fc6870cc7340b08e">&#9670;&nbsp;</a></span>BlockVector() <span class="overload">[6/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt;::<a class="el" href="classBlockVector.html">BlockVector</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__Vectors.html#gab0855e15b27a3f125629272a1b969920">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_sizes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Set the number of blocks to <code>block_sizes.size()</code> and initialize each block with <code>block_sizes[i]</code> zero elements. </p>

</div>
</div>
<a id="ga4c1be582d9a0a10db6101abe60d0d1d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c1be582d9a0a10db6101abe60d0d1d3">&#9670;&nbsp;</a></span>BlockVector() <span class="overload">[7/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt;::<a class="el" href="classBlockVector.html">BlockVector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockIndices.html">BlockIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>block_indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Initialize vector to the structure found in the <a class="el" href="classBlockIndices.html">BlockIndices</a> argument. </p>

</div>
</div>
<a id="gad4a4befcc007d8beed7e1dd91fe9c5e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4a4befcc007d8beed7e1dd91fe9c5e9">&#9670;&nbsp;</a></span>BlockVector() <span class="overload">[8/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt;::<a class="el" href="classBlockVector.html">BlockVector</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__Vectors.html#gab0855e15b27a3f125629272a1b969920">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Set the number of blocks to <code>block_sizes.size()</code>. Initialize the vector with the elements pointed to by the range of iterators given as second and third argument. Apart from the first argument, this constructor is in complete analogy to the respective constructor of the <code>std::vector</code> class, but the first argument is needed in order to know how to subdivide the block vector into different blocks. </p>

</div>
</div>
<a id="ga8d37feebc46fc1af1306d66f72e9f545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d37feebc46fc1af1306d66f72e9f545">&#9670;&nbsp;</a></span>~BlockVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt;::~<a class="el" href="classBlockVector.html">BlockVector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. Clears memory </p>

</div>
</div>
<a id="gad581edc4d3b86a88c4277117c4fae57a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad581edc4d3b86a88c4277117c4fae57a">&#9670;&nbsp;</a></span>compress() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt;::compress </td>
          <td>(</td>
          <td class="paramtype">::<a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em> = <code>::<a class="el" href="group__Vectors.html#gga40c50779cd14ba89bbf0bd9b4561964ca9c7dc8036a5632e9ed2a183c3c2812e6">VectorOperation::unknown</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the <a class="el" href="group__Vectors.html#gad581edc4d3b86a88c4277117c4fae57a">compress()</a> function on all the subblocks.</p>
<p>This functionality only needs to be called if using MPI based vectors and exists in other objects for compatibility.</p>
<p>See <a class="el" href="DEALGlossary.html#GlossCompress">Compressing distributed objects</a> for more information. </p>

</div>
</div>
<a id="ga3ddd3ad89fdeadf962828ee0c6d74b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ddd3ad89fdeadf962828ee0c6d74b6f">&#9670;&nbsp;</a></span>has_ghost_elements() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt;::has_ghost_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>false</code> as this is a serial block vector.</p>
<p>This functionality only needs to be called if using MPI based vectors and exists in other objects for compatibility. </p>

</div>
</div>
<a id="gaaa7d25220450aed5b09fa859eec359d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa7d25220450aed5b09fa859eec359d8">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/30]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockVector.html">BlockVector</a>&amp; <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#ga5623a846ef43840761d167225ff55143">value_type</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy operator: fill all components of the vector with the given scalar value. </p>

</div>
</div>
<a id="gabdc66f58f974c73cfe4b26171f188b3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdc66f58f974c73cfe4b26171f188b3c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/30]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockVector.html">BlockVector</a>&lt;Number&gt;&amp; <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy operator for arguments of the same type. Resize the present vector if necessary. </p>

</div>
</div>
<a id="ga9e0b08637a753fbfd5c639a53f1f77f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e0b08637a753fbfd5c639a53f1f77f9">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/30]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockVector.html">BlockVector</a>&lt;Number&gt;&amp; <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move the given vector. This operator replaces the present vector with the contents of the given argument vector. </p>

</div>
</div>
<a id="gabfcc8e87be6276987172a0558eb89a23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfcc8e87be6276987172a0558eb89a23">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/30]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;class Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockVector.html">BlockVector</a>&lt;Number&gt;&amp; <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy operator for template arguments of different types. Resize the present vector if necessary. </p>

</div>
</div>
<a id="ga40dd83907896cc3ab1334d530e934692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40dd83907896cc3ab1334d530e934692">&#9670;&nbsp;</a></span>operator=() <span class="overload">[5/30]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockVector.html">BlockVector</a>&lt;Number&gt;&amp; <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy a regular vector into a block vector. </p>

</div>
</div>
<a id="ga1cf7dc779cd3e07a022b43bfb87f0bfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cf7dc779cd3e07a022b43bfb87f0bfc">&#9670;&nbsp;</a></span>operator=() <span class="overload">[6/30]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockVector.html">BlockVector</a>&lt;Number&gt;&amp; <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A copy constructor from a Trilinos block vector to a deal.II block vector. </p>

</div>
</div>
<a id="gadf4d1d6c3538af95309a95da2ded758c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf4d1d6c3538af95309a95da2ded758c">&#9670;&nbsp;</a></span>reinit() <span class="overload">[1/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#gab0855e15b27a3f125629272a1b969920">size_type</a>&#160;</td>
          <td class="paramname"><em>block_size</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinitialize the <a class="el" href="classBlockVector.html">BlockVector</a> to contain <code>n_blocks</code> blocks of size <code>block_size</code> each.</p>
<p>If the second argument is left at its default value, then the block vector allocates the specified number of blocks but leaves them at zero size. You then need to later reinitialize the individual blocks, and call <a class="el" href="group__Exceptions.html#ga6a27b2a48e5b5780cd0a6640b928d794">collect_sizes()</a> to update the block system's knowledge of its individual block's sizes.</p>
<p>If <code>omit_zeroing_entries==false</code>, the vector is filled with zeros. </p>

</div>
</div>
<a id="ga994786648a6e71dcd0e26c8d4895659c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga994786648a6e71dcd0e26c8d4895659c">&#9670;&nbsp;</a></span>reinit() <span class="overload">[2/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__Vectors.html#gab0855e15b27a3f125629272a1b969920">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinitialize the <a class="el" href="classBlockVector.html">BlockVector</a> such that it contains <code>block_sizes.size()</code> blocks. Each block is reinitialized to dimension <code>block_sizes[i]</code>.</p>
<p>If the number of blocks is the same as before this function was called, all vectors remain the same and <a class="el" href="group__Vectors.html#gadf4d1d6c3538af95309a95da2ded758c">reinit()</a> is called for each vector.</p>
<p>If <code>omit_zeroing_entries==false</code>, the vector is filled with zeros.</p>
<p>Note that you must call this (or the other <a class="el" href="group__Vectors.html#gadf4d1d6c3538af95309a95da2ded758c">reinit()</a> functions) function, rather than calling the <a class="el" href="group__Vectors.html#gadf4d1d6c3538af95309a95da2ded758c">reinit()</a> functions of an individual block, to allow the block vector to update its caches of vector sizes. If you call <a class="el" href="group__Vectors.html#gadf4d1d6c3538af95309a95da2ded758c">reinit()</a> on one of the blocks, then subsequent actions on this object may yield unpredictable results since they may be routed to the wrong block. </p>

</div>
</div>
<a id="ga143400e3263cf7d79197c8236b35956f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga143400e3263cf7d79197c8236b35956f">&#9670;&nbsp;</a></span>reinit() <span class="overload">[3/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockIndices.html">BlockIndices</a> &amp;&#160;</td>
          <td class="paramname"><em>block_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinitialize the <a class="el" href="classBlockVector.html">BlockVector</a> to reflect the structure found in <a class="el" href="classBlockIndices.html">BlockIndices</a>.</p>
<p>If the number of blocks is the same as before this function was called, all vectors remain the same and <a class="el" href="group__Vectors.html#gadf4d1d6c3538af95309a95da2ded758c">reinit()</a> is called for each vector.</p>
<p>If <code>omit_zeroing_entries==false</code>, the vector is filled with zeros. </p>

</div>
</div>
<a id="gaf32bbcd70be08db7bd5db4eb413dff6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf32bbcd70be08db7bd5db4eb413dff6a">&#9670;&nbsp;</a></span>reinit() <span class="overload">[4/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the dimension to that of the vector <code>V</code>. The same applies as for the other <a class="el" href="group__Vectors.html#gadf4d1d6c3538af95309a95da2ded758c">reinit()</a> function.</p>
<p>The elements of <code>V</code> are not copied, i.e. this function is the same as calling <code>reinit (V.size(), omit_zeroing_entries)</code>.</p>
<p>Note that you must call this (or the other <a class="el" href="group__Vectors.html#gadf4d1d6c3538af95309a95da2ded758c">reinit()</a> functions) function, rather than calling the <a class="el" href="group__Vectors.html#gadf4d1d6c3538af95309a95da2ded758c">reinit()</a> functions of an individual block, to allow the block vector to update its caches of vector sizes. If you call <a class="el" href="group__Vectors.html#gadf4d1d6c3538af95309a95da2ded758c">reinit()</a> of one of the blocks, then subsequent actions of this object may yield unpredictable results since they may be routed to the wrong block. </p>

</div>
</div>
<a id="ga91880bf03fd7fd2b6fb5d0512d4c8711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91880bf03fd7fd2b6fb5d0512d4c8711">&#9670;&nbsp;</a></span>scale() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;class BlockVector2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt;::scale </td>
          <td>(</td>
          <td class="paramtype">const BlockVector2 &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiply each element of this vector by the corresponding element of <code>v</code>. </p>

</div>
</div>
<a id="ga159d4a8b6dc3e036c04482a661c3e5d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga159d4a8b6dc3e036c04482a661c3e5d9">&#9670;&nbsp;</a></span>swap() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swap the contents of this vector and the other vector <code>v</code>. One could do this operation with a temporary variable and copying over the data elements, but this function is significantly more efficient since it only swaps the pointers to the data of the two vectors and therefore does not need to allocate temporary storage and move data around.</p>
<p>This function is analogous to the <a class="el" href="group__Vectors.html#ga159d4a8b6dc3e036c04482a661c3e5d9">swap()</a> function of all C++ standard containers. Also, there is a global function swap(u,v) that simply calls <code>u.swap(v)</code>, again in analogy to standard functions. </p>

</div>
</div>
<a id="ga1e5f2a8ad93c314833469b89f2d6ec8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e5f2a8ad93c314833469b89f2d6ec8b">&#9670;&nbsp;</a></span>print() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>precision</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>scientific</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>across</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print to a stream. </p>

</div>
</div>
<a id="ga87c16a08fe250763830f42c517f6d0ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87c16a08fe250763830f42c517f6d0ae">&#9670;&nbsp;</a></span>block_write() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt;::block_write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the vector en bloc to a stream. This is done in a binary mode, so the output is neither readable by humans nor (probably) by other computers using a different operating system or number format. </p>

</div>
</div>
<a id="ga9afdd3848e94d63790bc1ba1041c3560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9afdd3848e94d63790bc1ba1041c3560">&#9670;&nbsp;</a></span>block_read() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt;::block_read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a vector en block from a file. This is done using the inverse operations to the above function, so it is reasonably fast because the bitstream is not interpreted.</p>
<p>The vector is resized if necessary.</p>
<p>A primitive form of error checking is performed which will recognize the bluntest attempts to interpret some data as a vector stored bitwise to a file, but not more. </p>

</div>
</div>
<a id="gae2a64fee4774f141397d2ab5838e6b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2a64fee4774f141397d2ab5838e6b2f">&#9670;&nbsp;</a></span>swap() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Global function which overloads the default implementation of the C++ standard library which uses a temporary object. The function simply exchanges the data of the two vectors. </p>

<p class="definition">Definition at line <a class="el" href="block__vector_8h_source.html#l00489">489</a> of file <a class="el" href="block__vector_8h_source.html">block_vector.h</a>.</p>

</div>
</div>
<a id="ga4ee6fdddb0ec9fb3c8d4e16abc17f6a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ee6fdddb0ec9fb3c8d4e16abc17f6a3">&#9670;&nbsp;</a></span>check_for_block_vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::true_type <a class="el" href="structIsBlockVector.html">IsBlockVector</a>&lt; VectorType &gt;::check_for_block_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload returning true if the class is derived from <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>, which is what block vectors do. </p>

</div>
</div>
<a id="gaab8dd8f67ddc91a78389088d662711e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab8dd8f67ddc91a78389088d662711e4">&#9670;&nbsp;</a></span>check_for_block_vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::false_type <a class="el" href="structIsBlockVector.html">IsBlockVector</a>&lt; VectorType &gt;::check_for_block_vector </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Catch all for all other potential vector types that are not block matrices. </p>

</div>
</div>
<a id="ga9ec9730a429aaea74edebb4f3c346155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ec9730a429aaea74edebb4f3c346155">&#9670;&nbsp;</a></span>Iterator() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockVectorType , bool Constness&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">internal::BlockVectorIterators::Iterator</a>&lt; BlockVectorType, Constness &gt;::<a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">Iterator</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Vectors.html#gac6cb619cadbaa9635f3cc6dba1d3b923">BlockVector</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#gaa1bcff6afb8cf43ac20e2cb12005472b">size_type</a>&#160;</td>
          <td class="paramname"><em>global_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct an iterator from a vector to which we point and the global index of the element pointed to.</p>
<p>Depending on the value of the <code>Constness</code> template argument of this class, the first argument of this constructor is either is a const or non-const reference. </p>

</div>
</div>
<a id="ga82cbb244c2ae9eb411fbaeeff6ab6e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82cbb244c2ae9eb411fbaeeff6ab6e53">&#9670;&nbsp;</a></span>Iterator() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockVectorType , bool Constness&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">internal::BlockVectorIterators::Iterator</a>&lt; BlockVectorType, Constness &gt;::<a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">Iterator</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">Iterator</a>&lt; BlockVectorType, !Constness &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor from an iterator of different constness.</p>
<dl class="section note"><dt>Note</dt><dd>Constructing a non-const iterator from a const iterator does not make sense. Attempting this will result in a compile-time error (via <code>static_assert</code>). </dd></dl>

</div>
</div>
<a id="ga850782f06274933fe5177fdc3b3036f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga850782f06274933fe5177fdc3b3036f7">&#9670;&nbsp;</a></span>Iterator() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockVectorType , bool Constness&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">internal::BlockVectorIterators::Iterator</a>&lt; BlockVectorType, Constness &gt;::<a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">Iterator</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">Iterator</a>&lt; BlockVectorType, Constness &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor from an iterator with the same constness. </p>

</div>
</div>
<a id="ga73e4d9e0541196fdaa17c604e6a648bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73e4d9e0541196fdaa17c604e6a648bc">&#9670;&nbsp;</a></span>Iterator() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockVectorType , bool Constness&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">internal::BlockVectorIterators::Iterator</a>&lt; BlockVectorType, Constness &gt;::<a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">Iterator</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Vectors.html#gac6cb619cadbaa9635f3cc6dba1d3b923">BlockVector</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#gaa1bcff6afb8cf43ac20e2cb12005472b">size_type</a>&#160;</td>
          <td class="paramname"><em>global_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#gaa1bcff6afb8cf43ac20e2cb12005472b">size_type</a>&#160;</td>
          <td class="paramname"><em>current_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#gaa1bcff6afb8cf43ac20e2cb12005472b">size_type</a>&#160;</td>
          <td class="paramname"><em>index_within_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#gaa1bcff6afb8cf43ac20e2cb12005472b">size_type</a>&#160;</td>
          <td class="paramname"><em>next_break_forward</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#gaa1bcff6afb8cf43ac20e2cb12005472b">size_type</a>&#160;</td>
          <td class="paramname"><em>next_break_backward</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor used internally in this class. The arguments match exactly the values of the respective member variables. </p>

</div>
</div>
<a id="gaabf2702b7981d15938041d8d735f3c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabf2702b7981d15938041d8d735f3c07">&#9670;&nbsp;</a></span>operator=() <span class="overload">[7/30]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockVectorType , bool Constness&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">Iterator</a>&amp; <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">internal::BlockVectorIterators::Iterator</a>&lt; BlockVectorType, Constness &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">Iterator</a>&lt; BlockVectorType, Constness &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy operator. </p>

</div>
</div>
<a id="ga88e0b47ebdc4fa9741856af70c402275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88e0b47ebdc4fa9741856af70c402275">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockVectorType , bool Constness&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Vectors.html#ga9d181875a1af61daa02e34ccb0862e0b">dereference_type</a> <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">internal::BlockVectorIterators::Iterator</a>&lt; BlockVectorType, Constness &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dereferencing operator. If the template argument <code>Constness</code> is <code>true</code>, then no writing to the result is possible, making this a const_iterator. </p>

</div>
</div>
<a id="ga5b8ece554d2c4e233a3d715ddd5e7165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b8ece554d2c4e233a3d715ddd5e7165">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockVectorType , bool Constness&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Vectors.html#ga9d181875a1af61daa02e34ccb0862e0b">dereference_type</a> <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">internal::BlockVectorIterators::Iterator</a>&lt; BlockVectorType, Constness &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#gad8cb3bf4001514075bff8361519b6046">difference_type</a>&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Random access operator, grant access to arbitrary elements relative to the one presently pointed to. </p>

</div>
</div>
<a id="gab1d778ac6c7dc073ee109f97480a1ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1d778ac6c7dc073ee109f97480a1ddd">&#9670;&nbsp;</a></span>operator++() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockVectorType , bool Constness&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">Iterator</a>&amp; <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">internal::BlockVectorIterators::Iterator</a>&lt; BlockVectorType, Constness &gt;::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prefix increment operator. This operator advances the iterator to the next element and returns a reference to <code>*this</code>. </p>

</div>
</div>
<a id="gac8dd3053d6bab44623b5cdf72ae19a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8dd3053d6bab44623b5cdf72ae19a09">&#9670;&nbsp;</a></span>operator++() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockVectorType , bool Constness&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">Iterator</a> <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">internal::BlockVectorIterators::Iterator</a>&lt; BlockVectorType, Constness &gt;::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Postfix increment operator. This operator advances the iterator to the next element and returns a copy of the old value of this iterator. </p>

</div>
</div>
<a id="gafd53b8d73d007ba3e42003153d14d841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd53b8d73d007ba3e42003153d14d841">&#9670;&nbsp;</a></span>operator--() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockVectorType , bool Constness&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">Iterator</a>&amp; <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">internal::BlockVectorIterators::Iterator</a>&lt; BlockVectorType, Constness &gt;::operator-- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prefix decrement operator. This operator retracts the iterator to the previous element and returns a reference to <code>*this</code>. </p>

</div>
</div>
<a id="gaa6c24849c69b440d5c002a13c07d5d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6c24849c69b440d5c002a13c07d5d95">&#9670;&nbsp;</a></span>operator--() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockVectorType , bool Constness&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">Iterator</a> <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">internal::BlockVectorIterators::Iterator</a>&lt; BlockVectorType, Constness &gt;::operator-- </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Postfix decrement operator. This operator retracts the iterator to the previous element and returns a copy of the old value of this iterator. </p>

</div>
</div>
<a id="ga14ab0af961d4aae22b8d3947b7a0dbb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14ab0af961d4aae22b8d3947b7a0dbb3">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockVectorType , bool Constness&gt; </div>
<div class="memtemplate">
template&lt;bool OtherConstness&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">internal::BlockVectorIterators::Iterator</a>&lt; BlockVectorType, Constness &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">Iterator</a>&lt; BlockVectorType, OtherConstness &gt; &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare for equality of iterators. This operator checks whether the vectors pointed to are the same, and if not it throws an exception. </p>

</div>
</div>
<a id="gaf6659c8c704fa68fb690cdff1f363218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6659c8c704fa68fb690cdff1f363218">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockVectorType , bool Constness&gt; </div>
<div class="memtemplate">
template&lt;bool OtherConstness&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">internal::BlockVectorIterators::Iterator</a>&lt; BlockVectorType, Constness &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">Iterator</a>&lt; BlockVectorType, OtherConstness &gt; &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare for inequality of iterators. This operator checks whether the vectors pointed to are the same, and if not it throws an exception. </p>

</div>
</div>
<a id="ga6a73ea3816628cdba5ffd7e75fc811c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a73ea3816628cdba5ffd7e75fc811c2">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockVectorType , bool Constness&gt; </div>
<div class="memtemplate">
template&lt;bool OtherConstness&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">internal::BlockVectorIterators::Iterator</a>&lt; BlockVectorType, Constness &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">Iterator</a>&lt; BlockVectorType, OtherConstness &gt; &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether this iterators points to an element previous to the one pointed to by the given argument. This operator checks whether the vectors pointed to are the same, and if not it throws an exception. </p>

</div>
</div>
<a id="gaeff1222550319569f6d00dde93c27871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeff1222550319569f6d00dde93c27871">&#9670;&nbsp;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockVectorType , bool Constness&gt; </div>
<div class="memtemplate">
template&lt;bool OtherConstness&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">internal::BlockVectorIterators::Iterator</a>&lt; BlockVectorType, Constness &gt;::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">Iterator</a>&lt; BlockVectorType, OtherConstness &gt; &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Comparison operator alike to the one above. </p>

</div>
</div>
<a id="gaf66ee628dd3cb921aea9eba8e21f98ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf66ee628dd3cb921aea9eba8e21f98ab">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockVectorType , bool Constness&gt; </div>
<div class="memtemplate">
template&lt;bool OtherConstness&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">internal::BlockVectorIterators::Iterator</a>&lt; BlockVectorType, Constness &gt;::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">Iterator</a>&lt; BlockVectorType, OtherConstness &gt; &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Comparison operator alike to the one above. </p>

</div>
</div>
<a id="gaa577307394ce1c46990c0e5cbdf78d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa577307394ce1c46990c0e5cbdf78d12">&#9670;&nbsp;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockVectorType , bool Constness&gt; </div>
<div class="memtemplate">
template&lt;bool OtherConstness&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">internal::BlockVectorIterators::Iterator</a>&lt; BlockVectorType, Constness &gt;::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">Iterator</a>&lt; BlockVectorType, OtherConstness &gt; &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Comparison operator alike to the one above. </p>

</div>
</div>
<a id="ga920dc46d0bd64a0384a9fa3f60287fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga920dc46d0bd64a0384a9fa3f60287fae">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockVectorType , bool Constness&gt; </div>
<div class="memtemplate">
template&lt;bool OtherConstness&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Vectors.html#gad8cb3bf4001514075bff8361519b6046">difference_type</a> <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">internal::BlockVectorIterators::Iterator</a>&lt; BlockVectorType, Constness &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">Iterator</a>&lt; BlockVectorType, OtherConstness &gt; &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the distance between the two iterators, in elements. </p>

</div>
</div>
<a id="gaf437ea4584dcf36bfeeb172c63b6dc9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf437ea4584dcf36bfeeb172c63b6dc9a">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockVectorType , bool Constness&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">Iterator</a> <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">internal::BlockVectorIterators::Iterator</a>&lt; BlockVectorType, Constness &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#gad8cb3bf4001514075bff8361519b6046">difference_type</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator which is the given number of elements in front of the present one. </p>

</div>
</div>
<a id="ga8a961f5e1a3e9dacceef15efc9958a6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a961f5e1a3e9dacceef15efc9958a6c">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockVectorType , bool Constness&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">Iterator</a> <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">internal::BlockVectorIterators::Iterator</a>&lt; BlockVectorType, Constness &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#gad8cb3bf4001514075bff8361519b6046">difference_type</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator which is the given number of elements behind the present one. </p>

</div>
</div>
<a id="ga8cbef2bc6d086e5203c2536265e654e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8cbef2bc6d086e5203c2536265e654e1">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockVectorType , bool Constness&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">Iterator</a>&amp; <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">internal::BlockVectorIterators::Iterator</a>&lt; BlockVectorType, Constness &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#gad8cb3bf4001514075bff8361519b6046">difference_type</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move the iterator <code>d</code> elements forward at once, and return the result. </p>

</div>
</div>
<a id="ga4b6f3aa156ff14f806e33d171d2b4a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b6f3aa156ff14f806e33d171d2b4a51">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockVectorType , bool Constness&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">Iterator</a>&amp; <a class="el" href="classinternal_1_1BlockVectorIterators_1_1Iterator.html">internal::BlockVectorIterators::Iterator</a>&lt; BlockVectorType, Constness &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#gad8cb3bf4001514075bff8361519b6046">difference_type</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move the iterator <code>d</code> elements backward at once, and return the result. </p>

</div>
</div>
<a id="ga28bef4c0ba10221b1aeaf200f1bd8957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28bef4c0ba10221b1aeaf200f1bd8957">&#9670;&nbsp;</a></span>BlockVector() <span class="overload">[9/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#gaa000c54aa3fc182e5f05422233af7257">size_type</a>&#160;</td>
          <td class="paramname"><em>num_blocks</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#gaa000c54aa3fc182e5f05422233af7257">size_type</a>&#160;</td>
          <td class="paramname"><em>block_size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor. There are three ways to use this constructor. First, without any arguments, it generates an object with no blocks. Given one argument, it initializes <code>num_blocks</code> blocks, but these blocks have size zero. The third variant finally initializes all blocks to the same size <code>block_size</code>.</p>
<p>Confer the other constructor further down if you intend to use blocks of different sizes. </p>

</div>
</div>
<a id="ga77e77142f145f27e6de83c7769fee866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77e77142f145f27e6de83c7769fee866">&#9670;&nbsp;</a></span>BlockVector() <span class="overload">[10/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy-Constructor. Dimension set to that of V, all components are copied from V </p>

</div>
</div>
<a id="ga6e6e3a3ba2c1ad09c7b2e9bde1fd52fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e6e3a3ba2c1ad09c7b2e9bde1fd52fd">&#9670;&nbsp;</a></span>BlockVector() <span class="overload">[11/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor taking a <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a> of another data type. This will fail if there is no conversion path from <code>OtherNumber</code> to <code>Number</code>. Note that you may lose accuracy when copying to a <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a> with data elements with less accuracy.</p>
<p>Older versions of gcc did not honor the <code>explicit</code> keyword on template constructors. In such cases, it is easy to accidentally write code that can be very inefficient, since the compiler starts performing hidden conversions. To avoid this, this function is disabled if we have detected a broken compiler during configuration. </p>

</div>
</div>
<a id="ga632b36dc3cfbe1858681e56f985b8a8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga632b36dc3cfbe1858681e56f985b8a8a">&#9670;&nbsp;</a></span>BlockVector() <span class="overload">[12/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__Vectors.html#gaa000c54aa3fc182e5f05422233af7257">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_sizes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Set the number of blocks to <code>block_sizes.size()</code> and initialize each block with <code>block_sizes[i]</code> zero elements. </p>

</div>
</div>
<a id="gad6a3fe3d069769bfe44cfbb12bb8d9ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6a3fe3d069769bfe44cfbb12bb8d9ec">&#9670;&nbsp;</a></span>BlockVector() <span class="overload">[13/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ghost_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a block vector with an <a class="el" href="classIndexSet.html">IndexSet</a> for the local range and ghost entries for each block. </p>

</div>
</div>
<a id="gae44f6a147f001ce40a3390356939cedb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae44f6a147f001ce40a3390356939cedb">&#9670;&nbsp;</a></span>BlockVector() <span class="overload">[14/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above but the ghost indices are assumed to be empty. </p>

</div>
</div>
<a id="ga599e94513f88be426a73c5ad3162b27a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga599e94513f88be426a73c5ad3162b27a">&#9670;&nbsp;</a></span>~BlockVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::~<a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor.</p>
<dl class="section note"><dt>Note</dt><dd>We need to explicitly provide a destructor, otherwise the linker may think it is unused and discards it, although required in a different section. The Intel compiler is prone to this behavior. </dd></dl>

</div>
</div>
<a id="ga2b82aa81372ebfe22ed6968ef8317417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b82aa81372ebfe22ed6968ef8317417">&#9670;&nbsp;</a></span>operator=() <span class="overload">[8/30]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#ga0a43b405989a623b76a92efe2dfa5e39">value_type</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy operator: fill all components of the vector with the given scalar value. </p>

</div>
</div>
<a id="ga0069a784bc60ecfc7d87075927b4b086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0069a784bc60ecfc7d87075927b4b086">&#9670;&nbsp;</a></span>operator=() <span class="overload">[9/30]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy operator for arguments of the same type. Resize the present vector if necessary. </p>

</div>
</div>
<a id="ga631ced4f5e83bbf22ece66c4ee1ea301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga631ced4f5e83bbf22ece66c4ee1ea301">&#9670;&nbsp;</a></span>operator=() <span class="overload">[10/30]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;class Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy operator for template arguments of different types. Resize the present vector if necessary. </p>

</div>
</div>
<a id="ga0806d02bb7a443ef28e810d1f4fe7381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0806d02bb7a443ef28e810d1f4fe7381">&#9670;&nbsp;</a></span>operator=() <span class="overload">[11/30]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy a regular vector into a block vector. </p>

</div>
</div>
<a id="gaaccfcceeeb6f47176b448d72945a112d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaccfcceeeb6f47176b448d72945a112d">&#9670;&nbsp;</a></span>operator=() <span class="overload">[12/30]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt;Number&gt;&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockVector.html">PETScWrappers::MPI::BlockVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>petsc_vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the content of a PETSc vector into the calling vector. This function assumes that the vectors layouts have already been initialized to match.</p>
<p>This operator is only available if deal.II was configured with PETSc. </p>

</div>
</div>
<a id="ga3f521396d68256f73799da5a1460fdf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f521396d68256f73799da5a1460fdf7">&#9670;&nbsp;</a></span>operator=() <span class="overload">[13/30]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt;Number&gt;&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>trilinos_vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the content of a Trilinos vector into the calling vector. This function assumes that the vectors layouts have already been initialized to match.</p>
<p>This operator is only available if deal.II was configured with Trilinos. </p>

</div>
</div>
<a id="ga7833e60852b449291aa16fcfc5b3d600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7833e60852b449291aa16fcfc5b3d600">&#9670;&nbsp;</a></span>reinit() <span class="overload">[5/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#gaa000c54aa3fc182e5f05422233af7257">size_type</a>&#160;</td>
          <td class="paramname"><em>num_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#gaa000c54aa3fc182e5f05422233af7257">size_type</a>&#160;</td>
          <td class="paramname"><em>block_size</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinitialize the <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a> to contain <code>num_blocks</code> blocks of size <code>block_size</code> each.</p>
<p>If the second argument is left at its default value, then the block vector allocates the specified number of blocks but leaves them at zero size. You then need to later reinitialize the individual blocks, and call <a class="el" href="group__Exceptions.html#ga6a27b2a48e5b5780cd0a6640b928d794">collect_sizes()</a> to update the block system's knowledge of its individual block's sizes.</p>
<p>If <code>omit_zeroing_entries==false</code>, the vector is filled with zeros. </p>

</div>
</div>
<a id="gad74c8e31c81f8ef46b26d3c958125f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad74c8e31c81f8ef46b26d3c958125f22">&#9670;&nbsp;</a></span>reinit() <span class="overload">[6/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__Vectors.html#gaa000c54aa3fc182e5f05422233af7257">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinitialize the <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a> such that it contains <code>block_sizes.size()</code> blocks. Each block is reinitialized to dimension <code>block_sizes[i]</code>.</p>
<p>If the number of blocks is the same as before this function was called, all vectors remain the same and <a class="el" href="group__Vectors.html#ga7833e60852b449291aa16fcfc5b3d600">reinit()</a> is called for each vector.</p>
<p>If <code>omit_zeroing_entries==false</code>, the vector is filled with zeros.</p>
<p>Note that you must call this (or the other <a class="el" href="group__Vectors.html#ga7833e60852b449291aa16fcfc5b3d600">reinit()</a> functions) function, rather than calling the <a class="el" href="group__Vectors.html#ga7833e60852b449291aa16fcfc5b3d600">reinit()</a> functions of an individual block, to allow the block vector to update its caches of vector sizes. If you call <a class="el" href="group__Vectors.html#ga7833e60852b449291aa16fcfc5b3d600">reinit()</a> on one of the blocks, then subsequent actions on this object may yield unpredictable results since they may be routed to the wrong block. </p>

</div>
</div>
<a id="gab9ebeba63b750246591e48b468e3e737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9ebeba63b750246591e48b468e3e737">&#9670;&nbsp;</a></span>reinit() <span class="overload">[7/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the dimension to that of the vector <code>V</code>. The same applies as for the other <a class="el" href="group__Vectors.html#ga7833e60852b449291aa16fcfc5b3d600">reinit()</a> function.</p>
<p>The elements of <code>V</code> are not copied, i.e. this function is the same as calling <code>reinit (V.size(), omit_zeroing_entries)</code>.</p>
<p>Note that you must call this (or the other <a class="el" href="group__Vectors.html#ga7833e60852b449291aa16fcfc5b3d600">reinit()</a> functions) function, rather than calling the <a class="el" href="group__Vectors.html#ga7833e60852b449291aa16fcfc5b3d600">reinit()</a> functions of an individual block, to allow the block vector to update its caches of vector sizes. If you call <a class="el" href="group__Vectors.html#ga7833e60852b449291aa16fcfc5b3d600">reinit()</a> of one of the blocks, then subsequent actions of this object may yield unpredictable results since they may be routed to the wrong block. </p>

</div>
</div>
<a id="ga852d132f4827ec54f9583013a536761b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga852d132f4827ec54f9583013a536761b">&#9670;&nbsp;</a></span>compress() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::compress </td>
          <td>(</td>
          <td class="paramtype">::<a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function copies the data that has accumulated in the data buffer for ghost indices to the owning processor. For the meaning of the argument <code>operation</code>, see the entry on <a class="el" href="DEALGlossary.html#GlossCompress">Compressing distributed vectors and matrices</a> in the glossary.</p>
<p>There are two variants for this function. If called with argument <code><a class="el" href="group__Vectors.html#gga40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a></code> adds all the data accumulated in ghost elements to the respective elements on the owning processor and clears the ghost array afterwards. If called with argument <code><a class="el" href="group__Vectors.html#gga40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a></code>, a set operation is performed. Since setting elements in a vector with ghost elements is ambiguous (as one can set both the element on the ghost site as well as the owning site), this operation makes the assumption that all data is set correctly on the owning processor. Upon call of compress(VectorOperation::insert), all ghost entries are therefore simply zeroed out (using zero_ghost_values()). In debug mode, a check is performed that makes sure that the data set is actually consistent between processors, i.e., whenever a non-zero ghost element is found, it is compared to the value on the owning processor and an exception is thrown if these elements do not agree. </p>

</div>
</div>
<a id="gaec81b97d7e38d836457bfbc7b2f20226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec81b97d7e38d836457bfbc7b2f20226">&#9670;&nbsp;</a></span>update_ghost_values() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::update_ghost_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills the data field for ghost indices with the values stored in the respective positions of the owning processor. This function is needed before reading from ghosts. The function is <code>const</code> even though ghost data is changed. This is needed to allow functions with a <code>const</code> vector to perform the data exchange without creating temporaries. </p>

</div>
</div>
<a id="gae9e0cf1c878130c12b0c16cad8da0610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9e0cf1c878130c12b0c16cad8da0610">&#9670;&nbsp;</a></span>zero_out_ghosts() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::zero_out_ghosts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method zeros the entries on ghost dofs, but does not touch locally owned DoFs.</p>
<p>After calling this method, read access to ghost elements of the vector is forbidden and an exception is thrown. Only write access to ghost elements is allowed in this state.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000067">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__Vectors.html#gaa205bf18350c2095d459c75edfa622db">zero_out_ghost_values()</a> instead. </dd></dl>

</div>
</div>
<a id="gaa205bf18350c2095d459c75edfa622db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa205bf18350c2095d459c75edfa622db">&#9670;&nbsp;</a></span>zero_out_ghost_values() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::zero_out_ghost_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method zeros the entries on ghost dofs, but does not touch locally owned DoFs.</p>
<p>After calling this method, read access to ghost elements of the vector is forbidden and an exception is thrown. Only write access to ghost elements is allowed in this state. </p>

</div>
</div>
<a id="ga0ac470622adef2b2aec45be681112de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ac470622adef2b2aec45be681112de3">&#9670;&nbsp;</a></span>has_ghost_elements() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::has_ghost_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return if this <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a> contains ghost elements. </p>

</div>
</div>
<a id="ga872d9c74afd697767a824cdd69135ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga872d9c74afd697767a824cdd69135ba4">&#9670;&nbsp;</a></span>add() <span class="overload">[1/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__Vectors.html#gaa000c54aa3fc182e5f05422233af7257">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a collective add operation that adds a whole set of values stored in <code>values</code> to the vector components specified by <code>indices</code>. </p>

</div>
</div>
<a id="gac1f222571d59cc48f9d505fc7ba4d8dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1f222571d59cc48f9d505fc7ba4d8dd">&#9670;&nbsp;</a></span>sadd() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::sadd </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scaling and simple vector addition, i.e. <code><em>this = s</em>(*this)+V</code>. </p>

</div>
</div>
<a id="ga809ec1490fd39c130932290aae65355c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga809ec1490fd39c130932290aae65355c">&#9670;&nbsp;</a></span>all_zero() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::all_zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether the vector contains only elements with value zero. This function is mainly for internal consistency checks and should seldom be used when not in debug mode since it uses quite some time. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga8c03a20480770e68f0d4e1e6456e78eb">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga7df34df7e744cbfdb5cec39176821cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7df34df7e744cbfdb5cec39176821cf1">&#9670;&nbsp;</a></span>mean_value() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Number <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::mean_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the mean value of all the entries in the vector. </p>

<p>Implements <a class="el" href="group__Vectors.html#gab3e11175ad9c308d796d72aa0fc6b44b">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="gab588b3e1883730aff30b5408fcf22298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab588b3e1883730aff30b5408fcf22298">&#9670;&nbsp;</a></span>lp_norm() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Vectors.html#gab99352244c902251dcd351118e7c468a">real_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::lp_norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#gab99352244c902251dcd351118e7c468a">real_type</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\(l_p\)-norm of the vector. The pth root of the sum of the pth powers of the absolute values of the elements. </p>

</div>
</div>
<a id="ga2072c8a6af39eb4ef8aa61e18b5864c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2072c8a6af39eb4ef8aa61e18b5864c1">&#9670;&nbsp;</a></span>swap() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swap the contents of this vector and the other vector <code>v</code>. One could do this operation with a temporary variable and copying over the data elements, but this function is significantly more efficient since it only swaps the pointers to the data of the two vectors and therefore does not need to allocate temporary storage and move data around.</p>
<p>Limitation: right now this function only works if both vectors have the same number of blocks. If needed, the numbers of blocks should be exchanged, too.</p>
<p>This function is analogous to the <a class="el" href="group__Vectors.html#ga2072c8a6af39eb4ef8aa61e18b5864c1">swap()</a> function of all C++ standard containers. Also, there is a global function swap(u,v) that simply calls <code>u.swap(v)</code>, again in analogy to standard functions. </p>

</div>
</div>
<a id="ga456e59ce23e0da8010f74d80875f6aa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga456e59ce23e0da8010f74d80875f6aa5">&#9670;&nbsp;</a></span>reinit() <span class="overload">[8/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Change the dimension to that of the vector V. The elements of V are not copied. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga786d97fd050d53e86d523b1b0766f568">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga5be26d6eb72dcefdec2e2305d0e1c2e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5be26d6eb72dcefdec2e2305d0e1c2e6">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt;Number&gt;&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiply the entire vector by a fixed factor. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga02349286c5e57d29396dfac9290d302f">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga4daee550e5e52be51395ca7afe42896d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4daee550e5e52be51395ca7afe42896d">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt;Number&gt;&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Divide the entire vector by a fixed factor. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga198b28b1759b52bd5df5345be6ff8868">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga4a97828f252550978a7525b82d1e1f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a97828f252550978a7525b82d1e1f92">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt;Number&gt;&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add the vector <code>V</code> to the present one. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga8b581c9b2dd4a55c2a5998e62b195bd9">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga52fb6dc78db248d8b4749632ef52d36f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52fb6dc78db248d8b4749632ef52d36f">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt;Number&gt;&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtract the vector <code>V</code> from the present one. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga61e201954ade41d8b8ba290e5841efb2">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga8143655154d18b0c5753b00158b2e2f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8143655154d18b0c5753b00158b2e2f1">&#9670;&nbsp;</a></span>import() <span class="overload">[1/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::import </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1CommunicationPatternBase.html">Utilities::MPI::CommunicationPatternBase</a> &gt;&#160;</td>
          <td class="paramname"><em>communication_pattern</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Import all the elements present in the vector's <a class="el" href="classIndexSet.html">IndexSet</a> from the input vector <code>V</code>. <a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> <code>operation</code> is used to decide if the elements in <code>V</code> should be added to the current vector or replace the current elements. The last parameter can be used if the same communication pattern is used multiple times. This can be used to improve performance. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga0c05d3725740bda0feab10c660582669">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga93f5bd0dc1f676eaf0747b580b6ca468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93f5bd0dc1f676eaf0747b580b6ca468">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Number <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the scalar product of two vectors. </p>

<p>Implements <a class="el" href="group__Vectors.html#gabe15b048b316e02c2c88644713f9bda8">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="gae860233e47e643eb93892aa873da9889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae860233e47e643eb93892aa873da9889">&#9670;&nbsp;</a></span>multivector_inner_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename FullMatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::multivector_inner_product </td>
          <td>(</td>
          <td class="paramtype">FullMatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>symmetric</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the scalar product between each block of this vector and <code>V</code> and store the result in a full matrix <code>matrix</code>. This function computes the result by forming \(A_{ij}=U_i \cdot V_j\) where \(U_i\) and \(V_j\) indicate the \(i\)th block (not element!) of \(U\) and the \(j\)th block of \(V\), respectively. If <code>symmetric</code> is <code>true</code>, it is assumed that inner product results in a square symmetric matrix and almost half of the scalar products can be avoided.</p>
<p>Obviously, this function can only be used if all blocks of both vectors are of the same size.</p>
<dl class="section note"><dt>Note</dt><dd>Internally, a single global reduction will be called to accumulate scalar product between locally owned degrees of freedom. </dd></dl>

</div>
</div>
<a id="gaa0a5a9811aff25c8dd2a242d1e309547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0a5a9811aff25c8dd2a242d1e309547">&#9670;&nbsp;</a></span>multivector_inner_product_with_metric()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename FullMatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::multivector_inner_product_with_metric </td>
          <td>(</td>
          <td class="paramtype">const FullMatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>symmetric</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the scalar product between each block of this vector and <code>V</code> using a metric tensor <code>matrix</code>. This function computes the result of \( \sum_{ij} A^{ij} U_i \cdot V_j\) where \(U_i\) and \(V_j\) indicate the \(i\)th block (not element) of \(U\) and the \(j\)th block of \(V\), respectively. If <code>symmetric</code> is <code>true</code>, it is assumed that \(U_i \cdot V_j\) and \(A^{ij}\) are symmetric matrices and almost half of the scalar products can be avoided.</p>
<p>Obviously, this function can only be used if all blocks of both vectors are of the same size.</p>
<dl class="section note"><dt>Note</dt><dd>Internally, a single global reduction will be called to accumulate the scalar product between locally owned degrees of freedom. </dd></dl>

</div>
</div>
<a id="gaeda5640c41b09bae50c6c3c6a863e289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeda5640c41b09bae50c6c3c6a863e289">&#9670;&nbsp;</a></span>mmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename FullMatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::mmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FullMatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em> = <code>Number(0.)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>b</em> = <code>Number(1.)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set each block of this vector as follows: \(V^i = s V^i + b \sum_{j} U_j A^{ji}\) where \(V^i\) and \(U_j\) indicate the \(i\)th block (not element) of \(V\) and the \(j\)th block of \(U\), respectively.</p>
<p>Obviously, this function can only be used if all blocks of both vectors are of the same size. </p>

</div>
</div>
<a id="gaccecdd88bcfc805d1554fc99e8f05e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccecdd88bcfc805d1554fc99e8f05e38">&#9670;&nbsp;</a></span>add() <span class="overload">[2/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add <code>a</code> to all components. Note that <code>a</code> is a scalar not a vector. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga3dbc94fab7a9b8490941588107b5d27b">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="gab0b1677974de1a51cade3dea2e268dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0b1677974de1a51cade3dea2e268dd0">&#9670;&nbsp;</a></span>add() <span class="overload">[3/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Simple addition of a multiple of a vector, i.e. <code>*this += a*V</code>. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga5d989f75097f8bb45e5297a262ed941d">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga32a59caf6a091dc576366547bb71dc86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32a59caf6a091dc576366547bb71dc86">&#9670;&nbsp;</a></span>add() <span class="overload">[4/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiple addition of scaled vectors, i.e. <code>*this += a*V+b*W</code>. </p>

<p>Implements <a class="el" href="group__Vectors.html#gabc8bff328d603ccb5978a6b7d6543c8c">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga3515ad42ca76e04aed377d32d266daa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3515ad42ca76e04aed377d32d266daa6">&#9670;&nbsp;</a></span>add() <span class="overload">[5/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__Vectors.html#gaa000c54aa3fc182e5f05422233af7257">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A collective add operation: This function adds a whole set of values stored in <code>values</code> to the vector components specified by <code>indices</code>. </p>

</div>
</div>
<a id="ga5a306d119c19bffc19f7d99800e5de79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a306d119c19bffc19f7d99800e5de79">&#9670;&nbsp;</a></span>sadd() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::sadd </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scaling and simple addition of a multiple of a vector, i.e. <code><em>this = s</em>(*this)+a*V</code>. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga8f8a5799eb407e559540aae082f9ec87">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga6b50074b32093b5471d1c7e033c0f2d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b50074b32093b5471d1c7e033c0f2d6">&#9670;&nbsp;</a></span>scale() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>scaling_factors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scale each element of this vector by the corresponding element in the argument. This function is mostly meant to simulate multiplication (and immediate re-assignment) by a diagonal scaling matrix. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga27c492ff183de02d4f75f3d152c6f0ac">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="gad8bc1dd4072504da9cbea82e6ba01180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8bc1dd4072504da9cbea82e6ba01180">&#9670;&nbsp;</a></span>equ() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::equ </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assignment <code>*this = a*V</code>. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga344fbb1ede704fb7b14e6e60048e9da3">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga2cdf84bbe46a886cdde6bad3a4246163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cdf84bbe46a886cdde6bad3a4246163">&#9670;&nbsp;</a></span>l1_norm() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__Vectors.html#gab99352244c902251dcd351118e7c468a">real_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::l1_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the l<sub>1</sub> norm of the vector (i.e., the sum of the absolute values of all entries among all processors). </p>

<p>Implements <a class="el" href="group__Vectors.html#ga6ad9146f2c4a36cc762456b4cba21b4c">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga8fceaca158b4b7b17d280c618c469228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fceaca158b4b7b17d280c618c469228">&#9670;&nbsp;</a></span>l2_norm() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__Vectors.html#gab99352244c902251dcd351118e7c468a">real_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::l2_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the \(l_2\) norm of the vector (i.e., the square root of the sum of the square of all entries among all processors). </p>

<p>Implements <a class="el" href="group__Vectors.html#ga2d4822289e1415f1bf35c84c4b7ee292">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga52b4564def3f222e3c54266a61c75810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52b4564def3f222e3c54266a61c75810">&#9670;&nbsp;</a></span>norm_sqr() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Vectors.html#gab99352244c902251dcd351118e7c468a">real_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::norm_sqr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the square of the \(l_2\) norm of the vector. </p>

</div>
</div>
<a id="ga1403274bfe2ad51433f205ae1a10b6ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1403274bfe2ad51433f205ae1a10b6ae">&#9670;&nbsp;</a></span>linfty_norm() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__Vectors.html#gab99352244c902251dcd351118e7c468a">real_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::linfty_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the maximum norm of the vector (i.e., the maximum absolute value among all entries and among all processors). </p>

<p>Implements <a class="el" href="group__Vectors.html#gaf84f65fc1f6ebc21534271c42c33d159">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="gaf1c44bfad65af75c21d0d23af1125414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1c44bfad65af75c21d0d23af1125414">&#9670;&nbsp;</a></span>add_and_dot() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Number <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::add_and_dot </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform a combined operation of a vector addition and a subsequent inner product, returning the value of the inner product. In other words, the result of this function is the same as if the user called </p><div class="fragment"><div class="line">this-&gt;<a class="code" href="group__Vectors.html#ga872d9c74afd697767a824cdd69135ba4">add</a>(a, <a class="code" href="namespaceLAPACKSupport.html#aee5ef58d11434eb1d6a665e64bf17292">V</a>);</div>
<div class="line">return_value = *<span class="keyword">this</span> * W;</div>
<div class="ttc" id="agroup__Vectors_html_ga872d9c74afd697767a824cdd69135ba4"><div class="ttname"><a href="group__Vectors.html#ga872d9c74afd697767a824cdd69135ba4">LinearAlgebra::distributed::BlockVector::add</a></div><div class="ttdeci">void add(const std::vector&lt; size_type &gt; &amp;indices, const ::Vector&lt; OtherNumber &gt; &amp;values)</div></div>
<div class="ttc" id="anamespaceLAPACKSupport_html_aee5ef58d11434eb1d6a665e64bf17292"><div class="ttname"><a href="namespaceLAPACKSupport.html#aee5ef58d11434eb1d6a665e64bf17292">LAPACKSupport::V</a></div><div class="ttdeci">static const char V</div><div class="ttdef"><b>Definition:</b> <a href="lapack__support_8h_source.html#l00177">lapack_support.h:177</a></div></div>
</div><!-- fragment --><p>The reason this function exists is that this operation involves less memory transfer than calling the two functions separately. This method only needs to load three vectors, <code>this</code>, <code>V</code>, <code>W</code>, whereas calling separate methods means to load the calling vector <code>this</code> twice. Since most vector operations are memory transfer limited, this reduces the time by 25% (or 50% if <code>W</code> equals <code>this</code>).</p>
<p>For complex-valued vectors, the scalar product in the second step is implemented as \(\left&lt;v,w\right&gt;=\sum_i v_i \bar{w_i}\). </p>

<p>Implements <a class="el" href="group__Vectors.html#ga89ae394fb53af7daf23705d5992f9f11">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="gaf8d5be159fec545106c67bc940589fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8d5be159fec545106c67bc940589fcb">&#9670;&nbsp;</a></span>size() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__Vectors.html#gaa000c54aa3fc182e5f05422233af7257">size_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the global size of the vector, equal to the sum of the number of locally owned indices among all processors. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga79b24c9cc50ac00221c89466a021c62a">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga468dfbd79a0d0d614327f292ee66f76a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga468dfbd79a0d0d614327f292ee66f76a">&#9670;&nbsp;</a></span>locally_owned_elements() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ::<a class="el" href="classIndexSet.html">IndexSet</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::locally_owned_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an index set that describes which elements of this vector are owned by the current processor. As a consequence, the index sets returned on different processors if this is a distributed vector will form disjoint sets that add up to the complete index set. Obviously, if a vector is created on only one processor, then the result would satisfy </p><div class="fragment"><div class="line">vec.locally_owned_elements() == <a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(vec.size())</div>
<div class="ttc" id="aindex__set_8h_html_ad28b2e725afda38ffdef1bf61d5cadd4"><div class="ttname"><a href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a></div><div class="ttdeci">IndexSet complete_index_set(const IndexSet::size_type N)</div><div class="ttdef"><b>Definition:</b> <a href="index__set_8h_source.html#l01013">index_set.h:1013</a></div></div>
</div><!-- fragment --> 
<p>Implements <a class="el" href="group__Vectors.html#ga47e92627a68a0a778490b5694af4212b">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="gabb764f033c38e246091f50d0ee3f8b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb764f033c38e246091f50d0ee3f8b90">&#9670;&nbsp;</a></span>print() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>precision</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>scientific</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>across</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Print the vector to the output stream <code>out</code>. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga1fcac5e46eb6bc858f1715e30db75031">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga7d9c15a88fd2789219e70fd950d211e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d9c15a88fd2789219e70fd950d211e6">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the memory consumption of this class in bytes. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga4760b791f71d963298a5d49917f46555">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga702bf4533c5ce7e4144d3d86afb31195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga702bf4533c5ce7e4144d3d86afb31195">&#9670;&nbsp;</a></span>Vector() <span class="overload">[1/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Empty constructor. </p>

</div>
</div>
<a id="ga60510dc0ed5441f1875cea6800645d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60510dc0ed5441f1875cea6800645d3c">&#9670;&nbsp;</a></span>Vector() <span class="overload">[2/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor. Uses the parallel partitioning of <code>in_vector</code>. It should be noted that this constructor automatically sets ghost values to zero. Call <code><a class="el" href="group__Vectors.html#ga2a6cb7d50e02022283af53c2ae14f878">update_ghost_values()</a></code> directly following construction if a ghosted vector is required. </p>

</div>
</div>
<a id="ga3be6c4ce529bb9b6c13eb831d0a86f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3be6c4ce529bb9b6c13eb831d0a86f55">&#9670;&nbsp;</a></span>Vector() <span class="overload">[3/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a parallel vector of the given global size without any actual parallel distribution. </p>

</div>
</div>
<a id="ga31393977fc00f2d9c46f259330ef2a23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31393977fc00f2d9c46f259330ef2a23">&#9670;&nbsp;</a></span>Vector() <span class="overload">[4/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>local_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>ghost_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a parallel vector. The local range is specified by <code>locally_owned_set</code> (note that this must be a contiguous interval, multiple intervals are not possible). The <a class="el" href="classIndexSet.html">IndexSet</a> <code>ghost_indices</code> specifies ghost indices, i.e., indices which one might need to read data from or accumulate data from. It is allowed that the set of ghost indices also contains the local range, but it does not need to.</p>
<p>This function involves global communication, so it should only be called once for a given layout. Use the constructor with Vector&lt;Number&gt; argument to create additional vectors with the same parallel layout.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossGhostedVector">vectors with ghost elements</a> </dd></dl>

</div>
</div>
<a id="ga44feea9fec2eeab75baf051b65fa8094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44feea9fec2eeab75baf051b65fa8094">&#9670;&nbsp;</a></span>Vector() <span class="overload">[5/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>local_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same constructor as above but without any ghost indices. </p>

</div>
</div>
<a id="gafe52b52803ff7d23233e37083689b8f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe52b52803ff7d23233e37083689b8f1">&#9670;&nbsp;</a></span>Vector() <span class="overload">[6/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>partitioner</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create the vector based on the parallel partitioning described in <code>partitioner</code>. The input argument is a shared pointer, which stores the partitioner data only once and share it between several vectors with the same layout. </p>

</div>
</div>
<a id="ga99e3faeced0e8afcf1208a6955e88ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99e3faeced0e8afcf1208a6955e88ffd">&#9670;&nbsp;</a></span>~Vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::~<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<a id="gace027311492ed2f6e07fbd74d723e3a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace027311492ed2f6e07fbd74d723e3a9">&#9670;&nbsp;</a></span>reinit() <span class="overload">[9/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the global size of the vector to <code>size</code> without any actual parallel distribution. </p>

</div>
</div>
<a id="ga8a79ca37d7f7a8cfd04f5dd61d350ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a79ca37d7f7a8cfd04f5dd61d350ae5">&#9670;&nbsp;</a></span>reinit() <span class="overload">[10/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number2, MemorySpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Uses the parallel layout of the input vector <code>in_vector</code> and allocates memory for this vector. Recommended initialization function when several vectors with the same layout should be created.</p>
<p>If the flag <code>omit_zeroing_entries</code> is set to false, the memory will be initialized with zero, otherwise the memory will be untouched (and the user must make sure to fill it with reasonable data before using it). </p>

</div>
</div>
<a id="ga7415120211cbfb0b525423f5e028791e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7415120211cbfb0b525423f5e028791e">&#9670;&nbsp;</a></span>reinit() <span class="overload">[11/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>local_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>ghost_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the vector. The local range is specified by <code>locally_owned_set</code> (note that this must be a contiguous interval, multiple intervals are not possible). The <a class="el" href="classIndexSet.html">IndexSet</a> <code>ghost_indices</code> specifies ghost indices, i.e., indices which one might need to read data from or accumulate data from. It is allowed that the set of ghost indices also contains the local range, but it does not need to.</p>
<p>This function involves global communication, so it should only be called once for a given layout. Use the <code>reinit</code> function with Vector&lt;Number&gt; argument to create additional vectors with the same parallel layout.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossGhostedVector">vectors with ghost elements</a> </dd></dl>

</div>
</div>
<a id="gac86885392f82f70c0acdc2cc2fe272d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac86885392f82f70c0acdc2cc2fe272d5">&#9670;&nbsp;</a></span>reinit() <span class="overload">[12/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>local_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but without ghost entries. </p>

</div>
</div>
<a id="ga1a4afb6f468e902618d2f3bf41da181c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a4afb6f468e902618d2f3bf41da181c">&#9670;&nbsp;</a></span>reinit() <span class="overload">[13/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>partitioner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>comm_sm</em> = <code>MPI_COMM_SELF</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the vector given to the parallel partitioning described in <code>partitioner</code>. The input argument is a shared pointer, which stores the partitioner data only once and share it between several vectors with the same layout.</p>
<p>The optional argument <code>comm_sm</code>, which consists of processes on the same shared-memory domain, allows users have read-only access to both locally-owned and ghost values of processes combined in the shared-memory communicator. See the general documentation of this class for more information about this argument. </p>

</div>
</div>
<a id="gac6c95ee056cdf27d171711cd7c8f5701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6c95ee056cdf27d171711cd7c8f5701">&#9670;&nbsp;</a></span>reinit() <span class="overload">[14/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&#160;</td>
          <td class="paramname"><em>local_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&#160;</td>
          <td class="paramname"><em>ghost_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>comm_sm</em> = <code>MPI_COMM_SELF</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize vector with <code>local_size</code> locally-owned and <code>ghost_size</code> ghost degrees of freedoms.</p>
<p>The optional argument <code>comm_sm</code>, which consists of processes on the same shared-memory domain, allows users have read-only access to both locally-owned and ghost values of processes combined in the shared-memory communicator. See the general documentation of this class for more information about this argument.</p>
<dl class="section note"><dt>Note</dt><dd>In the created underlying partitioner, the local index range is translated to global indices in an ascending and one-to-one fashion, i.e., the indices of process \(p\) sit exactly between the indices of the processes \(p-1\) and \(p+1\), respectively. Setting the <code>ghost_size</code> variable to an appropriate value provides memory space for the ghost data in a vector's memory allocation as and allows access to it via <a class="el" href="group__Vectors.html#ga1c4bc946b94f19d7e11c00f41a39db02">local_element()</a>. However, the associated global indices must be handled externally in this case. </dd></dl>

</div>
</div>
<a id="ga2ca1b9394ef76f792c06e3d4f006b4e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ca1b9394ef76f792c06e3d4f006b4e1">&#9670;&nbsp;</a></span>swap() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swap the contents of this vector and the other vector <code>v</code>. One could do this operation with a temporary variable and copying over the data elements, but this function is significantly more efficient since it only swaps the pointers to the data of the two vectors and therefore does not need to allocate temporary storage and move data around.</p>
<p>This function is analogous to the <code>swap</code> function of all C++ standard containers. Also, there is a global function <code>swap(u,v)</code> that simply calls <code>u.swap(v)</code>, again in analogy to standard functions. </p>

</div>
</div>
<a id="gabb2a2d81a821ae954545ca77a89fa240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb2a2d81a821ae954545ca77a89fa240">&#9670;&nbsp;</a></span>operator=() <span class="overload">[14/30]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt;Number, MemorySpace&gt;&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assigns the vector to the parallel partitioning of the input vector <code>in_vector</code>, and copies all the data.</p>
<p>If one of the input vector or the calling vector (to the left of the assignment operator) had ghost elements set before this operation, the calling vector will have ghost values set. Otherwise, it will be in write mode. If the input vector does not have any ghost elements at all, the vector will also update its ghost values in analogy to the respective setting the Trilinos and PETSc vectors. </p>

</div>
</div>
<a id="gad364c47c5b3b7b991490cd626c729f0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad364c47c5b3b7b991490cd626c729f0b">&#9670;&nbsp;</a></span>operator=() <span class="overload">[15/30]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt;Number, MemorySpace&gt;&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number2, MemorySpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assigns the vector to the parallel partitioning of the input vector <code>in_vector</code>, and copies all the data.</p>
<p>If one of the input vector or the calling vector (to the left of the assignment operator) had ghost elements set before this operation, the calling vector will have ghost values set. Otherwise, it will be in write mode. If the input vector does not have any ghost elements at all, the vector will also update its ghost values in analogy to the respective setting the Trilinos and PETSc vectors. </p>

</div>
</div>
<a id="ga8a204103e550697467d933388b732bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a204103e550697467d933388b732bda">&#9670;&nbsp;</a></span>compress() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::compress </td>
          <td>(</td>
          <td class="paramtype">::<a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function copies the data that has accumulated in the data buffer for ghost indices to the owning processor. For the meaning of the argument <code>operation</code>, see the entry on <a class="el" href="DEALGlossary.html#GlossCompress">Compressing distributed vectors and matrices</a> in the glossary.</p>
<p>There are four variants for this function. If called with argument <code><a class="el" href="group__Vectors.html#gga40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a></code> adds all the data accumulated in ghost elements to the respective elements on the owning processor and clears the ghost array afterwards. If called with argument <code><a class="el" href="group__Vectors.html#gga40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a></code>, a set operation is performed. Since setting elements in a vector with ghost elements is ambiguous (as one can set both the element on the ghost site as well as the owning site), this operation makes the assumption that all data is set correctly on the owning processor. Upon call of compress(VectorOperation::insert), all ghost entries are thus simply zeroed out (using zero_ghost_values()). In debug mode, a check is performed for whether the data set is actually consistent between processors, i.e., whenever a non-zero ghost element is found, it is compared to the value on the owning processor and an exception is thrown if these elements do not agree. If called with <a class="el" href="group__Vectors.html#gga40c50779cd14ba89bbf0bd9b4561964ca5e8042e5d04399d125cb923eda7a8d8b">VectorOperation::min</a> or <a class="el" href="group__Vectors.html#gga40c50779cd14ba89bbf0bd9b4561964caaae8b002691d4887ce68ecf3e785c13e">VectorOperation::max</a>, the minimum or maximum on all elements across the processors is set. </p><dl class="section note"><dt>Note</dt><dd>This vector class has a fixed set of ghost entries attached to the local representation. As a consequence, all ghost entries are assumed to be valid and will be exchanged unconditionally according to the given <a class="el" href="structVectorOperation.html">VectorOperation</a>. Make sure to initialize all ghost entries with the neutral element of the given <a class="el" href="structVectorOperation.html">VectorOperation</a> or touch all ghost entries. The neutral element is zero for <a class="el" href="group__Vectors.html#gga40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a> and <a class="el" href="group__Vectors.html#gga40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>, <code>+inf</code> for <a class="el" href="group__Vectors.html#gga40c50779cd14ba89bbf0bd9b4561964ca5e8042e5d04399d125cb923eda7a8d8b">VectorOperation::min</a>, and <code>-inf</code> for <a class="el" href="group__Vectors.html#gga40c50779cd14ba89bbf0bd9b4561964caaae8b002691d4887ce68ecf3e785c13e">VectorOperation::max</a>. If all values are initialized with values below zero and compress is called with <a class="el" href="group__Vectors.html#gga40c50779cd14ba89bbf0bd9b4561964caaae8b002691d4887ce68ecf3e785c13e">VectorOperation::max</a> two times subsequently, the maximal value after the second calculation will be zero. </dd></dl>

</div>
</div>
<a id="ga2a6cb7d50e02022283af53c2ae14f878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a6cb7d50e02022283af53c2ae14f878">&#9670;&nbsp;</a></span>update_ghost_values() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::update_ghost_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills the data field for ghost indices with the values stored in the respective positions of the owning processor. This function is needed before reading from ghosts. The function is <code>const</code> even though ghost data is changed. This is needed to allow functions with a <code>const</code> vector to perform the data exchange without creating temporaries.</p>
<p>After calling this method, write access to ghost elements of the vector is forbidden and an exception is thrown. Only read access to ghost elements is allowed in this state. Note that all subsequent operations on this vector, like global vector addition, etc., will also update the ghost values by a call to this method after the operation. However, global reduction operations like norms or the inner product will always ignore ghost elements in order to avoid counting the ghost data more than once. To allow writing to ghost elements again, call <a class="el" href="group__Vectors.html#ga0242ed0c3e3664e6b4204d28a726a0b7">zero_out_ghost_values()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossGhostedVector">vectors with ghost elements</a> </dd></dl>

</div>
</div>
<a id="gaab0c01436acde21cc2dbb5576d8f2375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab0c01436acde21cc2dbb5576d8f2375">&#9670;&nbsp;</a></span>compress_start()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::compress_start </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>communication_channel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em> = <code><a class="el" href="group__Vectors.html#gga40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initiates communication for the <code><a class="el" href="group__Vectors.html#ga8a204103e550697467d933388b732bda">compress()</a></code> function with non- blocking communication. This function does not wait for the transfer to finish, in order to allow for other computations during the time it takes until all data arrives.</p>
<p>Before the data is actually exchanged, the function must be followed by a call to <code><a class="el" href="group__Vectors.html#gada0b48d524285ca7b302da593b3321a9">compress_finish()</a></code>.</p>
<p>In case this function is called for more than one vector before <code><a class="el" href="group__Vectors.html#gada0b48d524285ca7b302da593b3321a9">compress_finish()</a></code> is invoked, it is mandatory to specify a unique communication channel to each such call, in order to avoid several messages with the same ID that will corrupt this operation. Any communication channel less than 100 is a valid value (in particular, the range \([100, 200)\) is reserved for <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>). </p>

</div>
</div>
<a id="gada0b48d524285ca7b302da593b3321a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada0b48d524285ca7b302da593b3321a9">&#9670;&nbsp;</a></span>compress_finish()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::compress_finish </td>
          <td>(</td>
          <td class="paramtype">::<a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For all requests that have been initiated in compress_start, wait for the communication to finish. Once it is finished, add or set the data (depending on the flag operation) to the respective positions in the owning processor, and clear the contents in the ghost data fields. The meaning of this argument is the same as in <a class="el" href="group__Vectors.html#ga8a204103e550697467d933388b732bda">compress()</a>.</p>
<p>This function should be called exactly once per vector after calling compress_start, otherwise the result is undefined. In particular, it is not well-defined to call compress_start on the same vector again before compress_finished has been called. However, there is no warning to prevent this situation.</p>
<p>Must follow a call to the <code>compress_start</code> function.</p>
<p>When the <a class="el" href="namespaceMemorySpace.html">MemorySpace</a> is CUDA and MPI is not CUDA-aware, data changed on the device after the call to compress_start will be lost. </p>

</div>
</div>
<a id="gab7045a29ddd2b5fb86ce56c3806e08d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7045a29ddd2b5fb86ce56c3806e08d3">&#9670;&nbsp;</a></span>update_ghost_values_start()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::update_ghost_values_start </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>communication_channel</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initiates communication for the <code><a class="el" href="group__Vectors.html#ga2a6cb7d50e02022283af53c2ae14f878">update_ghost_values()</a></code> function with non-blocking communication. This function does not wait for the transfer to finish, in order to allow for other computations during the time it takes until all data arrives.</p>
<p>Before the data is actually exchanged, the function must be followed by a call to <code><a class="el" href="group__Vectors.html#gab305a49968449aa44e998f4364838479">update_ghost_values_finish()</a></code>.</p>
<p>In case this function is called for more than one vector before <code><a class="el" href="group__Vectors.html#gab305a49968449aa44e998f4364838479">update_ghost_values_finish()</a></code> is invoked, it is mandatory to specify a unique communication channel to each such call, in order to avoid several messages with the same ID that will corrupt this operation. Any communication channel less than 100 is a valid value (in particular, the range \([100, 200)\) is reserved for <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>). </p>

</div>
</div>
<a id="gab305a49968449aa44e998f4364838479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab305a49968449aa44e998f4364838479">&#9670;&nbsp;</a></span>update_ghost_values_finish()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::update_ghost_values_finish </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For all requests that have been started in update_ghost_values_start, wait for the communication to finish.</p>
<p>Must follow a call to the <code>update_ghost_values_start</code> function before reading data from ghost indices. </p>

</div>
</div>
<a id="gac0dc3fd03c7851d5577c159703282548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0dc3fd03c7851d5577c159703282548">&#9670;&nbsp;</a></span>zero_out_ghosts() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::zero_out_ghosts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method zeros the entries on ghost dofs, but does not touch locally owned DoFs.</p>
<p>After calling this method, read access to ghost elements of the vector is forbidden and an exception is thrown. Only write access to ghost elements is allowed in this state.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000068">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__Vectors.html#ga0242ed0c3e3664e6b4204d28a726a0b7">zero_out_ghost_values()</a> instead. </dd></dl>

</div>
</div>
<a id="ga0242ed0c3e3664e6b4204d28a726a0b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0242ed0c3e3664e6b4204d28a726a0b7">&#9670;&nbsp;</a></span>zero_out_ghost_values() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::zero_out_ghost_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method zeros the entries on ghost dofs, but does not touch locally owned DoFs.</p>
<p>After calling this method, read access to ghost elements of the vector is forbidden and an exception is thrown. Only write access to ghost elements is allowed in this state. </p>

</div>
</div>
<a id="ga17719d884e60b2ad0077a03b92382975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17719d884e60b2ad0077a03b92382975">&#9670;&nbsp;</a></span>has_ghost_elements() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::has_ghost_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the vector currently is in a state where ghost values can be read or not. This is the same functionality as other parallel vectors have. If this method returns false, this only means that read-access to ghost elements is prohibited whereas write access is still possible (to those entries specified as ghosts during initialization), not that there are no ghost elements at all.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossGhostedVector">vectors with ghost elements</a> </dd></dl>

</div>
</div>
<a id="gab792ddb04b95a220e489f2d7f9eee990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab792ddb04b95a220e489f2d7f9eee990">&#9670;&nbsp;</a></span>copy_locally_owned_data_from()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::copy_locally_owned_data_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number2, MemorySpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method copies the data in the locally owned range from another distributed vector <code>src</code> into the calling vector. As opposed to operator= that also includes ghost entries, this operation ignores the ghost range. The only prerequisite is that the local range on the calling vector and the given vector <code>src</code> are the same on all processors. It is explicitly allowed that the two vectors have different ghost elements that might or might not be related to each other.</p>
<p>Since no data exchange is performed, make sure that neither <code>src</code> nor the calling vector have pending communications in order to obtain correct results. </p>

</div>
</div>
<a id="gaf7b743d761233b92e0ed23e6bf37a409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7b743d761233b92e0ed23e6bf37a409">&#9670;&nbsp;</a></span>import() <span class="overload">[2/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<div class="memtemplate">
template&lt;typename MemorySpace2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::import </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Import all the elements present in the distributed vector <code>src</code>. <a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> <code>operation</code> is used to decide if the elements in <code>V</code> should be added to the current vector or replace the current elements. The main purpose of this function is to get data from one memory space, e.g. CUDA, to the other, e.g. the Host.</p>
<dl class="section note"><dt>Note</dt><dd>The partitioners of the two distributed vectors need to be the same as no MPI communication is performed. </dd></dl>

</div>
</div>
<a id="ga7bde7122a6d05d6815f507f7cb27819a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bde7122a6d05d6815f507f7cb27819a">&#9670;&nbsp;</a></span>reinit() <span class="overload">[15/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Change the dimension to that of the vector V. The elements of V are not copied. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga786d97fd050d53e86d523b1b0766f568">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="gad85b449afaa8f491f01d7670bcc48099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad85b449afaa8f491f01d7670bcc48099">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt;Number, MemorySpace&gt;&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiply the entire vector by a fixed factor. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga02349286c5e57d29396dfac9290d302f">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga16146ad677e926f3bdbed2aca3248247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16146ad677e926f3bdbed2aca3248247">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt;Number, MemorySpace&gt;&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Divide the entire vector by a fixed factor. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga198b28b1759b52bd5df5345be6ff8868">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga3eabb34382bc0694390f97616742bcdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3eabb34382bc0694390f97616742bcdf">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt;Number, MemorySpace&gt;&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add the vector <code>V</code> to the present one. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga8b581c9b2dd4a55c2a5998e62b195bd9">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga132ecfef78dfec86c1b6a5423d642ae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga132ecfef78dfec86c1b6a5423d642ae0">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt;Number, MemorySpace&gt;&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtract the vector <code>V</code> from the present one. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga61e201954ade41d8b8ba290e5841efb2">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="gad947177e38381c4fd058876a4f27f771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad947177e38381c4fd058876a4f27f771">&#9670;&nbsp;</a></span>import() <span class="overload">[3/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::import </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1CommunicationPatternBase.html">Utilities::MPI::CommunicationPatternBase</a> &gt;&#160;</td>
          <td class="paramname"><em>communication_pattern</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Import all the elements present in the vector's <a class="el" href="classIndexSet.html">IndexSet</a> from the input vector <code>V</code>. <a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> <code>operation</code> is used to decide if the elements in <code>V</code> should be added to the current vector or replace the current elements. The last parameter can be used if the same communication pattern is used multiple times. This can be used to improve performance.</p>
<dl class="section note"><dt>Note</dt><dd>If the <a class="el" href="namespaceMemorySpace.html">MemorySpace</a> is CUDA, the data in the <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a> will be moved to the device. </dd></dl>

<p>Implements <a class="el" href="group__Vectors.html#ga0c05d3725740bda0feab10c660582669">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga829281a9ccc9f1cf9720ee5a535efd21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga829281a9ccc9f1cf9720ee5a535efd21">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Number <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the scalar product of two vectors. </p>

<p>Implements <a class="el" href="group__Vectors.html#gabe15b048b316e02c2c88644713f9bda8">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="gac029174b48a0707da587b6ce3bc25047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac029174b48a0707da587b6ce3bc25047">&#9670;&nbsp;</a></span>add() <span class="overload">[6/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add <code>a</code> to all components. Note that <code>a</code> is a scalar not a vector. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga3dbc94fab7a9b8490941588107b5d27b">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="gab7d70c674b55edbb3595acaedc310996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7d70c674b55edbb3595acaedc310996">&#9670;&nbsp;</a></span>add() <span class="overload">[7/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Simple addition of a multiple of a vector, i.e. <code>*this += a*V</code>. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga5d989f75097f8bb45e5297a262ed941d">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga25d752a33b33192932b0dd8054d2c40e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25d752a33b33192932b0dd8054d2c40e">&#9670;&nbsp;</a></span>add() <span class="overload">[8/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiple addition of scaled vectors, i.e. <code>*this += a*V+b*W</code>. </p>

<p>Implements <a class="el" href="group__Vectors.html#gabc8bff328d603ccb5978a6b7d6543c8c">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga883f439a5130ebbbc15f765928a0ad92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga883f439a5130ebbbc15f765928a0ad92">&#9670;&nbsp;</a></span>add() <span class="overload">[9/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A collective add operation: This function adds a whole set of values stored in <code>values</code> to the vector components specified by <code>indices</code>. </p>

</div>
</div>
<a id="gaa6376a098589519491fc452d1529f57b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6376a098589519491fc452d1529f57b">&#9670;&nbsp;</a></span>sadd() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::sadd </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scaling and simple addition of a multiple of a vector, i.e. <code><em>this = s</em>(*this)+a*V</code>. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga8f8a5799eb407e559540aae082f9ec87">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="gaacdf6bfd4533c47587ba0debe177710e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacdf6bfd4533c47587ba0debe177710e">&#9670;&nbsp;</a></span>scale() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>scaling_factors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scale each element of this vector by the corresponding element in the argument. This function is mostly meant to simulate multiplication (and immediate re-assignment) by a diagonal scaling matrix. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga27c492ff183de02d4f75f3d152c6f0ac">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga43c64a6bebc56d849307ef1fcad62c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43c64a6bebc56d849307ef1fcad62c23">&#9670;&nbsp;</a></span>equ() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::equ </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assignment <code>*this = a*V</code>. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga344fbb1ede704fb7b14e6e60048e9da3">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga0e93518655d2231061f4eb916e98a130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e93518655d2231061f4eb916e98a130">&#9670;&nbsp;</a></span>l1_norm() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__Vectors.html#ga34599939674e79cdc3808bb074bcf0ee">real_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::l1_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the l<sub>1</sub> norm of the vector (i.e., the sum of the absolute values of all entries among all processors). </p>

<p>Implements <a class="el" href="group__Vectors.html#ga6ad9146f2c4a36cc762456b4cba21b4c">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="gaf355599021a687026ab9818efd57e82d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf355599021a687026ab9818efd57e82d">&#9670;&nbsp;</a></span>l2_norm() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__Vectors.html#ga34599939674e79cdc3808bb074bcf0ee">real_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::l2_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the \(l_2\) norm of the vector (i.e., the square root of the sum of the square of all entries among all processors). </p>

<p>Implements <a class="el" href="group__Vectors.html#ga2d4822289e1415f1bf35c84c4b7ee292">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="gaeecc4f641fb6c425eb9f12048d7e8efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeecc4f641fb6c425eb9f12048d7e8efd">&#9670;&nbsp;</a></span>norm_sqr() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Vectors.html#ga34599939674e79cdc3808bb074bcf0ee">real_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::norm_sqr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the square of the \(l_2\) norm of the vector. </p>

</div>
</div>
<a id="ga2e7bf945225df27d522ec30f1530c0aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e7bf945225df27d522ec30f1530c0aa">&#9670;&nbsp;</a></span>linfty_norm() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__Vectors.html#ga34599939674e79cdc3808bb074bcf0ee">real_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::linfty_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the maximum norm of the vector (i.e., the maximum absolute value among all entries and among all processors). </p>

<p>Implements <a class="el" href="group__Vectors.html#gaf84f65fc1f6ebc21534271c42c33d159">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="gaf1dc41a177aadb6a2f6d0d7c2cf41eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1dc41a177aadb6a2f6d0d7c2cf41eba">&#9670;&nbsp;</a></span>add_and_dot() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Number <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::add_and_dot </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform a combined operation of a vector addition and a subsequent inner product, returning the value of the inner product. In other words, the result of this function is the same as if the user called </p><div class="fragment"><div class="line">this-&gt;<a class="code" href="group__Vectors.html#gac029174b48a0707da587b6ce3bc25047">add</a>(a, <a class="code" href="namespaceLAPACKSupport.html#aee5ef58d11434eb1d6a665e64bf17292">V</a>);</div>
<div class="line">return_value = *<span class="keyword">this</span> * W;</div>
<div class="ttc" id="agroup__Vectors_html_gac029174b48a0707da587b6ce3bc25047"><div class="ttname"><a href="group__Vectors.html#gac029174b48a0707da587b6ce3bc25047">LinearAlgebra::distributed::Vector::add</a></div><div class="ttdeci">virtual void add(const Number a) override</div></div>
</div><!-- fragment --><p>The reason this function exists is that this operation involves less memory transfer than calling the two functions separately. This method only needs to load three vectors, <code>this</code>, <code>V</code>, <code>W</code>, whereas calling separate methods means to load the calling vector <code>this</code> twice. Since most vector operations are memory transfer limited, this reduces the time by 25% (or 50% if <code>W</code> equals <code>this</code>).</p>
<p>For complex-valued vectors, the scalar product in the second step is implemented as \(\left&lt;v,w\right&gt;=\sum_i v_i \bar{w_i}\). </p>

<p>Implements <a class="el" href="group__Vectors.html#ga89ae394fb53af7daf23705d5992f9f11">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga99297a298764249d0c0b5adf9a96e1c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99297a298764249d0c0b5adf9a96e1c7">&#9670;&nbsp;</a></span>size() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the global size of the vector, equal to the sum of the number of locally owned indices among all processors. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga79b24c9cc50ac00221c89466a021c62a">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="gaff5265a5af79342c77ac50d584c9d3e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff5265a5af79342c77ac50d584c9d3e4">&#9670;&nbsp;</a></span>locally_owned_elements() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ::<a class="el" href="classIndexSet.html">IndexSet</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::locally_owned_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an index set that describes which elements of this vector are owned by the current processor. As a consequence, the index sets returned on different processors if this is a distributed vector will form disjoint sets that add up to the complete index set. Obviously, if a vector is created on only one processor, then the result would satisfy </p><div class="fragment"><div class="line">vec.locally_owned_elements() == <a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(vec.size())</div>
</div><!-- fragment --> 
<p>Implements <a class="el" href="group__Vectors.html#ga47e92627a68a0a778490b5694af4212b">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="gab2218dcb909cf45f3e495ac250ea9260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2218dcb909cf45f3e495ac250ea9260">&#9670;&nbsp;</a></span>print() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>precision</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>scientific</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>across</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Print the vector to the output stream <code>out</code>. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga1fcac5e46eb6bc858f1715e30db75031">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga493afd09167ce2c18d27252178d88c59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga493afd09167ce2c18d27252178d88c59">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the memory consumption of this class in bytes. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga4760b791f71d963298a5d49917f46555">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga85d501a9f8c20d9142fe6a0f88bb12a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85d501a9f8c20d9142fe6a0f88bb12a4">&#9670;&nbsp;</a></span>operator=() <span class="overload">[16/30]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt;Number, MemorySpace&gt;&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets all elements of the vector to the scalar <code>s</code>. If the scalar is zero, also ghost elements are set to zero, otherwise they remain unchanged. </p>

<p>Implements <a class="el" href="group__Vectors.html#gae5dd9195f5c8988b1c8d9cd7878228cb">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga79cb76c50ddfade06995373dfc14cdb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79cb76c50ddfade06995373dfc14cdb4">&#9670;&nbsp;</a></span>add() <span class="overload">[10/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a collective add operation that adds a whole set of values stored in <code>values</code> to the vector components specified by <code>indices</code>. </p>

</div>
</div>
<a id="ga428a001329c576451c1a77557212527a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga428a001329c576451c1a77557212527a">&#9670;&nbsp;</a></span>add() <span class="overload">[11/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname"><em>n_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OtherNumber *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take an address where n_elements are stored contiguously and add them into the vector. </p>

</div>
</div>
<a id="ga44cbdb2b9d3612d549e544dcd11a33ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44cbdb2b9d3612d549e544dcd11a33ed">&#9670;&nbsp;</a></span>sadd() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::sadd </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scaling and simple vector addition, i.e. <code><em>this = s</em>(*this)+V</code>. </p>

</div>
</div>
<a id="gabebeb6ebf3dedc1123663eae12374b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabebeb6ebf3dedc1123663eae12374b06">&#9670;&nbsp;</a></span>local_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::local_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the local size of the vector, i.e., the number of indices owned locally.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000069">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__Vectors.html#ga3db2bea96180138f039b9d2934534492">locally_owned_size()</a> instead. </dd></dl>

</div>
</div>
<a id="ga3db2bea96180138f039b9d2934534492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3db2bea96180138f039b9d2934534492">&#9670;&nbsp;</a></span>locally_owned_size() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::locally_owned_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the local size of the vector, i.e., the number of indices owned locally. </p>

</div>
</div>
<a id="gae8fc3d0924b59159a50ed9838d8a6592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8fc3d0924b59159a50ed9838d8a6592">&#9670;&nbsp;</a></span>in_local_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::in_local_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname"><em>global_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if the given global index is in the local range of this processor. </p>

</div>
</div>
<a id="gafdcd750879bde459ccb63936c74a0e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdcd750879bde459ccb63936c74a0e87">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Vectors.html#ga35abed3e6b898142990cecf00e8387da">iterator</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make the <code><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a></code> class a bit like the <code>vector&lt;&gt;</code> class of the C++ standard library by returning iterators to the start and end of the <em>locally owned</em> elements of this vector.</p>
<p>It holds that <a class="el" href="group__Vectors.html#gab0a4b780b6b8fded62768da4164d2378">end()</a> - <a class="el" href="group__Vectors.html#gafdcd750879bde459ccb63936c74a0e87">begin()</a> == <a class="el" href="group__Vectors.html#ga3db2bea96180138f039b9d2934534492">locally_owned_size()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>For the CUDA memory space, the iterator points to memory on the device. </dd></dl>

</div>
</div>
<a id="gae038db1a3998888e469398031da2b980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae038db1a3998888e469398031da2b980">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Vectors.html#ga4a990da0f1e95dd6004fbf0cf711c53d">const_iterator</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return constant iterator to the start of the locally owned elements of the vector.</p>
<dl class="section note"><dt>Note</dt><dd>For the CUDA memory space, the iterator points to memory on the device. </dd></dl>

</div>
</div>
<a id="gab0a4b780b6b8fded62768da4164d2378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0a4b780b6b8fded62768da4164d2378">&#9670;&nbsp;</a></span>end() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Vectors.html#ga35abed3e6b898142990cecf00e8387da">iterator</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator pointing to the element past the end of the array of locally owned entries.</p>
<dl class="section note"><dt>Note</dt><dd>For the CUDA memory space, the iterator points to memory on the device. </dd></dl>

</div>
</div>
<a id="ga362987561884296cee4ba45f4fe85abe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga362987561884296cee4ba45f4fe85abe">&#9670;&nbsp;</a></span>end() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Vectors.html#ga4a990da0f1e95dd6004fbf0cf711c53d">const_iterator</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a constant iterator pointing to the element past the end of the array of the locally owned entries.</p>
<dl class="section note"><dt>Note</dt><dd>For the CUDA memory space, the iterator points to memory on the device. </dd></dl>

</div>
</div>
<a id="gac551bfa7fd898a0a8e85f59109c091ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac551bfa7fd898a0a8e85f59109c091ed">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname"><em>global_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read access to the data in the position corresponding to <code>global_index</code>. The index must be either in the local range of the vector or be specified as a ghost index at construction.</p>
<p>Performance: <code>O(1)</code> for locally owned elements that represent a contiguous range and <code>O(log(n<sub>ranges</sub>))</code> for ghost elements (quite fast, but slower than <a class="el" href="group__Vectors.html#ga1c4bc946b94f19d7e11c00f41a39db02">local_element()</a>). </p>

</div>
</div>
<a id="ga58b7c43da3b837f4b811ad4cc813d899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58b7c43da3b837f4b811ad4cc813d899">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname"><em>global_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read and write access to the data in the position corresponding to <code>global_index</code>. The index must be either in the local range of the vector or be specified as a ghost index at construction.</p>
<p>Performance: <code>O(1)</code> for locally owned elements that represent a contiguous range and <code>O(log(n<sub>ranges</sub>))</code> for ghost elements (quite fast, but slower than <a class="el" href="group__Vectors.html#ga1c4bc946b94f19d7e11c00f41a39db02">local_element()</a>). </p>

</div>
</div>
<a id="ga5c497852ad2b7d6917a4b60f6c7b28bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c497852ad2b7d6917a4b60f6c7b28bf">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname"><em>global_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read access to the data in the position corresponding to <code>global_index</code>. The index must be either in the local range of the vector or be specified as a ghost index at construction.</p>
<p>This function does the same thing as operator(). </p>

</div>
</div>
<a id="ga1bc5f6e645477d457a68784b83bdf582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bc5f6e645477d457a68784b83bdf582">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname"><em>global_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read and write access to the data in the position corresponding to <code>global_index</code>. The index must be either in the local range of the vector or be specified as a ghost index at construction.</p>
<p>This function does the same thing as operator(). </p>

</div>
</div>
<a id="ga1c4bc946b94f19d7e11c00f41a39db02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c4bc946b94f19d7e11c00f41a39db02">&#9670;&nbsp;</a></span>local_element() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::local_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname"><em>local_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read access to the data field specified by <code>local_index</code>. Locally owned indices can be accessed with indices <code>[0,locally_owned_size)</code>, and ghost indices with indices <code>[locally_owned_size,locally_owned_size+ n_ghost_entries]</code>.</p>
<p>Performance: Direct array access (fast). </p>

</div>
</div>
<a id="ga397872125364fdcaf89e62f8616d7d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga397872125364fdcaf89e62f8616d7d62">&#9670;&nbsp;</a></span>local_element() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::local_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname"><em>local_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read and write access to the data field specified by <code>local_index</code>. Locally owned indices can be accessed with indices <code>[0,<a class="el" href="group__Vectors.html#ga3db2bea96180138f039b9d2934534492">locally_owned_size()</a>)</code>, and ghost indices with indices <code>[<a class="el" href="group__Vectors.html#ga3db2bea96180138f039b9d2934534492">locally_owned_size()</a>, <a class="el" href="group__Vectors.html#ga3db2bea96180138f039b9d2934534492">locally_owned_size()</a>+n_ghosts]</code>.</p>
<p>Performance: Direct array access (fast). </p>

</div>
</div>
<a id="ga8db545d71e642710a044554d6df060d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8db545d71e642710a044554d6df060d9">&#9670;&nbsp;</a></span>get_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number* <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::get_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the pointer to the underlying raw array.</p>
<dl class="section note"><dt>Note</dt><dd>For the CUDA memory space, the pointer points to memory on the device. </dd></dl>

</div>
</div>
<a id="gad49497fa8fad0250a2bd0f4a36179ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad49497fa8fad0250a2bd0f4a36179ff2">&#9670;&nbsp;</a></span>extract_subvector_to() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::extract_subvector_to </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instead of getting individual elements of a vector via operator(), this function allows getting a whole set of elements at once. The indices of the elements to be read are stated in the first argument, the corresponding values are returned in the second.</p>
<p>If the current vector is called <code>v</code>, then this function is the equivalent to the code </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;indices.size(); ++i)</div>
<div class="line">  <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>[i] = v[indices[i]];</div>
<div class="ttc" id="anamespaceEvaluationFlags_html_a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58"><div class="ttname"><a href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a></div><div class="ttdeci">@ values</div><div class="ttdef"><b>Definition:</b> <a href="evaluation__flags_8h_source.html#l00051">evaluation_flags.h:51</a></div></div>
</div><!-- fragment --><dl class="section pre"><dt>Precondition</dt><dd>The sizes of the <code>indices</code> and <code>values</code> arrays must be identical.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is not implemented for CUDA memory space. </dd></dl>

</div>
</div>
<a id="gaeb9494a9258d9f0b06b97550921c5e0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb9494a9258d9f0b06b97550921c5e0e">&#9670;&nbsp;</a></span>extract_subvector_to() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<div class="memtemplate">
template&lt;typename ForwardIterator , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::extract_subvector_to </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>indices_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator&#160;</td>
          <td class="paramname"><em>indices_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>values_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instead of getting individual elements of a vector via operator(), this function allows getting a whole set of elements at once. In contrast to the previous function, this function obtains the indices of the elements by dereferencing all elements of the iterator range provided by the first two arguments, and puts the vector values into memory locations obtained by dereferencing a range of iterators starting at the location pointed to by the third argument.</p>
<p>If the current vector is called <code>v</code>, then this function is the equivalent to the code </p><div class="fragment"><div class="line">ForwardIterator indices_p = indices_begin;</div>
<div class="line">OutputIterator  values_p  = values_begin;</div>
<div class="line"><span class="keywordflow">while</span> (indices_p != indices_end)</div>
<div class="line">{</div>
<div class="line">  *values_p = v[*indices_p];</div>
<div class="line">  ++indices_p;</div>
<div class="line">  ++values_p;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section pre"><dt>Precondition</dt><dd>It must be possible to write into as many memory locations starting at <code>values_begin</code> as there are iterators between <code>indices_begin</code> and <code>indices_end</code>. </dd></dl>

</div>
</div>
<a id="ga5ed7dc1d792f9344f1c8720e5f639351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ed7dc1d792f9344f1c8720e5f639351">&#9670;&nbsp;</a></span>all_zero() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::all_zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether the vector contains only elements with value zero. This is a collective operation. This function is expensive, because potentially all elements have to be checked. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga8c03a20480770e68f0d4e1e6456e78eb">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga64f0fddbf542f0e6ff6344e0fa7d55f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64f0fddbf542f0e6ff6344e0fa7d55f9">&#9670;&nbsp;</a></span>mean_value() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Number <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::mean_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the mean value of all the entries in the vector. </p>

<p>Implements <a class="el" href="group__Vectors.html#gab3e11175ad9c308d796d72aa0fc6b44b">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga8bf8c57a134cf1c5f27dab3a5cc1edf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bf8c57a134cf1c5f27dab3a5cc1edf5">&#9670;&nbsp;</a></span>lp_norm() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Vectors.html#ga34599939674e79cdc3808bb074bcf0ee">real_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::lp_norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#ga34599939674e79cdc3808bb074bcf0ee">real_type</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\(l_p\)-norm of the vector. The pth root of the sum of the pth powers of the absolute values of the elements. </p>

</div>
</div>
<a id="ga995b4962ed8eee92cb0db9678c2047eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga995b4962ed8eee92cb0db9678c2047eb">&#9670;&nbsp;</a></span>get_mpi_communicator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const MPI_Comm&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::get_mpi_communicator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a reference to the MPI communicator object in use with this vector. </p>

</div>
</div>
<a id="ga57d72f160499a5f0bc289da5b5187546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57d72f160499a5f0bc289da5b5187546">&#9670;&nbsp;</a></span>get_partitioner()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::shared_ptr&lt;const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a>&gt;&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::get_partitioner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the MPI partitioner that describes the parallel layout of the vector. This object can be used to initialize another vector with the respective <a class="el" href="group__Vectors.html#gace027311492ed2f6e07fbd74d723e3a9">reinit()</a> call, for additional queries regarding the parallel communication, or the compatibility of partitioners. </p>

</div>
</div>
<a id="ga1121c9b5aa9c34d0fe36486fecf08b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1121c9b5aa9c34d0fe36486fecf08b58">&#9670;&nbsp;</a></span>partitioners_are_compatible()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::partitioners_are_compatible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &amp;&#160;</td>
          <td class="paramname"><em>part</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether the given partitioner is compatible with the partitioner used for this vector. Two partitioners are compatible if they have the same local size and the same ghost indices. They do not necessarily need to be the same data field of the shared pointer. This is a local operation only, i.e., if only some processors decide that the partitioning is not compatible, only these processors will return <code>false</code>, whereas the other processors will return <code>true</code>. </p>

</div>
</div>
<a id="ga8f678da4f2dec42cd6f9bc383c0f3c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f678da4f2dec42cd6f9bc383c0f3c11">&#9670;&nbsp;</a></span>partitioners_are_globally_compatible()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::partitioners_are_globally_compatible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &amp;&#160;</td>
          <td class="paramname"><em>part</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether the given partitioner is compatible with the partitioner used for this vector. Two partitioners are compatible if they have the same local size and the same ghost indices. They do not necessarily need to be the same data field. As opposed to <a class="el" href="group__Vectors.html#ga1121c9b5aa9c34d0fe36486fecf08b58">partitioners_are_compatible()</a>, this method checks for compatibility among all processors and the method only returns <code>true</code> if the partitioner is the same on all processors.</p>
<p>This method performs global communication, so make sure to use it only in a context where all processors call it the same number of times. </p>

</div>
</div>
<a id="ga662fd533f2cae84a902e7a587fc6f36c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga662fd533f2cae84a902e7a587fc6f36c">&#9670;&nbsp;</a></span>set_ghost_state()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::set_ghost_state </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>ghosted</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the ghost state of this vector to <code>ghosted</code>. </p>

</div>
</div>
<a id="gad16bd935d90fe664309c52be1615bd4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad16bd935d90fe664309c52be1615bd4b">&#9670;&nbsp;</a></span>shared_vector_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classArrayView.html">ArrayView</a>&lt;const Number&gt; &gt;&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::shared_vector_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get pointers to the beginning of the values of the other processes of the same shared-memory domain. </p>

</div>
</div>
<a id="ga9f9fec5521e69ebd55f8d7dac02cf610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f9fec5521e69ebd55f8d7dac02cf610">&#9670;&nbsp;</a></span>add_local()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::add_local </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Simple addition of a multiple of a vector, i.e. <code>*this += a*V</code> without MPI communication. </p>

</div>
</div>
<a id="gac7b56c7dbbe54762d35b9f536e9d9c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7b56c7dbbe54762d35b9f536e9d9c76">&#9670;&nbsp;</a></span>sadd_local()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::sadd_local </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scaling and simple addition of a multiple of a vector, i.e. <code><em>this = s</em>(*this)+a*V</code> without MPI communication. </p>

</div>
</div>
<a id="gaec8a0511ae8151672f9a92a699523c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec8a0511ae8151672f9a92a699523c52">&#9670;&nbsp;</a></span>inner_product_local()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::inner_product_local </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number2, MemorySpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Local part of the inner product of two vectors. </p>

</div>
</div>
<a id="ga45739e3cb34a433f67b5c0e23fa5dcf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45739e3cb34a433f67b5c0e23fa5dcf7">&#9670;&nbsp;</a></span>norm_sqr_local()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Vectors.html#ga34599939674e79cdc3808bb074bcf0ee">real_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::norm_sqr_local </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Local part of <a class="el" href="group__Vectors.html#gaeecc4f641fb6c425eb9f12048d7e8efd">norm_sqr()</a>. </p>

</div>
</div>
<a id="ga0cab16fed261f1579c11ea5c81cb0eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cab16fed261f1579c11ea5c81cb0eb7">&#9670;&nbsp;</a></span>mean_value_local()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::mean_value_local </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Local part of <a class="el" href="group__Vectors.html#ga64f0fddbf542f0e6ff6344e0fa7d55f9">mean_value()</a>. </p>

</div>
</div>
<a id="ga2df86018fd6619067a0749deb49c6288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2df86018fd6619067a0749deb49c6288">&#9670;&nbsp;</a></span>l1_norm_local()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Vectors.html#ga34599939674e79cdc3808bb074bcf0ee">real_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::l1_norm_local </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Local part of <a class="el" href="group__Vectors.html#ga0e93518655d2231061f4eb916e98a130">l1_norm()</a>. </p>

</div>
</div>
<a id="gac6b149f392aea2068ad62632dd865e5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6b149f392aea2068ad62632dd865e5c">&#9670;&nbsp;</a></span>lp_norm_local()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Vectors.html#ga34599939674e79cdc3808bb074bcf0ee">real_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::lp_norm_local </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#ga34599939674e79cdc3808bb074bcf0ee">real_type</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Local part of <a class="el" href="group__Vectors.html#ga8bf8c57a134cf1c5f27dab3a5cc1edf5">lp_norm()</a>. </p>

</div>
</div>
<a id="ga21bc694084db3eb69bd8bb9439787131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21bc694084db3eb69bd8bb9439787131">&#9670;&nbsp;</a></span>linfty_norm_local()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Vectors.html#ga34599939674e79cdc3808bb074bcf0ee">real_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::linfty_norm_local </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Local part of <a class="el" href="group__Vectors.html#ga2e7bf945225df27d522ec30f1530c0aa">linfty_norm()</a>. </p>

</div>
</div>
<a id="ga1fb83d9dd19884023fb6c739c1958a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fb83d9dd19884023fb6c739c1958a7a">&#9670;&nbsp;</a></span>add_and_dot_local()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::add_and_dot_local </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Local part of the addition followed by an inner product of two vectors. The same applies for complex-valued vectors as for the <a class="el" href="group__Vectors.html#gaf1dc41a177aadb6a2f6d0d7c2cf41eba">add_and_dot()</a> function. </p>

</div>
</div>
<a id="ga4aaa85ec1704806392274242fa705ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4aaa85ec1704806392274242fa705ed8">&#9670;&nbsp;</a></span>clear_mpi_requests()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::clear_mpi_requests </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A helper function that clears the compress_requests and update_ghost_values_requests field. Used in <a class="el" href="group__Vectors.html#gace027311492ed2f6e07fbd74d723e3a9">reinit()</a> functions. </p>

</div>
</div>
<a id="ga0f5a3788d6c951791217cd59f8cd9fbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f5a3788d6c951791217cd59f8cd9fbc">&#9670;&nbsp;</a></span>resize_val() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::resize_val </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname"><em>new_allocated_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>comm_sm</em> = <code>MPI_COMM_SELF</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A helper function that is used to resize the val array. </p>

</div>
</div>
<a id="ga33e1965eb91cb5e16e215e9217a71c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33e1965eb91cb5e16e215e9217a71c55">&#9670;&nbsp;</a></span>detect() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> <a class="el" href="classinternal_1_1LinearOperatorImplementation_1_1ReinitHelper.html">internal::LinearOperatorImplementation::ReinitHelper</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number &gt; &gt;::has_get_mpi_communicator&lt; T &gt;::detect </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga2865c5f46c87f8fc63d640461516ba49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2865c5f46c87f8fc63d640461516ba49">&#9670;&nbsp;</a></span>detect() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static decltype(std::declval&lt;U&gt;().get_mpi_communicator()) <a class="el" href="classinternal_1_1LinearOperatorImplementation_1_1ReinitHelper.html">internal::LinearOperatorImplementation::ReinitHelper</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number &gt; &gt;::has_get_mpi_communicator&lt; T &gt;::detect </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga56022312fe71c8c4b958ab38d6f5db81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56022312fe71c8c4b958ab38d6f5db81">&#9670;&nbsp;</a></span>detect() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> <a class="el" href="classinternal_1_1LinearOperatorImplementation_1_1ReinitHelper.html">internal::LinearOperatorImplementation::ReinitHelper</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number &gt; &gt;::has_locally_owned_domain_indices&lt; T &gt;::detect </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga2d1b35db1ac8dde8fb4d31974c2726d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d1b35db1ac8dde8fb4d31974c2726d7">&#9670;&nbsp;</a></span>detect() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static decltype(std::declval&lt;U&gt;().locally_owned_domain_indices()) <a class="el" href="classinternal_1_1LinearOperatorImplementation_1_1ReinitHelper.html">internal::LinearOperatorImplementation::ReinitHelper</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number &gt; &gt;::has_locally_owned_domain_indices&lt; T &gt;::detect </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga3bc73349878445ff2166b1ab069f69eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3bc73349878445ff2166b1ab069f69eb">&#9670;&nbsp;</a></span>detect() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> <a class="el" href="classinternal_1_1LinearOperatorImplementation_1_1ReinitHelper.html">internal::LinearOperatorImplementation::ReinitHelper</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number &gt; &gt;::has_locally_owned_range_indices&lt; T &gt;::detect </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gab135f50d6f101b59817a0e27bfe92092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab135f50d6f101b59817a0e27bfe92092">&#9670;&nbsp;</a></span>detect() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static decltype(std::declval&lt;U&gt;().locally_owned_range_indices()) <a class="el" href="classinternal_1_1LinearOperatorImplementation_1_1ReinitHelper.html">internal::LinearOperatorImplementation::ReinitHelper</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number &gt; &gt;::has_locally_owned_range_indices&lt; T &gt;::detect </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga41ecc6007d7fcd495df08efe4cf1e275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41ecc6007d7fcd495df08efe4cf1e275">&#9670;&nbsp;</a></span>detect() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> <a class="el" href="classinternal_1_1LinearOperatorImplementation_1_1ReinitHelper.html">internal::LinearOperatorImplementation::ReinitHelper</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number &gt; &gt;::has_initialize_dof_vector&lt; T &gt;::detect </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gaefbebd59134c254383766e2a10bef603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefbebd59134c254383766e2a10bef603">&#9670;&nbsp;</a></span>detect() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static decltype(std::declval&lt;U&gt;().initialize_dof_vector( std::declval&lt;<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt;Number&gt; &amp;&gt;())) <a class="el" href="classinternal_1_1LinearOperatorImplementation_1_1ReinitHelper.html">internal::LinearOperatorImplementation::ReinitHelper</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number &gt; &gt;::has_initialize_dof_vector&lt; T &gt;::detect </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gad4580b978dacc9bea5f60a3bbcc2f9f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4580b978dacc9bea5f60a3bbcc2f9f7">&#9670;&nbsp;</a></span>reinit_domain_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename MatrixType , typename std::enable_if&lt; has_get_mpi_communicator&lt; MatrixType &gt;::value &amp;&amp;has_locally_owned_domain_indices&lt; MatrixType &gt;::value, MatrixType &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classinternal_1_1LinearOperatorImplementation_1_1ReinitHelper.html">internal::LinearOperatorImplementation::ReinitHelper</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number &gt; &gt;::reinit_domain_vector </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01956">1956</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="ga3eb0b92ae4d682329e13171ec9145c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3eb0b92ae4d682329e13171ec9145c1b">&#9670;&nbsp;</a></span>reinit_range_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename MatrixType , typename std::enable_if&lt; has_get_mpi_communicator&lt; MatrixType &gt;::value &amp;&amp;has_locally_owned_range_indices&lt; MatrixType &gt;::value, MatrixType &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classinternal_1_1LinearOperatorImplementation_1_1ReinitHelper.html">internal::LinearOperatorImplementation::ReinitHelper</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number &gt; &gt;::reinit_range_vector </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01986">1986</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="ga4e76154cdf026cc7fd2e32d7e1de7d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e76154cdf026cc7fd2e32d7e1de7d7b">&#9670;&nbsp;</a></span>Vector() <span class="overload">[7/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1Vector.html">LinearAlgebra::Vector</a>&lt; Number &gt;::<a class="el" href="classLinearAlgebra_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor. Create a vector of dimension zero. </p>

</div>
</div>
<a id="ga06fa00fc31e8865d1ba39e0e44aa7c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06fa00fc31e8865d1ba39e0e44aa7c5f">&#9670;&nbsp;</a></span>Vector() <span class="overload">[8/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1Vector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classLinearAlgebra_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1Vector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor. Sets the dimension to that of the given vector and copies all elements. </p>

<p class="definition">Definition at line <a class="el" href="la__vector_8h_source.html#l00427">427</a> of file <a class="el" href="la__vector_8h_source.html">la_vector.h</a>.</p>

</div>
</div>
<a id="ga2de475367d8e8440fc32564a9178216f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2de475367d8e8440fc32564a9178216f">&#9670;&nbsp;</a></span>Vector() <span class="overload">[9/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1Vector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classLinearAlgebra_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#ga81ab101056e685ef358597528a48ccb7">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor. Set dimension to <code>n</code> and initialize all elements with zero.</p>
<p>The constructor is made explicit to avoid accident like this: <code>v=0;</code>. Presumably, the user wants to set every element of the vector to zero, but instead, what happens is this call: <code>v=<a class="el" href="classLinearAlgebra_1_1Vector.html">Vector</a>&lt;Number&gt;(0);</code>, i.e. the vector is replaced by one of length zero. </p>

<p class="definition">Definition at line <a class="el" href="la__vector_8h_source.html#l00434">434</a> of file <a class="el" href="la__vector_8h_source.html">la_vector.h</a>.</p>

</div>
</div>
<a id="gaf441b2c23134f8e6e08c833f918888a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf441b2c23134f8e6e08c833f918888a2">&#9670;&nbsp;</a></span>Vector() <span class="overload">[10/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1Vector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classLinearAlgebra_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize the vector with a given range of values pointed to by the iterators. This function exists in analogy to the <code>std::vector</code> class. </p>

<p class="definition">Definition at line <a class="el" href="la__vector_8h_source.html#l00442">442</a> of file <a class="el" href="la__vector_8h_source.html">la_vector.h</a>.</p>

</div>
</div>
<a id="ga5ace9efb83033bbf80d60e49d6da337d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ace9efb83033bbf80d60e49d6da337d">&#9670;&nbsp;</a></span>reinit() <span class="overload">[16/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1Vector.html">LinearAlgebra::Vector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#ga81ab101056e685ef358597528a48ccb7">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the global size of the vector to <code>size</code>. The stored elements have their index in [0,size).</p>
<p>If the flag <code>omit_zeroing_entries</code> is set to false, the memory will be initialized with zero, otherwise the memory will be untouched (and the user must make sure to fill it with reasonable data before using it). </p>

<p>Reimplemented from <a class="el" href="group__Vectors.html#gaaee2ea7c671f9ece558b081b0d104295">LinearAlgebra::ReadWriteVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="gafac30b01402f08d630d9c00151eace83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafac30b01402f08d630d9c00151eace83">&#9670;&nbsp;</a></span>reinit() <span class="overload">[17/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1Vector.html">LinearAlgebra::Vector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Uses the same <a class="el" href="classIndexSet.html">IndexSet</a> as the one of the input vector <code>in_vector</code> and allocates memory for this vector.</p>
<p>If the flag <code>omit_zeroing_entries</code> is set to false, the memory will be initialized with zero, otherwise the memory will be untouched (and the user must make sure to fill it with reasonable data before using it). </p>

</div>
</div>
<a id="ga43835ffaaf2af03d72164910c82f7ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43835ffaaf2af03d72164910c82f7ce7">&#9670;&nbsp;</a></span>reinit() <span class="overload">[18/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1Vector.html">LinearAlgebra::Vector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>locally_stored_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes the vector. The indices are specified by <code>locally_stored_indices</code>.</p>
<p>If the flag <code>omit_zeroing_entries</code> is set to false, the memory will be initialized with zero, otherwise the memory will be untouched (and the user must make sure to fill it with reasonable data before using it). locally_stored_indices. </p>

<p>Reimplemented from <a class="el" href="group__Vectors.html#gaaa5d0c1a26755df4f451091e051a5277">LinearAlgebra::ReadWriteVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="gaa64c8e418f460ed9e2886b45bf982b08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa64c8e418f460ed9e2886b45bf982b08">&#9670;&nbsp;</a></span>reinit() <span class="overload">[19/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1Vector.html">LinearAlgebra::Vector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Change the dimension to that of the vector V. The elements of V are not copied. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga786d97fd050d53e86d523b1b0766f568">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="gaf010746729396790ea5444245bd7e87b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf010746729396790ea5444245bd7e87b">&#9670;&nbsp;</a></span>has_ghost_elements() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classLinearAlgebra_1_1Vector.html">LinearAlgebra::Vector</a>&lt; Number &gt;::has_ghost_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>false</code> as this is a serial vector.</p>
<p>This functionality only needs to be called if using MPI based vectors and exists in other objects for compatibility. </p>

</div>
</div>
<a id="ga70e74e5c8e76f6f1571d77b4b7f88887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70e74e5c8e76f6f1571d77b4b7f88887">&#9670;&nbsp;</a></span>operator=() <span class="overload">[17/30]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1Vector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classLinearAlgebra_1_1Vector.html">LinearAlgebra::Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1Vector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the data of the input vector <code>in_vector</code>. </p>

</div>
</div>
<a id="gaadf5d3c185df855c835d3e03bbb10eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadf5d3c185df855c835d3e03bbb10eba">&#9670;&nbsp;</a></span>operator=() <span class="overload">[18/30]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1Vector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classLinearAlgebra_1_1Vector.html">LinearAlgebra::Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1Vector.html">Vector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the data of the input vector <code>in_vector</code>. </p>

</div>
</div>
<a id="ga557ab29f95f51396ced9cd9deb2c8581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga557ab29f95f51396ced9cd9deb2c8581">&#9670;&nbsp;</a></span>operator=() <span class="overload">[19/30]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1Vector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classLinearAlgebra_1_1Vector.html">LinearAlgebra::Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets all elements of the vector to the scalar <code>s</code>. This operation is only allowed if <code>s</code> is equal to zero. </p>

<p>Implements <a class="el" href="group__Vectors.html#gae5dd9195f5c8988b1c8d9cd7878228cb">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="gaf94005df1795ba915f56cbe9689bafe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf94005df1795ba915f56cbe9689bafe1">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1Vector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classLinearAlgebra_1_1Vector.html">LinearAlgebra::Vector</a>&lt; Number &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiply the entire vector by a fixed factor. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga02349286c5e57d29396dfac9290d302f">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="gab2e30d0e4ce88f2def5c702abfde3647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2e30d0e4ce88f2def5c702abfde3647">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1Vector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classLinearAlgebra_1_1Vector.html">LinearAlgebra::Vector</a>&lt; Number &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Divide the entire vector by a fixed factor. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga198b28b1759b52bd5df5345be6ff8868">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="gafaac1b52eb924a1e85dcc07dfe97c1e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafaac1b52eb924a1e85dcc07dfe97c1e0">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1Vector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classLinearAlgebra_1_1Vector.html">LinearAlgebra::Vector</a>&lt; Number &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add the vector <code>V</code> to the present one. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga8b581c9b2dd4a55c2a5998e62b195bd9">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga7564016986f801b180919010fd5520aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7564016986f801b180919010fd5520aa">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1Vector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classLinearAlgebra_1_1Vector.html">LinearAlgebra::Vector</a>&lt; Number &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtract the vector <code>V</code> from the present one. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga61e201954ade41d8b8ba290e5841efb2">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga579d6877263ae00b309422bcd6e3d307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga579d6877263ae00b309422bcd6e3d307">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Number <a class="el" href="classLinearAlgebra_1_1Vector.html">LinearAlgebra::Vector</a>&lt; Number &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the scalar product of two vectors. </p>

<p>Implements <a class="el" href="group__Vectors.html#gabe15b048b316e02c2c88644713f9bda8">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="gab9e93ebac6f78cc400dcc1398dc07014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9e93ebac6f78cc400dcc1398dc07014">&#9670;&nbsp;</a></span>import() <span class="overload">[4/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1Vector.html">LinearAlgebra::Vector</a>&lt; Number &gt;::import </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1CommunicationPatternBase.html">Utilities::MPI::CommunicationPatternBase</a> &gt;&#160;</td>
          <td class="paramname"><em>communication_pattern</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is not implemented and will throw an exception. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga0c05d3725740bda0feab10c660582669">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="gae544cbdf92826eec01c0cceeff69817a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae544cbdf92826eec01c0cceeff69817a">&#9670;&nbsp;</a></span>add() <span class="overload">[12/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1Vector.html">LinearAlgebra::Vector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add <code>a</code> to all components. Note that <code>a</code> is a scalar not a vector. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga3dbc94fab7a9b8490941588107b5d27b">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga9468f18bddc88c38140e99961ae0c360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9468f18bddc88c38140e99961ae0c360">&#9670;&nbsp;</a></span>add() <span class="overload">[13/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1Vector.html">LinearAlgebra::Vector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Simple addition of a multiple of a vector, i.e. <code>*this += a*V</code>. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga5d989f75097f8bb45e5297a262ed941d">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga5c4190172e7ebc876dbdcde8617813f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c4190172e7ebc876dbdcde8617813f3">&#9670;&nbsp;</a></span>add() <span class="overload">[14/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1Vector.html">LinearAlgebra::Vector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiple addition of a multiple of a vector, i.e. <code>*this += a*V+b*W</code>. </p>

<p>Implements <a class="el" href="group__Vectors.html#gabc8bff328d603ccb5978a6b7d6543c8c">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="gab0e8184f5712096bc81ef553b0d3adc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0e8184f5712096bc81ef553b0d3adc5">&#9670;&nbsp;</a></span>sadd() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1Vector.html">LinearAlgebra::Vector</a>&lt; Number &gt;::sadd </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scaling and simple addition of a multiple of a vector, i.e. <code><em>this = s</em>(*this)+a*V</code>. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga8f8a5799eb407e559540aae082f9ec87">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga45e4f966a68c411aed4525ab4ebb0645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45e4f966a68c411aed4525ab4ebb0645">&#9670;&nbsp;</a></span>scale() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1Vector.html">LinearAlgebra::Vector</a>&lt; Number &gt;::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>scaling_factors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scale each element of this vector by the corresponding element in the argument. This function is mostly meant to simulate multiplication (and immediate re-assignment) by a diagonal scaling matrix. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga27c492ff183de02d4f75f3d152c6f0ac">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="gafb746b1de6c4efea8e2b90e28471a398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb746b1de6c4efea8e2b90e28471a398">&#9670;&nbsp;</a></span>equ() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1Vector.html">LinearAlgebra::Vector</a>&lt; Number &gt;::equ </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assignment <code>*this = a*V</code>. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga344fbb1ede704fb7b14e6e60048e9da3">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga98de521b6d2dab1cf767b6abb2ca9c17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98de521b6d2dab1cf767b6abb2ca9c17">&#9670;&nbsp;</a></span>all_zero() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> <a class="el" href="classLinearAlgebra_1_1Vector.html">LinearAlgebra::Vector</a>&lt; Number &gt;::all_zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether the vector contains only elements with value zero. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga8c03a20480770e68f0d4e1e6456e78eb">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga88d01435c6542c25fdad43bdb6fdd421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88d01435c6542c25fdad43bdb6fdd421">&#9670;&nbsp;</a></span>mean_value() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__Vectors.html#gad23ad800e8a9a3bc7c4867c6ae884d19">value_type</a> <a class="el" href="classLinearAlgebra_1_1Vector.html">LinearAlgebra::Vector</a>&lt; Number &gt;::mean_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the mean value of all the entries of this vector. </p>

<p>Implements <a class="el" href="group__Vectors.html#gab3e11175ad9c308d796d72aa0fc6b44b">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga7e8d6fff438ca92832676d01f8d75c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e8d6fff438ca92832676d01f8d75c4e">&#9670;&nbsp;</a></span>l1_norm() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt;Number&gt;::<a class="el" href="group__Vectors.html#gaf1c0cad1a0b23c477db4c97ba895b038">real_type</a> <a class="el" href="classLinearAlgebra_1_1Vector.html">LinearAlgebra::Vector</a>&lt; Number &gt;::l1_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the l<sub>1</sub> norm of the vector (i.e., the sum of the absolute values of all entries). </p>

<p>Implements <a class="el" href="group__Vectors.html#ga6ad9146f2c4a36cc762456b4cba21b4c">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga3ecec231c62d47fe3c7aba269fd8ffb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ecec231c62d47fe3c7aba269fd8ffb8">&#9670;&nbsp;</a></span>l2_norm() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt;Number&gt;::<a class="el" href="group__Vectors.html#gaf1c0cad1a0b23c477db4c97ba895b038">real_type</a> <a class="el" href="classLinearAlgebra_1_1Vector.html">LinearAlgebra::Vector</a>&lt; Number &gt;::l2_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the l<sub>2</sub> norm of the vector (i.e., the square root of the sum of the square of all entries among all processors). </p>

<p>Implements <a class="el" href="group__Vectors.html#ga2d4822289e1415f1bf35c84c4b7ee292">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="gab77a07267e7a186d7948b09396edecff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab77a07267e7a186d7948b09396edecff">&#9670;&nbsp;</a></span>linfty_norm() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt;Number&gt;::<a class="el" href="group__Vectors.html#gaf1c0cad1a0b23c477db4c97ba895b038">real_type</a> <a class="el" href="classLinearAlgebra_1_1Vector.html">LinearAlgebra::Vector</a>&lt; Number &gt;::linfty_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the maximum norm of the vector (i.e., the maximum absolute value among all entries and among all processors). </p>

<p>Implements <a class="el" href="group__Vectors.html#gaf84f65fc1f6ebc21534271c42c33d159">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="gaecfb1b3222bb8069117f3d2c707c3060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecfb1b3222bb8069117f3d2c707c3060">&#9670;&nbsp;</a></span>add_and_dot() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Number <a class="el" href="classLinearAlgebra_1_1Vector.html">LinearAlgebra::Vector</a>&lt; Number &gt;::add_and_dot </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform a combined operation of a vector addition and a subsequent inner product, returning the value of the inner product. In other words, the result of this function is the same as if the user called </p><div class="fragment"><div class="line">this-&gt;<a class="code" href="group__Vectors.html#gae544cbdf92826eec01c0cceeff69817a">add</a>(a, <a class="code" href="namespaceLAPACKSupport.html#aee5ef58d11434eb1d6a665e64bf17292">V</a>);</div>
<div class="line">return_value = *<span class="keyword">this</span> * W;</div>
<div class="ttc" id="agroup__Vectors_html_gae544cbdf92826eec01c0cceeff69817a"><div class="ttname"><a href="group__Vectors.html#gae544cbdf92826eec01c0cceeff69817a">LinearAlgebra::Vector::add</a></div><div class="ttdeci">virtual void add(const Number a) override</div></div>
</div><!-- fragment --><p>The reason this function exists is that this operation involves less memory transfer than calling the two functions separately. This method only needs to load three vectors, <code>this</code>, <code>V</code>, <code>W</code>, whereas calling separate methods means to load the calling vector <code>this</code> twice. Since most vector operations are memory transfer limited, this reduces the time by 25% (or 50% if <code>W</code> equals <code>this</code>).</p>
<p>For complex-valued vectors, the scalar product in the second step is implemented as \(\left&lt;v,w\right&gt;=\sum_i v_i \bar{w_i}\). </p>

<p>Implements <a class="el" href="group__Vectors.html#ga89ae394fb53af7daf23705d5992f9f11">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="gae5f0787421df51268c993616c2d604e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5f0787421df51268c993616c2d604e9">&#9670;&nbsp;</a></span>size() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1Vector.html">Vector</a>&lt; Number &gt;::<a class="el" href="group__Vectors.html#ga81ab101056e685ef358597528a48ccb7">size_type</a> <a class="el" href="classLinearAlgebra_1_1Vector.html">Vector</a>&lt; Number &gt;::size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the global size of the vector, equal to the sum of the number of locally owned indices among all processors. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga79b24c9cc50ac00221c89466a021c62a">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="la__vector_8h_source.html#l00453">453</a> of file <a class="el" href="la__vector_8h_source.html">la_vector.h</a>.</p>

</div>
</div>
<a id="ga6ecb7b79933b2e2e578187960bc79950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ecb7b79933b2e2e578187960bc79950">&#9670;&nbsp;</a></span>locally_owned_elements() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> <a class="el" href="classLinearAlgebra_1_1Vector.html">Vector</a>&lt; Number &gt;::locally_owned_elements</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an index set that describes which elements of this vector are owned by the current processor. As a consequence, the index sets returned on different processors if this is a distributed vector will form disjoint sets that add up to the complete index set. Obviously, if a vector is created on only one processor, then the result would satisfy </p><div class="fragment"><div class="line">vec.locally_owned_elements() == <a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(vec.size())</div>
</div><!-- fragment --> 
<p>Implements <a class="el" href="group__Vectors.html#ga47e92627a68a0a778490b5694af4212b">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="la__vector_8h_source.html#l00462">462</a> of file <a class="el" href="la__vector_8h_source.html">la_vector.h</a>.</p>

</div>
</div>
<a id="ga9d3fc386b73ef25215696c1d8beaa9d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d3fc386b73ef25215696c1d8beaa9d8">&#9670;&nbsp;</a></span>print() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1Vector.html">Vector</a>&lt; Number &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>precision</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>scientific</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>across</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Print the vector to the output stream <code>out</code>. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga1fcac5e46eb6bc858f1715e30db75031">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="la__vector_8h_source.html#l00471">471</a> of file <a class="el" href="la__vector_8h_source.html">la_vector.h</a>.</p>

</div>
</div>
<a id="ga2fadcc595d3e7e9ba44de8c85fd7595c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fadcc595d3e7e9ba44de8c85fd7595c">&#9670;&nbsp;</a></span>print_as_numpy_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1Vector.html">LinearAlgebra::Vector</a>&lt; Number &gt;::print_as_numpy_array </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>precision</em> = <code>9</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the vector to the output stream <code>out</code> in a format that can be read by numpy::readtxt(). Note that the <a class="el" href="classIndexSet.html">IndexSet</a> is not printed but only the values stored in the <a class="el" href="classLinearAlgebra_1_1Vector.html">Vector</a>. To load the vector in python just do <code> vector = numpy.loadtxt('my_vector.txt') </code> </p>

</div>
</div>
<a id="gac4d5d8410505af4a5647773a61ab70a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4d5d8410505af4a5647773a61ab70a2">&#9670;&nbsp;</a></span>block_write() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1Vector.html">LinearAlgebra::Vector</a>&lt; Number &gt;::block_write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the vector en bloc to a file. This is done in a binary mode, so the output is neither readable by humans nor (probably) by other computers using a different operating system or number format. </p>

</div>
</div>
<a id="gaa89063bf513a89e3f6e508ff39942600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa89063bf513a89e3f6e508ff39942600">&#9670;&nbsp;</a></span>block_read() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1Vector.html">LinearAlgebra::Vector</a>&lt; Number &gt;::block_read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a vector en block from a file. This is done using the inverse operations to the above function, so it is reasonably fast because the bitstream is not interpreted.</p>
<p>The vector is resized if necessary.</p>
<p>A primitive form of error checking is performed which will recognize the bluntest attempts to interpret some data as a vector stored bitwise to a file, but not more. </p>

</div>
</div>
<a id="gae3d016b943c09add2765165f4dd4aedf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3d016b943c09add2765165f4dd4aedf">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classLinearAlgebra_1_1Vector.html">Vector</a>&lt; Number &gt;::memory_consumption</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the memory consumption of this class in bytes. </p>

<p>Implements <a class="el" href="group__Vectors.html#ga4760b791f71d963298a5d49917f46555">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="la__vector_8h_source.html#l00499">499</a> of file <a class="el" href="la__vector_8h_source.html">la_vector.h</a>.</p>

</div>
</div>
<a id="ga5f95e2fb7828dfe996ab38096759bcd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f95e2fb7828dfe996ab38096759bcd6">&#9670;&nbsp;</a></span>serialize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1Vector.html">Vector</a>&lt; Number &gt;::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write and read the data of this object from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. </p>

<p class="definition">Definition at line <a class="el" href="la__vector_8h_source.html#l00484">484</a> of file <a class="el" href="la__vector_8h_source.html">la_vector.h</a>.</p>

</div>
</div>
<a id="gaa019c2aa2c09503086bcb0604679f2ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa019c2aa2c09503086bcb0604679f2ba">&#9670;&nbsp;</a></span>ReadWriteVector() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::<a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Empty constructor. </p>

</div>
</div>
<a id="ga0e113f1d04f1faebde287699f2d4585c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e113f1d04f1faebde287699f2d4585c">&#9670;&nbsp;</a></span>ReadWriteVector() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::<a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor. </p>

</div>
</div>
<a id="ga0f57e4d076b7772b7ba15928070c2315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f57e4d076b7772b7ba15928070c2315">&#9670;&nbsp;</a></span>ReadWriteVector() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::<a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#gadc1437e8371646dcca5b74c01dc064a4">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct a vector given the size, the stored elements have their index in [0,size). </p>

</div>
</div>
<a id="gad3ebd721f36c364d3207672265406469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3ebd721f36c364d3207672265406469">&#9670;&nbsp;</a></span>ReadWriteVector() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::<a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>locally_stored_indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct a vector whose stored elements indices are given by the <a class="el" href="classIndexSet.html">IndexSet</a> <code>locally_stored_indices</code>. </p>

</div>
</div>
<a id="gad19d8a267b3b5d99e324cf5b448c6cde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad19d8a267b3b5d99e324cf5b448c6cde">&#9670;&nbsp;</a></span>~ReadWriteVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::~<a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<a id="gaaee2ea7c671f9ece558b081b0d104295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaee2ea7c671f9ece558b081b0d104295">&#9670;&nbsp;</a></span>reinit() <span class="overload">[20/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#gadc1437e8371646dcca5b74c01dc064a4">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the global size of the vector to <code>size</code>. The stored elements have their index in [0,size).</p>
<p>If the flag <code>omit_zeroing_entries</code> is set to false, the memory will be initialized with zero, otherwise the memory will be untouched (and the user must make sure to fill it with reasonable data before using it). </p>

<p>Reimplemented in <a class="el" href="group__Vectors.html#ga5ace9efb83033bbf80d60e49d6da337d">LinearAlgebra::Vector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga0aa62727797cde32d9dafb4dbcdd107f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0aa62727797cde32d9dafb4dbcdd107f">&#9670;&nbsp;</a></span>reinit() <span class="overload">[21/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Uses the same <a class="el" href="classIndexSet.html">IndexSet</a> as the one of the input vector <code>in_vector</code> and allocates memory for this vector.</p>
<p>If the flag <code>omit_zeroing_entries</code> is set to false, the memory will be initialized with zero, otherwise the memory will be untouched (and the user must make sure to fill it with reasonable data before using it). </p>

</div>
</div>
<a id="gaaa5d0c1a26755df4f451091e051a5277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa5d0c1a26755df4f451091e051a5277">&#9670;&nbsp;</a></span>reinit() <span class="overload">[22/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>locally_stored_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes the vector. The indices are specified by <code>locally_stored_indices</code>.</p>
<p>If the flag <code>omit_zeroing_entries</code> is set to false, the memory will be initialized with zero, otherwise the memory will be untouched (and the user must make sure to fill it with reasonable data before using it). locally_stored_indices. </p>

<p>Reimplemented in <a class="el" href="group__Vectors.html#ga43835ffaaf2af03d72164910c82f7ce7">LinearAlgebra::Vector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="gaa96d95c60ec7a4ba186c7aa4e762d05c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa96d95c60ec7a4ba186c7aa4e762d05c">&#9670;&nbsp;</a></span>reinit() <span class="overload">[23/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>trilinos_vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize this <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a> by supplying access to all locally available entries in the given ghosted or non-ghosted vector.</p>
<dl class="section note"><dt>Note</dt><dd>This function currently copies the values from the argument into the <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>, so modifications here will not modify <code>trilinos_vec</code>.</dd></dl>
<p>This function is mainly written for backwards-compatibility to get element access to a ghosted <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> inside the library. </p>

</div>
</div>
<a id="ga245371b4cfb447d8f39fcfd4646c5435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga245371b4cfb447d8f39fcfd4646c5435">&#9670;&nbsp;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const Functor &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply the functor <code>func</code> to each element of the vector. The functor should look like </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Functor</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="group__Vectors.html#ga233998157aa2acdbde9717aec827ccbf">operator() </a>(Number &amp;value);</div>
<div class="line">};</div>
<div class="ttc" id="agroup__Vectors_html_ga233998157aa2acdbde9717aec827ccbf"><div class="ttname"><a href="group__Vectors.html#ga233998157aa2acdbde9717aec827ccbf">LinearAlgebra::ReadWriteVector::operator()</a></div><div class="ttdeci">Number operator()(const size_type global_index) const</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This function requires that the header read_write_vector.templates.h be included. </dd></dl>

</div>
</div>
<a id="gaed3562c39eaa838680a68cd85ffd81fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed3562c39eaa838680a68cd85ffd81fa">&#9670;&nbsp;</a></span>swap() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swap the contents of this vector and the other vector <code>v</code>. One could do this operation with a temporary variable and copying over the data elements, but this function is significantly more efficient since it only swaps the pointers to the data of the two vectors and therefore does not need to allocate temporary storage and move data around.</p>
<p>This function is analogous to the <code>swap</code> function of all C++ standard containers. Also, there is a global function <code>swap(u,v)</code> that simply calls <code>u.swap(v)</code>, again in analogy to standard functions. </p>

</div>
</div>
<a id="ga62ce4785132ec1e65de894c7e6198bc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62ce4785132ec1e65de894c7e6198bc3">&#9670;&nbsp;</a></span>operator=() <span class="overload">[20/30]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt;Number&gt;&amp; <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the data and the <a class="el" href="classIndexSet.html">IndexSet</a> of the input vector <code>in_vector</code>. </p>

</div>
</div>
<a id="ga0a983cd43825afc39d1466a6d468d18c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a983cd43825afc39d1466a6d468d18c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[21/30]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt;Number&gt;&amp; <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the data and the <a class="el" href="classIndexSet.html">IndexSet</a> of the input vector <code>in_vector</code>. </p>

</div>
</div>
<a id="ga699aa5c6cb9dad6bd0b93f0e744f74c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga699aa5c6cb9dad6bd0b93f0e744f74c4">&#9670;&nbsp;</a></span>operator=() <span class="overload">[22/30]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt;Number&gt;&amp; <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets all elements of the vector to the scalar <code>s</code>. This operation is only allowed if <code>s</code> is equal to zero. </p>

</div>
</div>
<a id="ga01a417b8d7b2c5858f49cdc4c663779f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01a417b8d7b2c5858f49cdc4c663779f">&#9670;&nbsp;</a></span>import() <span class="overload">[5/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::import </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classLinearAlgebra_1_1Vector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1CommunicationPatternBase.html">Utilities::MPI::CommunicationPatternBase</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>communication_pattern</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Imports all the elements present in the vector's <a class="el" href="classIndexSet.html">IndexSet</a> from the input vector <code>vec</code>. <a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> <code>operation</code> is used to decide if the elements in <code>V</code> should be added to the current vector or replace the current elements.</p>
<dl class="section note"><dt>Note</dt><dd>The parameter <code>communication_pattern</code> is ignored since we are dealing with a serial vector here. </dd></dl>

</div>
</div>
<a id="gabcfcb11452e35b004342be5e52353566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcfcb11452e35b004342be5e52353566">&#9670;&nbsp;</a></span>import() <span class="overload">[6/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::import </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1Vector.html">LinearAlgebra::Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1CommunicationPatternBase.html">Utilities::MPI::CommunicationPatternBase</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>communication_pattern</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Imports all the elements present in the vector's <a class="el" href="classIndexSet.html">IndexSet</a> from the input vector <code>vec</code>. <a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> <code>operation</code> is used to decide if the elements in <code>V</code> should be added to the current vector or replace the current elements.</p>
<dl class="section note"><dt>Note</dt><dd>The parameter <code>communication_pattern</code> is ignored since we are dealing with a serial vector here. </dd></dl>

</div>
</div>
<a id="ga47547164f123faf9f035ba7dbca7c656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47547164f123faf9f035ba7dbca7c656">&#9670;&nbsp;</a></span>import() <span class="overload">[7/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename MemorySpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::import </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">distributed::Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1CommunicationPatternBase.html">Utilities::MPI::CommunicationPatternBase</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>communication_pattern</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Imports all the elements present in the vector's <a class="el" href="classIndexSet.html">IndexSet</a> from the input vector <code>vec</code>. <a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> <code>operation</code> is used to decide if the elements in <code>V</code> should be added to the current vector or replace the current elements. The last parameter can be used if the same communication pattern is used multiple times. This can be used to improve performance. </p>

</div>
</div>
<a id="ga9df1826dfefe6f66fe9cdfce6798e1f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9df1826dfefe6f66fe9cdfce6798e1f2">&#9670;&nbsp;</a></span>import() <span class="overload">[8/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::import </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>petsc_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1CommunicationPatternBase.html">Utilities::MPI::CommunicationPatternBase</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>communication_pattern</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Imports all the elements present in the vector's <a class="el" href="classIndexSet.html">IndexSet</a> from the input vector <code>petsc_vec</code>. <a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> <code>operation</code> is used to decide if the elements in <code>V</code> should be added to the current vector or replace the current elements. The last parameter can be used if the same communication pattern is used multiple times. This can be used to improve performance. </p>

</div>
</div>
<a id="gacf957a87754a8daf166f1092a6df45cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf957a87754a8daf166f1092a6df45cb">&#9670;&nbsp;</a></span>import() <span class="overload">[9/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::import </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>trilinos_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1CommunicationPatternBase.html">Utilities::MPI::CommunicationPatternBase</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>communication_pattern</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Imports all the elements present in the vector's <a class="el" href="classIndexSet.html">IndexSet</a> from the input vector <code>trilinos_vec</code>. <a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> <code>operation</code> is used to decide if the elements in <code>V</code> should be added to the current vector or replace the current elements. The last parameter can be used if the same communication pattern is used multiple times. This can be used to improve performance.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>trilinos_vec</code> is not allowed to have ghost entries. </dd></dl>

</div>
</div>
<a id="ga4ae6b0675de89b62f36bd72a55183eec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ae6b0675de89b62f36bd72a55183eec">&#9670;&nbsp;</a></span>import() <span class="overload">[10/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::import </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1TpetraWrappers_1_1Vector.html">TpetraWrappers::Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>tpetra_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1CommunicationPatternBase.html">Utilities::MPI::CommunicationPatternBase</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>communication_pattern</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Imports all the elements present in the vector's <a class="el" href="classIndexSet.html">IndexSet</a> from the input vector <code>tpetra_vec</code>. <a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> <code>operation</code> is used to decide if the elements in <code>V</code> should be added to the current vector or replace the current elements. The last parameter can be used if the same communication pattern is used multiple times. This can be used to improve performance. </p>

</div>
</div>
<a id="ga4ec5fe3bd8abc4eb3da40c1bb3918d2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ec5fe3bd8abc4eb3da40c1bb3918d2c">&#9670;&nbsp;</a></span>import() <span class="overload">[11/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::import </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1EpetraWrappers_1_1Vector.html">EpetraWrappers::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>epetra_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1CommunicationPatternBase.html">Utilities::MPI::CommunicationPatternBase</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>communication_pattern</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Imports all the elements present in the vector's <a class="el" href="classIndexSet.html">IndexSet</a> from the input vector <code>epetra_vec</code>. <a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> <code>operation</code> is used to decide if the elements in <code>V</code> should be added to the current vector or replace the current elements. The last parameter can be used if the same communication pattern is used multiple times. This can be used to improve performance. </p>

</div>
</div>
<a id="gaae7b535ae7de6290b381a421aed5e0ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae7b535ae7de6290b381a421aed5e0ad">&#9670;&nbsp;</a></span>import() <span class="overload">[12/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::import </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html">CUDAWrappers::Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>cuda_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1CommunicationPatternBase.html">Utilities::MPI::CommunicationPatternBase</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>communication_pattern</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Import all the elements present in the vector's <a class="el" href="classIndexSet.html">IndexSet</a> from the input vector <code>cuda_vec</code>. <a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> <code>operation</code> is used to decide if the elements in <code>V</code> should be added to the current vector or replace the current elements. The last parameter is not used. </p>

</div>
</div>
<a id="ga0e20857fed96063ebd2d3edaea1082bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e20857fed96063ebd2d3edaea1082bf">&#9670;&nbsp;</a></span>size() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Vectors.html#gadc1437e8371646dcca5b74c01dc064a4">size_type</a> <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The value returned by this function denotes the dimension of the vector spaces that are modeled by objects of this kind. However, objects of the current class do not actually stores all elements of vectors of this space but may, in fact store only a subset. The number of elements stored is returned by <a class="el" href="group__Vectors.html#gaedac815f15ee3c78363e02baa97457e0">n_elements()</a> and is smaller or equal to the number returned by the current function. </p>

</div>
</div>
<a id="gaedac815f15ee3c78363e02baa97457e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedac815f15ee3c78363e02baa97457e0">&#9670;&nbsp;</a></span>n_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Vectors.html#gadc1437e8371646dcca5b74c01dc064a4">size_type</a> <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::n_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the number of elements stored. It is smaller or equal to the dimension of the vector space that is modeled by an object of this kind. This dimension is return by <a class="el" href="group__Vectors.html#ga0e20857fed96063ebd2d3edaea1082bf">size()</a>.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000085">Deprecated:</a></b></dt><dd>use <a class="el" href="group__Vectors.html#gab0d3b0776e02bb473ecc785b3c4f89cf">locally_owned_size()</a> instead. </dd></dl>

</div>
</div>
<a id="gab0d3b0776e02bb473ecc785b3c4f89cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0d3b0776e02bb473ecc785b3c4f89cf">&#9670;&nbsp;</a></span>locally_owned_size() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Vectors.html#gadc1437e8371646dcca5b74c01dc064a4">size_type</a> <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::locally_owned_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the local size of the vector, i.e., the number of indices owned locally. </p>

</div>
</div>
<a id="gaaee475607463efff722ce083b6cd4f7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaee475607463efff722ce083b6cd4f7d">&#9670;&nbsp;</a></span>get_stored_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classIndexSet.html">IndexSet</a>&amp; <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::get_stored_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the <a class="el" href="classIndexSet.html">IndexSet</a> that represents the indices of the elements stored. </p>

</div>
</div>
<a id="ga1c0f991527a8dd09601b764e59d097fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c0f991527a8dd09601b764e59d097fc">&#9670;&nbsp;</a></span>begin() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Vectors.html#ga5e28f8f12865657afed81936ca9308ac">iterator</a> <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make the <code><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a></code> class a bit like the <code>vector&lt;&gt;</code> class of the C++ standard library by returning iterators to the start and end of the <em>locally stored</em> elements of this vector. </p>

</div>
</div>
<a id="gac4138913e659866ebba5801a88167270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4138913e659866ebba5801a88167270">&#9670;&nbsp;</a></span>begin() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Vectors.html#gac39936b0017c60e97d2c6643b612d970">const_iterator</a> <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return constant iterator to the start of the locally stored elements of the vector. </p>

</div>
</div>
<a id="ga4dbfbf3b3c7dcb1e96174eba41f3734c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4dbfbf3b3c7dcb1e96174eba41f3734c">&#9670;&nbsp;</a></span>end() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Vectors.html#ga5e28f8f12865657afed81936ca9308ac">iterator</a> <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator pointing to the element past the end of the array of locally stored entries. </p>

</div>
</div>
<a id="gab61f02fa9f52e7aa88d56310c6c0176a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab61f02fa9f52e7aa88d56310c6c0176a">&#9670;&nbsp;</a></span>end() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Vectors.html#gac39936b0017c60e97d2c6643b612d970">const_iterator</a> <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a constant iterator pointing to the element past the end of the array of the locally stored entries. </p>

</div>
</div>
<a id="ga233998157aa2acdbde9717aec827ccbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga233998157aa2acdbde9717aec827ccbf">&#9670;&nbsp;</a></span>operator()() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#gadc1437e8371646dcca5b74c01dc064a4">size_type</a>&#160;</td>
          <td class="paramname"><em>global_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read access to the data in the position corresponding to <code>global_index</code>. An exception is thrown if <code>global_index</code> is not stored by the current object. </p>

</div>
</div>
<a id="ga4a325d56a1d1c7f8db022eb442867d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a325d56a1d1c7f8db022eb442867d34">&#9670;&nbsp;</a></span>operator()() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number&amp; <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#gadc1437e8371646dcca5b74c01dc064a4">size_type</a>&#160;</td>
          <td class="paramname"><em>global_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read and write access to the data in the position corresponding to <code>global_index</code>. An exception is thrown if <code>global_index</code> is not stored by the current object. </p>

</div>
</div>
<a id="ga71445351bd4b9dfb4ff0c1c516658fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71445351bd4b9dfb4ff0c1c516658fe6">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#gadc1437e8371646dcca5b74c01dc064a4">size_type</a>&#160;</td>
          <td class="paramname"><em>global_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read access to the data in the position corresponding to <code>global_index</code>. An exception is thrown if <code>global_index</code> is not stored by the current object.</p>
<p>This function does the same thing as operator(). </p>

</div>
</div>
<a id="gaf9cf2035df2a9ba8777c80ffe4c1a914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9cf2035df2a9ba8777c80ffe4c1a914">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number&amp; <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#gadc1437e8371646dcca5b74c01dc064a4">size_type</a>&#160;</td>
          <td class="paramname"><em>global_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read and write access to the data in the position corresponding to <code>global_index</code>. An exception is thrown if <code>global_index</code> is not stored by the current object.</p>
<p>This function does the same thing as operator(). </p>

</div>
</div>
<a id="gabe49ac3785c3ed8cdf2c2200c9dd3b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe49ac3785c3ed8cdf2c2200c9dd3b94">&#9670;&nbsp;</a></span>extract_subvector_to() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::extract_subvector_to </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__Vectors.html#gadc1437e8371646dcca5b74c01dc064a4">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instead of getting individual elements of a vector via operator(), this function allows getting a whole set of elements at once. The indices of the elements to be read are stated in the first argument, the corresponding values are returned in the second.</p>
<p>If the current vector is called <code>v</code>, then this function is the equivalent to the code </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;indices.size(); ++i)</div>
<div class="line">  <a class="code" href="group__Vectors.html#ga18f97cb8e503f790483ddaddfa768a25">values</a>[i] = v[indices[i]];</div>
<div class="ttc" id="agroup__Vectors_html_ga18f97cb8e503f790483ddaddfa768a25"><div class="ttname"><a href="group__Vectors.html#ga18f97cb8e503f790483ddaddfa768a25">LinearAlgebra::ReadWriteVector::values</a></div><div class="ttdeci">std::unique_ptr&lt; Number[], decltype(std::free) * &gt; values</div><div class="ttdef"><b>Definition:</b> <a href="read__write__vector_8h_source.html#l00739">read_write_vector.h:739</a></div></div>
</div><!-- fragment --><dl class="section pre"><dt>Precondition</dt><dd>The sizes of the <code>indices</code> and <code>values</code> arrays must be identical. </dd></dl>

</div>
</div>
<a id="gaae3387187c82a78eabb153f0d7bf1af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae3387187c82a78eabb153f0d7bf1af4">&#9670;&nbsp;</a></span>extract_subvector_to() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename ForwardIterator , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::extract_subvector_to </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>indices_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator&#160;</td>
          <td class="paramname"><em>indices_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>values_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instead of getting individual elements of a vector via operator(), this function allows getting a whole set of elements at once. In contrast to the previous function, this function obtains the indices of the elements by dereferencing all elements of the iterator range provided by the first two arguments, and puts the vector values into memory locations obtained by dereferencing a range of iterators starting at the location pointed to by the third argument.</p>
<p>If the current vector is called <code>v</code>, then this function is the equivalent to the code </p><div class="fragment"><div class="line">ForwardIterator indices_p = indices_begin;</div>
<div class="line">OutputIterator  values_p  = values_begin;</div>
<div class="line"><span class="keywordflow">while</span> (indices_p != indices_end)</div>
<div class="line">{</div>
<div class="line">  *values_p = v[*indices_p];</div>
<div class="line">  ++indices_p;</div>
<div class="line">  ++values_p;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section pre"><dt>Precondition</dt><dd>It must be possible to write into as many memory locations starting at <code>values_begin</code> as there are iterators between <code>indices_begin</code> and <code>indices_end</code>. </dd></dl>

</div>
</div>
<a id="ga722901ebee9fe3e68a29549ca30259a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga722901ebee9fe3e68a29549ca30259a8">&#9670;&nbsp;</a></span>local_element() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::local_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#gadc1437e8371646dcca5b74c01dc064a4">size_type</a>&#160;</td>
          <td class="paramname"><em>local_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read access to the data field specified by <code>local_index</code>. When you access elements in the order in which they are stored, it is necessary that you know in which they are stored. In other words, you need to know the map between the global indices of the elements this class stores, and the local indices into the contiguous array of these global elements. For this, see the general documentation of this class.</p>
<p>Performance: Direct array access (fast). </p>

</div>
</div>
<a id="gaa7a1d6b3129693772cc2ae757d1f3c36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7a1d6b3129693772cc2ae757d1f3c36">&#9670;&nbsp;</a></span>local_element() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number&amp; <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::local_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#gadc1437e8371646dcca5b74c01dc064a4">size_type</a>&#160;</td>
          <td class="paramname"><em>local_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read and write access to the data field specified by <code>local_index</code>. When you access elements in the order in which they are stored, it is necessary that you know in which they are stored. In other words, you need to know the map between the global indices of the elements this class stores, and the local indices into the contiguous array of these global elements. For this, see the general documentation of this class.</p>
<p>Performance: Direct array access (fast). </p>

</div>
</div>
<a id="ga20d03806be45070a19e1c809819b4b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20d03806be45070a19e1c809819b4b74">&#9670;&nbsp;</a></span>add() <span class="overload">[15/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__Vectors.html#gadc1437e8371646dcca5b74c01dc064a4">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function adds a whole set of values stored in <code>values</code> to the vector components specified by <code>indices</code>. </p>

</div>
</div>
<a id="ga557e8adec1fd28216d0ebb7ca4a9b213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga557e8adec1fd28216d0ebb7ca4a9b213">&#9670;&nbsp;</a></span>add() <span class="overload">[16/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__Vectors.html#gadc1437e8371646dcca5b74c01dc064a4">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is similar to the previous one but takes a <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a> of values. </p>

</div>
</div>
<a id="ga77cc92419018a05c262f946cef212f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77cc92419018a05c262f946cef212f63">&#9670;&nbsp;</a></span>add() <span class="overload">[17/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#gadc1437e8371646dcca5b74c01dc064a4">size_type</a>&#160;</td>
          <td class="paramname"><em>n_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#gadc1437e8371646dcca5b74c01dc064a4">size_type</a> *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number2 *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take an address where <code>n_elements</code> are stored contiguously and add them into the vector. Handles all cases which are not covered by the other two <code><a class="el" href="group__Vectors.html#ga20d03806be45070a19e1c809819b4b74">add()</a></code> functions above. </p>

</div>
</div>
<a id="ga30e936065ac760ac8ce71741374a2576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30e936065ac760ac8ce71741374a2576">&#9670;&nbsp;</a></span>print() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>precision</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>scientific</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints the vector to the output stream <code>out</code>. </p>

</div>
</div>
<a id="ga2457ff17e4f00e2a964769dfcefebdb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2457ff17e4f00e2a964769dfcefebdb3">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the memory consumption of this class in bytes. </p>

</div>
</div>
<a id="gaf005c963a8c3eacb0dbcc57af085239e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf005c963a8c3eacb0dbcc57af085239e">&#9670;&nbsp;</a></span>import() <span class="overload">[13/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::import </td>
          <td>(</td>
          <td class="paramtype">const Tpetra::Vector&lt; Number, int, <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tpetra_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>locally_owned_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>mpi_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1CommunicationPatternBase.html">Utilities::MPI::CommunicationPatternBase</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>communication_pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Import all the elements present in the vector's <a class="el" href="classIndexSet.html">IndexSet</a> from the input vector <code>tpetra_vector</code>. This is an helper function and it should not be used directly. </p>

</div>
</div>
<a id="gada3a3abdf4f08d06bb4fe99551ef188f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada3a3abdf4f08d06bb4fe99551ef188f">&#9670;&nbsp;</a></span>import() <span class="overload">[14/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::import </td>
          <td>(</td>
          <td class="paramtype">const Epetra_MultiVector &amp;&#160;</td>
          <td class="paramname"><em>multivector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>locally_owned_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>mpi_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1CommunicationPatternBase.html">Utilities::MPI::CommunicationPatternBase</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>communication_pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Import all the elements present in the vector's <a class="el" href="classIndexSet.html">IndexSet</a> from the input vector <code>multivector</code>. This is an helper function and it should not be used directly. </p>

</div>
</div>
<a id="ga6f246ddfbf22f0f8a54274a6540228d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f246ddfbf22f0f8a54274a6540228d7">&#9670;&nbsp;</a></span>global_to_local()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::global_to_local </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&#160;</td>
          <td class="paramname"><em>global_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the local position of <code>global_index</code>. </p>

<p class="definition">Definition at line <a class="el" href="read__write__vector_8h_source.html#l00686">686</a> of file <a class="el" href="read__write__vector_8h_source.html">read_write_vector.h</a>.</p>

</div>
</div>
<a id="ga714412eda5ff0683842db5a92947db2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga714412eda5ff0683842db5a92947db2f">&#9670;&nbsp;</a></span>resize_val() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::resize_val </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#gadc1437e8371646dcca5b74c01dc064a4">size_type</a>&#160;</td>
          <td class="paramname"><em>new_allocated_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A helper function that is used to resize the val array. </p>

</div>
</div>
<a id="ga264014f023c96eb2bffd450ee31a8c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga264014f023c96eb2bffd450ee31a8c19">&#9670;&nbsp;</a></span>create_tpetra_comm_pattern()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1TpetraWrappers_1_1CommunicationPattern.html">TpetraWrappers::CommunicationPattern</a> <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::create_tpetra_comm_pattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>source_index_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>mpi_comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a <a class="el" href="classLinearAlgebra_1_1TpetraWrappers_1_1CommunicationPattern.html">TpetraWrappers::CommunicationPattern</a> and store it for future use. </p>

</div>
</div>
<a id="ga79499404d7d07670c72c36e065e5e060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79499404d7d07670c72c36e065e5e060">&#9670;&nbsp;</a></span>create_epetra_comm_pattern()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1EpetraWrappers_1_1CommunicationPattern.html">EpetraWrappers::CommunicationPattern</a> <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::create_epetra_comm_pattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>source_index_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>mpi_comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a <a class="el" href="classLinearAlgebra_1_1EpetraWrappers_1_1CommunicationPattern.html">EpetraWrappers::CommunicationPattern</a> and store it for future use. </p>

</div>
</div>
<a id="ga3c695d004ca539667dca8f1f220c67da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c695d004ca539667dca8f1f220c67da">&#9670;&nbsp;</a></span>FunctorTemplate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::<a class="el" href="classLinearAlgebra_1_1ReadWriteVector_1_1FunctorTemplate.html">FunctorTemplate</a>&lt; Functor &gt;::<a class="el" href="classLinearAlgebra_1_1ReadWriteVector_1_1FunctorTemplate.html">FunctorTemplate</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Functor &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Take a functor and store a copy of it. </p>

</div>
</div>
<a id="ga626b8a89b685a551394246345ef3e0e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga626b8a89b685a551394246345ef3e0e1">&#9670;&nbsp;</a></span>operator()() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::<a class="el" href="classLinearAlgebra_1_1ReadWriteVector_1_1FunctorTemplate.html">FunctorTemplate</a>&lt; Functor &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#gadc1437e8371646dcca5b74c01dc064a4">size_type</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#gadc1437e8371646dcca5b74c01dc064a4">size_type</a>&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Evaluate the element with the stored copy of the functor. </p>

</div>
</div>
<a id="ga5424155269bd22011e9ff796e0c77e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5424155269bd22011e9ff796e0c77e69">&#9670;&nbsp;</a></span>Vector() <span class="overload">[11/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Create a vector of dimension zero. </p>

</div>
</div>
<a id="ga55f3a1869eafb7680e44c3fe5c0f6d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55f3a1869eafb7680e44c3fe5c0f6d39">&#9670;&nbsp;</a></span>Vector() <span class="overload">[12/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor. Sets the dimension to that of the given vector, and copies all elements.</p>
<p>We would like to make this constructor explicit, but standard containers insist on using it implicitly.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="gac466762a351e7d9c48c05705730070e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac466762a351e7d9c48c05705730070e3">&#9670;&nbsp;</a></span>Vector() <span class="overload">[13/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor. Creates a new vector by stealing the internal data of the vector <code>v</code>. </p>

</div>
</div>
<a id="ga9b9f407c4064e4d83796c5f5149aa1c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b9f407c4064e4d83796c5f5149aa1c0">&#9670;&nbsp;</a></span>Vector() <span class="overload">[14/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor taking a vector of another data type.</p>
<p>This constructor will fail to compile if there is no conversion path from <code>OtherNumber</code> to <code>Number</code>. You may lose accuracy when copying to a vector with data elements with less accuracy. </p>

</div>
</div>
<a id="gafb43a268341d826272c4255b46b4b14b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb43a268341d826272c4255b46b4b14b">&#9670;&nbsp;</a></span>Vector() <span class="overload">[15/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor taking an object of type <code>std::initializer_list</code>. This constructor can be used to initialize a vector using a brace-enclosed list of numbers, such as in the following example: </p><div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> v({1,2,3});</div>
<div class="ttc" id="aclassVector_html"><div class="ttname"><a href="classVector.html">Vector&lt; double &gt;</a></div></div>
</div><!-- fragment --><p> This creates a vector of size 3, whose (double precision) elements have values 1.0, 2.0, and 3.0.</p>
<p>This constructor will fail to compile if there is no conversion path from <code>OtherNumber</code> to <code>Number</code>. You may lose accuracy when copying to a vector with data elements with less accuracy. </p>

</div>
</div>
<a id="ga6478b634eb646ffaa11f6f82b91d92a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6478b634eb646ffaa11f6f82b91d92a9">&#9670;&nbsp;</a></span>Vector() <span class="overload">[16/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">PETScWrappers::VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Another copy constructor: copy the values from a PETSc vector class. This copy constructor is only available if PETSc was detected during configuration time.</p>
<p>Note that due to the communication model used in MPI, this operation can only succeed if all processes do it at the same time when <code>v</code> is a distributed vector: It is not possible for only one process to obtain a copy of a parallel vector while the other jobs do something else. </p>

</div>
</div>
<a id="ga1bb6efe58ff7587ec88b542fe705bba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bb6efe58ff7587ec88b542fe705bba6">&#9670;&nbsp;</a></span>Vector() <span class="overload">[17/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Another copy constructor: copy the values from a Trilinos wrapper vector. This copy constructor is only available if Trilinos was detected during configuration time.</p>
<dl class="section note"><dt>Note</dt><dd>Due to the communication model used in MPI, this operation can only succeed if all processes that have knowledge of <code>v</code> (i.e. those given by <code>v.get_mpi_communicator()</code>) do it at the same time. This means that unless you use a split MPI communicator then it is not normally possible for only one or a subset of processes to obtain a copy of a parallel vector while the other jobs do something else. In other words, calling this function is a 'collective operation' that needs to be executed by all MPI processes that jointly share <code>v</code>. </dd></dl>

</div>
</div>
<a id="ga2de475367d8e8440fc32564a9178216f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2de475367d8e8440fc32564a9178216f">&#9670;&nbsp;</a></span>Vector() <span class="overload">[18/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#ga5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor. Set dimension to <code>n</code> and initialize all elements with zero.</p>
<p>The constructor is made explicit to avoid accidents like this: <code>v=0;</code>. Presumably, the user wants to set every element of the vector to zero, but instead, what happens is this call: <code>v=<a class="el" href="classVector.html">Vector</a>&lt;number&gt;(0);</code>, i.e. the vector is replaced by one of length zero. </p>

</div>
</div>
<a id="gaf441b2c23134f8e6e08c833f918888a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf441b2c23134f8e6e08c833f918888a2">&#9670;&nbsp;</a></span>Vector() <span class="overload">[19/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the vector with a given range of values pointed to by the iterators. This function is there in analogy to the <code>std::vector</code> class. </p>

</div>
</div>
<a id="ga9a2ad8f9f15b0fa4b207fe053c81c050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a2ad8f9f15b0fa4b207fe053c81c050">&#9670;&nbsp;</a></span>~Vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::~<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor, deallocates memory. Made virtual to allow for derived classes to behave properly. </p>

</div>
</div>
<a id="ga8740c5534b6dbc31f4f1503a5e2a10a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8740c5534b6dbc31f4f1503a5e2a10a3">&#9670;&nbsp;</a></span>compress() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::compress </td>
          <td>(</td>
          <td class="paramtype">::<a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em> = <code>::<a class="el" href="group__Vectors.html#gga40c50779cd14ba89bbf0bd9b4561964ca9c7dc8036a5632e9ed2a183c3c2812e6">VectorOperation::unknown</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does nothing but exists for compatibility with the parallel vector classes.</p>
<p>For the parallel vector wrapper class, this function compresses the underlying representation of the vector, i.e. flushes the buffers of the vector object if it has any. This function is necessary after writing into a vector element-by-element and before anything else can be done on it.</p>
<p>However, for the implementation of this class, it is immaterial and thus an empty function. </p>

</div>
</div>
<a id="gac4a4dbef7dd65ef8ad35ae56b57d7c05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4a4dbef7dd65ef8ad35ae56b57d7c05">&#9670;&nbsp;</a></span>reinit() <span class="overload">[24/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#ga5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Change the dimension of the vector to <code>N</code>. The reserved memory for this vector remains unchanged if possible, to make things faster; this may waste some memory, so keep this in mind. However, if <code>N==0</code> all memory is freed, i.e. if you want to resize the vector and release the memory not needed, you have to first call <code>reinit(0)</code> and then <code>reinit(N)</code>. This cited behavior is analogous to that of the standard library containers.</p>
<p>If <code>omit_zeroing_entries</code> is false, the vector is filled by zeros. Otherwise, the elements are left an unspecified state.</p>
<p>This function is virtual in order to allow for derived classes to handle memory separately. </p>

</div>
</div>
<a id="ga99737189c3f716cf97cb1aba667ff7b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99737189c3f716cf97cb1aba667ff7b2">&#9670;&nbsp;</a></span>grow_or_shrink()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::grow_or_shrink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#ga5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but will preserve the values of vector upon resizing. If we new size is bigger, we will have </p><p class="formulaDsp">
\[ \mathbf V \rightarrow \left( \begin{array}{c} \mathbf V \\ \mathbf 0 \end{array} \right) \]
</p>
<p> whereas if the desired size is smaller, then </p><p class="formulaDsp">
\[ \left( \begin{array}{c} \mathbf V_1 \\ \mathbf V_2 \end{array} \right) \rightarrow \mathbf V_1 \]
</p>
 
</div>
</div>
<a id="gabae296943fe1f9cc5ada1d98761d0a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabae296943fe1f9cc5ada1d98761d0a19">&#9670;&nbsp;</a></span>apply_givens_rotation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::apply_givens_rotation </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; Number, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>csr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#ga5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#ga5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply <a href="https://en.wikipedia.org/wiki/Givens_rotation">Givens rotation</a> <code>csr</code> (a triplet of cosine, sine and radius, see <a class="el" href="namespaceUtilities_1_1LinearAlgebra.html#a22a928b284f7a00ad77fc52bca120835">Utilities::LinearAlgebra::givens_rotation()</a>) to the vector in the plane spanned by the <code>i'th</code> and <code>k'th</code> unit vectors. </p>

</div>
</div>
<a id="ga4724e0d85120bda42159be96c493a702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4724e0d85120bda42159be96c493a702">&#9670;&nbsp;</a></span>reinit() <span class="overload">[25/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the dimension to that of the vector <code>V</code>. The same applies as for the other <code>reinit</code> function.</p>
<p>The elements of <code>V</code> are not copied, i.e. this function is the same as calling <code>reinit (V.size(), omit_zeroing_entries)</code>. </p>

</div>
</div>
<a id="ga9818314bd7dc4e66849559f429e06151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9818314bd7dc4e66849559f429e06151">&#9670;&nbsp;</a></span>swap() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swap the contents of this vector and the other vector <code>v</code>. One could do this operation with a temporary variable and copying over the data elements, but this function is significantly more efficient since it only swaps the pointers to the data of the two vectors and therefore does not need to allocate temporary storage and move data around.</p>
<p>This function is analogous to the <code>swap</code> function of all C++ standard containers. Also, there is a global function <code>swap(u,v)</code> that simply calls <code>u.swap(v)</code>, again in analogy to standard functions.</p>
<p>This function is virtual in order to allow for derived classes to handle memory separately. </p>

</div>
</div>
<a id="ga9e835da7c35928e87f425f41ba30c2f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e835da7c35928e87f425f41ba30c2f1">&#9670;&nbsp;</a></span>operator=() <span class="overload">[23/30]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set all components of the vector to the given number <code>s</code>.</p>
<p>Since the semantics of assigning a scalar to a vector are not immediately clear, this operator should really only be used if you want to set the entire vector to zero. This allows the intuitive notation <code>v=0</code>. Assigning other values is deprecated and may be disallowed in the future.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="ga5cd12a193b97aa945190a9ce19a81e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cd12a193b97aa945190a9ce19a81e18">&#9670;&nbsp;</a></span>operator=() <span class="overload">[24/30]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the given vector. Resize the present vector if necessary.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="gae5aba516443a99330968b4dbda6d12ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5aba516443a99330968b4dbda6d12ac">&#9670;&nbsp;</a></span>operator=() <span class="overload">[25/30]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move the given vector. This operator replaces the present vector with the internal data of the vector <code>v</code> and resets <code>v</code> to the state it would have after being newly default-constructed. </p>

</div>
</div>
<a id="gaa40c43480e8d2c50d0bb0a13421b7264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa40c43480e8d2c50d0bb0a13421b7264">&#9670;&nbsp;</a></span>operator=() <span class="overload">[26/30]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the given vector. Resize the present vector if necessary.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="ga5b25ae266b150f897762592e56e5e649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b25ae266b150f897762592e56e5e649">&#9670;&nbsp;</a></span>operator=() <span class="overload">[27/30]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy operator for assigning a block vector to a regular vector. </p>

</div>
</div>
<a id="ga75e25dfec5386326daa1e3a7eea06c6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75e25dfec5386326daa1e3a7eea06c6c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[28/30]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">PETScWrappers::VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Another copy operator: copy the values from a PETSc wrapper vector class. This operator is only available if PETSc was detected during configuration time.</p>
<p>Note that due to the communication model used in MPI, this operation can only succeed if all processes do it at the same time when <code>v</code> is a distributed vector: It is not possible for only one process to obtain a copy of a parallel vector while the other jobs do something else. </p>

</div>
</div>
<a id="ga4d21d0e4ddcd2e645180487745e56692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d21d0e4ddcd2e645180487745e56692">&#9670;&nbsp;</a></span>operator=() <span class="overload">[29/30]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Another copy operator: copy the values from a (sequential or parallel, depending on the underlying compiler) Trilinos wrapper vector class. This operator is only available if Trilinos was detected during configuration time.</p>
<dl class="section note"><dt>Note</dt><dd>Due to the communication model used in MPI, this operation can only succeed if all processes that have knowledge of <code>v</code> (i.e. those given by <code>v.get_mpi_communicator()</code>) do it at the same time. This means that unless you use a split MPI communicator then it is not normally possible for only one or a subset of processes to obtain a copy of a parallel vector while the other jobs do something else. In other words, calling this function is a 'collective operation' that needs to be executed by all MPI processes that jointly share <code>v</code>. </dd></dl>

</div>
</div>
<a id="ga7a226204eb09ef133f124ad2137c17f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a226204eb09ef133f124ad2137c17f4">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test for equality. This function assumes that the present vector and the one to compare with have the same size already, since comparing vectors of different sizes makes not much sense anyway. </p>

</div>
</div>
<a id="ga082ee1076dfadf9933073247e56e80c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga082ee1076dfadf9933073247e56e80c7">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test for inequality. This function assumes that the present vector and the one to compare with have the same size already, since comparing vectors of different sizes makes not much sense anyway. </p>

</div>
</div>
<a id="ga2371854d97a2f717da3170b72e2a58e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2371854d97a2f717da3170b72e2a58e8">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the scalar product of two vectors. The return type is the underlying type of <code>this</code> vector, so the return type and the accuracy with which it the result is computed depend on the order of the arguments of this vector.</p>
<p>For complex vectors, the scalar product is implemented as \(\left&lt;v,w\right&gt;=\sum_i v_i \bar{w_i}\).</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). The algorithm uses pairwise summation with the same order of summation in every run, which gives fully repeatable results from one run to another. </dd></dl>

</div>
</div>
<a id="gaad5a995087a003f81fa5b74513e13677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad5a995087a003f81fa5b74513e13677">&#9670;&nbsp;</a></span>norm_sqr() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Vectors.html#ga02452a5983fd0e8c956ab9278213bd2c">real_type</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::norm_sqr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the square of the \(l_2\)-norm.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). The algorithm uses pairwise summation with the same order of summation in every run, which gives fully repeatable results from one run to another. </dd></dl>

</div>
</div>
<a id="ga33d47f6cd8a2b9ec62f133e7d303b745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33d47f6cd8a2b9ec62f133e7d303b745">&#9670;&nbsp;</a></span>mean_value() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::mean_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mean value of the elements of this vector.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). The algorithm uses pairwise summation with the same order of summation in every run, which gives fully repeatable results from one run to another. </dd></dl>

</div>
</div>
<a id="gaeaa8fc05dd5a8a8f9560a5de096ebb4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeaa8fc05dd5a8a8f9560a5de096ebb4e">&#9670;&nbsp;</a></span>l1_norm() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Vectors.html#ga02452a5983fd0e8c956ab9278213bd2c">real_type</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::l1_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\(l_1\)-norm of the vector. The sum of the absolute values.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). The algorithm uses pairwise summation with the same order of summation in every run, which gives fully repeatable results from one run to another. </dd></dl>

</div>
</div>
<a id="ga8ee1b8309a7a9ecf109c8a7116733ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ee1b8309a7a9ecf109c8a7116733ef8">&#9670;&nbsp;</a></span>l2_norm() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Vectors.html#ga02452a5983fd0e8c956ab9278213bd2c">real_type</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::l2_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\(l_2\)-norm of the vector. The square root of the sum of the squares of the elements.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). The algorithm uses pairwise summation with the same order of summation in every run, which gives fully repeatable results from one run to another. </dd></dl>

</div>
</div>
<a id="ga708e76373444e3b1d12dbee72f5d32b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga708e76373444e3b1d12dbee72f5d32b9">&#9670;&nbsp;</a></span>lp_norm() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Vectors.html#ga02452a5983fd0e8c956ab9278213bd2c">real_type</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::lp_norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#ga02452a5983fd0e8c956ab9278213bd2c">real_type</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\(l_p\)-norm of the vector. The pth root of the sum of the pth powers of the absolute values of the elements.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). The algorithm uses pairwise summation with the same order of summation in every run, which gives fully repeatable results from one run to another. </dd></dl>

</div>
</div>
<a id="ga9f6b7f7afb05aaff7e1ab8f9942b6dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f6b7f7afb05aaff7e1ab8f9942b6dae">&#9670;&nbsp;</a></span>linfty_norm() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Vectors.html#ga02452a5983fd0e8c956ab9278213bd2c">real_type</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::linfty_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum absolute value of the elements. </p>

</div>
</div>
<a id="ga3659971dfc5e53759da2be27d702d078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3659971dfc5e53759da2be27d702d078">&#9670;&nbsp;</a></span>add_and_dot() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::add_and_dot </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a combined operation of a vector addition and a subsequent inner product, returning the value of the inner product. In other words, the result of this function is the same as if the user called </p><div class="fragment"><div class="line">this-&gt;<a class="code" href="group__Vectors.html#ga10b0336c485e36c7b4b105dd2a926002">add</a>(a, <a class="code" href="namespaceLAPACKSupport.html#aee5ef58d11434eb1d6a665e64bf17292">V</a>);</div>
<div class="line">return_value = *<span class="keyword">this</span> * W;</div>
<div class="ttc" id="agroup__Vectors_html_ga10b0336c485e36c7b4b105dd2a926002"><div class="ttname"><a href="group__Vectors.html#ga10b0336c485e36c7b4b105dd2a926002">Vector::add</a></div><div class="ttdeci">void add(const std::vector&lt; size_type &gt; &amp;indices, const std::vector&lt; OtherNumber &gt; &amp;values)</div></div>
</div><!-- fragment --><p>The reason this function exists is that this operation involves less memory transfer than calling the two functions separately. This method only needs to load three vectors, <code>this</code>, <code>V</code>, <code>W</code>, whereas calling separate methods means to load the calling vector <code>this</code> twice. Since most vector operations are memory transfer limited, this reduces the time by 25% (or 50% if <code>W</code> equals <code>this</code>).</p>
<p>For complex-valued vectors, the scalar product in the second step is implemented as \(\left&lt;v,w\right&gt;=\sum_i v_i \bar{w_i}\).</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). The algorithm uses pairwise summation with the same order of summation in every run, which gives fully repeatable results from one run to another. </dd></dl>

</div>
</div>
<a id="ga46010ca9f43c93431f7ee66817e670ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46010ca9f43c93431f7ee66817e670ca">&#9670;&nbsp;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Vectors.html#ga8f7ef5265cbcae4d30f7e3fcde61a7f9">pointer</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pointer to the underlying data buffer. </p>

</div>
</div>
<a id="ga24916f568e015cc783628a2c9664c666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24916f568e015cc783628a2c9664c666">&#9670;&nbsp;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Vectors.html#ga0a1be85b8a5e0669f9034cf8e4421a11">const_pointer</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a const pointer to the underlying data buffer. </p>

</div>
</div>
<a id="gaf34b888fe493ef2ed188179de69ad7ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf34b888fe493ef2ed188179de69ad7ed">&#9670;&nbsp;</a></span>begin() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Vectors.html#gacb8006e49918faaffeccd151669d0934">iterator</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make the <code><a class="el" href="classVector.html">Vector</a></code> class a bit like the <code>vector&lt;&gt;</code> class of the C++ standard library by returning iterators to the start and end of the elements of this vector. </p>

</div>
</div>
<a id="ga710df6df8902b609158fa277f216d146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga710df6df8902b609158fa277f216d146">&#9670;&nbsp;</a></span>begin() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Vectors.html#ga31d7e7b4278a3fa08a6e5ceec3deb0fb">const_iterator</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return constant iterator to the start of the vectors. </p>

</div>
</div>
<a id="ga7a2a770cb19d3e5b0b69b08ffc88184f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a2a770cb19d3e5b0b69b08ffc88184f">&#9670;&nbsp;</a></span>end() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Vectors.html#gacb8006e49918faaffeccd151669d0934">iterator</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator pointing to the element past the end of the array. </p>

</div>
</div>
<a id="gabc9d45917e1f6cd2ba60dc4aef430ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc9d45917e1f6cd2ba60dc4aef430ce9">&#9670;&nbsp;</a></span>end() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Vectors.html#ga31d7e7b4278a3fa08a6e5ceec3deb0fb">const_iterator</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a constant iterator pointing to the element past the end of the array. </p>

</div>
</div>
<a id="gad3af32d65459fad49b43d41ec7e848c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3af32d65459fad49b43d41ec7e848c3">&#9670;&nbsp;</a></span>operator()() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#ga5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the value of the <code>ith</code> component. </p>

</div>
</div>
<a id="ga1268a6b336ee46bd8b2ac746cbe82643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1268a6b336ee46bd8b2ac746cbe82643">&#9670;&nbsp;</a></span>operator()() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#ga5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the <code>ith</code> component as a writeable reference. </p>

</div>
</div>
<a id="ga5c137f6bd56f1fad54a13a8cc46f5b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c137f6bd56f1fad54a13a8cc46f5b12">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#ga5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the value of the <code>ith</code> component.</p>
<p>Exactly the same as operator(). </p>

</div>
</div>
<a id="ga4d7bafc88c457dbc2e7db6a533d35391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d7bafc88c457dbc2e7db6a533d35391">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#ga5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the <code>ith</code> component as a writeable reference.</p>
<p>Exactly the same as operator(). </p>

</div>
</div>
<a id="gae406cc28ed782932504a186ba1c5f9e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae406cc28ed782932504a186ba1c5f9e8">&#9670;&nbsp;</a></span>extract_subvector_to() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::extract_subvector_to </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__Vectors.html#ga5927fb109e04d1d4988dae5c910fc32d">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instead of getting individual elements of a vector via operator(), this function allows getting a whole set of elements at once. The indices of the elements to be read are stated in the first argument, the corresponding values are returned in the second.</p>
<p>If the current vector is called <code>v</code>, then this function is the equivalent to the code </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; indices.size(); ++i)</div>
<div class="line">  <a class="code" href="group__Vectors.html#gab392612c190ffa0dd4daa4eea36507c4">values</a>[i] = v[indices[i]];</div>
<div class="ttc" id="agroup__Vectors_html_gab392612c190ffa0dd4daa4eea36507c4"><div class="ttname"><a href="group__Vectors.html#gab392612c190ffa0dd4daa4eea36507c4">Vector::values</a></div><div class="ttdeci">AlignedVector&lt; Number &gt; values</div><div class="ttdef"><b>Definition:</b> <a href="vector_8h_source.html#l01006">vector.h:1006</a></div></div>
</div><!-- fragment --><dl class="section pre"><dt>Precondition</dt><dd>The sizes of the <code>indices</code> and <code>values</code> arrays must be identical. </dd></dl>

</div>
</div>
<a id="ga079ae7a1b9cf454549e0925103208cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga079ae7a1b9cf454549e0925103208cc5">&#9670;&nbsp;</a></span>extract_subvector_to() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename ForwardIterator , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::extract_subvector_to </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>indices_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator&#160;</td>
          <td class="paramname"><em>indices_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>values_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instead of getting individual elements of a vector via operator(), this function allows getting a whole set of elements at once. In contrast to the previous function, this function obtains the indices of the elements by dereferencing all elements of the iterator range provided by the first two arguments, and puts the vector values into memory locations obtained by dereferencing a range of iterators starting at the location pointed to by the third argument.</p>
<p>If the current vector is called <code>v</code>, then this function is the equivalent to the code </p><div class="fragment"><div class="line">ForwardIterator indices_p = indices_begin;</div>
<div class="line">OutputIterator  values_p  = values_begin;</div>
<div class="line"><span class="keywordflow">while</span> (indices_p != indices_end)</div>
<div class="line">  {</div>
<div class="line">    *values_p = v[*indices_p];</div>
<div class="line">    ++indices_p;</div>
<div class="line">    ++values_p;</div>
<div class="line">  }</div>
</div><!-- fragment --><dl class="section pre"><dt>Precondition</dt><dd>It must be possible to write into as many memory locations starting at <code>values_begin</code> as there are iterators between <code>indices_begin</code> and <code>indices_end</code>. </dd></dl>

</div>
</div>
<a id="ga0b2abb4f2a3a722b30165373ea982a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b2abb4f2a3a722b30165373ea982a50">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add the given vector to the present one.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="ga603f91549c76b084a88e47d8824997ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga603f91549c76b084a88e47d8824997ab">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtract the given vector from the present one.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="ga10b0336c485e36c7b4b105dd2a926002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10b0336c485e36c7b4b105dd2a926002">&#9670;&nbsp;</a></span>add() <span class="overload">[18/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__Vectors.html#ga5927fb109e04d1d4988dae5c910fc32d">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A collective add operation: This function adds a whole set of values stored in <code>values</code> to the vector components specified by <code>indices</code>. </p>

</div>
</div>
<a id="gaeb5a1e611de68e9631791cebf3736c86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb5a1e611de68e9631791cebf3736c86">&#9670;&nbsp;</a></span>add() <span class="overload">[19/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__Vectors.html#ga5927fb109e04d1d4988dae5c910fc32d">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a second collective add operation. As a difference, this function takes a deal.II vector of values. </p>

</div>
</div>
<a id="gacd1770cabeceaf722763742cdc1e10ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd1770cabeceaf722763742cdc1e10ba">&#9670;&nbsp;</a></span>add() <span class="overload">[20/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#ga5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>n_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#ga5927fb109e04d1d4988dae5c910fc32d">size_type</a> *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OtherNumber *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take an address where <code>n_elements</code> are stored contiguously and add them into the vector. Handles all cases which are not covered by the other two <code><a class="el" href="group__Vectors.html#ga10b0336c485e36c7b4b105dd2a926002">add()</a></code> functions above. </p>

</div>
</div>
<a id="ga2b264924f2c8dc130e0be826f40e0da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b264924f2c8dc130e0be826f40e0da0">&#9670;&nbsp;</a></span>add() <span class="overload">[21/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Addition of <code>s</code> to all components. Note that <code>s</code> is a scalar and not a vector.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="ga141369afc3169fc80597a7d70fa7b7a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga141369afc3169fc80597a7d70fa7b7a6">&#9670;&nbsp;</a></span>add() <span class="overload">[22/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiple addition of scaled vectors, i.e. <code>*this += a*V+b*W</code>.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="gaae0643f15938ef8dc4727d90405cf83f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae0643f15938ef8dc4727d90405cf83f">&#9670;&nbsp;</a></span>add() <span class="overload">[23/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Simple addition of a multiple of a vector, i.e. <code>*this += a*V</code>.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="ga7126299241702719e409f59c0ec07d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7126299241702719e409f59c0ec07d51">&#9670;&nbsp;</a></span>sadd() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::sadd </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scaling and simple vector addition, i.e. <code><em>this = s</em>(*this)+V</code>.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="ga2d2bb04de50473779d407149dec7be9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d2bb04de50473779d407149dec7be9f">&#9670;&nbsp;</a></span>sadd() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::sadd </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scaling and simple addition, i.e. <code><em>this = s</em>(*this)+a*V</code>.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="ga4f3e7e9460e7395dd67b95e61dd87d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f3e7e9460e7395dd67b95e61dd87d37">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale each element of the vector by a constant value.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="ga4263fde23b0a636562ca9751d51b5e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4263fde23b0a636562ca9751d51b5e4a">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale each element of the vector by the inverse of the given value.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="gaa956ed8a13546e788464672e88057b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa956ed8a13546e788464672e88057b65">&#9670;&nbsp;</a></span>scale() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>scaling_factors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale each element of this vector by the corresponding element in the argument. This function is mostly meant to simulate multiplication (and immediate re-assignment) by a diagonal scaling matrix.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="ga0a3d0f3f7fb1a7d6196a0def1bacf371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a3d0f3f7fb1a7d6196a0def1bacf371">&#9670;&nbsp;</a></span>scale() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>scaling_factors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale each element of this vector by the corresponding element in the argument. This function is mostly meant to simulate multiplication (and immediate re-assignment) by a diagonal scaling matrix. </p>

</div>
</div>
<a id="ga5feedb1e66657dcc91855748c936879a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5feedb1e66657dcc91855748c936879a">&#9670;&nbsp;</a></span>equ() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::equ </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment <code>*this = a*u</code>.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="gab59511c3b4ce9b3fe8454c8657234a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab59511c3b4ce9b3fe8454c8657234a25">&#9670;&nbsp;</a></span>equ() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::equ </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment <code>*this = a*u</code>. </p>

</div>
</div>
<a id="gae50dd04b204d8ebf6be467c3ebe2234f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae50dd04b204d8ebf6be467c3ebe2234f">&#9670;&nbsp;</a></span>update_ghost_values() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::update_ghost_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does nothing but exists for compatibility with the <code>parallel</code> vector classes (e.g., <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> class). </p>

</div>
</div>
<a id="ga4d43302d459c7cb6ae4b5bad13d31507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d43302d459c7cb6ae4b5bad13d31507">&#9670;&nbsp;</a></span>print() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>precision</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>scientific</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>across</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print to a stream. <code>precision</code> denotes the desired precision with which values shall be printed, <code>scientific</code> whether scientific notation shall be used. If <code>across</code> is <code>true</code> then the vector is printed in a line, while if <code>false</code> then the elements are printed on a separate line each. </p>

</div>
</div>
<a id="ga31f18ed7d00d429247dc3127ba496e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31f18ed7d00d429247dc3127ba496e42">&#9670;&nbsp;</a></span>block_write() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::block_write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the vector en bloc to a file. This is done in a binary mode, so the output is neither readable by humans nor (probably) by other computers using a different operating system or number format. </p>

</div>
</div>
<a id="ga57d77409b8591a13d5ee10c2e705593a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57d77409b8591a13d5ee10c2e705593a">&#9670;&nbsp;</a></span>block_read() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::block_read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a vector en block from a file. This is done using the inverse operations to the above function, so it is reasonably fast because the bitstream is not interpreted.</p>
<p>The vector is resized if necessary.</p>
<p>A primitive form of error checking is performed which will recognize the bluntest attempts to interpret some data as a vector stored bitwise to a file, but not more. </p>

</div>
</div>
<a id="ga9c9b9333d11630bf0fc82a7957e0d1c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c9b9333d11630bf0fc82a7957e0d1c1">&#9670;&nbsp;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::save </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the data of this object to a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. </p>

</div>
</div>
<a id="ga3b7a75b54cfee3d921a467f2ca126b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b7a75b54cfee3d921a467f2ca126b54">&#9670;&nbsp;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::load </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the data of this object from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. </p>

</div>
</div>
<a id="ga6121484e53939ed6ad6024141ee0cd50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6121484e53939ed6ad6024141ee0cd50">&#9670;&nbsp;</a></span>serialize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>archive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write and read the data of this object from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. </p>

</div>
</div>
<a id="ga21bdbe031534857b865272b4e986b830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21bdbe031534857b865272b4e986b830">&#9670;&nbsp;</a></span>in_local_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::in_local_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#ga5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>global_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if the given global index is in the local range of this processor. Since this is not a distributed vector the method always returns true. </p>

</div>
</div>
<a id="gaac6b216c32fbf2cddb2466a8033ad3e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac6b216c32fbf2cddb2466a8033ad3e6">&#9670;&nbsp;</a></span>locally_owned_elements() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::locally_owned_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an index set that describes which elements of this vector are owned by the current processor. Note that this index set does not include elements this vector may store locally as ghost elements but that are in fact owned by another processor. As a consequence, the index sets returned on different processors if this is a distributed vector will form disjoint sets that add up to the complete index set. Obviously, if a vector is created on only one processor, then the result would satisfy </p><div class="fragment"><div class="line">vec.locally_owned_elements() == <a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a> (vec.size())</div>
</div><!-- fragment --><p>Since the current data type does not support parallel data storage across different processors, the returned index set is the complete index set. </p>

</div>
</div>
<a id="ga81dcfa5c77bdd426603386c0844149ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81dcfa5c77bdd426603386c0844149ae">&#9670;&nbsp;</a></span>size() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Vectors.html#ga5927fb109e04d1d4988dae5c910fc32d">size_type</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return dimension of the vector. </p>

</div>
</div>
<a id="gad2508c8f07d54ab6a69fba59daf6df2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2508c8f07d54ab6a69fba59daf6df2c">&#9670;&nbsp;</a></span>locally_owned_size() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Vectors.html#ga5927fb109e04d1d4988dae5c910fc32d">size_type</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::locally_owned_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return local dimension of the vector. Since this vector does not support distributed data this is always the same value as <a class="el" href="group__Vectors.html#ga81dcfa5c77bdd426603386c0844149ae">size()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function exists for compatibility with <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>. </dd></dl>

</div>
</div>
<a id="gae72a04de37cc5ba8f0263809a59ec99e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae72a04de37cc5ba8f0263809a59ec99e">&#9670;&nbsp;</a></span>all_zero() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::all_zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the vector contains only elements with value zero. This function is mainly for internal consistency checks and should seldom be used when not in debug mode since it uses quite some time. </p>

</div>
</div>
<a id="gad8e23a22888630c9874cbddf8bcccdf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8e23a22888630c9874cbddf8bcccdf5">&#9670;&nbsp;</a></span>is_non_negative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::is_non_negative </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return <code>true</code> if the vector has no negative entries, i.e. all entries are zero or positive. This function is used, for example, to check whether refinement indicators are really all positive (or zero).</p>
<p>The function obviously only makes sense if the template argument of this class is a real type. If it is a complex type, then an exception is thrown. </p>

</div>
</div>
<a id="gaea73d2cb54e87b69a9b7cdb17ed274df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea73d2cb54e87b69a9b7cdb17ed274df">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. </p>

</div>
</div>
<a id="ga0ca33f52511daa54531089f98b316458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ca33f52511daa54531089f98b316458">&#9670;&nbsp;</a></span>has_ghost_elements() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::has_ghost_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function exists for compatibility with the <code>parallel</code> vector classes (e.g., <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> class). Always returns false since this implementation is serial. </p>

</div>
</div>
<a id="gaab49b815c8f8e5394cd0ed96a687270c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab49b815c8f8e5394cd0ed96a687270c">&#9670;&nbsp;</a></span>maybe_reset_thread_partitioner()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::maybe_reset_thread_partitioner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convenience function used at the end of initialization or reinitialization. Resets (if necessary) the loop partitioner to the correct state, based on its current state and the length of the vector. </p>

</div>
</div>
<a id="ga27b879d09291ecb28bb0ea39d7a181b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27b879d09291ecb28bb0ea39d7a181b6">&#9670;&nbsp;</a></span>do_reinit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::do_reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Vectors.html#ga5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>reset_partitioner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Actual implementation of the reinit functions. </p>

</div>
</div>
<a id="ga77cffd135b29b32a9d77a1bcdef4b95a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77cffd135b29b32a9d77a1bcdef4b95a">&#9670;&nbsp;</a></span>swap() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Global function <code>swap</code> which overloads the default implementation of the C++ standard library which uses a temporary object. The function simply exchanges the data of the two vectors. </p>

<p class="definition">Definition at line <a class="el" href="vector_8h_source.html#l01381">1381</a> of file <a class="el" href="vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="ga809f9fb92ff19a343c238f3de52416e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga809f9fb92ff19a343c238f3de52416e2">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Output operator writing a vector to a stream. This operator outputs the elements of the vector one by one, with a space between entries. Each entry is formatted according to the flags set on the output stream. </p>

<p class="definition">Definition at line <a class="el" href="vector_8h_source.html#l01395">1395</a> of file <a class="el" href="vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="ga786d97fd050d53e86d523b1b0766f568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga786d97fd050d53e86d523b1b0766f568">&#9670;&nbsp;</a></span>reinit() <span class="overload">[26/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">LinearAlgebra::VectorSpaceVector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Change the dimension to that of the vector V. The elements of V are not copied. </p>

<p>Implemented in <a class="el" href="classLinearAlgebra_1_1TpetraWrappers_1_1Vector.html#abe6e945ef4344f482fed6cc314932749">LinearAlgebra::TpetraWrappers::Vector&lt; Number &gt;</a>, <a class="el" href="group__Vectors.html#gaa64c8e418f460ed9e2886b45bf982b08">LinearAlgebra::Vector&lt; Number &gt;</a>, <a class="el" href="group__Vectors.html#ga7bde7122a6d05d6815f507f7cb27819a">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;</a>, <a class="el" href="group__Vectors.html#ga456e59ce23e0da8010f74d80875f6aa5">LinearAlgebra::distributed::BlockVector&lt; Number &gt;</a>, <a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html#a21cf017d8c7736d90b3b10b9d8d762cd">LinearAlgebra::CUDAWrappers::Vector&lt; Number &gt;</a>, and <a class="el" href="classLinearAlgebra_1_1EpetraWrappers_1_1Vector.html#a01a85378829530e2f2084e794abc2eb2">LinearAlgebra::EpetraWrappers::Vector</a>.</p>

</div>
</div>
<a id="gae5dd9195f5c8988b1c8d9cd7878228cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5dd9195f5c8988b1c8d9cd7878228cb">&#9670;&nbsp;</a></span>operator=() <span class="overload">[30/30]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt;Number&gt;&amp; <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">LinearAlgebra::VectorSpaceVector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets all elements of the vector to the scalar <code>s</code>. This operation is only allowed if <code>s</code> is equal to zero. </p>

<p>Implemented in <a class="el" href="classLinearAlgebra_1_1TpetraWrappers_1_1Vector.html#ad981f339051c92d66c817558048a6846">LinearAlgebra::TpetraWrappers::Vector&lt; Number &gt;</a>, <a class="el" href="group__Vectors.html#ga557ab29f95f51396ced9cd9deb2c8581">LinearAlgebra::Vector&lt; Number &gt;</a>, <a class="el" href="group__Vectors.html#ga85d501a9f8c20d9142fe6a0f88bb12a4">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;</a>, <a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html#ae0c1b2c2d07cb0337aa0b26b91511a57">LinearAlgebra::CUDAWrappers::Vector&lt; Number &gt;</a>, and <a class="el" href="classLinearAlgebra_1_1EpetraWrappers_1_1Vector.html#a09a110595f321854e90789c964918896">LinearAlgebra::EpetraWrappers::Vector</a>.</p>

</div>
</div>
<a id="ga02349286c5e57d29396dfac9290d302f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02349286c5e57d29396dfac9290d302f">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt;Number&gt;&amp; <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">LinearAlgebra::VectorSpaceVector</a>&lt; Number &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiply the entire vector by a fixed factor. </p>

<p>Implemented in <a class="el" href="classLinearAlgebra_1_1TpetraWrappers_1_1Vector.html#a98987d4f092c0f32287d88a48d5bedd9">LinearAlgebra::TpetraWrappers::Vector&lt; Number &gt;</a>, <a class="el" href="group__Vectors.html#gaf94005df1795ba915f56cbe9689bafe1">LinearAlgebra::Vector&lt; Number &gt;</a>, <a class="el" href="group__Vectors.html#gad85b449afaa8f491f01d7670bcc48099">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;</a>, <a class="el" href="group__Vectors.html#ga5be26d6eb72dcefdec2e2305d0e1c2e6">LinearAlgebra::distributed::BlockVector&lt; Number &gt;</a>, <a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html#a06230677bba96a3b40493ab249884238">LinearAlgebra::CUDAWrappers::Vector&lt; Number &gt;</a>, and <a class="el" href="classLinearAlgebra_1_1EpetraWrappers_1_1Vector.html#aedc8b543e50101ce81b05f2a47157b7e">LinearAlgebra::EpetraWrappers::Vector</a>.</p>

</div>
</div>
<a id="ga198b28b1759b52bd5df5345be6ff8868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga198b28b1759b52bd5df5345be6ff8868">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt;Number&gt;&amp; <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">LinearAlgebra::VectorSpaceVector</a>&lt; Number &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Divide the entire vector by a fixed factor. </p>

<p>Implemented in <a class="el" href="classLinearAlgebra_1_1TpetraWrappers_1_1Vector.html#aee236e11d1934d9561c625a7d68d83a6">LinearAlgebra::TpetraWrappers::Vector&lt; Number &gt;</a>, <a class="el" href="group__Vectors.html#gab2e30d0e4ce88f2def5c702abfde3647">LinearAlgebra::Vector&lt; Number &gt;</a>, <a class="el" href="group__Vectors.html#ga16146ad677e926f3bdbed2aca3248247">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;</a>, <a class="el" href="group__Vectors.html#ga4daee550e5e52be51395ca7afe42896d">LinearAlgebra::distributed::BlockVector&lt; Number &gt;</a>, <a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html#aa312b375c4977d46ee1150ee0ec8a472">LinearAlgebra::CUDAWrappers::Vector&lt; Number &gt;</a>, and <a class="el" href="classLinearAlgebra_1_1EpetraWrappers_1_1Vector.html#a0c41ca41579b53f1769600ce0475286a">LinearAlgebra::EpetraWrappers::Vector</a>.</p>

</div>
</div>
<a id="ga8b581c9b2dd4a55c2a5998e62b195bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b581c9b2dd4a55c2a5998e62b195bd9">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt;Number&gt;&amp; <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">LinearAlgebra::VectorSpaceVector</a>&lt; Number &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add the vector <code>V</code> to the present one. </p>

<p>Implemented in <a class="el" href="classLinearAlgebra_1_1TpetraWrappers_1_1Vector.html#aada663a8149db9f588926913608bc6ed">LinearAlgebra::TpetraWrappers::Vector&lt; Number &gt;</a>, <a class="el" href="group__Vectors.html#gafaac1b52eb924a1e85dcc07dfe97c1e0">LinearAlgebra::Vector&lt; Number &gt;</a>, <a class="el" href="group__Vectors.html#ga3eabb34382bc0694390f97616742bcdf">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;</a>, <a class="el" href="group__Vectors.html#ga4a97828f252550978a7525b82d1e1f92">LinearAlgebra::distributed::BlockVector&lt; Number &gt;</a>, <a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html#ac08e5fe1086909ae9361e649d82a4e3e">LinearAlgebra::CUDAWrappers::Vector&lt; Number &gt;</a>, and <a class="el" href="classLinearAlgebra_1_1EpetraWrappers_1_1Vector.html#aeeddc3c140af220e9aa551b0fc740b1c">LinearAlgebra::EpetraWrappers::Vector</a>.</p>

</div>
</div>
<a id="ga61e201954ade41d8b8ba290e5841efb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61e201954ade41d8b8ba290e5841efb2">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt;Number&gt;&amp; <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">LinearAlgebra::VectorSpaceVector</a>&lt; Number &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtract the vector <code>V</code> from the present one. </p>

<p>Implemented in <a class="el" href="classLinearAlgebra_1_1TpetraWrappers_1_1Vector.html#a43339a231f61c29d853726ca77473301">LinearAlgebra::TpetraWrappers::Vector&lt; Number &gt;</a>, <a class="el" href="group__Vectors.html#ga7564016986f801b180919010fd5520aa">LinearAlgebra::Vector&lt; Number &gt;</a>, <a class="el" href="group__Vectors.html#ga132ecfef78dfec86c1b6a5423d642ae0">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;</a>, <a class="el" href="group__Vectors.html#ga52fb6dc78db248d8b4749632ef52d36f">LinearAlgebra::distributed::BlockVector&lt; Number &gt;</a>, <a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html#aaeced2faa3367bf9fabd003403e95bb3">LinearAlgebra::CUDAWrappers::Vector&lt; Number &gt;</a>, and <a class="el" href="classLinearAlgebra_1_1EpetraWrappers_1_1Vector.html#aab04bdd644e7ab24f64e7313a089aef5">LinearAlgebra::EpetraWrappers::Vector</a>.</p>

</div>
</div>
<a id="ga0c05d3725740bda0feab10c660582669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c05d3725740bda0feab10c660582669">&#9670;&nbsp;</a></span>import() <span class="overload">[15/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">LinearAlgebra::VectorSpaceVector</a>&lt; Number &gt;::import </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1CommunicationPatternBase.html">Utilities::MPI::CommunicationPatternBase</a> &gt;&#160;</td>
          <td class="paramname"><em>communication_pattern</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Import all the elements present in the vector's <a class="el" href="classIndexSet.html">IndexSet</a> from the input vector <code>V</code>. <a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> <code>operation</code> is used to decide if the elements in <code>V</code> should be added to the current vector or replace the current elements. The last parameter can be used if the same communication pattern is used multiple times. This can be used to improve performance. </p>

<p>Implemented in <a class="el" href="classLinearAlgebra_1_1TpetraWrappers_1_1Vector.html#a02878727b941d850ee88b47082063cac">LinearAlgebra::TpetraWrappers::Vector&lt; Number &gt;</a>, <a class="el" href="group__Vectors.html#gab9e93ebac6f78cc400dcc1398dc07014">LinearAlgebra::Vector&lt; Number &gt;</a>, <a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html#a4eb4be4392f70400691d84338052bc69">LinearAlgebra::CUDAWrappers::Vector&lt; Number &gt;</a>, <a class="el" href="classLinearAlgebra_1_1EpetraWrappers_1_1Vector.html#ace7537b0ef745100419afb1d6bbc7f85">LinearAlgebra::EpetraWrappers::Vector</a>, <a class="el" href="group__Vectors.html#gad947177e38381c4fd058876a4f27f771">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;</a>, and <a class="el" href="group__Vectors.html#ga8143655154d18b0c5753b00158b2e2f1">LinearAlgebra::distributed::BlockVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="gabe15b048b316e02c2c88644713f9bda8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe15b048b316e02c2c88644713f9bda8">&#9670;&nbsp;</a></span>operator*() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Number <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">LinearAlgebra::VectorSpaceVector</a>&lt; Number &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the scalar product of two vectors. </p>

<p>Implemented in <a class="el" href="classLinearAlgebra_1_1TpetraWrappers_1_1Vector.html#a34d6c52000b55c0fc3946408d055e2da">LinearAlgebra::TpetraWrappers::Vector&lt; Number &gt;</a>, <a class="el" href="group__Vectors.html#ga579d6877263ae00b309422bcd6e3d307">LinearAlgebra::Vector&lt; Number &gt;</a>, <a class="el" href="group__Vectors.html#ga829281a9ccc9f1cf9720ee5a535efd21">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;</a>, <a class="el" href="group__Vectors.html#ga93f5bd0dc1f676eaf0747b580b6ca468">LinearAlgebra::distributed::BlockVector&lt; Number &gt;</a>, <a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html#a5036623a6fa1659cfb5f5cd6cb6038c7">LinearAlgebra::CUDAWrappers::Vector&lt; Number &gt;</a>, and <a class="el" href="classLinearAlgebra_1_1EpetraWrappers_1_1Vector.html#a84d10936e3afd0cc1b202cff6b0a2062">LinearAlgebra::EpetraWrappers::Vector</a>.</p>

</div>
</div>
<a id="ga3dbc94fab7a9b8490941588107b5d27b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3dbc94fab7a9b8490941588107b5d27b">&#9670;&nbsp;</a></span>add() <span class="overload">[24/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">LinearAlgebra::VectorSpaceVector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add <code>a</code> to all components. Note that <code>a</code> is a scalar not a vector. </p>

<p>Implemented in <a class="el" href="classLinearAlgebra_1_1TpetraWrappers_1_1Vector.html#a188417b2094d7feaa37f233b7a20f8f7">LinearAlgebra::TpetraWrappers::Vector&lt; Number &gt;</a>, <a class="el" href="group__Vectors.html#gae544cbdf92826eec01c0cceeff69817a">LinearAlgebra::Vector&lt; Number &gt;</a>, <a class="el" href="group__Vectors.html#gac029174b48a0707da587b6ce3bc25047">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;</a>, <a class="el" href="group__Vectors.html#gaccecdd88bcfc805d1554fc99e8f05e38">LinearAlgebra::distributed::BlockVector&lt; Number &gt;</a>, <a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html#a939179fd58fe2a59d2f2bb9aac0de992">LinearAlgebra::CUDAWrappers::Vector&lt; Number &gt;</a>, and <a class="el" href="classLinearAlgebra_1_1EpetraWrappers_1_1Vector.html#ad26a25234497efe5c2ccbb54fdc8aec9">LinearAlgebra::EpetraWrappers::Vector</a>.</p>

</div>
</div>
<a id="ga5d989f75097f8bb45e5297a262ed941d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d989f75097f8bb45e5297a262ed941d">&#9670;&nbsp;</a></span>add() <span class="overload">[25/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">LinearAlgebra::VectorSpaceVector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Simple addition of a multiple of a vector, i.e. <code>*this += a*V</code>. </p>

<p>Implemented in <a class="el" href="classLinearAlgebra_1_1TpetraWrappers_1_1Vector.html#a7c641324a0f58b37abb404620a121953">LinearAlgebra::TpetraWrappers::Vector&lt; Number &gt;</a>, <a class="el" href="group__Vectors.html#ga9468f18bddc88c38140e99961ae0c360">LinearAlgebra::Vector&lt; Number &gt;</a>, <a class="el" href="group__Vectors.html#gab7d70c674b55edbb3595acaedc310996">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;</a>, <a class="el" href="group__Vectors.html#gab0b1677974de1a51cade3dea2e268dd0">LinearAlgebra::distributed::BlockVector&lt; Number &gt;</a>, <a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html#aa5b6829b6cce6130a53aa808f4f07b9f">LinearAlgebra::CUDAWrappers::Vector&lt; Number &gt;</a>, and <a class="el" href="classLinearAlgebra_1_1EpetraWrappers_1_1Vector.html#aad540ba52fcd5e8e8e74a5cfef5e8498">LinearAlgebra::EpetraWrappers::Vector</a>.</p>

</div>
</div>
<a id="gabc8bff328d603ccb5978a6b7d6543c8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc8bff328d603ccb5978a6b7d6543c8c">&#9670;&nbsp;</a></span>add() <span class="overload">[26/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">LinearAlgebra::VectorSpaceVector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiple addition of scaled vectors, i.e. <code>*this += a*V+b*W</code>. </p>

<p>Implemented in <a class="el" href="classLinearAlgebra_1_1TpetraWrappers_1_1Vector.html#a7401881ea891f07908882e54da0d74c6">LinearAlgebra::TpetraWrappers::Vector&lt; Number &gt;</a>, <a class="el" href="group__Vectors.html#ga5c4190172e7ebc876dbdcde8617813f3">LinearAlgebra::Vector&lt; Number &gt;</a>, <a class="el" href="group__Vectors.html#ga25d752a33b33192932b0dd8054d2c40e">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;</a>, <a class="el" href="group__Vectors.html#ga32a59caf6a091dc576366547bb71dc86">LinearAlgebra::distributed::BlockVector&lt; Number &gt;</a>, <a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html#a758abdca1248f7d26a07f529561038a9">LinearAlgebra::CUDAWrappers::Vector&lt; Number &gt;</a>, and <a class="el" href="classLinearAlgebra_1_1EpetraWrappers_1_1Vector.html#a5408b4e71dc8c1dfc78a951c2bde44b1">LinearAlgebra::EpetraWrappers::Vector</a>.</p>

</div>
</div>
<a id="ga8f8a5799eb407e559540aae082f9ec87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f8a5799eb407e559540aae082f9ec87">&#9670;&nbsp;</a></span>sadd() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">LinearAlgebra::VectorSpaceVector</a>&lt; Number &gt;::sadd </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scaling and simple addition of a multiple of a vector, i.e. <code><em>this = s</em>(*this)+a*V</code>. </p>

<p>Implemented in <a class="el" href="classLinearAlgebra_1_1TpetraWrappers_1_1Vector.html#aa9e6d64499cfe21f82c13eb7a2d40fbd">LinearAlgebra::TpetraWrappers::Vector&lt; Number &gt;</a>, <a class="el" href="group__Vectors.html#gab0e8184f5712096bc81ef553b0d3adc5">LinearAlgebra::Vector&lt; Number &gt;</a>, <a class="el" href="group__Vectors.html#gaa6376a098589519491fc452d1529f57b">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;</a>, <a class="el" href="group__Vectors.html#ga5a306d119c19bffc19f7d99800e5de79">LinearAlgebra::distributed::BlockVector&lt; Number &gt;</a>, <a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html#a8c4edb6ccce4e77e883abf49075b640a">LinearAlgebra::CUDAWrappers::Vector&lt; Number &gt;</a>, and <a class="el" href="classLinearAlgebra_1_1EpetraWrappers_1_1Vector.html#af4738dd4306bb5e8da2510b7776814e3">LinearAlgebra::EpetraWrappers::Vector</a>.</p>

</div>
</div>
<a id="ga27c492ff183de02d4f75f3d152c6f0ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27c492ff183de02d4f75f3d152c6f0ac">&#9670;&nbsp;</a></span>scale() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">LinearAlgebra::VectorSpaceVector</a>&lt; Number &gt;::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>scaling_factors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scale each element of this vector by the corresponding element in the argument. This function is mostly meant to simulate multiplication (and immediate re-assignment) by a diagonal scaling matrix. </p>

<p>Implemented in <a class="el" href="classLinearAlgebra_1_1TpetraWrappers_1_1Vector.html#abf53f3965f0f669c5af89d27f41447df">LinearAlgebra::TpetraWrappers::Vector&lt; Number &gt;</a>, <a class="el" href="group__Vectors.html#ga45e4f966a68c411aed4525ab4ebb0645">LinearAlgebra::Vector&lt; Number &gt;</a>, <a class="el" href="group__Vectors.html#gaacdf6bfd4533c47587ba0debe177710e">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;</a>, <a class="el" href="group__Vectors.html#ga6b50074b32093b5471d1c7e033c0f2d6">LinearAlgebra::distributed::BlockVector&lt; Number &gt;</a>, <a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html#ac79cc5bd8f679c04a874954a0cbe2022">LinearAlgebra::CUDAWrappers::Vector&lt; Number &gt;</a>, and <a class="el" href="classLinearAlgebra_1_1EpetraWrappers_1_1Vector.html#a7fe16f9373a6278ec38bf60152dd46d4">LinearAlgebra::EpetraWrappers::Vector</a>.</p>

</div>
</div>
<a id="ga344fbb1ede704fb7b14e6e60048e9da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga344fbb1ede704fb7b14e6e60048e9da3">&#9670;&nbsp;</a></span>equ() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">LinearAlgebra::VectorSpaceVector</a>&lt; Number &gt;::equ </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assignment <code>*this = a*V</code>. </p>

<p>Implemented in <a class="el" href="classLinearAlgebra_1_1TpetraWrappers_1_1Vector.html#ac9b2dc20021600fed2ace7ba772efa26">LinearAlgebra::TpetraWrappers::Vector&lt; Number &gt;</a>, <a class="el" href="group__Vectors.html#gafb746b1de6c4efea8e2b90e28471a398">LinearAlgebra::Vector&lt; Number &gt;</a>, <a class="el" href="group__Vectors.html#ga43c64a6bebc56d849307ef1fcad62c23">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;</a>, <a class="el" href="group__Vectors.html#gad8bc1dd4072504da9cbea82e6ba01180">LinearAlgebra::distributed::BlockVector&lt; Number &gt;</a>, <a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html#aac09e8772e382e1cecfd5a1cd5e82f74">LinearAlgebra::CUDAWrappers::Vector&lt; Number &gt;</a>, and <a class="el" href="classLinearAlgebra_1_1EpetraWrappers_1_1Vector.html#adc0d0669851a7cd50dce1393edbf373e">LinearAlgebra::EpetraWrappers::Vector</a>.</p>

</div>
</div>
<a id="ga8c03a20480770e68f0d4e1e6456e78eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c03a20480770e68f0d4e1e6456e78eb">&#9670;&nbsp;</a></span>all_zero() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">LinearAlgebra::VectorSpaceVector</a>&lt; Number &gt;::all_zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether the vector contains only elements with value zero. </p>

<p>Implemented in <a class="el" href="classLinearAlgebra_1_1TpetraWrappers_1_1Vector.html#af45803c1836996d6f5f5c7c1f91f7ca6">LinearAlgebra::TpetraWrappers::Vector&lt; Number &gt;</a>, <a class="el" href="classLinearAlgebra_1_1EpetraWrappers_1_1Vector.html#ac116900124527ac3cdb1911bdb0297dc">LinearAlgebra::EpetraWrappers::Vector</a>, <a class="el" href="group__Vectors.html#ga98de521b6d2dab1cf767b6abb2ca9c17">LinearAlgebra::Vector&lt; Number &gt;</a>, <a class="el" href="group__Vectors.html#ga5ed7dc1d792f9344f1c8720e5f639351">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;</a>, <a class="el" href="group__Vectors.html#ga809ec1490fd39c130932290aae65355c">LinearAlgebra::distributed::BlockVector&lt; Number &gt;</a>, and <a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html#a671f76de4c475a3ae5efde6913a5a7e6">LinearAlgebra::CUDAWrappers::Vector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="gab3e11175ad9c308d796d72aa0fc6b44b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3e11175ad9c308d796d72aa0fc6b44b">&#9670;&nbsp;</a></span>mean_value() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__Vectors.html#ga327cd3179fb6078605a14b772a0dc20d">value_type</a> <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">LinearAlgebra::VectorSpaceVector</a>&lt; Number &gt;::mean_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the mean value of all the entries of this vector. </p>

<p>Implemented in <a class="el" href="classLinearAlgebra_1_1TpetraWrappers_1_1Vector.html#a842104e8cdf70070d9c16b547554cf70">LinearAlgebra::TpetraWrappers::Vector&lt; Number &gt;</a>, <a class="el" href="classLinearAlgebra_1_1EpetraWrappers_1_1Vector.html#a0603b53d5be0917dcf1ef06dbd99c28a">LinearAlgebra::EpetraWrappers::Vector</a>, <a class="el" href="group__Vectors.html#ga88d01435c6542c25fdad43bdb6fdd421">LinearAlgebra::Vector&lt; Number &gt;</a>, <a class="el" href="group__Vectors.html#ga64f0fddbf542f0e6ff6344e0fa7d55f9">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;</a>, <a class="el" href="group__Vectors.html#ga7df34df7e744cbfdb5cec39176821cf1">LinearAlgebra::distributed::BlockVector&lt; Number &gt;</a>, and <a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html#a9c81a6bee274ff72667f3b1baeb18d92">LinearAlgebra::CUDAWrappers::Vector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga6ad9146f2c4a36cc762456b4cba21b4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ad9146f2c4a36cc762456b4cba21b4c">&#9670;&nbsp;</a></span>l1_norm() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__Vectors.html#ga6ec199439799ef30b1845bda4cbe8d43">real_type</a> <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">LinearAlgebra::VectorSpaceVector</a>&lt; Number &gt;::l1_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the l<sub>1</sub> norm of the vector (i.e., the sum of the absolute values of all entries among all processors). </p>

<p>Implemented in <a class="el" href="classLinearAlgebra_1_1TpetraWrappers_1_1Vector.html#a21b0d5b76b6640f70cefbcb884df43cb">LinearAlgebra::TpetraWrappers::Vector&lt; Number &gt;</a>, <a class="el" href="classLinearAlgebra_1_1EpetraWrappers_1_1Vector.html#a60146aab95bde2e40c6a6a068157da1c">LinearAlgebra::EpetraWrappers::Vector</a>, <a class="el" href="group__Vectors.html#ga7e8d6fff438ca92832676d01f8d75c4e">LinearAlgebra::Vector&lt; Number &gt;</a>, <a class="el" href="group__Vectors.html#ga0e93518655d2231061f4eb916e98a130">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;</a>, <a class="el" href="group__Vectors.html#ga2cdf84bbe46a886cdde6bad3a4246163">LinearAlgebra::distributed::BlockVector&lt; Number &gt;</a>, and <a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html#a81960366e44072875665af4bdf16a241">LinearAlgebra::CUDAWrappers::Vector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga2d4822289e1415f1bf35c84c4b7ee292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d4822289e1415f1bf35c84c4b7ee292">&#9670;&nbsp;</a></span>l2_norm() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__Vectors.html#ga6ec199439799ef30b1845bda4cbe8d43">real_type</a> <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">LinearAlgebra::VectorSpaceVector</a>&lt; Number &gt;::l2_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the l<sub>2</sub> norm of the vector (i.e., the square root of the sum of the square of all entries among all processors). </p>

<p>Implemented in <a class="el" href="classLinearAlgebra_1_1TpetraWrappers_1_1Vector.html#a0b0507dc22a28d81da84606a259a0c58">LinearAlgebra::TpetraWrappers::Vector&lt; Number &gt;</a>, <a class="el" href="classLinearAlgebra_1_1EpetraWrappers_1_1Vector.html#a3a7cce492cac9392af906e9071faa213">LinearAlgebra::EpetraWrappers::Vector</a>, <a class="el" href="group__Vectors.html#ga3ecec231c62d47fe3c7aba269fd8ffb8">LinearAlgebra::Vector&lt; Number &gt;</a>, <a class="el" href="group__Vectors.html#gaf355599021a687026ab9818efd57e82d">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;</a>, <a class="el" href="group__Vectors.html#ga8fceaca158b4b7b17d280c618c469228">LinearAlgebra::distributed::BlockVector&lt; Number &gt;</a>, and <a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html#a5d6e9b140d1addf63221e047c72a41be">LinearAlgebra::CUDAWrappers::Vector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="gaf84f65fc1f6ebc21534271c42c33d159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf84f65fc1f6ebc21534271c42c33d159">&#9670;&nbsp;</a></span>linfty_norm() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__Vectors.html#ga6ec199439799ef30b1845bda4cbe8d43">real_type</a> <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">LinearAlgebra::VectorSpaceVector</a>&lt; Number &gt;::linfty_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the maximum norm of the vector (i.e., the maximum absolute value among all entries and among all processors). </p>

<p>Implemented in <a class="el" href="classLinearAlgebra_1_1TpetraWrappers_1_1Vector.html#aacd97177406e04295ed1e792240fa9bb">LinearAlgebra::TpetraWrappers::Vector&lt; Number &gt;</a>, <a class="el" href="classLinearAlgebra_1_1EpetraWrappers_1_1Vector.html#abd60a8c755ee693233e60b39ddb7bec2">LinearAlgebra::EpetraWrappers::Vector</a>, <a class="el" href="group__Vectors.html#gab77a07267e7a186d7948b09396edecff">LinearAlgebra::Vector&lt; Number &gt;</a>, <a class="el" href="group__Vectors.html#ga2e7bf945225df27d522ec30f1530c0aa">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;</a>, <a class="el" href="group__Vectors.html#ga1403274bfe2ad51433f205ae1a10b6ae">LinearAlgebra::distributed::BlockVector&lt; Number &gt;</a>, and <a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html#aa1f7f3aaf1405f3da7b20b42b13cf8ff">LinearAlgebra::CUDAWrappers::Vector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga89ae394fb53af7daf23705d5992f9f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89ae394fb53af7daf23705d5992f9f11">&#9670;&nbsp;</a></span>add_and_dot() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Number <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">LinearAlgebra::VectorSpaceVector</a>&lt; Number &gt;::add_and_dot </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform a combined operation of a vector addition and a subsequent inner product, returning the value of the inner product. In other words, the result of this function is the same as if the user called </p><div class="fragment"><div class="line">this-&gt;<a class="code" href="group__Vectors.html#ga3dbc94fab7a9b8490941588107b5d27b">add</a>(a, <a class="code" href="namespaceLAPACKSupport.html#aee5ef58d11434eb1d6a665e64bf17292">V</a>);</div>
<div class="line">return_value = *<span class="keyword">this</span> * W;</div>
<div class="ttc" id="agroup__Vectors_html_ga3dbc94fab7a9b8490941588107b5d27b"><div class="ttname"><a href="group__Vectors.html#ga3dbc94fab7a9b8490941588107b5d27b">LinearAlgebra::VectorSpaceVector::add</a></div><div class="ttdeci">virtual void add(const Number a)=0</div></div>
</div><!-- fragment --><p>The reason this function exists is that this operation involves less memory transfer than calling the two functions separately. This method only needs to load three vectors, <code>this</code>, <code>V</code>, <code>W</code>, whereas calling separate methods means to load the calling vector <code>this</code> twice. Since most vector operations are memory transfer limited, this reduces the time by 25% (or 50% if <code>W</code> equals <code>this</code>).</p>
<p>For complex-valued vectors, the scalar product in the second step is implemented as \(\left&lt;v,w\right&gt;=\sum_i v_i \bar{w_i}\). </p>

<p>Implemented in <a class="el" href="classLinearAlgebra_1_1TpetraWrappers_1_1Vector.html#ad5a4f0c5771597bdc955d5753977aa2a">LinearAlgebra::TpetraWrappers::Vector&lt; Number &gt;</a>, <a class="el" href="group__Vectors.html#gaecfb1b3222bb8069117f3d2c707c3060">LinearAlgebra::Vector&lt; Number &gt;</a>, <a class="el" href="group__Vectors.html#gaf1dc41a177aadb6a2f6d0d7c2cf41eba">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;</a>, <a class="el" href="group__Vectors.html#gaf1c44bfad65af75c21d0d23af1125414">LinearAlgebra::distributed::BlockVector&lt; Number &gt;</a>, <a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html#a7b6b92b7c5828a57ca33bc2123c7ebdd">LinearAlgebra::CUDAWrappers::Vector&lt; Number &gt;</a>, and <a class="el" href="classLinearAlgebra_1_1EpetraWrappers_1_1Vector.html#a77cac6bc08a711ba9f1a9305de1c6c2f">LinearAlgebra::EpetraWrappers::Vector</a>.</p>

</div>
</div>
<a id="ga6207efeaeff0d0f321b35d29d58e8df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6207efeaeff0d0f321b35d29d58e8df2">&#9670;&nbsp;</a></span>compress() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">LinearAlgebra::VectorSpaceVector</a>&lt; Number &gt;::compress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function does nothing and only exists for backward compatibility. </p>

<p class="definition">Definition at line <a class="el" href="vector__space__vector_8h_source.html#l00225">225</a> of file <a class="el" href="vector__space__vector_8h_source.html">vector_space_vector.h</a>.</p>

</div>
</div>
<a id="ga79b24c9cc50ac00221c89466a021c62a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79b24c9cc50ac00221c89466a021c62a">&#9670;&nbsp;</a></span>size() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__Vectors.html#ga42c84b64cfafc72e8eef6e284bf899dc">size_type</a> <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">LinearAlgebra::VectorSpaceVector</a>&lt; Number &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the global size of the vector, equal to the sum of the number of locally owned indices among all processors. </p>

<p>Implemented in <a class="el" href="classLinearAlgebra_1_1TpetraWrappers_1_1Vector.html#a19ed81b0093826a588a063b40b713cdf">LinearAlgebra::TpetraWrappers::Vector&lt; Number &gt;</a>, <a class="el" href="classLinearAlgebra_1_1EpetraWrappers_1_1Vector.html#a9971bcba3686dcac87182debc89ba97b">LinearAlgebra::EpetraWrappers::Vector</a>, <a class="el" href="group__Vectors.html#gae5f0787421df51268c993616c2d604e9">LinearAlgebra::Vector&lt; Number &gt;</a>, <a class="el" href="group__Vectors.html#ga99297a298764249d0c0b5adf9a96e1c7">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;</a>, <a class="el" href="group__Vectors.html#gaf8d5be159fec545106c67bc940589fcb">LinearAlgebra::distributed::BlockVector&lt; Number &gt;</a>, and <a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html#ae5f0787421df51268c993616c2d604e9">LinearAlgebra::CUDAWrappers::Vector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga47e92627a68a0a778490b5694af4212b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47e92627a68a0a778490b5694af4212b">&#9670;&nbsp;</a></span>locally_owned_elements() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ::<a class="el" href="classIndexSet.html">IndexSet</a> <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">LinearAlgebra::VectorSpaceVector</a>&lt; Number &gt;::locally_owned_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an index set that describes which elements of this vector are owned by the current processor. As a consequence, the index sets returned on different processors if this is a distributed vector will form disjoint sets that add up to the complete index set. Obviously, if a vector is created on only one processor, then the result would satisfy </p><div class="fragment"><div class="line">vec.locally_owned_elements() == <a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(vec.size())</div>
</div><!-- fragment --> 
<p>Implemented in <a class="el" href="classLinearAlgebra_1_1TpetraWrappers_1_1Vector.html#ab28a99a1f7adc95b4e2bb2d1b3d221ea">LinearAlgebra::TpetraWrappers::Vector&lt; Number &gt;</a>, <a class="el" href="classLinearAlgebra_1_1EpetraWrappers_1_1Vector.html#a6ecb7b79933b2e2e578187960bc79950">LinearAlgebra::EpetraWrappers::Vector</a>, <a class="el" href="group__Vectors.html#ga6ecb7b79933b2e2e578187960bc79950">LinearAlgebra::Vector&lt; Number &gt;</a>, <a class="el" href="group__Vectors.html#gaff5265a5af79342c77ac50d584c9d3e4">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;</a>, <a class="el" href="group__Vectors.html#ga468dfbd79a0d0d614327f292ee66f76a">LinearAlgebra::distributed::BlockVector&lt; Number &gt;</a>, and <a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html#a6ecb7b79933b2e2e578187960bc79950">LinearAlgebra::CUDAWrappers::Vector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga1fcac5e46eb6bc858f1715e30db75031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fcac5e46eb6bc858f1715e30db75031">&#9670;&nbsp;</a></span>print() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">LinearAlgebra::VectorSpaceVector</a>&lt; Number &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>precision</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>scientific</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>across</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Print the vector to the output stream <code>out</code>. </p>

<p>Implemented in <a class="el" href="classLinearAlgebra_1_1TpetraWrappers_1_1Vector.html#a652352530b27a5e008d1e132c2c983b3">LinearAlgebra::TpetraWrappers::Vector&lt; Number &gt;</a>, <a class="el" href="classLinearAlgebra_1_1EpetraWrappers_1_1Vector.html#a9d3fc386b73ef25215696c1d8beaa9d8">LinearAlgebra::EpetraWrappers::Vector</a>, <a class="el" href="group__Vectors.html#ga9d3fc386b73ef25215696c1d8beaa9d8">LinearAlgebra::Vector&lt; Number &gt;</a>, <a class="el" href="group__Vectors.html#gab2218dcb909cf45f3e495ac250ea9260">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;</a>, <a class="el" href="group__Vectors.html#gabb764f033c38e246091f50d0ee3f8b90">LinearAlgebra::distributed::BlockVector&lt; Number &gt;</a>, and <a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html#a91d6d3a8939ad5bf4be1769c1cd3b9bc">LinearAlgebra::CUDAWrappers::Vector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga4760b791f71d963298a5d49917f46555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4760b791f71d963298a5d49917f46555">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">LinearAlgebra::VectorSpaceVector</a>&lt; Number &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the memory consumption of this class in bytes. </p>

<p>Implemented in <a class="el" href="classLinearAlgebra_1_1TpetraWrappers_1_1Vector.html#aef5bb977032de6dd837e1f39c228fa3a">LinearAlgebra::TpetraWrappers::Vector&lt; Number &gt;</a>, <a class="el" href="classLinearAlgebra_1_1EpetraWrappers_1_1Vector.html#ae3d016b943c09add2765165f4dd4aedf">LinearAlgebra::EpetraWrappers::Vector</a>, <a class="el" href="group__Vectors.html#gae3d016b943c09add2765165f4dd4aedf">LinearAlgebra::Vector&lt; Number &gt;</a>, <a class="el" href="group__Vectors.html#ga493afd09167ce2c18d27252178d88c59">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;</a>, <a class="el" href="group__Vectors.html#ga7d9c15a88fd2789219e70fd950d211e6">LinearAlgebra::distributed::BlockVector&lt; Number &gt;</a>, and <a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html#ae68547bd67eea7c9f9c328352fdd880e">LinearAlgebra::CUDAWrappers::Vector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ga2c9fca8ab72a89a97a9b8ebc84c7d03e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c9fca8ab72a89a97a9b8ebc84c7d03e">&#9670;&nbsp;</a></span>~VectorSpaceVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">LinearAlgebra::VectorSpaceVector</a>&lt; Number &gt;::~<a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. Declared as virtual so that inheriting classes (which may manage their own memory) are destroyed correctly. </p>

</div>
</div>
<a id="ga42433961867fd78582a867ba7f68bd01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42433961867fd78582a867ba7f68bd01">&#9670;&nbsp;</a></span>set_zero_mean_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LinearAlgebra::set_zero_mean_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shift all entries of the vector by a constant factor so that the mean value of the vector becomes zero. </p>

<p class="definition">Definition at line <a class="el" href="vector__space__vector_8h_source.html#l00283">283</a> of file <a class="el" href="vector__space__vector_8h_source.html">vector_space_vector.h</a>.</p>

</div>
</div>
<a id="gae2a64fee4774f141397d2ab5838e6b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2a64fee4774f141397d2ab5838e6b2f">&#9670;&nbsp;</a></span>swap() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Global function which overloads the default implementation of the C++ standard library which uses a temporary object. The function simply exchanges the data of the two vectors. </p>

<p class="definition">Definition at line <a class="el" href="block__vector_8h_source.html#l00489">489</a> of file <a class="el" href="block__vector_8h_source.html">block_vector.h</a>.</p>

</div>
</div>
<a id="ga77cffd135b29b32a9d77a1bcdef4b95a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77cffd135b29b32a9d77a1bcdef4b95a">&#9670;&nbsp;</a></span>swap() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Global function <code>swap</code> which overloads the default implementation of the C++ standard library which uses a temporary object. The function simply exchanges the data of the two vectors. </p>

<p class="definition">Definition at line <a class="el" href="vector_8h_source.html#l01381">1381</a> of file <a class="el" href="vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="ga809f9fb92ff19a343c238f3de52416e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga809f9fb92ff19a343c238f3de52416e2">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Output operator writing a vector to a stream. This operator outputs the elements of the vector one by one, with a space between entries. Each entry is formatted according to the flags set on the output stream. </p>

<p class="definition">Definition at line <a class="el" href="vector_8h_source.html#l01395">1395</a> of file <a class="el" href="vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="ga5ecaeebd349b3741eb385e158cba9658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ecaeebd349b3741eb385e158cba9658">&#9670;&nbsp;</a></span>ExcVectorTypeNotCompatible() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a>&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::ExcVectorTypeNotCompatible </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempt to perform an operation between two incompatible vector types. </p>

</div>
</div>
<a id="ga0160d956c8460b3c0b60e1ba597d47f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0160d956c8460b3c0b60e1ba597d47f5">&#9670;&nbsp;</a></span>ExcIteratorRangeDoesNotMatchVectorSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a>&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::ExcIteratorRangeDoesNotMatchVectorSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="ga453c188166f7296fb04e52fb788d40fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga453c188166f7296fb04e52fb788d40fd">&#9670;&nbsp;</a></span>ExcVectorTypeNotCompatible() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a>&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::ExcVectorTypeNotCompatible </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempt to perform an operation between two incompatible vector types. </p>

</div>
</div>
<a id="ga7181557daa1b267845919814c21323bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7181557daa1b267845919814c21323bb">&#9670;&nbsp;</a></span>ExcNotAllowedForCuda()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a>&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::ExcNotAllowedForCuda </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempt to perform an operation not implemented on the device. </p>

</div>
</div>
<a id="ga4e3eb31c0abb4a6f0832c29849017d48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e3eb31c0abb4a6f0832c29849017d48">&#9670;&nbsp;</a></span>ExcNonMatchingElements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a>&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::ExcNonMatchingElements </td>
          <td>(</td>
          <td class="paramtype">Number&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Number&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>arg3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exception </p><dl class="section note"><dt>Note</dt><dd>The message that will be printed by this exception reads: <div class="doxygen-generated-exception-message"> &lt;&lt; "Called compress(VectorOperation::insert), but" &lt;&lt; " the element received from a remote processor, value " &lt;&lt; std::setprecision(16) &lt;&lt; arg1 &lt;&lt; ", does not match with the value " &lt;&lt; std::setprecision(16) &lt;&lt; arg2 &lt;&lt; " on the owner processor " &lt;&lt; arg3 </div> </dd></dl>

</div>
</div>
<a id="ga67e3523483dc1fbe7c4d21b0b96a2be9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67e3523483dc1fbe7c4d21b0b96a2be9">&#9670;&nbsp;</a></span>ExcAccessToNonLocalElement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a>&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::ExcAccessToNonLocalElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname"><em>arg3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname"><em>arg4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exception </p><dl class="section note"><dt>Note</dt><dd>The message that will be printed by this exception reads: <div class="doxygen-generated-exception-message"> &lt;&lt; "You tried to access element " &lt;&lt; arg1 &lt;&lt; " of a distributed vector, but this element is not " &lt;&lt; "stored on the current processor. Note: The range of " &lt;&lt; "locally owned elements is [" &lt;&lt; arg2 &lt;&lt; "," &lt;&lt; arg3 &lt;&lt; "], and there are " &lt;&lt; arg4 &lt;&lt; " ghost elements " &lt;&lt; "that this vector can access." &lt;&lt; "\n\n" &lt;&lt; "A common source for this kind of problem is that you " &lt;&lt; "are passing a 'fully distributed' vector into a function " &lt;&lt; "that needs read access to vector elements that correspond " &lt;&lt; "to degrees of freedom on ghost cells (or at least to " &lt;&lt; "'locally active' degrees of freedom that are not also " &lt;&lt; "'locally owned'). You need to pass a vector that has these " &lt;&lt; "elements as ghost entries." </div> </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gaf1aa9207795db77aaa6d5d0f23e8dbe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1aa9207795db77aaa6d5d0f23e8dbe7">&#9670;&nbsp;</a></span>value <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbool.html">bool</a> <a class="el" href="structIsBlockVector.html">IsBlockVector</a>&lt; VectorType &gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    std::is_same&lt;decltype(check_for_block_vector(std::declval&lt;VectorType *&gt;())),</div>
<div class="line">                 std::true_type&gt;<a class="code" href="group__Vectors.html#gaf1aa9207795db77aaa6d5d0f23e8dbe7">::value</a></div>
<div class="ttc" id="agroup__Vectors_html_gaf1aa9207795db77aaa6d5d0f23e8dbe7"><div class="ttname"><a href="group__Vectors.html#gaf1aa9207795db77aaa6d5d0f23e8dbe7">IsBlockVector::value</a></div><div class="ttdeci">static const bool value</div><div class="ttdef"><b>Definition:</b> <a href="block__vector__base_8h_source.html#l00090">block_vector_base.h:90</a></div></div>
</div><!-- fragment --><p>A statically computable value that indicates whether the template argument to this class is a block vector (in fact whether the type is derived from BlockVectorBase&lt;T&gt;). </p>

<p class="definition">Definition at line <a class="el" href="block__vector__base_8h_source.html#l00090">90</a> of file <a class="el" href="block__vector__base_8h_source.html">block_vector_base.h</a>.</p>

</div>
</div>
<a id="ga4b58ae27edeb2cbb96a5a2496109154b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b58ae27edeb2cbb96a5a2496109154b">&#9670;&nbsp;</a></span>communication_block_size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned int <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::communication_block_size = 20</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The chunks size to split communication in <a class="el" href="group__Vectors.html#gaec81b97d7e38d836457bfbc7b2f20226">update_ghost_values()</a> and <a class="el" href="group__Vectors.html#ga852d132f4827ec54f9583013a536761b">compress()</a> calls.</p>
<p>Most common MPI implementations will get slow when too many messages/requests are outstanding. Even when messages are small, say 1 kB only, we should collect enough data with <code>communication_block_size</code> to cover typical infiniband latencies which are around a few microseconds. Sending 20 kB at a throughput of 5 GB/s takes 4 microseconds, so we should arrive at the bandwidth dominated regime then which is good enough. </p>

<p class="definition">Definition at line <a class="el" href="la__parallel__block__vector_8h_source.html#l00100">100</a> of file <a class="el" href="la__parallel__block__vector_8h_source.html">la_parallel_block_vector.h</a>.</p>

</div>
</div>
<a id="ga3f1e1f118b38f6731b99f2f5bed7cd18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f1e1f118b38f6731b99f2f5bed7cd18">&#9670;&nbsp;</a></span>partitioner</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a>&gt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::partitioner</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Shared pointer to store the parallel partitioning information. This information can be shared between several vectors that have the same partitioning. </p>

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01331">1331</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="ga3654b450369a501269a65e8fe917ef7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3654b450369a501269a65e8fe917ef7b">&#9670;&nbsp;</a></span>allocated_size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Vectors.html#ga301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::allocated_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The size that is currently allocated in the val array. </p>

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01336">1336</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="ga2e986decf5878ef8fc13c691910bf263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e986decf5878ef8fc13c691910bf263">&#9670;&nbsp;</a></span>data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mutable ::<a class="el" href="structMemorySpace_1_1MemorySpaceData.html">MemorySpace::MemorySpaceData</a>&lt;Number, MemorySpace&gt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Underlying data structure storing the local elements of this vector. </p>

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01341">1341</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="gaa22a8f4e80c1fe4ff79779dcda71a0b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa22a8f4e80c1fe4ff79779dcda71a0b9">&#9670;&nbsp;</a></span>thread_loop_partitioner <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;::<a class="el" href="classparallel_1_1internal_1_1TBBPartitioner.html">parallel::internal::TBBPartitioner</a>&gt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::thread_loop_partitioner</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For parallel loops with TBB, this member variable stores the affinity information of loops. </p>

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01348">1348</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="ga2c7e2584032a7c664c2c28c0436cd6ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c7e2584032a7c664c2c28c0436cd6ce">&#9670;&nbsp;</a></span>import_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mutable ::<a class="el" href="structMemorySpace_1_1MemorySpaceData.html">MemorySpace::MemorySpaceData</a>&lt;Number, MemorySpace&gt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::import_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Temporary storage that holds the data that is sent to this processor in <a class="el" href="group__Vectors.html#ga8a204103e550697467d933388b732bda">compress()</a> or sent from this processor in <a class="el" href="group__Vectors.html#ga2a6cb7d50e02022283af53c2ae14f878">update_ghost_values()</a>. </p>

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01355">1355</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="gaf41fb0de7a379de6c6a58801bd93827b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf41fb0de7a379de6c6a58801bd93827b">&#9670;&nbsp;</a></span>vector_is_ghosted</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::vector_is_ghosted</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores whether the vector currently allows for reading ghost elements or not. Note that this is to ensure consistent ghost data and does not indicate whether the vector actually can store ghost elements. In particular, when assembling a vector we do not allow reading elements, only writing them. </p>

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01364">1364</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="gae53eaaa25a65ca1ce774e713dd37154c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae53eaaa25a65ca1ce774e713dd37154c">&#9670;&nbsp;</a></span>compress_requests</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;MPI_Request&gt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::compress_requests</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A vector that collects all requests from <a class="el" href="group__Vectors.html#ga8a204103e550697467d933388b732bda">compress()</a> operations. This class uses persistent MPI communicators, i.e., the communication channels are stored during successive calls to a given function. This reduces the overhead involved with setting up the MPI machinery, but it does not remove the need for a receive operation to be posted before the data can actually be sent. </p>

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01375">1375</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="gada6604e63e86194c350e0c1ab9d70387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada6604e63e86194c350e0c1ab9d70387">&#9670;&nbsp;</a></span>update_ghost_values_requests</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;MPI_Request&gt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::update_ghost_values_requests</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A vector that collects all requests from <a class="el" href="group__Vectors.html#ga2a6cb7d50e02022283af53c2ae14f878">update_ghost_values()</a> operations. This class uses persistent MPI communicators. </p>

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01381">1381</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="gaf2ca9ef90490cbf818d17fcca54a76f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2ca9ef90490cbf818d17fcca54a76f2">&#9670;&nbsp;</a></span>mutex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A lock that makes sure that the <a class="el" href="group__Vectors.html#ga8a204103e550697467d933388b732bda">compress()</a> and <a class="el" href="group__Vectors.html#ga2a6cb7d50e02022283af53c2ae14f878">update_ghost_values()</a> functions give reasonable results also when used with several threads. </p>

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01389">1389</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="ga4d06704d2372317ea90b5e5bd9c1dc9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d06704d2372317ea90b5e5bd9c1dc9f">&#9670;&nbsp;</a></span>comm_sm</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MPI_Comm <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::comm_sm</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Communicator to be used for the shared-memory domain. See the general documentation of this class for more information about the purpose of <code>comm_sm</code>. </p>

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01396">1396</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="ga42953ed0dea7466b965c0da21def4b4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42953ed0dea7466b965c0da21def4b4e">&#9670;&nbsp;</a></span>value <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbool.html">bool</a> <a class="el" href="classinternal_1_1LinearOperatorImplementation_1_1ReinitHelper.html">internal::LinearOperatorImplementation::ReinitHelper</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number &gt; &gt;::has_get_mpi_communicator&lt; T &gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">          !std::is_same&lt;bool, decltype(detect(std::declval&lt;T&gt;()))&gt;<a class="code" href="group__Vectors.html#ga42953ed0dea7466b965c0da21def4b4e">::value</a></div>
<div class="ttc" id="agroup__Vectors_html_ga42953ed0dea7466b965c0da21def4b4e"><div class="ttname"><a href="group__Vectors.html#ga42953ed0dea7466b965c0da21def4b4e">internal::LinearOperatorImplementation::ReinitHelper&lt; LinearAlgebra::distributed::Vector&lt; Number &gt; &gt;::has_get_mpi_communicator::value</a></div><div class="ttdeci">static const bool value</div><div class="ttdef"><b>Definition:</b> <a href="la__parallel__vector_8h_source.html#l01890">la_parallel_vector.h:1890</a></div></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01890">1890</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="ga0788317f13f611a302fa6209598b62c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0788317f13f611a302fa6209598b62c7">&#9670;&nbsp;</a></span>value <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbool.html">bool</a> <a class="el" href="classinternal_1_1LinearOperatorImplementation_1_1ReinitHelper.html">internal::LinearOperatorImplementation::ReinitHelper</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number &gt; &gt;::has_locally_owned_domain_indices&lt; T &gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">          !std::is_same&lt;bool, decltype(detect(std::declval&lt;T&gt;()))&gt;<a class="code" href="group__Vectors.html#ga0788317f13f611a302fa6209598b62c7">::value</a></div>
<div class="ttc" id="agroup__Vectors_html_ga0788317f13f611a302fa6209598b62c7"><div class="ttname"><a href="group__Vectors.html#ga0788317f13f611a302fa6209598b62c7">internal::LinearOperatorImplementation::ReinitHelper&lt; LinearAlgebra::distributed::Vector&lt; Number &gt; &gt;::has_locally_owned_domain_indices::value</a></div><div class="ttdeci">static const bool value</div><div class="ttdef"><b>Definition:</b> <a href="la__parallel__vector_8h_source.html#l01908">la_parallel_vector.h:1908</a></div></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01908">1908</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="gaa8932910bed82ab3389eb8f5b43c7e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8932910bed82ab3389eb8f5b43c7e7a">&#9670;&nbsp;</a></span>value <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbool.html">bool</a> <a class="el" href="classinternal_1_1LinearOperatorImplementation_1_1ReinitHelper.html">internal::LinearOperatorImplementation::ReinitHelper</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number &gt; &gt;::has_locally_owned_range_indices&lt; T &gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">          !std::is_same&lt;bool, decltype(detect(std::declval&lt;T&gt;()))&gt;<a class="code" href="group__Vectors.html#gaa8932910bed82ab3389eb8f5b43c7e7a">::value</a></div>
<div class="ttc" id="agroup__Vectors_html_gaa8932910bed82ab3389eb8f5b43c7e7a"><div class="ttname"><a href="group__Vectors.html#gaa8932910bed82ab3389eb8f5b43c7e7a">internal::LinearOperatorImplementation::ReinitHelper&lt; LinearAlgebra::distributed::Vector&lt; Number &gt; &gt;::has_locally_owned_range_indices::value</a></div><div class="ttdeci">static const bool value</div><div class="ttdef"><b>Definition:</b> <a href="la__parallel__vector_8h_source.html#l01926">la_parallel_vector.h:1926</a></div></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01926">1926</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="ga01ac428a1c72c6a8d18aab0a6ed8e130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01ac428a1c72c6a8d18aab0a6ed8e130">&#9670;&nbsp;</a></span>value <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbool.html">bool</a> <a class="el" href="classinternal_1_1LinearOperatorImplementation_1_1ReinitHelper.html">internal::LinearOperatorImplementation::ReinitHelper</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number &gt; &gt;::has_initialize_dof_vector&lt; T &gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">          !std::is_same&lt;bool, decltype(detect(std::declval&lt;T&gt;()))&gt;<a class="code" href="group__Vectors.html#ga01ac428a1c72c6a8d18aab0a6ed8e130">::value</a></div>
<div class="ttc" id="agroup__Vectors_html_ga01ac428a1c72c6a8d18aab0a6ed8e130"><div class="ttname"><a href="group__Vectors.html#ga01ac428a1c72c6a8d18aab0a6ed8e130">internal::LinearOperatorImplementation::ReinitHelper&lt; LinearAlgebra::distributed::Vector&lt; Number &gt; &gt;::has_initialize_dof_vector::value</a></div><div class="ttdeci">static const bool value</div><div class="ttdef"><b>Definition:</b> <a href="la__parallel__vector_8h_source.html#l01945">la_parallel_vector.h:1945</a></div></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01945">1945</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="gafc5ab96d5e5729daebc67f6972cf7d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc5ab96d5e5729daebc67f6972cf7d7e">&#9670;&nbsp;</a></span>stored_elements</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::stored_elements</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Indices of the elements stored. </p>

<p class="definition">Definition at line <a class="el" href="read__write__vector_8h_source.html#l00723">723</a> of file <a class="el" href="read__write__vector_8h_source.html">read_write_vector.h</a>.</p>

</div>
</div>
<a id="gabc229cf3f043c2d7ecc0ecacc2f39f2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc229cf3f043c2d7ecc0ecacc2f39f2e">&#9670;&nbsp;</a></span>source_stored_elements</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::source_stored_elements</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classIndexSet.html">IndexSet</a> of the elements of the last imported vector; </p>

<p class="definition">Definition at line <a class="el" href="read__write__vector_8h_source.html#l00728">728</a> of file <a class="el" href="read__write__vector_8h_source.html">read_write_vector.h</a>.</p>

</div>
</div>
<a id="gaede32a438077b03a579151b0f9175fbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaede32a438077b03a579151b0f9175fbc">&#9670;&nbsp;</a></span>comm_pattern</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classUtilities_1_1MPI_1_1CommunicationPatternBase.html">Utilities::MPI::CommunicationPatternBase</a>&gt; <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::comm_pattern</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>CommunicationPattern for the communication between the source_stored_elements <a class="el" href="classIndexSet.html">IndexSet</a> and the current vector. </p>

<p class="definition">Definition at line <a class="el" href="read__write__vector_8h_source.html#l00734">734</a> of file <a class="el" href="read__write__vector_8h_source.html">read_write_vector.h</a>.</p>

</div>
</div>
<a id="ga18f97cb8e503f790483ddaddfa768a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18f97cb8e503f790483ddaddfa768a25">&#9670;&nbsp;</a></span>values <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;Number[], decltype(std::free) *&gt; <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::values</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the array of local elements of this vector. </p>

<p class="definition">Definition at line <a class="el" href="read__write__vector_8h_source.html#l00739">739</a> of file <a class="el" href="read__write__vector_8h_source.html">read_write_vector.h</a>.</p>

</div>
</div>
<a id="gaf1527d12757fb046479195b42143df76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1527d12757fb046479195b42143df76">&#9670;&nbsp;</a></span>thread_loop_partitioner <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;::<a class="el" href="classparallel_1_1internal_1_1TBBPartitioner.html">parallel::internal::TBBPartitioner</a>&gt; <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::thread_loop_partitioner</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For parallel loops with TBB, this member variable stores the affinity information of loops. </p>

<p class="definition">Definition at line <a class="el" href="read__write__vector_8h_source.html#l00746">746</a> of file <a class="el" href="read__write__vector_8h_source.html">read_write_vector.h</a>.</p>

</div>
</div>
<a id="gaa0c9de09db03b21ed9d6d13ee1ba3f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0c9de09db03b21ed9d6d13ee1ba3f82">&#9670;&nbsp;</a></span>parent</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&amp; <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::<a class="el" href="classLinearAlgebra_1_1ReadWriteVector_1_1FunctorTemplate.html">FunctorTemplate</a>&lt; Functor &gt;::parent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Alias to the <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a> object that owns the <a class="el" href="classLinearAlgebra_1_1ReadWriteVector_1_1FunctorTemplate.html">FunctorTemplate</a>. </p>

<p class="definition">Definition at line <a class="el" href="read__write__vector_8h_source.html#l00777">777</a> of file <a class="el" href="read__write__vector_8h_source.html">read_write_vector.h</a>.</p>

</div>
</div>
<a id="gaeeb220d0b08318d41b09d3c4f1337d78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeeb220d0b08318d41b09d3c4f1337d78">&#9670;&nbsp;</a></span>functor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Functor&amp; <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::<a class="el" href="classLinearAlgebra_1_1ReadWriteVector_1_1FunctorTemplate.html">FunctorTemplate</a>&lt; Functor &gt;::functor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy of the functor. </p>

<p class="definition">Definition at line <a class="el" href="read__write__vector_8h_source.html#l00782">782</a> of file <a class="el" href="read__write__vector_8h_source.html">read_write_vector.h</a>.</p>

</div>
</div>
<a id="gab392612c190ffa0dd4daa4eea36507c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab392612c190ffa0dd4daa4eea36507c4">&#9670;&nbsp;</a></span>values <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;Number&gt; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::values</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Array of elements owned by this vector. </p>

<p class="definition">Definition at line <a class="el" href="vector_8h_source.html#l01006">1006</a> of file <a class="el" href="vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="ga566a66df753d0a75121aa84fa4164d56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga566a66df753d0a75121aa84fa4164d56">&#9670;&nbsp;</a></span>thread_loop_partitioner <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classparallel_1_1internal_1_1TBBPartitioner.html">parallel::internal::TBBPartitioner</a>&gt; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::thread_loop_partitioner</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For parallel loops with TBB, this member variable stores the affinity information of loops. </p>

<p class="definition">Definition at line <a class="el" href="vector_8h_source.html#l01029">1029</a> of file <a class="el" href="vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends</h2>
<a id="gac14c06b74acbf135ede85924e7b3d521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac14c06b74acbf135ede85924e7b3d521">&#9670;&nbsp;</a></span>Vector <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 , typename MemorySpace2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Typedef for the vector type used</p>
<p>Typedef for the vector type used. </p>

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01414">1414</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="ga07c61e4419c2e58a70f3798109c14fac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07c61e4419c2e58a70f3798109c14fac">&#9670;&nbsp;</a></span>BlockVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace  = MemorySpace::Host&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Typedef for the block-vector type used</p>
<p>Typedef for the type used to describe vectors that consist of multiple blocks.</p>
<p>An implementation of block vectors based on distributed deal.II vectors. While the base class provides for most of the interface, this class handles the actual allocation of vectors and provides functions that are specific to the underlying vector type.</p>
<dl class="section note"><dt>Note</dt><dd>Instantiations for this template are provided for <code>&lt;float&gt; and &lt;double&gt;</code>; others can be generated in application programs (see the section on <a class="el" href="Instantiations.html">Template instantiations</a> in the manual).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBlockLA">Block (linear algebra)</a></dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000070">Deprecated:</a></b></dt><dd>Use <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a> instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01418">1418</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="ga879f896329da9659f538e8dc9d386087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga879f896329da9659f538e8dc9d386087">&#9670;&nbsp;</a></span>Vector <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classLinearAlgebra_1_1Vector.html">Vector</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Typedef for the vector type used</p>
<p>Typedef for the vector type used. </p>

<p class="definition">Definition at line <a class="el" href="la__vector_8h_source.html#l00420">420</a> of file <a class="el" href="la__vector_8h_source.html">la_vector.h</a>.</p>

</div>
</div>
<a id="ga1c84d108d27ea3c0df7f0d8417b08f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c84d108d27ea3c0df7f0d8417b08f11">&#9670;&nbsp;</a></span>ReadWriteVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="read__write__vector_8h_source.html#l00750">750</a> of file <a class="el" href="read__write__vector_8h_source.html">read_write_vector.h</a>.</p>

</div>
</div>
<a id="ga879f896329da9659f538e8dc9d386087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga879f896329da9659f538e8dc9d386087">&#9670;&nbsp;</a></span>Vector <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classVector.html">Vector</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Typedef for the vector type used</p>
<p>Typedef for the vector type used. </p>

<p class="definition">Definition at line <a class="el" href="vector_8h_source.html#l01033">1033</a> of file <a class="el" href="vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
