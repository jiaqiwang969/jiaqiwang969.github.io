<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classDataOutRotation.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: DataOutRotation&lt; dim, DoFHandlerType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.3.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.3.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classDataOutRotation-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DataOutRotation&lt; dim, DoFHandlerType &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__IO.html">Input/Output</a> &raquo; <a class="el" href="group__output.html">Graphical output</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="data__out__rotation_8h_source.html">deal.II/numerics/data_out_rotation.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for DataOutRotation&lt; dim, DoFHandlerType &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classDataOutRotation__inherit__graph.svg" width="1460" height="91"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad14f7812afddb65c553cff6068bd64e0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutRotation.html#ad14f7812afddb65c553cff6068bd64e0">cell_iterator</a> = typename <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; DoFHandlerType, <a class="el" href="classDataOutRotation.html#aa90a504a33269e4b5c08138da3646381">dimension</a>+1 &gt;::<a class="el" href="classDataOutRotation.html#ad14f7812afddb65c553cff6068bd64e0">cell_iterator</a></td></tr>
<tr class="separator:ad14f7812afddb65c553cff6068bd64e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062005bfe37e877e1f44e1c3e8e6cb27"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27">DataVectorType</a> </td></tr>
<tr class="separator:a062005bfe37e877e1f44e1c3e8e6cb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9ba0c7778094b954fccd774ef350040d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutRotation.html#a9ba0c7778094b954fccd774ef350040d">build_patches</a> (const unsigned int n_patches_per_circle, const unsigned int n_subdivisions=0)</td></tr>
<tr class="separator:a9ba0c7778094b954fccd774ef350040d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6820c4e0f27a15573e6522620caab58"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classDataOutRotation.html#ad14f7812afddb65c553cff6068bd64e0">cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutRotation.html#ab6820c4e0f27a15573e6522620caab58">first_cell</a> ()</td></tr>
<tr class="separator:ab6820c4e0f27a15573e6522620caab58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341f76fc14af202fa3598454eda22364"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classDataOutRotation.html#ad14f7812afddb65c553cff6068bd64e0">cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutRotation.html#a341f76fc14af202fa3598454eda22364">next_cell</a> (const <a class="el" href="classDataOutRotation.html#ad14f7812afddb65c553cff6068bd64e0">cell_iterator</a> &amp;cell)</td></tr>
<tr class="separator:a341f76fc14af202fa3598454eda22364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1eb26168177faa30ffbcf9cbb9c3cd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;)</td></tr>
<tr class="separator:ac1eb26168177faa30ffbcf9cbb9c3cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8d4fbc99c408d956c4685fd4c97b99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a0a8d4fbc99c408d956c4685fd4c97b99">attach_triangulation</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; DoFHandlerType::dimension, DoFHandlerType::space_dimension &gt; &amp;)</td></tr>
<tr class="separator:a0a8d4fbc99c408d956c4685fd4c97b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4b76e565ba0701c4d32c26075ed3b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (const VectorType &amp;data, const std::vector&lt; std::string &gt; &amp;names, const <a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27">DataVectorType</a> type=<a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27ad7189bcb96ade9f785a40b8959ac443e">type_automatic</a>, const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;data_component_interpretation=std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;())</td></tr>
<tr class="separator:ace4b76e565ba0701c4d32c26075ed3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f47f598ad14b15eb519350a2846432"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a65f47f598ad14b15eb519350a2846432">add_data_vector</a> (const VectorType &amp;data, const std::string &amp;name, const <a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27">DataVectorType</a> type=<a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27ad7189bcb96ade9f785a40b8959ac443e">type_automatic</a>, const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;data_component_interpretation=std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;())</td></tr>
<tr class="separator:a65f47f598ad14b15eb519350a2846432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bce7f46c9ad03ecdd71a86d47f8fb11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a4bce7f46c9ad03ecdd71a86d47f8fb11">add_data_vector</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;dof_handler, const VectorType &amp;data, const std::vector&lt; std::string &gt; &amp;names, const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;data_component_interpretation=std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;())</td></tr>
<tr class="separator:a4bce7f46c9ad03ecdd71a86d47f8fb11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ed745ab12b197a57cc5e22af0fcd8a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a5ed745ab12b197a57cc5e22af0fcd8a7">add_data_vector</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;dof_handler, const VectorType &amp;data, const std::string &amp;name, const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;data_component_interpretation=std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;())</td></tr>
<tr class="separator:a5ed745ab12b197a57cc5e22af0fcd8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6aa38d46f054f61211dbc02a16e384"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a4f6aa38d46f054f61211dbc02a16e384">add_data_vector</a> (const VectorType &amp;data, const <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; DoFHandlerType::space_dimension &gt; &amp;data_postprocessor)</td></tr>
<tr class="separator:a4f6aa38d46f054f61211dbc02a16e384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444344dcaaff07df72672b57001e1c27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a444344dcaaff07df72672b57001e1c27">add_data_vector</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;dof_handler, const VectorType &amp;data, const <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; DoFHandlerType::space_dimension &gt; &amp;data_postprocessor)</td></tr>
<tr class="separator:a444344dcaaff07df72672b57001e1c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f52f05c045de7fa390449c1ed339c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#ab1f52f05c045de7fa390449c1ed339c1">add_mg_data_vector</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;dof_handler, const <a class="el" href="classMGLevelObject.html">MGLevelObject</a>&lt; VectorType &gt; &amp;data, const std::vector&lt; std::string &gt; &amp;names, const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;data_component_interpretation=std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;())</td></tr>
<tr class="separator:ab1f52f05c045de7fa390449c1ed339c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c63ba80dac30bc2a18664a154d8e80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a90c63ba80dac30bc2a18664a154d8e80">add_mg_data_vector</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;dof_handler, const <a class="el" href="classMGLevelObject.html">MGLevelObject</a>&lt; VectorType &gt; &amp;data, const std::string &amp;name)</td></tr>
<tr class="separator:a90c63ba80dac30bc2a18664a154d8e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38df03770155948e7f702e14599e28e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a38df03770155948e7f702e14599e28e7">clear_data_vectors</a> ()</td></tr>
<tr class="separator:a38df03770155948e7f702e14599e28e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bda326e895cf4b1489d271cb358cfdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a1bda326e895cf4b1489d271cb358cfdd">clear_input_data_references</a> ()</td></tr>
<tr class="separator:a1bda326e895cf4b1489d271cb358cfdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d51e2c8ddb56ac1306927c502cd5983"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a4d51e2c8ddb56ac1306927c502cd5983">merge_patches</a> (const <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; DoFHandlerType2, patch_dim, patch_dim &gt; &amp;source, const <a class="el" href="classPoint.html">Point</a>&lt; patch_dim &gt; &amp;shift=<a class="el" href="classPoint.html">Point</a>&lt; patch_dim &gt;())</td></tr>
<tr class="separator:a4d51e2c8ddb56ac1306927c502cd5983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4769fe891f8d7f9caa1ba4f854484958"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a4769fe891f8d7f9caa1ba4f854484958">clear</a> ()</td></tr>
<tr class="separator:a4769fe891f8d7f9caa1ba4f854484958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af605c2840093a5f03e873153544da225"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#af605c2840093a5f03e873153544da225">memory_consumption</a> () const</td></tr>
<tr class="separator:af605c2840093a5f03e873153544da225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc05be5cd920b234e68548735852446e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gafc05be5cd920b234e68548735852446e">write_dx</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:gafc05be5cd920b234e68548735852446e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea2031a2a6fe56c9b7d3f9f338f20882"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaea2031a2a6fe56c9b7d3f9f338f20882">write_eps</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:gaea2031a2a6fe56c9b7d3f9f338f20882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7f2c3305058c94333d8aa699286b807"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gae7f2c3305058c94333d8aa699286b807">write_gmv</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:gae7f2c3305058c94333d8aa699286b807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85407e870a68179ebe62410d9efc153f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga85407e870a68179ebe62410d9efc153f">write_gnuplot</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:ga85407e870a68179ebe62410d9efc153f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33a15f01cb0171da2956be68ad496cd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga33a15f01cb0171da2956be68ad496cd0">write_povray</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:ga33a15f01cb0171da2956be68ad496cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga980b995a6f5944a75721097de39069c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga980b995a6f5944a75721097de39069c1">write_tecplot</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:ga980b995a6f5944a75721097de39069c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bf06b8647892769140884b3ab44a08e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga2bf06b8647892769140884b3ab44a08e">write_ucd</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:ga2bf06b8647892769140884b3ab44a08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacad99726038e4fca7f605fdffb3317e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacad99726038e4fca7f605fdffb3317e4">write_vtk</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:gacad99726038e4fca7f605fdffb3317e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93c780f93105e0daaa76c6c43694b4ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga93c780f93105e0daaa76c6c43694b4ae">write_vtu</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:ga93c780f93105e0daaa76c6c43694b4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5df488dad82b811ceb08cb1adf9eafcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5df488dad82b811ceb08cb1adf9eafcd">write_vtu_in_parallel</a> (const std::string &amp;filename, const MPI_Comm &amp;comm) const</td></tr>
<tr class="separator:ga5df488dad82b811ceb08cb1adf9eafcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1eff778443cd0431cd807c45b6ae16d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga1eff778443cd0431cd807c45b6ae16d9">write_pvtu_record</a> (std::ostream &amp;out, const std::vector&lt; std::string &gt; &amp;piece_names) const</td></tr>
<tr class="separator:ga1eff778443cd0431cd807c45b6ae16d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0864e51eb173c87e2a3edc9391ea8009"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga0864e51eb173c87e2a3edc9391ea8009">write_vtu_with_pvtu_record</a> (const std::string &amp;directory, const std::string &amp;filename_without_extension, const unsigned int counter, const MPI_Comm &amp;mpi_communicator, const unsigned int n_digits_for_counter=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>, const unsigned int n_groups=0) const</td></tr>
<tr class="separator:ga0864e51eb173c87e2a3edc9391ea8009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab56595d7d5aebfb2b3abfdaad51df20d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gab56595d7d5aebfb2b3abfdaad51df20d">write_svg</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:gab56595d7d5aebfb2b3abfdaad51df20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffac60e1e3799ae884642113a8e2e723"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaffac60e1e3799ae884642113a8e2e723">write_deal_II_intermediate</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:gaffac60e1e3799ae884642113a8e2e723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45ef5cf2b6515c10ff080729a9901155"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classXDMFEntry.html">XDMFEntry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga45ef5cf2b6515c10ff080729a9901155">create_xdmf_entry</a> (const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;data_filter, const std::string &amp;h5_filename, const <a class="el" href="classdouble.html">double</a> cur_time, const MPI_Comm &amp;comm) const</td></tr>
<tr class="separator:ga45ef5cf2b6515c10ff080729a9901155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f0b3eec5ee65bd7915c4e46272287eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classXDMFEntry.html">XDMFEntry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga0f0b3eec5ee65bd7915c4e46272287eb">create_xdmf_entry</a> (const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;data_filter, const std::string &amp;h5_mesh_filename, const std::string &amp;h5_solution_filename, const <a class="el" href="classdouble.html">double</a> cur_time, const MPI_Comm &amp;comm) const</td></tr>
<tr class="separator:ga0f0b3eec5ee65bd7915c4e46272287eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfab5d02f11dcede67bb61ff3ae105d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gabfab5d02f11dcede67bb61ff3ae105d2">write_xdmf_file</a> (const std::vector&lt; <a class="el" href="classXDMFEntry.html">XDMFEntry</a> &gt; &amp;entries, const std::string &amp;filename, const MPI_Comm &amp;comm) const</td></tr>
<tr class="separator:gabfab5d02f11dcede67bb61ff3ae105d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29468f4e8eca1367d44b1a2431d39e91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga29468f4e8eca1367d44b1a2431d39e91">write_hdf5_parallel</a> (const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;data_filter, const std::string &amp;filename, const MPI_Comm &amp;comm) const</td></tr>
<tr class="separator:ga29468f4e8eca1367d44b1a2431d39e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78fdf1cc5071d85ecb2d707d798bf063"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga78fdf1cc5071d85ecb2d707d798bf063">write_hdf5_parallel</a> (const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;data_filter, const <a class="el" href="classbool.html">bool</a> write_mesh_file, const std::string &amp;mesh_filename, const std::string &amp;solution_filename, const MPI_Comm &amp;comm) const</td></tr>
<tr class="separator:ga78fdf1cc5071d85ecb2d707d798bf063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga154d8192688eef96f052f50c2f669aa8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga154d8192688eef96f052f50c2f669aa8">write_filtered_data</a> (<a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;filtered_data) const</td></tr>
<tr class="separator:ga154d8192688eef96f052f50c2f669aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78e73ad285a8792ff0f9f227b82eb108"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga78e73ad285a8792ff0f9f227b82eb108">write</a> (std::ostream &amp;out, const <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> output_format=<a class="el" href="group__Exceptions.html#gaa3cbced9f1d4ae661f13018f4c980aa1aaca645a9a5b8782ed6dff8ef6b809e07">DataOutBase::default_format</a>) const</td></tr>
<tr class="separator:ga78e73ad285a8792ff0f9f227b82eb108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dab6e0fed8d4ad90d658f71a68eb32c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga6dab6e0fed8d4ad90d658f71a68eb32c">set_default_format</a> (const <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> default_format)</td></tr>
<tr class="separator:ga6dab6e0fed8d4ad90d658f71a68eb32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7280a24690b117454acfb0fa058299c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac7280a24690b117454acfb0fa058299c">set_flags</a> (const FlagType &amp;flags)</td></tr>
<tr class="separator:gac7280a24690b117454acfb0fa058299c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36120ca3f536c90709e135161030f16c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga36120ca3f536c90709e135161030f16c">default_suffix</a> (const <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> output_format=<a class="el" href="group__Exceptions.html#gaa3cbced9f1d4ae661f13018f4c980aa1aaca645a9a5b8782ed6dff8ef6b809e07">DataOutBase::default_format</a>) const</td></tr>
<tr class="separator:ga36120ca3f536c90709e135161030f16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a975649e4516ee7c7a67ae2f8dddd97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga0a975649e4516ee7c7a67ae2f8dddd97">parse_parameters</a> (<a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</td></tr>
<tr class="separator:ga0a975649e4516ee7c7a67ae2f8dddd97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ga764e9c566ca921f43ff5e1d693feb857"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga764e9c566ca921f43ff5e1d693feb857">ExcRadialVariableHasNegativeValues</a> (<a class="el" href="classdouble.html">double</a> arg1)</td></tr>
<tr class="separator:ga764e9c566ca921f43ff5e1d693feb857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f2f1d644d9cb1c4d1714d5173d159f2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga1f2f1d644d9cb1c4d1714d5173d159f2">declare_parameters</a> (<a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</td></tr>
<tr class="separator:ga1f2f1d644d9cb1c4d1714d5173d159f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aa90a504a33269e4b5c08138da3646381"><td class="memItemLeft" align="right" valign="top">static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutRotation.html#aa90a504a33269e4b5c08138da3646381">dimension</a> = DoFHandlerType::dimension</td></tr>
<tr class="separator:aa90a504a33269e4b5c08138da3646381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be219cfcba24e76099c0fd421bb1fbf"><td class="memItemLeft" align="right" valign="top">static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutRotation.html#a7be219cfcba24e76099c0fd421bb1fbf">space_dimension</a> = DoFHandlerType::space_dimension</td></tr>
<tr class="separator:a7be219cfcba24e76099c0fd421bb1fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a5d7ef9ef54d930c6cf85e37a1b155e30"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a5d7ef9ef54d930c6cf85e37a1b155e30">Patch</a> = ::<a class="el" href="structDataOutBase_1_1Patch.html">DataOutBase::Patch</a>&lt; patch_dim, patch_dim &gt;</td></tr>
<tr class="separator:a5d7ef9ef54d930c6cf85e37a1b155e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a496f2bb31228bec26f4ce73ef4166b3d"><td class="memItemLeft" align="right" valign="top">virtual const std::vector&lt; <a class="el" href="classDataOut__DoFData.html#a5d7ef9ef54d930c6cf85e37a1b155e30">Patch</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a496f2bb31228bec26f4ce73ef4166b3d">get_patches</a> () const override</td></tr>
<tr class="separator:a496f2bb31228bec26f4ce73ef4166b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e60dbfa99a1a31f520893b7145ab321"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a7e60dbfa99a1a31f520893b7145ab321">get_dataset_names</a> () const override</td></tr>
<tr class="separator:a7e60dbfa99a1a31f520893b7145ab321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf6228742921d4f04fafca0bf30e9cc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt;::<a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; DoFHandlerType::dimension, DoFHandlerType::space_dimension &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a5bf6228742921d4f04fafca0bf30e9cc">get_fes</a> () const</td></tr>
<tr class="separator:a5bf6228742921d4f04fafca0bf30e9cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34486ffea504c88c1bc3e121c8809f1e"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::tuple&lt; unsigned int, unsigned int, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a34486ffea504c88c1bc3e121c8809f1e">get_nonscalar_data_ranges</a> () const override</td></tr>
<tr class="separator:a34486ffea504c88c1bc3e121c8809f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3292ed269dfb832d20ae35db4177473"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac3292ed269dfb832d20ae35db4177473">validate_dataset_names</a> () const</td></tr>
<tr class="separator:gac3292ed269dfb832d20ae35db4177473"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:abf58679bb3ce869323a2a997415aa1df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; DoFHandlerType::dimension, DoFHandlerType::space_dimension &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#abf58679bb3ce869323a2a997415aa1df">triangulation</a></td></tr>
<tr class="separator:abf58679bb3ce869323a2a997415aa1df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a282f4d56013f02908e665353fc4b21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a6a282f4d56013f02908e665353fc4b21">dofs</a></td></tr>
<tr class="separator:a6a282f4d56013f02908e665353fc4b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6bc1c5c850d7d5c15362a5fdc936777"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classinternal_1_1DataOutImplementation_1_1DataEntryBase.html">internal::DataOutImplementation::DataEntryBase</a>&lt; DoFHandlerType::dimension, DoFHandlerType::space_dimension &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#ac6bc1c5c850d7d5c15362a5fdc936777">dof_data</a></td></tr>
<tr class="separator:ac6bc1c5c850d7d5c15362a5fdc936777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d58dd18d706e9bc613e3e635538750a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classinternal_1_1DataOutImplementation_1_1DataEntryBase.html">internal::DataOutImplementation::DataEntryBase</a>&lt; DoFHandlerType::dimension, DoFHandlerType::space_dimension &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a7d58dd18d706e9bc613e3e635538750a">cell_data</a></td></tr>
<tr class="separator:a7d58dd18d706e9bc613e3e635538750a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb583ebaa6c26c5d31c0becf5aff5558"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classDataOut__DoFData.html#a5d7ef9ef54d930c6cf85e37a1b155e30">Patch</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#adb583ebaa6c26c5d31c0becf5aff5558">patches</a></td></tr>
<tr class="separator:adb583ebaa6c26c5d31c0becf5aff5558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga072edd6d53d1c5a1e4c71af22a123228"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga072edd6d53d1c5a1e4c71af22a123228">default_subdivisions</a></td></tr>
<tr class="separator:ga072edd6d53d1c5a1e4c71af22a123228"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a4f605df329e780e741e143a9fa3ae69c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutRotation.html#a4f605df329e780e741e143a9fa3ae69c">build_one_patch</a> (const <a class="el" href="classDataOutRotation.html#ad14f7812afddb65c553cff6068bd64e0">cell_iterator</a> *cell, <a class="el" href="structinternal_1_1DataOutRotationImplementation_1_1ParallelData.html">internal::DataOutRotationImplementation::ParallelData</a>&lt; <a class="el" href="classDataOutRotation.html#aa90a504a33269e4b5c08138da3646381">dimension</a>, <a class="el" href="classDataOutRotation.html#a7be219cfcba24e76099c0fd421bb1fbf">space_dimension</a> &gt; &amp;data, std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">DataOutBase::Patch</a>&lt; <a class="el" href="classDataOutRotation.html#aa90a504a33269e4b5c08138da3646381">dimension</a>+1, <a class="el" href="classDataOutRotation.html#a7be219cfcba24e76099c0fd421bb1fbf">space_dimension</a>+1 &gt;&gt; &amp;my_patches)</td></tr>
<tr class="separator:a4f605df329e780e741e143a9fa3ae69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8cca59e1dd63590824828c21f5854a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#aa8cca59e1dd63590824828c21f5854a0">add_data_vector_internal</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; *dof_handler, const VectorType &amp;data, const std::vector&lt; std::string &gt; &amp;names, const <a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27">DataVectorType</a> type, const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;data_component_interpretation, const <a class="el" href="classbool.html">bool</a> deduce_output_names)</td></tr>
<tr class="separator:aa8cca59e1dd63590824828c21f5854a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ga82c974193222c8c3c3950a6b9047328d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga82c974193222c8c3c3950a6b9047328d">default_fmt</a></td></tr>
<tr class="separator:ga82c974193222c8c3c3950a6b9047328d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebcd8f42c70f0b26f34e7e62b8808b35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDataOutBase_1_1DXFlags.html">DataOutBase::DXFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaebcd8f42c70f0b26f34e7e62b8808b35">dx_flags</a></td></tr>
<tr class="separator:gaebcd8f42c70f0b26f34e7e62b8808b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77b3216d3e76e2ed65ad6967d2ca42b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDataOutBase_1_1UcdFlags.html">DataOutBase::UcdFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga77b3216d3e76e2ed65ad6967d2ca42b5">ucd_flags</a></td></tr>
<tr class="separator:ga77b3216d3e76e2ed65ad6967d2ca42b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8466681c18e24c0b3c7af7eae5e0997e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDataOutBase_1_1GnuplotFlags.html">DataOutBase::GnuplotFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga8466681c18e24c0b3c7af7eae5e0997e">gnuplot_flags</a></td></tr>
<tr class="separator:ga8466681c18e24c0b3c7af7eae5e0997e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77a68867f11f41af91470c37b930cac8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDataOutBase_1_1PovrayFlags.html">DataOutBase::PovrayFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga77a68867f11f41af91470c37b930cac8">povray_flags</a></td></tr>
<tr class="separator:ga77a68867f11f41af91470c37b930cac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8b6e70c57dd3994130304d33fc0a0fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDataOutBase_1_1EpsFlags.html">DataOutBase::EpsFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gae8b6e70c57dd3994130304d33fc0a0fd">eps_flags</a></td></tr>
<tr class="separator:gae8b6e70c57dd3994130304d33fc0a0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62aad8dd9acbe017b15757d419d356ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDataOutBase_1_1GmvFlags.html">DataOutBase::GmvFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga62aad8dd9acbe017b15757d419d356ae">gmv_flags</a></td></tr>
<tr class="separator:ga62aad8dd9acbe017b15757d419d356ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga295e120b8f3a3f38f94810e82a5aa90d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDataOutBase_1_1TecplotFlags.html">DataOutBase::TecplotFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga295e120b8f3a3f38f94810e82a5aa90d">tecplot_flags</a></td></tr>
<tr class="separator:ga295e120b8f3a3f38f94810e82a5aa90d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae690412df124f4dcea1b34450535ce83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gae690412df124f4dcea1b34450535ce83">vtk_flags</a></td></tr>
<tr class="separator:gae690412df124f4dcea1b34450535ce83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe7a9711c62ab10adf2e629c4fceafa5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDataOutBase_1_1SvgFlags.html">DataOutBase::SvgFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gabe7a9711c62ab10adf2e629c4fceafa5">svg_flags</a></td></tr>
<tr class="separator:gabe7a9711c62ab10adf2e629c4fceafa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d1bb3d43066b0163db165f79b93a6de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDataOutBase_1_1Deal__II__IntermediateFlags.html">DataOutBase::Deal_II_IntermediateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga0d1bb3d43066b0163db165f79b93a6de">deal_II_intermediate_flags</a></td></tr>
<tr class="separator:ga0d1bb3d43066b0163db165f79b93a6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, typename DoFHandlerType = DoFHandler&lt;dim&gt;&gt;<br />
class DataOutRotation&lt; dim, DoFHandlerType &gt;</h3>

<p>This class generates output in the full domain of computations that were done using rotational symmetry of domain and solution. In particular, if a computation of a three dimensional problem with rotational symmetry around the <code>z-axis</code> (i.e. in the <code>r-z-plane</code>) was done, then this class can be used to generate the output in the original <code>x-y-z</code> space. In order to do so, it generates from each cell in the computational mesh a cell in the space with dimension one greater than that of the <a class="el" href="classDoFHandler.html">DoFHandler</a> object. The resulting output will then consist of hexahedra forming an object that has rotational symmetry around the z-axis. As most graphical programs can not represent ring-like structures, the angular (rotation) variable is discretized into a finite number of intervals as well; the number of these intervals must be given to the <code>build_patches</code> function. It is noted, however, that while this function generates nice pictures of the whole domain, it often produces <em>very</em> large output files.</p>
<h3>Interface</h3>
<p>The interface of this class is copied from the <a class="el" href="classDataOut.html">DataOut</a> class. Furthermore, they share the common parent class <a class="el" href="classDataOut__DoFData.html#ad4dd3ef4d97b4ab200c15da17734479d">DataOut_DoFData()</a>. See the reference of these two classes for a discussion of the interface and how to extend it by deriving further classes from this class.</p>
<h3>Details for 1d computations</h3>
<p>The one coordinate in the triangulation used by the <a class="el" href="classDoFHandler.html">DoFHandler</a> object passed to this class is taken as the radial variable, and the output will then be either a circle or a ring domain. It is in the user's responsibility to assure that the radial coordinate only attains non- negative values.</p>
<h3>Details for 2d computations</h3>
<p>We consider the computation (represented by the <a class="el" href="classDoFHandler.html">DoFHandler</a> object that is attached to this class) to have happened in the <code>r-z-plane</code>, where <code>r</code> is the radial variable and <code>z</code> denotes the axis of revolution around which the solution is symmetric. The output is in <code>x-y-z</code> space, where the radial dependence is transformed to the <code>x-y</code> plane. At present, it is not possible to exchange the meaning of the first and second variable of the plane in which the simulation was made, i.e. generate output from a simulation where the first variable denoted the symmetry axis, and the second denoted the radial variable. You have to take that into account when first programming your application.</p>
<p>It is in the responsibility of the user to make sure that the radial variable attains only non-negative values.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This class only makes sense if the first template argument, <code>dim</code> equals the dimension of the <a class="el" href="classDoFHandler.html">DoFHandler</a> type given as the second template argument, i.e., if <code>dim == DoFHandlerType::dimension</code>. This redundancy is a historical relic from the time where the library had only a single <a class="el" href="classDoFHandler.html">DoFHandler</a> class and this class consequently only a single template argument. </dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__rotation_8h_source.html#l00122">122</a> of file <a class="el" href="data__out__rotation_8h_source.html">data_out_rotation.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ad14f7812afddb65c553cff6068bd64e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad14f7812afddb65c553cff6068bd64e0">&#9670;&nbsp;</a></span>cell_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType  = DoFHandler&lt;dim&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDataOutRotation.html">DataOutRotation</a>&lt; dim, DoFHandlerType &gt;::<a class="el" href="classDataOutRotation.html#ad14f7812afddb65c553cff6068bd64e0">cell_iterator</a> =  typename <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt;DoFHandlerType, <a class="el" href="classDataOutRotation.html#aa90a504a33269e4b5c08138da3646381">dimension</a> + 1&gt;::<a class="el" href="classDataOutRotation.html#ad14f7812afddb65c553cff6068bd64e0">cell_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef to the iterator type of the dof handler class under consideration. </p>

<p class="definition">Definition at line <a class="el" href="data__out__rotation_8h_source.html#l00142">142</a> of file <a class="el" href="data__out__rotation_8h_source.html">data_out_rotation.h</a>.</p>

</div>
</div>
<a id="a5d7ef9ef54d930c6cf85e37a1b155e30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d7ef9ef54d930c6cf85e37a1b155e30">&#9670;&nbsp;</a></span>Patch</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_dim  &gt;::<a class="el" href="classDataOut__DoFData.html#a5d7ef9ef54d930c6cf85e37a1b155e30">Patch</a> =  ::<a class="el" href="structDataOutBase_1_1Patch.html">DataOutBase::Patch</a>&lt;patch_dim, patch_dim &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Abbreviate the somewhat lengthy name for the Patch class. </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00965">965</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a062005bfe37e877e1f44e1c3e8e6cb27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a062005bfe37e877e1f44e1c3e8e6cb27">&#9670;&nbsp;</a></span>DataVectorType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27">DataOut_DoFData::DataVectorType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Type describing what the vector given to <a class="el" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector()</a> is: a vector that has one entry per degree of freedom in a <a class="el" href="classDoFHandler.html">DoFHandler</a> object (such as solution vectors), or one entry per cell in the triangulation underlying the <a class="el" href="classDoFHandler.html">DoFHandler</a> object (such as error per cell data). The value <a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27ad7189bcb96ade9f785a40b8959ac443e">type_automatic</a> tells <a class="el" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector()</a> to find out itself (see the documentation of <a class="el" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector()</a> for the method used). </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00617">617</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9ba0c7778094b954fccd774ef350040d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ba0c7778094b954fccd774ef350040d">&#9670;&nbsp;</a></span>build_patches()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutRotation.html">DataOutRotation</a>&lt; dim, DoFHandlerType &gt;::build_patches </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_patches_per_circle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_subdivisions</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the central function of this class since it builds the list of patches to be written by the low-level functions of the base class. A patch is, in essence, some intermediate representation of the data on each cell of a triangulation and <a class="el" href="classDoFHandler.html">DoFHandler</a> object that can then be used to write files in some format that is readable by visualization programs.</p>
<p>You can find an overview of the use of this function in the general documentation of this class. An example is also provided in the documentation of this class's base class <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_patches_per_circle</td><td>Denotes into how many intervals the angular (rotation) variable is to be subdivided.</td></tr>
    <tr><td class="paramname">n_subdivisions</td><td>See <a class="el" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">DataOut::build_patches()</a> for an extensive description of this parameter. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="data__out__rotation_8cc_source.html#l00456">456</a> of file <a class="el" href="data__out__rotation_8cc_source.html">data_out_rotation.cc</a>.</p>

</div>
</div>
<a id="ab6820c4e0f27a15573e6522620caab58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6820c4e0f27a15573e6522620caab58">&#9670;&nbsp;</a></span>first_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataOutRotation.html">DataOutRotation</a>&lt; dim, DoFHandlerType &gt;::<a class="el" href="classDataOutRotation.html#ad14f7812afddb65c553cff6068bd64e0">cell_iterator</a> <a class="el" href="classDataOutRotation.html">DataOutRotation</a>&lt; dim, DoFHandlerType &gt;::first_cell</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the first cell which we want output for. The default implementation returns the first <a class="el" href="DEALGlossary.html#GlossActive">active cell</a>, but you might want to return other cells in a derived class. </p>

<p class="definition">Definition at line <a class="el" href="data__out__rotation_8cc_source.html#l00557">557</a> of file <a class="el" href="data__out__rotation_8cc_source.html">data_out_rotation.cc</a>.</p>

</div>
</div>
<a id="a341f76fc14af202fa3598454eda22364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a341f76fc14af202fa3598454eda22364">&#9670;&nbsp;</a></span>next_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataOutRotation.html">DataOutRotation</a>&lt; dim, DoFHandlerType &gt;::<a class="el" href="classDataOutRotation.html#ad14f7812afddb65c553cff6068bd64e0">cell_iterator</a> <a class="el" href="classDataOutRotation.html">DataOutRotation</a>&lt; dim, DoFHandlerType &gt;::next_cell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataOutRotation.html#ad14f7812afddb65c553cff6068bd64e0">cell_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the next cell after <code>cell</code> which we want output for. If there are no more cells, <code>dofs-&gt;<a class="el" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end()</a></code> shall be returned.</p>
<p>The default implementation returns the next active cell, but you might want to return other cells in a derived class. Note that the default implementation assumes that the given <code>cell</code> is active, which is guaranteed as long as <code>first_cell</code> is also used from the default implementation. Overloading only one of the two functions might not be a good idea. </p>

<p class="definition">Definition at line <a class="el" href="data__out__rotation_8cc_source.html#l00565">565</a> of file <a class="el" href="data__out__rotation_8cc_source.html">data_out_rotation.cc</a>.</p>

</div>
</div>
<a id="a4f605df329e780e741e143a9fa3ae69c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f605df329e780e741e143a9fa3ae69c">&#9670;&nbsp;</a></span>build_one_patch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutRotation.html">DataOutRotation</a>&lt; dim, DoFHandlerType &gt;::build_one_patch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataOutRotation.html#ad14f7812afddb65c553cff6068bd64e0">cell_iterator</a> *&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal_1_1DataOutRotationImplementation_1_1ParallelData.html">internal::DataOutRotationImplementation::ParallelData</a>&lt; <a class="el" href="classDataOutRotation.html#aa90a504a33269e4b5c08138da3646381">dimension</a>, <a class="el" href="classDataOutRotation.html#a7be219cfcba24e76099c0fd421bb1fbf">space_dimension</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">DataOutBase::Patch</a>&lt; <a class="el" href="classDataOutRotation.html#aa90a504a33269e4b5c08138da3646381">dimension</a>+1, <a class="el" href="classDataOutRotation.html#a7be219cfcba24e76099c0fd421bb1fbf">space_dimension</a>+1 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>my_patches</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Build all of the patches that correspond to the cell given in the first argument. Use the second argument as scratch space for parallel invocation in <a class="el" href="namespaceWorkStream.html">WorkStream</a>, and put the results into the last argument. </p>

<p class="definition">Definition at line <a class="el" href="data__out__rotation_8cc_source.html#l00103">103</a> of file <a class="el" href="data__out__rotation_8cc_source.html">data_out_rotation.cc</a>.</p>

</div>
</div>
<a id="ac1eb26168177faa30ffbcf9cbb9c3cd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1eb26168177faa30ffbcf9cbb9c3cd5">&#9670;&nbsp;</a></span>attach_dof_handler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_dim  &gt;::attach_dof_handler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt;  &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Designate a dof handler to be used to extract geometry data and the mapping between nodes and node values. This call is not necessary if all added data vectors are supplemented with a <a class="el" href="classDoFHandler.html">DoFHandler</a> argument.</p>
<p>This call is optional: If you add data vectors with specified <a class="el" href="classDoFHandler.html">DoFHandler</a> object, then that contains all information needed to generate the output. </p>

</div>
</div>
<a id="a0a8d4fbc99c408d956c4685fd4c97b99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a8d4fbc99c408d956c4685fd4c97b99">&#9670;&nbsp;</a></span>attach_triangulation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_dim  &gt;::attach_triangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; DoFHandlerType::dimension, DoFHandlerType::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Designate a triangulation to be used to extract geometry data and the mapping between nodes and node values.</p>
<p>This call is optional: If you add data vectors with specified <a class="el" href="classDoFHandler.html">DoFHandler</a> object, then that contains all information needed to generate the output. This call is useful when you only output cell vectors and no <a class="el" href="classDoFHandler.html">DoFHandler</a> at all, in which case it provides the geometry. </p>

</div>
</div>
<a id="ace4b76e565ba0701c4d32c26075ed3b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace4b76e565ba0701c4d32c26075ed3b9">&#9670;&nbsp;</a></span>add_data_vector() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_dim  &gt;::add_data_vector </td>
          <td>(</td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27">DataVectorType</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27ad7189bcb96ade9f785a40b8959ac443e">type_automatic</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_component_interpretation</em> = <code>std::vector&lt;&#160;<a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a data vector together with its name.</p>
<p>A pointer to the vector is stored, so you have to make sure the vector exists at that address at least as long as you call the <code>write_*</code> functions.</p>
<p>It is assumed that the vector has the same number of components as there are degrees of freedom in the dof handler, in which case it is assumed to be a vector storing nodal data; or the size may be the number of active cells on the present grid, in which case it is assumed to be a cell data vector. As the number of degrees of freedom and of cells is usually not equal, the function can determine itself which type of vector it is given. However, there are corner cases where this automatic determination does not work. One example is if you compute with piecewise constant elements and have a scalar solution, then there are as many cells as there are degrees of freedom (though they may be numbered differently). Another possibility is if you have a 1d mesh embedded in 2d space and the mesh consists of a closed curve of cells; in this case, there are as many nodes as there are cells, and when using a Q1 element you will have as many degrees of freedom as there are cells. In these cases, you can change the last argument of the function from its default value <a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27ad7189bcb96ade9f785a40b8959ac443e">type_automatic</a> to either <a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27ab25a70fb259c0f1d7a1a18fd6c772227">type_dof_data</a> or <a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27ad2ce9bc33018440a67440bb15791d751">type_cell_data</a>, depending on what the vector represents. Apart from such corner cases, you can leave the argument at its default value and let the function determine the type of the vector itself.</p>
<p>If it is a vector holding DoF data, the names given shall be one for each component of the underlying finite element. If it is a finite element composed of only one subelement, then there is another function following which takes a single name instead of a vector of names.</p>
<p>The data_component_interpretation argument contains information about how the individual components of output files that consist of more than one data set are to be interpreted.</p>
<p>For example, if one has a finite element for the Stokes equations in 2d, representing components (u,v,p), one would like to indicate that the first two, u and v, represent a logical vector so that later on when we generate graphical output we can hand them off to a visualization program that will automatically know to render them as a vector field, rather than as two separate and independent scalar fields.</p>
<p>The default value of this argument (i.e. an empty vector) corresponds is equivalent to a vector of values <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>, indicating that all output components are independent scalar fields. However, if the given data vector represents logical vectors, you may pass a vector that contains values <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>. In the example above, one would pass in a vector with components (<a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>) for (u,v,p).</p>
<p>The names of a data vector shall only contain characters which are letters, underscore and a few other ones. Refer to the ExcInvalidCharacter exception declared in this class to see which characters are valid and which are not.</p>
<dl class="section note"><dt>Note</dt><dd>The actual type for the vector argument may be any vector type from which <a class="el" href="classFEValues.html">FEValues</a> can extract values on a cell using the <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValuesBase::get_function_values()</a> function.</dd>
<dd>
When working in parallel, the vector to be written needs to be ghosted with read access to all degrees of freedom on the locally owned cells, see the <a class="el" href="step_40.html">step-40</a> or <a class="el" href="step_37.html">step-37</a> tutorial programs for details, i.e., it might be necessary to call data.update_ghost_values(). </dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00739">739</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a65f47f598ad14b15eb519350a2846432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65f47f598ad14b15eb519350a2846432">&#9670;&nbsp;</a></span>add_data_vector() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_dim  &gt;::add_data_vector </td>
          <td>(</td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27">DataVectorType</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27ad7189bcb96ade9f785a40b8959ac443e">type_automatic</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_component_interpretation</em> = <code>std::vector&lt;&#160;<a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is an abbreviation to the above one (see there for a discussion of the various arguments), intended for use with finite elements that are not composed of subelements. In this case, only one name per data vector needs to be given, which is what this function takes. It simply relays its arguments after a conversion of the <code>name</code> to a vector of strings, to the other <a class="el" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector()</a> function above.</p>
<p>If <code>data</code> is a vector with multiple components this function will generate distinct names for all components by appending an underscore and the number of each component to <code>name</code> </p>
<p>The actual type for the template argument may be any vector type from which <a class="el" href="classFEValues.html">FEValues</a> can extract values on a cell using the <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValuesBase::get_function_values()</a> function. </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00765">765</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a4bce7f46c9ad03ecdd71a86d47f8fb11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bce7f46c9ad03ecdd71a86d47f8fb11">&#9670;&nbsp;</a></span>add_data_vector() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_dim  &gt;::add_data_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt;  &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_component_interpretation</em> = <code>std::vector&lt;&#160;<a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is an extension of the above one (see there for a discussion of the arguments except the first one) and allows to set a vector with its own <a class="el" href="classDoFHandler.html">DoFHandler</a> object. This <a class="el" href="classDoFHandler.html">DoFHandler</a> needs to be compatible with the other <a class="el" href="classDoFHandler.html">DoFHandler</a> objects assigned with calls to <code>add_data_vector</code> or <code>attach_dof_handler</code>, in the sense that all of the <a class="el" href="classDoFHandler.html">DoFHandler</a> objects need to be based on the same triangulation. This function allows you to export data from multiple <a class="el" href="classDoFHandler.html">DoFHandler</a> objects that describe different solution components. An example of using this function is given in <a class="el" href="step_61.html">step-61</a>.</p>
<p>Since this function takes a <a class="el" href="classDoFHandler.html">DoFHandler</a> object and hence naturally represents dof data, the data vector type argument present in the other methods above is not necessary. </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00790">790</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a5ed745ab12b197a57cc5e22af0fcd8a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ed745ab12b197a57cc5e22af0fcd8a7">&#9670;&nbsp;</a></span>add_data_vector() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_dim  &gt;::add_data_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt;  &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_component_interpretation</em> = <code>std::vector&lt;&#160;<a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is an abbreviation of the function above with only a scalar <code>dof_handler</code> given and a single data name. </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00805">805</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a4f6aa38d46f054f61211dbc02a16e384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f6aa38d46f054f61211dbc02a16e384">&#9670;&nbsp;</a></span>add_data_vector() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_dim  &gt;::add_data_vector </td>
          <td>(</td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; DoFHandlerType::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_postprocessor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is an alternative to the above ones, allowing the output of derived quantities instead of the given data. This conversion has to be done in a class derived from <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>. This function is used in <a class="el" href="step_29.html">step-29</a>. Other uses are shown in <a class="el" href="step_32.html">step-32</a> and <a class="el" href="step_33.html">step-33</a>.</p>
<p>The names for these derived quantities are provided by the <code>data_postprocessor</code> argument. Likewise, the data_component_interpretation argument of the other <a class="el" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector()</a> functions is provided by the data_postprocessor argument. As only data of type <code>type_dof_data</code> can be transformed, this type is also known implicitly and does not have to be given.</p>
<dl class="section note"><dt>Note</dt><dd>The actual type for the vector argument may be any vector type from which <a class="el" href="classFEValues.html">FEValues</a> can extract values on a cell using the <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValuesBase::get_function_values()</a> function.</dd>
<dd>
The <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> object (i.e., in reality the object of your derived class) has to live until the <a class="el" href="classDataOut.html">DataOut</a> object is destroyed as the latter keeps a pointer to the former and will complain if the object pointed to is destroyed while the latter still has a pointer to it. If both the data postprocessor and <a class="el" href="classDataOut.html">DataOut</a> objects are local variables of a function (as they are, for example, in <a class="el" href="step_29.html">step-29</a>), then you can avoid this error by declaring the data postprocessor variable before the <a class="el" href="classDataOut.html">DataOut</a> variable as objects are destroyed in reverse order of declaration. </dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00841">841</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a444344dcaaff07df72672b57001e1c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a444344dcaaff07df72672b57001e1c27">&#9670;&nbsp;</a></span>add_data_vector() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_dim  &gt;::add_data_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt;  &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; DoFHandlerType::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_postprocessor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same function as above, but with a <a class="el" href="classDoFHandler.html">DoFHandler</a> object that does not need to coincide with the <a class="el" href="classDoFHandler.html">DoFHandler</a> initially set. Note that the postprocessor can only read data from the given <a class="el" href="classDoFHandler.html">DoFHandler</a> and solution vector, not other solution vectors or DoFHandlers. </p>

</div>
</div>
<a id="ab1f52f05c045de7fa390449c1ed339c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1f52f05c045de7fa390449c1ed339c1">&#9670;&nbsp;</a></span>add_mg_data_vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_dim  &gt;::add_mg_data_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt;  &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMGLevelObject.html">MGLevelObject</a>&lt; VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_component_interpretation</em> = <code>std::vector&lt;&#160;<a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a multilevel data vector.</p>
<p>This function adds the vector-valued multilevel vector <code>data</code> in the form of a vector on each level that belongs to the <a class="el" href="classDoFHandler.html">DoFHandler</a> <code>dof_handler</code> to the graphical output. This function is typically used in conjunction with a call to set_cell_selection() that selects cells on a specific level and not the active cells (the default).</p>
<p>A vector <code>data</code> can be obtained in several ways, for example by using <a class="el" href="classMultigrid.html#a2614db3c885e19f89b2df14422634c22">Multigrid::solution</a> or <a class="el" href="classMultigrid.html#adecf4e39189911da5096d1112c91680b">Multigrid::defect</a> during or after a multigrid cycle or by interpolating a solution via <a class="el" href="classMGTransferMatrixFree.html#a90aef560cc3d832589ca13a5f18e1414">MGTransferMatrixFree::interpolate_to_mg()</a>.</p>
<p>The handling of <code>names</code> and <code>data_component_interpretation</code> is identical to the <a class="el" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector()</a> function. </p>

</div>
</div>
<a id="a90c63ba80dac30bc2a18664a154d8e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90c63ba80dac30bc2a18664a154d8e80">&#9670;&nbsp;</a></span>add_mg_data_vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_dim  &gt;::add_mg_data_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt;  &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMGLevelObject.html">MGLevelObject</a>&lt; VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scalar version of the function above. </p>

</div>
</div>
<a id="a38df03770155948e7f702e14599e28e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38df03770155948e7f702e14599e28e7">&#9670;&nbsp;</a></span>clear_data_vectors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_dim  &gt;::clear_data_vectors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Release the pointers to the data vectors. This allows output of a new set of vectors without supplying the DoF handler again. Therefore, the <a class="el" href="classDataOut.html">DataOut</a> object can be used in an algebraic context. Note that besides the data vectors also the patches already computed are deleted. </p>

</div>
</div>
<a id="a1bda326e895cf4b1489d271cb358cfdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bda326e895cf4b1489d271cb358cfdd">&#9670;&nbsp;</a></span>clear_input_data_references()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_dim  &gt;::clear_input_data_references </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Release pointers to all input data elements, i.e. pointers to data vectors and to the DoF handler object. This function may be useful when you have called the <code>build_patches</code> function of derived class, since then the patches are built and the input data is no more needed, nor is there a need to reference it. You can then output the patches detached from the main thread and need not make sure anymore that the DoF handler object and vectors must not be deleted before the output thread is finished. </p>

</div>
</div>
<a id="a4d51e2c8ddb56ac1306927c502cd5983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d51e2c8ddb56ac1306927c502cd5983">&#9670;&nbsp;</a></span>merge_patches()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_dim  &gt;::merge_patches </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; DoFHandlerType2, patch_dim, patch_dim  &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; patch_dim  &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em> = <code><a class="el" href="classPoint.html">Point</a>&lt;patch_space_dim&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function can be used to merge the patches that were created using the <code>build_patches</code> function of the object given as argument into the list of patches created by this object. This is sometimes handy if one has, for example, a domain decomposition algorithm where each block is represented by a <a class="el" href="classDoFHandler.html">DoFHandler</a> of its own, but one wants to output the solution on all the blocks at the same time.</p>
<p>For this to work, the given argument and this object need to have the same number of output vectors, and they need to use the same number of subdivisions per patch. The output will probably look rather funny if patches in both objects overlap in space.</p>
<p>If you call <a class="el" href="classDataOutRotation.html#a9ba0c7778094b954fccd774ef350040d">build_patches()</a> for this object after merging in patches, the previous state is overwritten, and the merged-in patches are lost.</p>
<p>The second parameter allows to shift each node of the patches in the object passed in in the first parameter by a certain amount. This is sometimes useful to generate "exploded" views of a collection of blocks.</p>
<p>This function will fail if either this or the other object did not yet set up any patches. </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00941">941</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a4769fe891f8d7f9caa1ba4f854484958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4769fe891f8d7f9caa1ba4f854484958">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_dim  &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Release the pointers to the data vectors and the DoF handler. You have to set all data entries again using the <a class="el" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector()</a> function. The pointer to the dof handler is cleared as well, along with all other data. In effect, this function resets everything to a virgin state. </p>

</div>
</div>
<a id="af605c2840093a5f03e873153544da225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af605c2840093a5f03e873153544da225">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_dim  &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. </p>

</div>
</div>
<a id="a496f2bb31228bec26f4ce73ef4166b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a496f2bb31228bec26f4ce73ef4166b3d">&#9670;&nbsp;</a></span>get_patches()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::vector&lt;<a class="el" href="classDataOut__DoFData.html#a5d7ef9ef54d930c6cf85e37a1b155e30">Patch</a>&gt;&amp; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_dim  &gt;::get_patches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function by which the base class's functions get to know what patches they shall write to a file. </p>

<p>Implements <a class="el" href="group__Exceptions.html#ga7c3eeef4bc56cdb85c31e05dc09dae72">DataOutInterface&lt; patch_dim, patch_dim &gt;</a>.</p>

</div>
</div>
<a id="a7e60dbfa99a1a31f520893b7145ab321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e60dbfa99a1a31f520893b7145ab321">&#9670;&nbsp;</a></span>get_dataset_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_dim  &gt;::get_dataset_names </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Virtual function through which the names of data sets are obtained by the output functions of the base class. </p>

<p>Implements <a class="el" href="group__Exceptions.html#ga128e5dec286cc1a429b94e29dd55ab81">DataOutInterface&lt; patch_dim, patch_dim &gt;</a>.</p>

</div>
</div>
<a id="a5bf6228742921d4f04fafca0bf30e9cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bf6228742921d4f04fafca0bf30e9cc">&#9670;&nbsp;</a></span>get_fes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::shared_ptr&lt;::<a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt;DoFHandlerType::dimension, DoFHandlerType::space_dimension&gt; &gt; &gt; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_dim  &gt;::get_fes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Extracts the finite elements stored in the dof_data object, including a dummy object of FE_DGQ&lt;dim&gt;(0) in case only the triangulation is used. </p>

</div>
</div>
<a id="a34486ffea504c88c1bc3e121c8809f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34486ffea504c88c1bc3e121c8809f1e">&#9670;&nbsp;</a></span>get_nonscalar_data_ranges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; std::tuple&lt;unsigned int, unsigned int, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt; &gt; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_dim  &gt;::get_nonscalar_data_ranges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of the respective <a class="el" href="group__Exceptions.html#ga05d5d72abcf81f4174e15fd984f1267c">DataOutInterface::get_nonscalar_data_ranges()</a> function. See there for a more extensive documentation. </p>

<p>Reimplemented from <a class="el" href="group__Exceptions.html#ga05d5d72abcf81f4174e15fd984f1267c">DataOutInterface&lt; patch_dim, patch_dim &gt;</a>.</p>

</div>
</div>
<a id="aa8cca59e1dd63590824828c21f5854a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8cca59e1dd63590824828c21f5854a0">&#9670;&nbsp;</a></span>add_data_vector_internal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_dim  &gt;::add_data_vector_internal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt;  *&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27">DataVectorType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_component_interpretation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>deduce_output_names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Common function called by the four public add_data_vector methods. </p>

</div>
</div>
<a id="gafc05be5cd920b234e68548735852446e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc05be5cd920b234e68548735852446e">&#9670;&nbsp;</a></span>write_dx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_dx </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Obtain data through <a class="el" href="classDataOut__DoFData.html#a496f2bb31228bec26f4ce73ef4166b3d">get_patches()</a> and write it to <code>out</code> in OpenDX format. See <a class="el" href="namespaceDataOutBase.html#a75750d50e3d27159f8a1e4de7f0a8f32">DataOutBase::write_dx</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l02576">2576</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="gaea2031a2a6fe56c9b7d3f9f338f20882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea2031a2a6fe56c9b7d3f9f338f20882">&#9670;&nbsp;</a></span>write_eps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_eps </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Obtain data through <a class="el" href="classDataOut__DoFData.html#a496f2bb31228bec26f4ce73ef4166b3d">get_patches()</a> and write it to <code>out</code> in EPS format. See <a class="el" href="namespaceDataOutBase.html#a98914588b1516419a572a1718b1bf3d5">DataOutBase::write_eps</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l02583">2583</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="gae7f2c3305058c94333d8aa699286b807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7f2c3305058c94333d8aa699286b807">&#9670;&nbsp;</a></span>write_gmv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_gmv </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Obtain data through <a class="el" href="classDataOut__DoFData.html#a496f2bb31228bec26f4ce73ef4166b3d">get_patches()</a> and write it to <code>out</code> in GMV format. See <a class="el" href="namespaceDataOutBase.html#afa4389cfc36770d2881867f6889bc348">DataOutBase::write_gmv</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l02590">2590</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ga85407e870a68179ebe62410d9efc153f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85407e870a68179ebe62410d9efc153f">&#9670;&nbsp;</a></span>write_gnuplot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_gnuplot </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Obtain data through <a class="el" href="classDataOut__DoFData.html#a496f2bb31228bec26f4ce73ef4166b3d">get_patches()</a> and write it to <code>out</code> in GNUPLOT format. See <a class="el" href="namespaceDataOutBase.html#a3cfd561a7b5262f83e3cdc4020b377f4">DataOutBase::write_gnuplot</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l02597">2597</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ga33a15f01cb0171da2956be68ad496cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33a15f01cb0171da2956be68ad496cd0">&#9670;&nbsp;</a></span>write_povray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_povray </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Obtain data through <a class="el" href="classDataOut__DoFData.html#a496f2bb31228bec26f4ce73ef4166b3d">get_patches()</a> and write it to <code>out</code> in POVRAY format. See <a class="el" href="namespaceDataOutBase.html#ae661c9d7979da0c39b5f08fd715ed947">DataOutBase::write_povray</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l02604">2604</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ga980b995a6f5944a75721097de39069c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga980b995a6f5944a75721097de39069c1">&#9670;&nbsp;</a></span>write_tecplot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_tecplot </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Obtain data through <a class="el" href="classDataOut__DoFData.html#a496f2bb31228bec26f4ce73ef4166b3d">get_patches()</a> and write it to <code>out</code> in Tecplot format. See <a class="el" href="namespaceDataOutBase.html#ab9f9f33c200120450b6844d986a83604">DataOutBase::write_tecplot</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l02611">2611</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ga2bf06b8647892769140884b3ab44a08e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bf06b8647892769140884b3ab44a08e">&#9670;&nbsp;</a></span>write_ucd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_ucd </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Obtain data through <a class="el" href="classDataOut__DoFData.html#a496f2bb31228bec26f4ce73ef4166b3d">get_patches()</a> and write it to <code>out</code> in UCD format for AVS. See <a class="el" href="namespaceDataOutBase.html#a5ec32be3e3379b7c83dc339f52cf2ad6">DataOutBase::write_ucd</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l02618">2618</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="gacad99726038e4fca7f605fdffb3317e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacad99726038e4fca7f605fdffb3317e4">&#9670;&nbsp;</a></span>write_vtk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_vtk </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Obtain data through <a class="el" href="classDataOut__DoFData.html#a496f2bb31228bec26f4ce73ef4166b3d">get_patches()</a> and write it to <code>out</code> in Vtk format. See <a class="el" href="namespaceDataOutBase.html#a336d97147011f5f8f3746cac0a3ca4ab">DataOutBase::write_vtk</a>.</p>
<dl class="section note"><dt>Note</dt><dd>VTK is a legacy format and has largely been supplanted by the VTU format (an XML-structured version of VTK). In particular, VTU allows for the compression of data and consequently leads to much smaller file sizes that equivalent VTK files for large files. Since all visualization programs that support VTK also support VTU, you should consider using the latter file format instead, by using the <a class="el" href="group__Exceptions.html#ga93c780f93105e0daaa76c6c43694b4ae">write_vtu()</a> function. </dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l02632">2632</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ga93c780f93105e0daaa76c6c43694b4ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93c780f93105e0daaa76c6c43694b4ae">&#9670;&nbsp;</a></span>write_vtu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_vtu </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Obtain data through <a class="el" href="classDataOut__DoFData.html#a496f2bb31228bec26f4ce73ef4166b3d">get_patches()</a> and write it to <code>out</code> in Vtu (VTK's XML) format. See <a class="el" href="namespaceDataOutBase.html#a3aec479936b78bd0ec2ecc3674e24584">DataOutBase::write_vtu</a>.</p>
<p>Some visualization programs, such as ParaView, can read several separate VTU files to parallelize visualization. In that case, you need a <code>.pvtu</code> file that describes which VTU files form a group. The <a class="el" href="group__Exceptions.html#ga1eff778443cd0431cd807c45b6ae16d9">DataOutInterface::write_pvtu_record()</a> function can generate such a centralized record. Likewise, <a class="el" href="namespaceDataOutBase.html#a482d9621dcc87d6a43cf8a9651e16cd8">DataOutInterface::write_visit_record()</a> does the same for older versions of VisIt (although VisIt can also read <code>pvtu</code> records since version 2.5.1). Finally, <a class="el" href="namespaceDataOutBase.html#a6f1c052ba49fd44cd8e3f35ba871aebd">DataOutInterface::write_pvd_record()</a> can be used to group together the files that jointly make up a time dependent simulation. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l02649">2649</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ga5df488dad82b811ceb08cb1adf9eafcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5df488dad82b811ceb08cb1adf9eafcd">&#9670;&nbsp;</a></span>write_vtu_in_parallel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_vtu_in_parallel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Collective MPI call to write the solution from all participating nodes (those in the given communicator) to a single compressed .vtu file on a shared file system. The communicator can be a sub communicator of the one used by the computation. This routine uses MPI I/O to achieve high performance on parallel filesystems. Also see <a class="el" href="group__Exceptions.html#ga93c780f93105e0daaa76c6c43694b4ae">DataOutInterface::write_vtu()</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l02660">2660</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ga1eff778443cd0431cd807c45b6ae16d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1eff778443cd0431cd807c45b6ae16d9">&#9670;&nbsp;</a></span>write_pvtu_record()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_pvtu_record </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>piece_names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Some visualization programs, such as ParaView, can read several separate VTU files that all form part of the same simulation, in order to parallelize visualization. In that case, you need a <code>.pvtu</code> file that describes which VTU files (written, for example, through the <a class="el" href="group__Exceptions.html#ga93c780f93105e0daaa76c6c43694b4ae">DataOutInterface::write_vtu()</a> function) form a group. The current function can generate such a centralized record.</p>
<p>The central record file generated by this function contains a list of (scalar or vector) fields that describes which fields can actually be found in the individual files that comprise the set of parallel VTU files along with the names of these files. This function gets the names and types of fields through the <a class="el" href="classDataOut__DoFData.html#a7e60dbfa99a1a31f520893b7145ab321">get_dataset_names()</a> and <a class="el" href="classDataOut__DoFData.html#a34486ffea504c88c1bc3e121c8809f1e">get_nonscalar_data_ranges()</a> functions of this class. The second argument to this function specifies the names of the files that form the parallel set.</p>
<dl class="section note"><dt>Note</dt><dd>Use <a class="el" href="namespaceDataOutBase.html#a3aec479936b78bd0ec2ecc3674e24584">DataOutBase::write_vtu()</a> and <a class="el" href="group__Exceptions.html#ga93c780f93105e0daaa76c6c43694b4ae">DataOutInterface::write_vtu()</a> for writing each piece. Also note that only one parallel process needs to call the current function, listing the names of the files written by all parallel processes.</dd>
<dd>
The use of this function is explained in <a class="el" href="step_40.html">step-40</a>.</dd>
<dd>
In order to tell Paraview to group together multiple <code>pvtu</code> files that each describe one time step of a time dependent simulation, see the <a class="el" href="namespaceDataOutBase.html#a6f1c052ba49fd44cd8e3f35ba871aebd">DataOutBase::write_pvd_record()</a> function.</dd>
<dd>
Older versions of VisIt (before 2.5.1), can not read <code>pvtu</code> records. However, it can read visit records as written by the <a class="el" href="namespaceDataOutBase.html#a482d9621dcc87d6a43cf8a9651e16cd8">write_visit_record()</a> function. </dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l02697">2697</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ga0864e51eb173c87e2a3edc9391ea8009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0864e51eb173c87e2a3edc9391ea8009">&#9670;&nbsp;</a></span>write_vtu_with_pvtu_record()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_vtu_with_pvtu_record </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>directory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename_without_extension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>mpi_communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_digits_for_counter</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_groups</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function writes several .vtu files and a .pvtu record in parallel and constructs the filenames automatically. It is a combination of <a class="el" href="group__Exceptions.html#ga93c780f93105e0daaa76c6c43694b4ae">DataOutInterface::write_vtu()</a> or <a class="el" href="group__Exceptions.html#ga5df488dad82b811ceb08cb1adf9eafcd">DataOutInterface::write_vtu_in_parallel()</a>, and <a class="el" href="group__Exceptions.html#ga1eff778443cd0431cd807c45b6ae16d9">DataOutInterface::write_pvtu_record()</a>.</p>
<p>For example, running <code> write_vtu_with_pvtu_record("output/", "solution", 3, comm, 4, 2) </code> on 10 processes generates the files </p><div class="fragment"><div class="line">output/solution_0003.0.vtu</div>
<div class="line">output/solution_0003.1.vtu</div>
<div class="line">output/solution_0003.pvtu</div>
</div><!-- fragment --><p> where the <code>.0.vtu</code> file contains the output of the first half of the processes grouped together, and the <code>.1.vtu</code> the data from the remaining half.</p>
<p>A specified <code>directory</code> and a <code>filename_without_extension</code> form the first part of the filename. The filename is then extended with a <code>counter</code> labeling the current timestep/iteration/etc., the processor ID, and finally the .vtu/.pvtu ending. Since the number of timesteps to be written depends on the application, the number of digits to be reserved in the filename can be specified as parameter <code>n_digits_for_counter</code>, and the number is not padded with leading zeros if this parameter is left at its default value <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>. If more than one file identifier is needed (e.g. time step number and iteration counter of solver), the last identifier is used as <code>counter</code>, while all other identifiers have to be added to <code>filename_without_extension</code> when calling this function.</p>
<p>In a parallel setting, several files are typically written per time step. The number of files written in parallel depends on the number of MPI processes (see parameter <code>mpi_communicator</code>), and a specified number of <code>n_groups</code> with default value 0. The background is that VTU file output supports grouping files from several CPUs into a given number of files using MPI I/O when writing on a parallel filesystem. The default value of <code>n_groups</code> is 0, meaning that every MPI rank will write one file. A value of 1 will generate one big file containing the solution over the whole domain, while a larger value will create <code>n_groups</code> files (but not more than there are MPI ranks).</p>
<p>Note that only one processor needs to generate the .pvtu file, where processor zero is chosen to take over this job.</p>
<p>The return value is the filename of the centralized file for the pvtu record.</p>
<dl class="section note"><dt>Note</dt><dd>The code simply combines the strings <code>directory</code> and <code>filename_without_extension</code>, i.e., the user has to make sure that <code>directory</code> contains a trailing character, e.g. "/", that separates the directory from the filename.</dd>
<dd>
Use an empty string "" for the first argument if output is to be written in the current working directory. </dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l02759">2759</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="gab56595d7d5aebfb2b3abfdaad51df20d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab56595d7d5aebfb2b3abfdaad51df20d">&#9670;&nbsp;</a></span>write_svg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_svg </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Obtain data through <a class="el" href="classDataOut__DoFData.html#a496f2bb31228bec26f4ce73ef4166b3d">get_patches()</a> and write it to <code>out</code> in SVG format. See <a class="el" href="namespaceDataOutBase.html#ad20ab1f2f5ec29122aefe1f016ff6eac">DataOutBase::write_svg</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l02772">2772</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="gaffac60e1e3799ae884642113a8e2e723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffac60e1e3799ae884642113a8e2e723">&#9670;&nbsp;</a></span>write_deal_II_intermediate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_deal_II_intermediate </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Obtain data through <a class="el" href="classDataOut__DoFData.html#a496f2bb31228bec26f4ce73ef4166b3d">get_patches()</a> and write it to <code>out</code> in deal.II intermediate format. See <a class="el" href="namespaceDataOutBase.html#a70b0a895fd8b48c1555fa1c34f2cd176">DataOutBase::write_deal_II_intermediate</a>.</p>
<p>Note that the intermediate format is what its name suggests: a direct representation of internal data. It isn't standardized and will change whenever we change our internal representation. You can only expect to process files written in this format using the same version of deal.II that was used for writing. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l02785">2785</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ga45ef5cf2b6515c10ff080729a9901155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45ef5cf2b6515c10ff080729a9901155">&#9670;&nbsp;</a></span>create_xdmf_entry() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXDMFEntry.html">XDMFEntry</a> <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::create_xdmf_entry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>data_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>h5_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>cur_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an <a class="el" href="classXDMFEntry.html">XDMFEntry</a> based on the data in the data_filter. This assumes the mesh and solution data were written to a single file. See <a class="el" href="group__Exceptions.html#gabfab5d02f11dcede67bb61ff3ae105d2">write_xdmf_file()</a> for an example of usage. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l02793">2793</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ga0f0b3eec5ee65bd7915c4e46272287eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f0b3eec5ee65bd7915c4e46272287eb">&#9670;&nbsp;</a></span>create_xdmf_entry() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXDMFEntry.html">XDMFEntry</a> <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::create_xdmf_entry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>data_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>h5_mesh_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>h5_solution_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>cur_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an <a class="el" href="classXDMFEntry.html">XDMFEntry</a> based on the data in the data_filter. This assumes the mesh and solution data were written to separate files. See <a class="el" href="group__Exceptions.html#gabfab5d02f11dcede67bb61ff3ae105d2">write_xdmf_file()</a> for an example of usage. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l02804">2804</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="gabfab5d02f11dcede67bb61ff3ae105d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfab5d02f11dcede67bb61ff3ae105d2">&#9670;&nbsp;</a></span>write_xdmf_file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_xdmf_file </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classXDMFEntry.html">XDMFEntry</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write an XDMF file based on the provided vector of <a class="el" href="classXDMFEntry.html">XDMFEntry</a> objects. Below is an example of how to use this function with <a class="el" href="namespaceHDF5.html">HDF5</a> and the DataOutFilter:</p>
<div class="fragment"><div class="line"><a class="code" href="structDataOutBase_1_1DataOutFilterFlags.html">DataOutBase::DataOutFilterFlags</a> flags(<span class="keyword">true</span>, <span class="keyword">true</span>);</div>
<div class="line"><a class="code" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> data_filter(flags);</div>
<div class="line">std::vector&lt;XDMFEntry&gt; xdmf_entries;</div>
<div class="line"><span class="comment">// Filter the data and store it in data_filter</span></div>
<div class="line">data_out.write_filtered_data(data_filter);</div>
<div class="line"><span class="comment">// Write the filtered data to HDF5</span></div>
<div class="line">data_out.write_hdf5_parallel(data_filter, <span class="stringliteral">&quot;solution.h5&quot;</span>, MPI_COMM_WORLD);</div>
<div class="line"><span class="comment">// Create an XDMF entry detailing the HDF5 file</span></div>
<div class="line"><span class="keyword">auto</span> new_xdmf_entry = data_out.create_xdmf_entry(data_filter,</div>
<div class="line">                                                 <span class="stringliteral">&quot;solution.h5&quot;</span>,</div>
<div class="line">                                                 simulation_time,</div>
<div class="line">                                                 MPI_COMM_WORLD);</div>
<div class="line"><span class="comment">// Add the XDMF entry to the list</span></div>
<div class="line">xdmf_entries.push_back(new_xdmf_entry);</div>
<div class="line"><span class="comment">// Create an XDMF file from all stored entries</span></div>
<div class="line">data_out.write_xdmf_file(xdmf_entries, <span class="stringliteral">&quot;solution.xdmf&quot;</span>, MPI_COMM_WORLD);</div>
<div class="ttc" id="aclassDataOutBase_1_1DataOutFilter_html"><div class="ttname"><a href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a></div><div class="ttdef"><b>Definition:</b> <a href="data__out__base_8h_source.html#l01331">data_out_base.h:1332</a></div></div>
<div class="ttc" id="astructDataOutBase_1_1DataOutFilterFlags_html"><div class="ttname"><a href="structDataOutBase_1_1DataOutFilterFlags.html">DataOutBase::DataOutFilterFlags</a></div><div class="ttdef"><b>Definition:</b> <a href="data__out__base_8h_source.html#l01262">data_out_base.h:1263</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l02835">2835</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ga29468f4e8eca1367d44b1a2431d39e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29468f4e8eca1367d44b1a2431d39e91">&#9670;&nbsp;</a></span>write_hdf5_parallel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_hdf5_parallel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>data_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write the data in <code>data_filter</code> to a single <a class="el" href="namespaceHDF5.html">HDF5</a> file containing both the mesh and solution values. Below is an example of how to use this function with the DataOutFilter:</p>
<div class="fragment"><div class="line"><a class="code" href="structDataOutBase_1_1DataOutFilterFlags.html">DataOutBase::DataOutFilterFlags</a> flags(<span class="keyword">true</span>, <span class="keyword">true</span>);</div>
<div class="line"><a class="code" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> data_filter(flags);</div>
<div class="line"><span class="comment">// Filter the data and store it in data_filter</span></div>
<div class="line">data_out.write_filtered_data(data_filter);</div>
<div class="line"><span class="comment">// Write the filtered data to HDF5</span></div>
<div class="line">data_out.write_hdf5_parallel(data_filter, <span class="stringliteral">&quot;solution.h5&quot;</span>, MPI_COMM_WORLD);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l02854">2854</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ga78fdf1cc5071d85ecb2d707d798bf063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78fdf1cc5071d85ecb2d707d798bf063">&#9670;&nbsp;</a></span>write_hdf5_parallel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_hdf5_parallel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>data_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>write_mesh_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mesh_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>solution_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write the data in data_filter to <a class="el" href="namespaceHDF5.html">HDF5</a> file(s). If write_mesh_file is false, the mesh data will not be written and the solution file will contain only the solution values. If write_mesh_file is true and the filenames are the same, the resulting file will contain both mesh data and solution values. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l02866">2866</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ga154d8192688eef96f052f50c2f669aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga154d8192688eef96f052f50c2f669aa8">&#9670;&nbsp;</a></span>write_filtered_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_filtered_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>filtered_data</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>DataOutFilter is an intermediate data format that reduces the amount of data that will be written to files. The object filled by this function can then later be used again to write data in a concrete file format; see, for example, <a class="el" href="namespaceDataOutBase.html#af5a956cffba0fa383f85a82bb2a4ca63">DataOutBase::write_hdf5_parallel()</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l02879">2879</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ga78e73ad285a8792ff0f9f227b82eb108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78e73ad285a8792ff0f9f227b82eb108">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a>&#160;</td>
          <td class="paramname"><em>output_format</em> = <code><a class="el" href="group__Exceptions.html#gaa3cbced9f1d4ae661f13018f4c980aa1aaca645a9a5b8782ed6dff8ef6b809e07">DataOutBase::default_format</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write data and grid to <code>out</code> according to the given data format. This function simply calls the appropriate <code>write_*</code> function. If no output format is requested, the <code>default_format</code> is written.</p>
<p>An error occurs if no format is provided and the default format is <code>default_format</code>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l02891">2891</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ga6dab6e0fed8d4ad90d658f71a68eb32c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6dab6e0fed8d4ad90d658f71a68eb32c">&#9670;&nbsp;</a></span>set_default_format()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::set_default_format </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a>&#160;</td>
          <td class="paramname"><em>default_format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the default format. The value set here is used anytime, output for format <code>default_format</code> is requested. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l02900">2900</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="gac7280a24690b117454acfb0fa058299c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7280a24690b117454acfb0fa058299c">&#9670;&nbsp;</a></span>set_flags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::set_flags </td>
          <td>(</td>
          <td class="paramtype">const FlagType &amp;&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the flags to be used for output. This method expects <code>flags</code> to be a member of one of the child classes of <code>OutputFlagsBase</code>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l02909">2909</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ga36120ca3f536c90709e135161030f16c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36120ca3f536c90709e135161030f16c">&#9670;&nbsp;</a></span>default_suffix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::default_suffix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a>&#160;</td>
          <td class="paramname"><em>output_format</em> = <code><a class="el" href="group__Exceptions.html#gaa3cbced9f1d4ae661f13018f4c980aa1aaca645a9a5b8782ed6dff8ef6b809e07">DataOutBase::default_format</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A function that returns the same string as the respective function in the base class does; the only exception being that if the parameter is omitted, then the value for the present default format is returned, i.e. the correct suffix for the format that was set through <a class="el" href="group__Exceptions.html#ga6dab6e0fed8d4ad90d658f71a68eb32c">set_default_format()</a> or <a class="el" href="group__Exceptions.html#ga0a975649e4516ee7c7a67ae2f8dddd97">parse_parameters()</a> before calling this function. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l02920">2920</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ga1f2f1d644d9cb1c4d1714d5173d159f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f2f1d644d9cb1c4d1714d5173d159f2">&#9670;&nbsp;</a></span>declare_parameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::declare_parameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;&#160;</td>
          <td class="paramname"><em>prm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Declare parameters for all output formats by declaring subsections within the parameter file for each output format and call the respective <code>declare_parameters</code> functions of the flag classes for each output format.</p>
<p>Some of the declared subsections may not contain entries, if the respective format does not export any flags.</p>
<p>Note that the top-level parameters denoting the number of subdivisions per patch and the output format are not declared, since they are only passed to virtual functions and are not stored inside objects of this type. You have to declare them yourself. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l02938">2938</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ga0a975649e4516ee7c7a67ae2f8dddd97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a975649e4516ee7c7a67ae2f8dddd97">&#9670;&nbsp;</a></span>parse_parameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::parse_parameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;&#160;</td>
          <td class="paramname"><em>prm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the parameters declared in <a class="el" href="group__Exceptions.html#ga1f2f1d644d9cb1c4d1714d5173d159f2">declare_parameters()</a> and set the flags for the output formats accordingly.</p>
<p>The flags thus obtained overwrite all previous contents of the flag objects as default-constructed or set by the <a class="el" href="group__Exceptions.html#gac7280a24690b117454acfb0fa058299c">set_flags()</a> function. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l02948">2948</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="gac3292ed269dfb832d20ae35db4177473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3292ed269dfb832d20ae35db4177473">&#9670;&nbsp;</a></span>validate_dataset_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::validate_dataset_names</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Validate that the names of the datasets returned by <a class="el" href="classDataOut__DoFData.html#a7e60dbfa99a1a31f520893b7145ab321">get_dataset_names()</a> and <a class="el" href="classDataOut__DoFData.html#a34486ffea504c88c1bc3e121c8809f1e">get_nonscalar_data_ranges()</a> are valid. This currently consists of checking that names are not used more than once. If an invalid state is encountered, an <a class="el" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert()</a> will be triggered in debug mode. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l03008">3008</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa90a504a33269e4b5c08138da3646381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa90a504a33269e4b5c08138da3646381">&#9670;&nbsp;</a></span>dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType  = DoFHandler&lt;dim&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int <a class="el" href="classDataOutRotation.html">DataOutRotation</a>&lt; dim, DoFHandlerType &gt;::dimension = DoFHandlerType::dimension</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An abbreviation for the dimension of the <a class="el" href="classDoFHandler.html">DoFHandler</a> object we work with. Faces are then <code>dimension-1</code> dimensional objects. </p>

<p class="definition">Definition at line <a class="el" href="data__out__rotation_8h_source.html#l00130">130</a> of file <a class="el" href="data__out__rotation_8h_source.html">data_out_rotation.h</a>.</p>

</div>
</div>
<a id="a7be219cfcba24e76099c0fd421bb1fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7be219cfcba24e76099c0fd421bb1fbf">&#9670;&nbsp;</a></span>space_dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType  = DoFHandler&lt;dim&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int <a class="el" href="classDataOutRotation.html">DataOutRotation</a>&lt; dim, DoFHandlerType &gt;::space_dimension = DoFHandlerType::space_dimension</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An abbreviation for the spatial dimension within which the triangulation and <a class="el" href="classDoFHandler.html">DoFHandler</a> are embedded in. </p>

<p class="definition">Definition at line <a class="el" href="data__out__rotation_8h_source.html#l00136">136</a> of file <a class="el" href="data__out__rotation_8h_source.html">data_out_rotation.h</a>.</p>

</div>
</div>
<a id="abf58679bb3ce869323a2a997415aa1df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf58679bb3ce869323a2a997415aa1df">&#9670;&nbsp;</a></span>triangulation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="classTriangulation.html">Triangulation</a>&lt;DoFHandlerType::dimension, DoFHandlerType::space_dimension&gt; &gt; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_dim  &gt;::triangulation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the triangulation object. </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00972">972</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a6a282f4d56013f02908e665353fc4b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a282f4d56013f02908e665353fc4b21">&#9670;&nbsp;</a></span>dofs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &gt; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_dim  &gt;::dofs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the optional handler object. </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00977">977</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="ac6bc1c5c850d7d5c15362a5fdc936777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6bc1c5c850d7d5c15362a5fdc936777">&#9670;&nbsp;</a></span>dof_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;<a class="el" href="classinternal_1_1DataOutImplementation_1_1DataEntryBase.html">internal::DataOutImplementation::DataEntryBase</a>&lt; DoFHandlerType::dimension, DoFHandlerType::space_dimension&gt; &gt; &gt; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_dim  &gt;::dof_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List of data elements with vectors of values for each degree of freedom. </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00985">985</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a7d58dd18d706e9bc613e3e635538750a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d58dd18d706e9bc613e3e635538750a">&#9670;&nbsp;</a></span>cell_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;<a class="el" href="classinternal_1_1DataOutImplementation_1_1DataEntryBase.html">internal::DataOutImplementation::DataEntryBase</a>&lt; DoFHandlerType::dimension, DoFHandlerType::space_dimension&gt; &gt; &gt; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_dim  &gt;::cell_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List of data elements with vectors of values for each cell. </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00993">993</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="adb583ebaa6c26c5d31c0becf5aff5558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb583ebaa6c26c5d31c0becf5aff5558">&#9670;&nbsp;</a></span>patches</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classDataOut__DoFData.html#a5d7ef9ef54d930c6cf85e37a1b155e30">Patch</a>&gt; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_dim  &gt;::patches</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is a list of patches that is created each time <a class="el" href="classDataOutRotation.html#a9ba0c7778094b954fccd774ef350040d">build_patches()</a> is called. These patches are used in the output routines of the base classes. </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l01000">1000</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="ga072edd6d53d1c5a1e4c71af22a123228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga072edd6d53d1c5a1e4c71af22a123228">&#9670;&nbsp;</a></span>default_subdivisions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::default_subdivisions</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The default number of subdivisions for patches. This is filled by <a class="el" href="group__Exceptions.html#ga0a975649e4516ee7c7a67ae2f8dddd97">parse_parameters()</a> and should be obeyed by <a class="el" href="classDataOutRotation.html#a9ba0c7778094b954fccd774ef350040d">build_patches()</a> in derived classes. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8h_source.html#l03016">3016</a> of file <a class="el" href="data__out__base_8h_source.html">data_out_base.h</a>.</p>

</div>
</div>
<a id="ga82c974193222c8c3c3950a6b9047328d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82c974193222c8c3c3950a6b9047328d">&#9670;&nbsp;</a></span>default_fmt</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::default_fmt</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Standard output format. Use this format, if output format default_format is requested. It can be changed by the <code>set_format</code> function or in a parameter file. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8h_source.html#l03024">3024</a> of file <a class="el" href="data__out__base_8h_source.html">data_out_base.h</a>.</p>

</div>
</div>
<a id="gaebcd8f42c70f0b26f34e7e62b8808b35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebcd8f42c70f0b26f34e7e62b8808b35">&#9670;&nbsp;</a></span>dx_flags</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDataOutBase_1_1DXFlags.html">DataOutBase::DXFlags</a> <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::dx_flags</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flags to be used upon output of OpenDX data. Can be changed by using the <code>set_flags</code> function. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8h_source.html#l03030">3030</a> of file <a class="el" href="data__out__base_8h_source.html">data_out_base.h</a>.</p>

</div>
</div>
<a id="ga77b3216d3e76e2ed65ad6967d2ca42b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77b3216d3e76e2ed65ad6967d2ca42b5">&#9670;&nbsp;</a></span>ucd_flags</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDataOutBase_1_1UcdFlags.html">DataOutBase::UcdFlags</a> <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::ucd_flags</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flags to be used upon output of UCD data. Can be changed by using the <code>set_flags</code> function. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8h_source.html#l03036">3036</a> of file <a class="el" href="data__out__base_8h_source.html">data_out_base.h</a>.</p>

</div>
</div>
<a id="ga8466681c18e24c0b3c7af7eae5e0997e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8466681c18e24c0b3c7af7eae5e0997e">&#9670;&nbsp;</a></span>gnuplot_flags</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDataOutBase_1_1GnuplotFlags.html">DataOutBase::GnuplotFlags</a> <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::gnuplot_flags</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flags to be used upon output of GNUPLOT data. Can be changed by using the <code>set_flags</code> function. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8h_source.html#l03042">3042</a> of file <a class="el" href="data__out__base_8h_source.html">data_out_base.h</a>.</p>

</div>
</div>
<a id="ga77a68867f11f41af91470c37b930cac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77a68867f11f41af91470c37b930cac8">&#9670;&nbsp;</a></span>povray_flags</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDataOutBase_1_1PovrayFlags.html">DataOutBase::PovrayFlags</a> <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::povray_flags</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flags to be used upon output of POVRAY data. Can be changed by using the <code>set_flags</code> function. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8h_source.html#l03048">3048</a> of file <a class="el" href="data__out__base_8h_source.html">data_out_base.h</a>.</p>

</div>
</div>
<a id="gae8b6e70c57dd3994130304d33fc0a0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8b6e70c57dd3994130304d33fc0a0fd">&#9670;&nbsp;</a></span>eps_flags</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDataOutBase_1_1EpsFlags.html">DataOutBase::EpsFlags</a> <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::eps_flags</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flags to be used upon output of EPS data in one space dimension. Can be changed by using the <code>set_flags</code> function. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8h_source.html#l03054">3054</a> of file <a class="el" href="data__out__base_8h_source.html">data_out_base.h</a>.</p>

</div>
</div>
<a id="ga62aad8dd9acbe017b15757d419d356ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62aad8dd9acbe017b15757d419d356ae">&#9670;&nbsp;</a></span>gmv_flags</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDataOutBase_1_1GmvFlags.html">DataOutBase::GmvFlags</a> <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::gmv_flags</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flags to be used upon output of gmv data in one space dimension. Can be changed by using the <code>set_flags</code> function. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8h_source.html#l03060">3060</a> of file <a class="el" href="data__out__base_8h_source.html">data_out_base.h</a>.</p>

</div>
</div>
<a id="ga295e120b8f3a3f38f94810e82a5aa90d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga295e120b8f3a3f38f94810e82a5aa90d">&#9670;&nbsp;</a></span>tecplot_flags</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDataOutBase_1_1TecplotFlags.html">DataOutBase::TecplotFlags</a> <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::tecplot_flags</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flags to be used upon output of Tecplot data in one space dimension. Can be changed by using the <code>set_flags</code> function. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8h_source.html#l03066">3066</a> of file <a class="el" href="data__out__base_8h_source.html">data_out_base.h</a>.</p>

</div>
</div>
<a id="gae690412df124f4dcea1b34450535ce83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae690412df124f4dcea1b34450535ce83">&#9670;&nbsp;</a></span>vtk_flags</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::vtk_flags</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flags to be used upon output of vtk data in one space dimension. Can be changed by using the <code>set_flags</code> function. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8h_source.html#l03072">3072</a> of file <a class="el" href="data__out__base_8h_source.html">data_out_base.h</a>.</p>

</div>
</div>
<a id="gabe7a9711c62ab10adf2e629c4fceafa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe7a9711c62ab10adf2e629c4fceafa5">&#9670;&nbsp;</a></span>svg_flags</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDataOutBase_1_1SvgFlags.html">DataOutBase::SvgFlags</a> <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::svg_flags</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flags to be used upon output of svg data in one space dimension. Can be changed by using the <code>set_flags</code> function. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8h_source.html#l03078">3078</a> of file <a class="el" href="data__out__base_8h_source.html">data_out_base.h</a>.</p>

</div>
</div>
<a id="ga0d1bb3d43066b0163db165f79b93a6de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d1bb3d43066b0163db165f79b93a6de">&#9670;&nbsp;</a></span>deal_II_intermediate_flags</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDataOutBase_1_1Deal__II__IntermediateFlags.html">DataOutBase::Deal_II_IntermediateFlags</a> <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::deal_II_intermediate_flags</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flags to be used upon output of deal.II intermediate data in one space dimension. Can be changed by using the <code>set_flags</code> function. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8h_source.html#l03084">3084</a> of file <a class="el" href="data__out__base_8h_source.html">data_out_base.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/numerics/<a class="el" href="data__out__rotation_8h_source.html">data_out_rotation.h</a></li>
<li>source/numerics/<a class="el" href="data__out__rotation_8cc_source.html">data_out_rotation.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
