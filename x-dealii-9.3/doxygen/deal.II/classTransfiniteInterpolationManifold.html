<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classTransfiniteInterpolationManifold.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: TransfiniteInterpolationManifold&lt; dim, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.3.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.3.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classTransfiniteInterpolationManifold-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TransfiniteInterpolationManifold&lt; dim, spacedim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__grid.html">Grids and Triangulations</a> &raquo; <a class="el" href="group__manifold.html">Manifold description for triangulations</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="grid_2manifold__lib_8h_source.html">deal.II/grid/manifold_lib.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for TransfiniteInterpolationManifold&lt; dim, spacedim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classTransfiniteInterpolationManifold__inherit__graph.svg" width="298" height="294"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a79eb483936cd38a0a9d42bf2071ee9ce"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> = std::array&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::vertices_per_face &gt;</td></tr>
<tr class="separator:a79eb483936cd38a0a9d42bf2071ee9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad9570bb3d1fb384a0bf8e6644c1a6e89"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransfiniteInterpolationManifold.html#ad9570bb3d1fb384a0bf8e6644c1a6e89">TransfiniteInterpolationManifold</a> ()</td></tr>
<tr class="separator:ad9570bb3d1fb384a0bf8e6644c1a6e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b56d5740b1a224123b44ca72c4432c1"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransfiniteInterpolationManifold.html#a6b56d5740b1a224123b44ca72c4432c1">~TransfiniteInterpolationManifold</a> () override</td></tr>
<tr class="separator:a6b56d5740b1a224123b44ca72c4432c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0b02e80a1bcb471d8bedd9a343bb4e"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransfiniteInterpolationManifold.html#aff0b02e80a1bcb471d8bedd9a343bb4e">clone</a> () const override</td></tr>
<tr class="separator:aff0b02e80a1bcb471d8bedd9a343bb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34326a35d9ec4b6911d90c85c21847d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransfiniteInterpolationManifold.html#a34326a35d9ec4b6911d90c85c21847d8">initialize</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="classTransfiniteInterpolationManifold.html#a0e291ba17bd296e1c79d053649e288f5">triangulation</a>)</td></tr>
<tr class="separator:a34326a35d9ec4b6911d90c85c21847d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634fa138b32712ad27c07e09a34f5c75"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransfiniteInterpolationManifold.html#a634fa138b32712ad27c07e09a34f5c75">get_new_point</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;surrounding_points, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classdouble.html">double</a> &gt; &amp;weights) const override</td></tr>
<tr class="separator:a634fa138b32712ad27c07e09a34f5c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38786b12dedbb6414cabc249551fe4a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransfiniteInterpolationManifold.html#aa38786b12dedbb6414cabc249551fe4a">get_new_points</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;surrounding_points, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classdouble.html">double</a> &gt; &amp;weights, <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; new_points) const override</td></tr>
<tr class="separator:aa38786b12dedbb6414cabc249551fe4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f1d301d7950f55b59e1c2982dfe942"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a73f1d301d7950f55b59e1c2982dfe942">get_new_point_on_quad</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 1 &gt;::quad_iterator &amp;) const</td></tr>
<tr class="separator:a73f1d301d7950f55b59e1c2982dfe942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1adb7e5b4a0feeeef7f9ec087e23d376"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a1adb7e5b4a0feeeef7f9ec087e23d376">get_new_point_on_quad</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 2 &gt;::quad_iterator &amp;) const</td></tr>
<tr class="separator:a1adb7e5b4a0feeeef7f9ec087e23d376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd7186dfb0ea938abda62e962d5f867"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a4bd7186dfb0ea938abda62e962d5f867">get_new_point_on_quad</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 3 &gt;::quad_iterator &amp;) const</td></tr>
<tr class="separator:a4bd7186dfb0ea938abda62e962d5f867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada653729888b24eb140a382512167163"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#ada653729888b24eb140a382512167163">get_new_point_on_hex</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt;::hex_iterator &amp;hex) const</td></tr>
<tr class="separator:ada653729888b24eb140a382512167163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a38fc3f140d54aa80195831a27c499"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#ae6a38fc3f140d54aa80195831a27c499">get_new_point_on_face</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 1 &gt;::face_iterator &amp;) const</td></tr>
<tr class="separator:ae6a38fc3f140d54aa80195831a27c499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bba395b8edbb4703d2e77689266436f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a9bba395b8edbb4703d2e77689266436f">get_new_point_on_face</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 2 &gt;::face_iterator &amp;) const</td></tr>
<tr class="separator:a9bba395b8edbb4703d2e77689266436f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd6859a4858667c7d37838276c8e8b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a4dd6859a4858667c7d37838276c8e8b2">get_new_point_on_face</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 3 &gt;::face_iterator &amp;) const</td></tr>
<tr class="separator:a4dd6859a4858667c7d37838276c8e8b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464ae5e689877ac0d06b08b33f718caa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a464ae5e689877ac0d06b08b33f718caa">normal_vector</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt;::face_iterator &amp;face, const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;p) const</td></tr>
<tr class="separator:a464ae5e689877ac0d06b08b33f718caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95b06b088819df6a9305d0009495d3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#ad95b06b088819df6a9305d0009495d3d">normal_vector</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt;::face_iterator &amp;face, const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;p) const</td></tr>
<tr class="separator:ad95b06b088819df6a9305d0009495d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae944375afbf9370708422e520c6969e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#ae944375afbf9370708422e520c6969e5">get_normals_at_vertices</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt;::face_iterator &amp;face, <a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;n) const</td></tr>
<tr class="separator:ae944375afbf9370708422e520c6969e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3477908d71618cfc0c2de81e8ad474"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a1e3477908d71618cfc0c2de81e8ad474">get_normals_at_vertices</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt;::face_iterator &amp;face, <a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;n) const</td></tr>
<tr class="separator:a1e3477908d71618cfc0c2de81e8ad474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Computing the location of points.</div></td></tr>
<tr class="memitem:aace84e99db1f4767ce9e524170a1de2c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#aace84e99db1f4767ce9e524170a1de2c">get_intermediate_point</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p1, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p2, const <a class="el" href="classdouble.html">double</a> w) const</td></tr>
<tr class="separator:aace84e99db1f4767ce9e524170a1de2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c25e5d735160e0d846aab01d918e86"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a29c25e5d735160e0d846aab01d918e86">project_to_manifold</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;surrounding_points, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;candidate) const</td></tr>
<tr class="separator:a29c25e5d735160e0d846aab01d918e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af518522b81bdfe059b88bb557f7a60ba"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#af518522b81bdfe059b88bb557f7a60ba">get_new_point_on_line</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::line_iterator &amp;line) const</td></tr>
<tr class="separator:af518522b81bdfe059b88bb557f7a60ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a7a18b04151504883074c24108266f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a59a7a18b04151504883074c24108266f">get_new_point_on_quad</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::quad_iterator &amp;quad) const</td></tr>
<tr class="separator:a59a7a18b04151504883074c24108266f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d8365135405a1f057020d84a315ffa6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a8d8365135405a1f057020d84a315ffa6">get_new_point_on_hex</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::hex_iterator &amp;hex) const</td></tr>
<tr class="separator:a8d8365135405a1f057020d84a315ffa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79c3a0f002136b483b50722ea6690d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#ab79c3a0f002136b483b50722ea6690d9">get_new_point_on_face</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;face) const</td></tr>
<tr class="separator:ab79c3a0f002136b483b50722ea6690d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36b25e230fefc6eb32d53cb6e69cbba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#af36b25e230fefc6eb32d53cb6e69cbba">get_new_point_on_cell</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell) const</td></tr>
<tr class="separator:af36b25e230fefc6eb32d53cb6e69cbba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Computing tangent vectors</div></td></tr>
<tr class="memitem:adff3c7c6851d64d1839964f7ebbfc787"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#adff3c7c6851d64d1839964f7ebbfc787">get_tangent_vector</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;x1, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;x2) const</td></tr>
<tr class="separator:adff3c7c6851d64d1839964f7ebbfc787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Computing normal vectors</div></td></tr>
<tr class="memitem:a8f737627dc946fb68c097d6ec83419d4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a8f737627dc946fb68c097d6ec83419d4">normal_vector</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;face, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p) const</td></tr>
<tr class="separator:a8f737627dc946fb68c097d6ec83419d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8317a03ab0c13971ff53bcb38b49e9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a2f8317a03ab0c13971ff53bcb38b49e9">get_normals_at_vertices</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;face, <a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;face_vertex_normals) const</td></tr>
<tr class="separator:a2f8317a03ab0c13971ff53bcb38b49e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ab6bd71369534cc578dd2801cd186eafe"><td class="memItemLeft" align="right" valign="top">std::array&lt; unsigned int, 20 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransfiniteInterpolationManifold.html#ab6bd71369534cc578dd2801cd186eafe">get_possible_cells_around_points</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;surrounding_points) const</td></tr>
<tr class="separator:ab6bd71369534cc578dd2801cd186eafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ad324a54fb7f415ec134ad486a4cd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransfiniteInterpolationManifold.html#ae2ad324a54fb7f415ec134ad486a4cd8">compute_chart_points</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;surrounding_points, <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; chart_points) const</td></tr>
<tr class="separator:ae2ad324a54fb7f415ec134ad486a4cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0aca899ae463ebeed22062081f6438"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransfiniteInterpolationManifold.html#a9a0aca899ae463ebeed22062081f6438">pull_back</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;initial_guess) const</td></tr>
<tr class="separator:a9a0aca899ae463ebeed22062081f6438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee61fce6c8981aea6bf48dbfd50ebd1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransfiniteInterpolationManifold.html#aee61fce6c8981aea6bf48dbfd50ebd1b">push_forward</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;chart_point) const</td></tr>
<tr class="separator:aee61fce6c8981aea6bf48dbfd50ebd1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f6a92da6eb36fa312c0aac4715cdc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 1, dim, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransfiniteInterpolationManifold.html#a23f6a92da6eb36fa312c0aac4715cdc5">push_forward_gradient</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;chart_point, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;pushed_forward_chart_point) const</td></tr>
<tr class="separator:a23f6a92da6eb36fa312c0aac4715cdc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a0e291ba17bd296e1c79d053649e288f5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransfiniteInterpolationManifold.html#a0e291ba17bd296e1c79d053649e288f5">triangulation</a></td></tr>
<tr class="separator:a0e291ba17bd296e1c79d053649e288f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750316fe04841cfe30a11a9c0b407a96"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransfiniteInterpolationManifold.html#a750316fe04841cfe30a11a9c0b407a96">level_coarse</a></td></tr>
<tr class="separator:a750316fe04841cfe30a11a9c0b407a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb1f6697bd23c98a60e99a0084019fab"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransfiniteInterpolationManifold.html#aeb1f6697bd23c98a60e99a0084019fab">coarse_cell_is_flat</a></td></tr>
<tr class="separator:aeb1f6697bd23c98a60e99a0084019fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a71680361d03d27cb966a057e9978bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFlatManifold.html">FlatManifold</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransfiniteInterpolationManifold.html#a8a71680361d03d27cb966a057e9978bc">chart_manifold</a></td></tr>
<tr class="separator:a8a71680361d03d27cb966a057e9978bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d85cd77d90a38a4f01ea9ba062cb99"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classinternal_1_1MappingQGenericImplementation_1_1InverseQuadraticApproximation.html">internal::MappingQGenericImplementation::InverseQuadraticApproximation</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransfiniteInterpolationManifold.html#a95d85cd77d90a38a4f01ea9ba062cb99">quadratic_approximation</a></td></tr>
<tr class="separator:a95d85cd77d90a38a4f01ea9ba062cb99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1347d7c35a8ea2fa557bc0a74322feb0"><td class="memItemLeft" align="right" valign="top">boost::signals2::connection&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransfiniteInterpolationManifold.html#a1347d7c35a8ea2fa557bc0a74322feb0">clear_signal</a></td></tr>
<tr class="separator:a1347d7c35a8ea2fa557bc0a74322feb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Subscriptor functionality</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp8d6bc922eebec0b76272099aee4a220d"></a>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</td></tr>
<tr class="memitem:ga20658b60d6ef2d530fafa076efa9f503"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga20658b60d6ef2d530fafa076efa9f503">counter</a></td></tr>
<tr class="separator:ga20658b60d6ef2d530fafa076efa9f503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73f9f8936b61e6e17ab2a82e9516e95b"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga73f9f8936b61e6e17ab2a82e9516e95b">counter_map</a></td></tr>
<tr class="separator:ga73f9f8936b61e6e17ab2a82e9516e95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga094d5932c6c004c2a2b1b966950fb2f7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga094d5932c6c004c2a2b1b966950fb2f7">validity_pointers</a></td></tr>
<tr class="separator:ga094d5932c6c004c2a2b1b966950fb2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44e13f7984b31af8d7c54921175a75ff"><td class="memItemLeft" align="right" valign="top">const std::type_info *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga44e13f7984b31af8d7c54921175a75ff">object_info</a></td></tr>
<tr class="separator:ga44e13f7984b31af8d7c54921175a75ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned int version)</td></tr>
<tr class="separator:ga68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga300c593ea0f9422dcbce1445903e6c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga300c593ea0f9422dcbce1445903e6c12">check_no_subscribers</a> () const noexcept</td></tr>
<tr class="separator:ga300c593ea0f9422dcbce1445903e6c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaeb9ac67567aa7d837f25debd33cd4ce5">map_value_type</a> = decltype(<a class="el" href="group__Exceptions.html#ga73f9f8936b61e6e17ab2a82e9516e95b">counter_map</a>)::value_type</td></tr>
<tr class="separator:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacebdc2d11f8522e4d9e8b7d73ac3f491">map_iterator</a> = decltype(<a class="el" href="group__Exceptions.html#ga73f9f8936b61e6e17ab2a82e9516e95b">counter_map</a>)::iterator</td></tr>
<tr class="separator:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e0d86893427a935e46d5bd6dcbc3f78"><td class="memItemLeft" align="right" valign="top">static std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7e0d86893427a935e46d5bd6dcbc3f78">mutex</a></td></tr>
<tr class="separator:ga7e0d86893427a935e46d5bd6dcbc3f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (int arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int spacedim = dim&gt;<br />
class TransfiniteInterpolationManifold&lt; dim, spacedim &gt;</h3>

<p>A mapping class that extends curved boundary descriptions into the interior of the computational domain. The outer curved boundary description is assumed to be given by another manifold (e.g. a polar manifold on a circle). The mechanism to extend the boundary information is a so-called transfinite interpolation. The use of this class is discussed extensively in <a class="el" href="step_65.html">step-65</a>.</p>
<p>The formula for extending such a description in 2D is, for example, described on <a href="https://en.wikipedia.org/wiki/Transfinite_interpolation">Wikipedia</a>. Given a point \((u,v)\) on the chart, the image of this point in real space is given by </p><p class="formulaDsp">
\begin{align*} \mathbf S(u,v) &amp;= (1-v)\mathbf c_0(u)+v \mathbf c_1(u) + (1-u)\mathbf c_2(v) + u \mathbf c_3(v) \\ &amp;\quad - \left[(1-u)(1-v) \mathbf x_0 + u(1-v) \mathbf x_1 + (1-u)v \mathbf x_2 + uv \mathbf x_3 \right] \end{align*}
</p>
<p> where \(\bf x_0, \bf x_1, \bf x_2, \bf x_3\) denote the four bounding vertices bounding the image space and \(\bf c_0, \bf c_1, \bf c_2, \bf c_3\) are the four curves describing the lines of the cell. If a curved manifold is attached to any of these lines, the evaluation is done according to <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold::get_new_point()</a> with the two end points of the line and appropriate weight. In 3D, the generalization of this formula is implemented, creating a weighted sum of the vertices (positive contribution), the lines (negative), and the faces (positive contribution).</p>
<p>This manifold is usually attached to a coarse mesh and then places new points as a combination of the descriptions on the boundaries, weighted appropriately according to the position of the point in the original chart coordinates \((u,v)\). This manifold should be preferred over setting only a curved manifold on the boundary of a mesh in most situations as it yields more uniform mesh distributions as the mesh is refined because it switches from a curved description to a straight description over all children of the initial coarse cell this manifold was attached to. This way, the curved nature of the manifold that is originally contained in one <em>coarse</em> mesh layer will be applied to more than one <em>fine</em> mesh layer once the mesh gets refined. Note that the mechanisms of <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a> are also built into the <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> class when only a surface of a cell is subject to a curved description, ensuring that even the default case without this manifold gets optimal convergence rates when applying curved boundary descriptions.</p>
<p>If no curved boundaries surround a coarse cell, this class reduces to a flat manifold description.</p>
<p>To give an example of using this class, the following code attaches a transfinite manifold to a circle:</p>
<div class="fragment"><div class="line"><a class="code" href="classPolarManifold.html">PolarManifold&lt;dim&gt;</a> polar_manifold;</div>
<div class="line"><a class="code" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold&lt;dim&gt;</a> inner_manifold;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="classTransfiniteInterpolationManifold.html#a0e291ba17bd296e1c79d053649e288f5">triangulation</a>;</div>
<div class="line"><a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a> (<a class="code" href="classTransfiniteInterpolationManifold.html#a0e291ba17bd296e1c79d053649e288f5">triangulation</a>);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classTransfiniteInterpolationManifold.html#a0e291ba17bd296e1c79d053649e288f5">triangulation</a>.<a class="code" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a>(1);</div>
<div class="line"><a class="code" href="classTransfiniteInterpolationManifold.html#a0e291ba17bd296e1c79d053649e288f5">triangulation</a>.<a class="code" href="group__manifold.html#ga1f1ea841946c94c079388ecf9ad2c00c">set_all_manifold_ids_on_boundary</a>(0);</div>
<div class="line"><a class="code" href="classTransfiniteInterpolationManifold.html#a0e291ba17bd296e1c79d053649e288f5">triangulation</a>.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a> (0, polar_manifold);</div>
<div class="line">inner_manifold.<a class="code" href="classTransfiniteInterpolationManifold.html#a34326a35d9ec4b6911d90c85c21847d8">initialize</a>(<a class="code" href="classTransfiniteInterpolationManifold.html#a0e291ba17bd296e1c79d053649e288f5">triangulation</a>);</div>
<div class="line"><a class="code" href="classTransfiniteInterpolationManifold.html#a0e291ba17bd296e1c79d053649e288f5">triangulation</a>.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a> (1, inner_manifold);</div>
<div class="line"><a class="code" href="classTransfiniteInterpolationManifold.html#a0e291ba17bd296e1c79d053649e288f5">triangulation</a>.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(4);</div>
<div class="ttc" id="aclassPolarManifold_html"><div class="ttname"><a href="classPolarManifold.html">PolarManifold</a></div><div class="ttdef"><b>Definition:</b> <a href="grid_2manifold__lib_8h_source.html#l00070">manifold_lib.h:71</a></div></div>
<div class="ttc" id="aclassTransfiniteInterpolationManifold_html"><div class="ttname"><a href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a></div><div class="ttdef"><b>Definition:</b> <a href="grid_2manifold__lib_8h_source.html#l00965">manifold_lib.h:966</a></div></div>
<div class="ttc" id="aclassTransfiniteInterpolationManifold_html_a0e291ba17bd296e1c79d053649e288f5"><div class="ttname"><a href="classTransfiniteInterpolationManifold.html#a0e291ba17bd296e1c79d053649e288f5">TransfiniteInterpolationManifold::triangulation</a></div><div class="ttdeci">const Triangulation&lt; dim, spacedim &gt; * triangulation</div><div class="ttdef"><b>Definition:</b> <a href="grid_2manifold__lib_8h_source.html#l01126">manifold_lib.h:1126</a></div></div>
<div class="ttc" id="aclassTransfiniteInterpolationManifold_html_a34326a35d9ec4b6911d90c85c21847d8"><div class="ttname"><a href="classTransfiniteInterpolationManifold.html#a34326a35d9ec4b6911d90c85c21847d8">TransfiniteInterpolationManifold::initialize</a></div><div class="ttdeci">void initialize(const Triangulation&lt; dim, spacedim &gt; &amp;triangulation)</div><div class="ttdef"><b>Definition:</b> <a href="grid_2manifold__lib_8cc_source.html#l01676">manifold_lib.cc:1676</a></div></div>
<div class="ttc" id="aclassTriangulation_html"><div class="ttname"><a href="classTriangulation.html">Triangulation</a></div><div class="ttdef"><b>Definition:</b> <a href="grid_2tria_8h_source.html#l01127">tria.h:1128</a></div></div>
<div class="ttc" id="aclassTriangulation_html_a6ad0b3fb24aae17f4668427a433dea19"><div class="ttname"><a href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">Triangulation::refine_global</a></div><div class="ttdeci">void refine_global(const unsigned int times=1)</div></div>
<div class="ttc" id="agroup__manifold_html_ga1f1ea841946c94c079388ecf9ad2c00c"><div class="ttname"><a href="group__manifold.html#ga1f1ea841946c94c079388ecf9ad2c00c">Triangulation::set_all_manifold_ids_on_boundary</a></div><div class="ttdeci">void set_all_manifold_ids_on_boundary(const types::manifold_id number)</div></div>
<div class="ttc" id="agroup__manifold_html_ga9f9d720f5fbdcdf3dcbb445feefbdb9f"><div class="ttname"><a href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">Triangulation::set_manifold</a></div><div class="ttdeci">void set_manifold(const types::manifold_id number, const Manifold&lt; dim, spacedim &gt; &amp;manifold_object)</div></div>
<div class="ttc" id="agroup__manifold_html_gae2acfbef517fd03855c4b371f3e182f7"><div class="ttname"><a href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">Triangulation::set_all_manifold_ids</a></div><div class="ttdeci">void set_all_manifold_ids(const types::manifold_id number)</div></div>
<div class="ttc" id="anamespaceGridGenerator_html_a533c4778cbc9bcbed365dcab42ca4418"><div class="ttname"><a href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a></div><div class="ttdeci">void hyper_ball(Triangulation&lt; dim &gt; &amp;tria, const Point&lt; dim &gt; &amp;center=Point&lt; dim &gt;(), const double radius=1., const bool attach_spherical_manifold_on_boundary_cells=false)</div></div>
</div><!-- fragment --><p>In this code, we first set all manifold ids to the id of the transfinite interpolation, and then re-set the manifold ids on the boundary to identify the curved boundary described by the polar manifold. With this code, one gets a really nice mesh:</p>
<p align="center"></p>
<div class="image">
<img src="circular_mesh_transfinite_interpolation.png" alt=""/>
</div>
 <p>which is obviously much nicer than the polar manifold applied to just the boundary:</p>
<p align="center"></p>
<div class="image">
<img src="circular_mesh_only_boundary_manifold.png" alt=""/>
</div>
 <p>This manifold is used in a few <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> functions, including <a class="el" href="namespaceGridGenerator.html#a9d0b8a34fe5ca58425aa1fcf0d6132f1">GridGenerator::channel_with_cylinder</a>.</p>
<h3>Implementation details</h3>
<p>In the implementation of this class, the manifolds surrounding a coarse cell are queried repeatedly to compute points on their interior. For optimal mesh quality, those manifolds should be compatible with a chart notion. For example, computing a point that is 0.25 along the line between two vertices using the weights 0.25 and 0.75 for the two vertices should give the same result as first computing the mid point at 0.5 and then again compute the midpoint between the first vertex and coarse mid point. This is the case for most of the manifold classes provided by deal.II, such as <a class="el" href="classSphericalManifold.html">SphericalManifold</a> or <a class="el" href="classPolarManifold.html">PolarManifold</a>, but it might be violated by naive implementations. In case the quality of the manifold is not good enough, upon mesh refinement it may happen that the transformation to a chart inside the <a class="el" href="classTransfiniteInterpolationManifold.html#a634fa138b32712ad27c07e09a34f5c75">get_new_point()</a> or <a class="el" href="classTransfiniteInterpolationManifold.html#aa38786b12dedbb6414cabc249551fe4a">get_new_points()</a> methods produces points that are outside the unit cell. Then this class throws an exception of type <a class="el" href="group__Exceptions.html#ga9d73c62039509e0f04c04102ace3071a">Mapping::ExcTransformationFailed</a>. In that case, the mesh should be refined before attaching this class, as done in the following example:</p>
<div class="fragment"><div class="line"><a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a> spherical_manifold;</div>
<div class="line"><a class="code" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold&lt;dim&gt;</a> inner_manifold;</div>
<div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="classTransfiniteInterpolationManifold.html#a0e291ba17bd296e1c79d053649e288f5">triangulation</a>;</div>
<div class="line"><a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a> (<a class="code" href="classTransfiniteInterpolationManifold.html#a0e291ba17bd296e1c79d053649e288f5">triangulation</a>);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classTransfiniteInterpolationManifold.html#a0e291ba17bd296e1c79d053649e288f5">triangulation</a>.<a class="code" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a>(1);</div>
<div class="line"><a class="code" href="classTransfiniteInterpolationManifold.html#a0e291ba17bd296e1c79d053649e288f5">triangulation</a>.<a class="code" href="group__manifold.html#ga1f1ea841946c94c079388ecf9ad2c00c">set_all_manifold_ids_on_boundary</a>(0);</div>
<div class="line"><a class="code" href="classTransfiniteInterpolationManifold.html#a0e291ba17bd296e1c79d053649e288f5">triangulation</a>.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a> (0, spherical_manifold);</div>
<div class="line">inner_manifold.<a class="code" href="classTransfiniteInterpolationManifold.html#a34326a35d9ec4b6911d90c85c21847d8">initialize</a>(<a class="code" href="classTransfiniteInterpolationManifold.html#a0e291ba17bd296e1c79d053649e288f5">triangulation</a>);</div>
<div class="line"><a class="code" href="classTransfiniteInterpolationManifold.html#a0e291ba17bd296e1c79d053649e288f5">triangulation</a>.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a> (1, inner_manifold);</div>
<div class="line"><a class="code" href="classTransfiniteInterpolationManifold.html#a0e291ba17bd296e1c79d053649e288f5">triangulation</a>.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(1);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// initialize the transfinite manifold again</span></div>
<div class="line">inner_manifold.<a class="code" href="classTransfiniteInterpolationManifold.html#a34326a35d9ec4b6911d90c85c21847d8">initialize</a>(<a class="code" href="classTransfiniteInterpolationManifold.html#a0e291ba17bd296e1c79d053649e288f5">triangulation</a>);</div>
<div class="line"><a class="code" href="classTransfiniteInterpolationManifold.html#a0e291ba17bd296e1c79d053649e288f5">triangulation</a>.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(4);</div>
<div class="ttc" id="aclassSphericalManifold_html"><div class="ttname"><a href="classSphericalManifold.html">SphericalManifold</a></div><div class="ttdef"><b>Definition:</b> <a href="grid_2manifold__lib_8h_source.html#l00236">manifold_lib.h:237</a></div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>For performance and accuracy reasons, it is recommended to apply the transfinite manifold to as coarse a mesh as possible. Regarding accuracy, the curved description can only be applied to new points created from a given neighborhood, and the grid quality is typically higher when extending the curved description over as large a domain as possible. Regarding performance, the identification of the correct coarse cell in the <a class="el" href="classTransfiniteInterpolationManifold.html#a634fa138b32712ad27c07e09a34f5c75">get_new_point()</a> method needs to pass all coarse cells, so expect a linear complexity in the number of coarse cells for each single mapping operation, i.e., at least quadratic in the number of coarse mesh cells for any global operation on the whole mesh. Thus, the current implementation is only economical when there are not more than a few hundreds of coarse cells. To make performance better for larger numbers of cells, one could extend the current implementation by a pre-identification of relevant cells with axis-aligned bounding boxes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2manifold__lib_8h_source.html#l00965">965</a> of file <a class="el" href="grid_2manifold__lib_8h_source.html">manifold_lib.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a79eb483936cd38a0a9d42bf2071ee9ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79eb483936cd38a0a9d42bf2071ee9ce">&#9670;&nbsp;</a></span>FaceVertexNormals</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::<a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> =  std::array&lt;<a class="el" href="classTensor.html">Tensor</a>&lt;1, spacedim&gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim&gt;::vertices_per_face&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Type keeping information about the normals at the vertices of a face of a cell. Thus, there are <code><a class="el" href="structGeometryInfo.html#aad8410f6471e4ac443b51f6c20809bfb">GeometryInfo&lt;dim&gt;::vertices_per_face</a></code> normal vectors, that define the tangent spaces of the boundary at the vertices. Note that the vectors stored in this object are not required to be normalized, nor to actually point outward, as one often will only want to check for orthogonality to define the tangent plane; if a function requires the normals to be normalized, then it must do so itself.</p>
<p>For obvious reasons, this type is not useful in 1d. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2grid_2manifold_8h_source.html#l00306">306</a> of file <a class="el" href="include_2deal_8II_2grid_2manifold_8h_source.html">manifold.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad9570bb3d1fb384a0bf8e6644c1a6e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9570bb3d1fb384a0bf8e6644c1a6e89">&#9670;&nbsp;</a></span>TransfiniteInterpolationManifold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a>&lt; dim, spacedim &gt;::<a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. </p>

<p class="definition">Definition at line <a class="el" href="grid_2manifold__lib_8cc_source.html#l01643">1643</a> of file <a class="el" href="grid_2manifold__lib_8cc_source.html">manifold_lib.cc</a>.</p>

</div>
</div>
<a id="a6b56d5740b1a224123b44ca72c4432c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b56d5740b1a224123b44ca72c4432c1">&#9670;&nbsp;</a></span>~TransfiniteInterpolationManifold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a>&lt; dim, spacedim &gt;::~<a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

<p class="definition">Definition at line <a class="el" href="grid_2manifold__lib_8cc_source.html#l01654">1654</a> of file <a class="el" href="grid_2manifold__lib_8cc_source.html">manifold_lib.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aff0b02e80a1bcb471d8bedd9a343bb4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0b02e80a1bcb471d8bedd9a343bb4e">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &gt; <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a>&lt; dim, spacedim &gt;::clone</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make a clone of this <a class="el" href="classManifold.html">Manifold</a> object. </p>

<p>Implements <a class="el" href="classManifold.html#a140e1b7c7334d16f99aa7ad0dbabb44a">Manifold&lt; dim, dim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="grid_2manifold__lib_8cc_source.html#l01664">1664</a> of file <a class="el" href="grid_2manifold__lib_8cc_source.html">manifold_lib.cc</a>.</p>

</div>
</div>
<a id="a34326a35d9ec4b6911d90c85c21847d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34326a35d9ec4b6911d90c85c21847d8">&#9670;&nbsp;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a>&lt; dim, spacedim &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the manifold with a coarse mesh. The prerequisite for using this class is that the input triangulation is uniformly refined and the manifold is later attached to the same triangulation.</p>
<p>Whenever the assignment of manifold ids changes on the level of the triangulation which this class was initialized with, <a class="el" href="classTransfiniteInterpolationManifold.html#a34326a35d9ec4b6911d90c85c21847d8">initialize()</a> must be called again to update the manifold ids connected to the coarse cells.</p>
<dl class="section note"><dt>Note</dt><dd>The triangulation used to construct the manifold must not be destroyed during the usage of this object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2manifold__lib_8cc_source.html#l01676">1676</a> of file <a class="el" href="grid_2manifold__lib_8cc_source.html">manifold_lib.cc</a>.</p>

</div>
</div>
<a id="a634fa138b32712ad27c07e09a34f5c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a634fa138b32712ad27c07e09a34f5c75">&#9670;&nbsp;</a></span>get_new_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a>&lt; dim, spacedim &gt;::get_new_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>surrounding_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the point which shall become the new vertex surrounded by the given points <code>surrounding_points</code>. <code>weights</code> contains appropriate weights for the surrounding points according to which the manifold determines the new point's position.</p>
<p>The implementation in this class overrides the method in the base class and computes the new point by a transfinite interpolation. The first step in the implementation is to identify the coarse cell on which the surrounding points are located. Then, the coordinates are transformed to the unit coordinates on the coarse cell by a Newton iteration, where the new point is then computed according to the weights. Finally, it is pushed forward to the real space according to the transfinite interpolation. </p>

<p>Reimplemented from <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt; dim, dim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="grid_2manifold__lib_8cc_source.html#l02580">2580</a> of file <a class="el" href="grid_2manifold__lib_8cc_source.html">manifold_lib.cc</a>.</p>

</div>
</div>
<a id="aa38786b12dedbb6414cabc249551fe4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa38786b12dedbb6414cabc249551fe4a">&#9670;&nbsp;</a></span>get_new_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a>&lt; dim, spacedim &gt;::get_new_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>surrounding_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt;&#160;</td>
          <td class="paramname"><em>new_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute a new set of points that interpolate between the given points <code>surrounding_points</code>. <code>weights</code> is a table with as many columns as <code>surrounding_points.size()</code>. The number of columns in <code>weights</code> must match the length of <code>new_points</code>.</p>
<p>The implementation in this class overrides the method in the base class and computes the new point by a transfinite interpolation. The first step in the implementation is to identify the coarse cell on which the surrounding points are located. Then, the coordinates are transformed to the unit coordinates on the coarse cell by a Newton iteration, where the new points are then computed according to the weights. Finally, the is pushed forward to the real space according to the transfinite interpolation.</p>
<p>The implementation does not allow for <code>surrounding_points</code> and <code>new_points</code> to point to the same vector, so make sure to pass different objects into the function. </p>

<p>Reimplemented from <a class="el" href="classManifold.html#a09b9fa8b80707d686b5929d0f27732a7">Manifold&lt; dim, dim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="grid_2manifold__lib_8cc_source.html#l02600">2600</a> of file <a class="el" href="grid_2manifold__lib_8cc_source.html">manifold_lib.cc</a>.</p>

</div>
</div>
<a id="ab6bd71369534cc578dd2801cd186eafe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6bd71369534cc578dd2801cd186eafe">&#9670;&nbsp;</a></span>get_possible_cells_around_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; unsigned int, 20 &gt; <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a>&lt; dim, spacedim &gt;::get_possible_cells_around_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>surrounding_points</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal function to identify the most suitable cells (=charts) where the given surrounding points are located. We use a cheap algorithm to identify the cells and rank the cells by probability before we actually do the search inside the relevant cells. The cells are sorted by the distance of a Q1 approximation of the inverse mapping to the unit cell of the surrounding points. We expect at most 20 cells (it should be up to 8 candidates on a 3D structured mesh and a bit more on unstructured ones, typically we only get two or three), so get an array with 20 entries of a the indices <code>cell-&gt;index()</code>. </p>

<p class="definition">Definition at line <a class="el" href="grid_2manifold__lib_8cc_source.html#l02233">2233</a> of file <a class="el" href="grid_2manifold__lib_8cc_source.html">manifold_lib.cc</a>.</p>

</div>
</div>
<a id="ae2ad324a54fb7f415ec134ad486a4cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2ad324a54fb7f415ec134ad486a4cd8">&#9670;&nbsp;</a></span>compute_chart_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a>&lt; dim, spacedim &gt;::compute_chart_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>surrounding_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt;&#160;</td>
          <td class="paramname"><em>chart_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finalizes the identification of the correct chart and populates <code>chart_points</code> with the pullbacks of the surrounding points. This method internally calls <code><a class="el" href="classTransfiniteInterpolationManifold.html#ab6bd71369534cc578dd2801cd186eafe">get_possible_cells_around_points()</a></code>.</p>
<p>Return an iterator to the cell on which the chart is defined. </p>

<p class="definition">Definition at line <a class="el" href="grid_2manifold__lib_8cc_source.html#l02319">2319</a> of file <a class="el" href="grid_2manifold__lib_8cc_source.html">manifold_lib.cc</a>.</p>

</div>
</div>
<a id="a9a0aca899ae463ebeed22062081f6438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a0aca899ae463ebeed22062081f6438">&#9670;&nbsp;</a></span>pull_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; dim &gt; <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a>&lt; dim, spacedim &gt;::pull_back </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>initial_guess</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pull back operation into the unit coordinates on the given coarse cell.</p>
<p>This method is currently based on a Newton-like iteration to find the point in the origin. One may speed up the iteration by providing a good initial guess as the third argument. If no better point is known, use cell-&gt;real_to_unit_cell_affine_approximation(p)</p>
<dl class="section note"><dt>Note</dt><dd>This internal function is currently not compatible with the <a class="el" href="classChartManifold.html#a5113d1d256ef1777f91eafe5f7d5fa35">ChartManifold::pull_back()</a> function because the given class represents an atlas of charts, not a single chart. Thus, the <a class="el" href="classTransfiniteInterpolationManifold.html#a9a0aca899ae463ebeed22062081f6438">pull_back()</a> operation is only valid with the additional information of the chart, given by a cell on the coarse grid. An alternative implementation could shift the index depending on the coarse cell for a 1-to-1 relation between the chart space and the image space. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2manifold__lib_8cc_source.html#l02082">2082</a> of file <a class="el" href="grid_2manifold__lib_8cc_source.html">manifold_lib.cc</a>.</p>

</div>
</div>
<a id="aee61fce6c8981aea6bf48dbfd50ebd1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee61fce6c8981aea6bf48dbfd50ebd1b">&#9670;&nbsp;</a></span>push_forward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a>&lt; dim, spacedim &gt;::push_forward </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>chart_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Push forward operation.</p>
<dl class="section note"><dt>Note</dt><dd>This internal function is currently not compatible with the <a class="el" href="classChartManifold.html#a713fbbf4271f9539bb2406f7029ab239">ChartManifold::push_forward()</a> function because the given class represents an atlas of charts, not a single chart. Thus, the <a class="el" href="classTransfiniteInterpolationManifold.html#aee61fce6c8981aea6bf48dbfd50ebd1b">push_forward()</a> operation is only valid with the additional information of the chart, given by a cell on the coarse grid. An alternative implementation could shift the index depending on the coarse cell for a 1-to-1 relation between the chart space and the image space. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2manifold__lib_8cc_source.html#l02032">2032</a> of file <a class="el" href="grid_2manifold__lib_8cc_source.html">manifold_lib.cc</a>.</p>

</div>
</div>
<a id="a23f6a92da6eb36fa312c0aac4715cdc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23f6a92da6eb36fa312c0aac4715cdc5">&#9670;&nbsp;</a></span>push_forward_gradient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 1, dim, spacedim &gt; <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a>&lt; dim, spacedim &gt;::push_forward_gradient </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>chart_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>pushed_forward_chart_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gradient of the push_forward method.</p>
<dl class="section note"><dt>Note</dt><dd>This internal function is not compatible with the <a class="el" href="classChartManifold.html#a9f6141f9a6780c6c271c73cb1c74e5b4">ChartManifold::push_forward_gradient()</a> function because the given class represents an atlas of charts, not a single chart. Furthermore, this private function also requires the user to provide the result of the <a class="el" href="classTransfiniteInterpolationManifold.html#aee61fce6c8981aea6bf48dbfd50ebd1b">push_forward()</a> call on the chart point for the single use case of this function, namely inside a Newton iteration where the gradient is computed by finite differences. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2manifold__lib_8cc_source.html#l02053">2053</a> of file <a class="el" href="grid_2manifold__lib_8cc_source.html">manifold_lib.cc</a>.</p>

</div>
</div>
<a id="aace84e99db1f4767ce9e524170a1de2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aace84e99db1f4767ce9e524170a1de2c">&#9670;&nbsp;</a></span>get_intermediate_point()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_intermediate_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an intermediate point between two given points. Overloading this function allows the default pair-wise reduction implementation of the method <a class="el" href="classTransfiniteInterpolationManifold.html#a634fa138b32712ad27c07e09a34f5c75">get_new_point()</a> that takes a <a class="el" href="classQuadrature.html">Quadrature</a> object as input to work properly.</p>
<p>An implementation of this function should returns a parametric curve on the manifold, joining the points <code>p1</code> and <code>p2</code>, with parameter <code>w</code> in the interval [0,1]. In particular <code>get_intermediate_point(p1, p2, 0.0)</code> should return <code>p1</code> and <code>get_intermediate_point(p1, p2, 1.0)</code> should return <code>p2</code>.</p>
<p>In its default implementation, this function calls the <a class="el" href="classManifold.html#a29c25e5d735160e0d846aab01d918e86">project_to_manifold()</a> method with the convex combination of <code>p1</code> and <code>p2</code>. User classes can get away by simply implementing the <a class="el" href="classManifold.html#a29c25e5d735160e0d846aab01d918e86">project_to_manifold()</a> method. </p>

<p>Reimplemented in <a class="el" href="classSphericalManifold.html#a71e38e3a474c01409683ca853f66f5eb">SphericalManifold&lt; dim, spacedim &gt;</a>, and <a class="el" href="classChartManifold.html#af255b3dfb6c1f38eaece0e995a85ec86">ChartManifold&lt; dim, spacedim, chartdim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00347">347</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a29c25e5d735160e0d846aab01d918e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29c25e5d735160e0d846aab01d918e86">&#9670;&nbsp;</a></span>project_to_manifold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::project_to_manifold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>surrounding_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>candidate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a point which lies close to the given manifold, it modifies it and projects it to manifold itself.</p>
<p>This class is used by the default implementation of the function <a class="el" href="classTransfiniteInterpolationManifold.html#a634fa138b32712ad27c07e09a34f5c75">get_new_point()</a> and should be implemented by derived classes. The default implementation simply throws an exception if called.</p>
<p>If your manifold is simple, you could implement this function only, and the default behavior should work out of the box. </p>

<p>Reimplemented in <a class="el" href="classFlatManifold.html#a8f30acedc685f5263d5924e7dbbaa478">FlatManifold&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00409">409</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="af518522b81bdfe059b88bb557f7a60ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af518522b81bdfe059b88bb557f7a60ba">&#9670;&nbsp;</a></span>get_new_point_on_line()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_line </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::line_iterator &amp;&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Return the point which shall become the new middle vertex of the two children of a regular line. In 2D, this line is a line at the boundary, while in 3d, it is bounding a face at the boundary (the lines therefore is also on the boundary).</p>
<p>The default implementation of this function passes its argument to the <a class="el" href="namespaceManifolds.html#aa3ae330e2a2d8030955d5a395f3f1d18">Manifolds::get_default_points_and_weights()</a> function, and then calls the <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> function. User derived classes can overload <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> or <a class="el" href="classManifold.html#a29c25e5d735160e0d846aab01d918e86">Manifold&lt;dim,spacedim&gt;::project_to_manifold()</a>, which is called by the default implementation of <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a>. </p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00427">427</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a59a7a18b04151504883074c24108266f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a7a18b04151504883074c24108266f">&#9670;&nbsp;</a></span>get_new_point_on_quad() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_quad </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::quad_iterator &amp;&#160;</td>
          <td class="paramname"><em>quad</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Return the point which shall become the common point of the four children of a quad at the boundary in three or more spatial dimensions. This function therefore is only useful in at least three dimensions and should not be called for lower dimensions.</p>
<p>This function is called after the four lines bounding the given <code>quad</code> are refined, so you may want to use the information provided by <code>quad-&gt;line(i)-&gt;child(j)</code>, <code>i=0...3</code>, <code>j=0,1</code>.</p>
<p>The default implementation of this function passes its argument to the <a class="el" href="namespaceManifolds.html#aa3ae330e2a2d8030955d5a395f3f1d18">Manifolds::get_default_points_and_weights()</a> function, and then calls the <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> function. User derived classes can overload <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> or <a class="el" href="classManifold.html#a29c25e5d735160e0d846aab01d918e86">Manifold&lt;dim,spacedim&gt;::project_to_manifold()</a>, which is called by the default implementation of <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a>. </p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00448">448</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a73f1d301d7950f55b59e1c2982dfe942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f1d301d7950f55b59e1c2982dfe942">&#9670;&nbsp;</a></span>get_new_point_on_quad() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; 1 &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; 1, 1 &gt;::get_new_point_on_quad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 1 &gt;::quad_iterator &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00419">419</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a1adb7e5b4a0feeeef7f9ec087e23d376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1adb7e5b4a0feeeef7f9ec087e23d376">&#9670;&nbsp;</a></span>get_new_point_on_quad() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; 1, 2 &gt;::get_new_point_on_quad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 2 &gt;::quad_iterator &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00430">430</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a4bd7186dfb0ea938abda62e962d5f867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd7186dfb0ea938abda62e962d5f867">&#9670;&nbsp;</a></span>get_new_point_on_quad() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; 1, 3 &gt;::get_new_point_on_quad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 3 &gt;::quad_iterator &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00441">441</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a8d8365135405a1f057020d84a315ffa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d8365135405a1f057020d84a315ffa6">&#9670;&nbsp;</a></span>get_new_point_on_hex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_hex </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::hex_iterator &amp;&#160;</td>
          <td class="paramname"><em>hex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Return the point which shall become the common point of the eight children of a hex in three or spatial dimensions. This function therefore is only useful in at least three dimensions and should not be called for lower dimensions.</p>
<p>This function is called after the all the bounding objects of the given <code>hex</code> are refined, so you may want to use the information provided by <code>hex-&gt;quad(i)-&gt;line(j)-&gt;child(k)</code>, <code>i=0...5</code>, <code>j=0...3</code>, <code>k=0,1</code>.</p>
<p>The default implementation of this function passes its argument to the <a class="el" href="namespaceManifolds.html#aa3ae330e2a2d8030955d5a395f3f1d18">Manifolds::get_default_points_and_weights()</a> function, and then calls the <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> function. User derived classes can overload <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> or <a class="el" href="classManifold.html#a29c25e5d735160e0d846aab01d918e86">Manifold&lt;dim,spacedim&gt;::project_to_manifold()</a>, which is called by the default implementation of <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a>. </p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00470">470</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="ada653729888b24eb140a382512167163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada653729888b24eb140a382512167163">&#9670;&nbsp;</a></span>get_new_point_on_hex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; 3, 3 &gt;::get_new_point_on_hex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt;::hex_iterator &amp;&#160;</td>
          <td class="paramname"><em>hex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00463">463</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="ab79c3a0f002136b483b50722ea6690d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab79c3a0f002136b483b50722ea6690d9">&#9670;&nbsp;</a></span>get_new_point_on_face() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_face </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Depending on <code>dim=2</code> or <code>dim=3</code> this function calls the get_new_point_on_line or the get_new_point_on_quad function. It throws an exception for <code>dim=1</code>. This wrapper allows dimension independent programming. </p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00481">481</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="ae6a38fc3f140d54aa80195831a27c499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a38fc3f140d54aa80195831a27c499">&#9670;&nbsp;</a></span>get_new_point_on_face() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; 1 &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; 1, 1 &gt;::get_new_point_on_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 1 &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00386">386</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a9bba395b8edbb4703d2e77689266436f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bba395b8edbb4703d2e77689266436f">&#9670;&nbsp;</a></span>get_new_point_on_face() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; 1, 2 &gt;::get_new_point_on_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 2 &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00397">397</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a4dd6859a4858667c7d37838276c8e8b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dd6859a4858667c7d37838276c8e8b2">&#9670;&nbsp;</a></span>get_new_point_on_face() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; 1, 3 &gt;::get_new_point_on_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 3 &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00408">408</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="af36b25e230fefc6eb32d53cb6e69cbba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36b25e230fefc6eb32d53cb6e69cbba">&#9670;&nbsp;</a></span>get_new_point_on_cell()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_cell </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Depending on <code>dim=1</code>, <code>dim=2</code> or <code>dim=3</code> this function calls the get_new_point_on_line, get_new_point_on_quad or the get_new_point_on_hex function. This wrapper allows dimension independent programming. </p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00492">492</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="adff3c7c6851d64d1839964f7ebbfc787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adff3c7c6851d64d1839964f7ebbfc787">&#9670;&nbsp;</a></span>get_tangent_vector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_tangent_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a vector that, at \(\mathbf x_1\), is tangential to the geodesic that connects two points \(\mathbf x_1,\mathbf x_2\). The geodesic is the shortest line between these two points, where "shortest" is defined via a metric specific to a particular implementation of this class in a derived class. For example, in the case of a <a class="el" href="classFlatManifold.html">FlatManifold</a>, the shortest line between two points is just the straight line, and in this case the tangent vector is just the difference \(\mathbf d=\mathbf x_2-\mathbf x_1\). On the other hand, for a manifold that describes a surface embedded in a higher dimensional space (e.g., the surface of a sphere), then the tangent vector is tangential to the surface, and consequently may point in a different direction than the straight line that connects the two points.</p>
<p>While tangent vectors are often normalized to unit length, the vectors returned by this function are normalized as described in the introduction of this class. Specifically, if \(\mathbf s(t)\) traces out the geodesic between the two points where \(\mathbf x_1 = \mathbf s(0)\) and \(\mathbf x_2 = \mathbf s(1)\), then the returned vector must equal \(\mathbf s&#39;(0)\). In other words, the norm of the returned vector also encodes, in some sense, the <em>length</em> of the geodesic because a curve \(\mathbf s(t)\) must move "faster" if the two points it connects between arguments \(t=0\) and \(t=1\) are farther apart.</p>
<p>The default implementation of this function approximates \(\mathbf s&#39;(0) \approx \frac{\mathbf s(\epsilon)-\mathbf x_1}{\epsilon}\) for a small value of \(\epsilon\), and the evaluation of \(\mathbf s(\epsilon)\) is done by calling <a class="el" href="classTransfiniteInterpolationManifold.html#a634fa138b32712ad27c07e09a34f5c75">get_new_point()</a>. If possible, derived classes should override this function by an implementation of the exact derivative.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>The first point that describes the geodesic, and the one at which the "direction" is to be evaluated. </td></tr>
    <tr><td class="paramname">x2</td><td>The second point that describes the geodesic. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A "direction" vector tangential to the geodesic. </dd></dl>

<p>Reimplemented in <a class="el" href="classSphericalManifold.html#ad65c74505057329e5bfae1fb436f3fd5">SphericalManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classChartManifold.html#a9577b9723c8d6fb8481ca99daec95682">ChartManifold&lt; dim, spacedim, chartdim &gt;</a>, and <a class="el" href="classFlatManifold.html#ab5eec4132f6d653dea1380f7d587ecdf">FlatManifold&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00539">539</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a8f737627dc946fb68c097d6ec83419d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f737627dc946fb68c097d6ec83419d4">&#9670;&nbsp;</a></span>normal_vector() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::normal_vector </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the normal vector to a face embedded in this manifold, at the point p. If p is not in fact on the surface, but only close-by, try to return something reasonable, for example the normal vector at the surface point closest to p. (The point p will in fact not normally lie on the actual surface, but rather be a quadrature point mapped by some polynomial mapping; the mapped surface, however, will not usually coincide with the actual surface.)</p>
<p>This function only makes sense if dim==spacedim because otherwise there is no unique normal vector but in fact a (spacedim-dim+1)-dimensional tangent space of vectors that are all both normal to the face and normal to the dim-dimensional surface that lives in spacedim-dimensional space. For example, think of a two-dimensional mesh that covers a two-dimensional surface in three-dimensional space. In that case, each face (edge) is one-dimensional, and there are two linearly independent vectors that are both normal to the edge: one is normal to the edge and tangent to the surface (intuitively, that would be the one that points from the current cell to the neighboring one, if the surface was locally flat), and the other one is rooted in the edge but points perpendicular to the surface (which is also perpendicular to the edge that lives within the surface). Thus, because there are no obviously correct semantics for this function if spacedim is greater than dim, the function will simply throw an error in that situation.</p>
<p>The face iterator gives an indication which face this function is supposed to compute the normal vector for. This is useful if the boundary of the domain is composed of different nondifferential pieces (for example when using the <a class="el" href="classFlatManifold.html">FlatManifold</a> class to approximate a geometry that is completely described by the coarse mesh, with piecewise (bi-)linear components between the vertices, but where the boundary may have a kink at the vertices itself).</p>
<dl class="section note"><dt>Note</dt><dd>In 2d, the default implementation of this function computes the normal vector by taking the tangent direction from p to the further one of the two vertices that make up an edge, and then rotates it outward (with respect to the coordinate system of the edge) by 90 degrees. In 3d, the default implementation is more complicated, aiming at avoiding problems with numerical round-off for points close to one of the vertices, and avoiding tangent directions that are linearly dependent. </dd></dl>

<p>Reimplemented in <a class="el" href="classSphericalManifold.html#adb333bd42dfb3e7bd933b0f1b9ada0d9">SphericalManifold&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFlatManifold.html#aab60f221758b3a32a596dde96fc1188c">FlatManifold&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00595">595</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a464ae5e689877ac0d06b08b33f718caa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a464ae5e689877ac0d06b08b33f718caa">&#9670;&nbsp;</a></span>normal_vector() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, 2 &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; 2, 2 &gt;::normal_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00145">145</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="ad95b06b088819df6a9305d0009495d3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad95b06b088819df6a9305d0009495d3d">&#9670;&nbsp;</a></span>normal_vector() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, 3 &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; 3, 3 &gt;::normal_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00166">166</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a2f8317a03ab0c13971ff53bcb38b49e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f8317a03ab0c13971ff53bcb38b49e9">&#9670;&nbsp;</a></span>get_normals_at_vertices() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_normals_at_vertices </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;&#160;</td>
          <td class="paramname"><em>face_vertex_normals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the normal vectors to the boundary at each vertex of the given face embedded in the <a class="el" href="classManifold.html">Manifold</a>. It is not required that the normal vectors be normed somehow. Neither is it required that the normals actually point outward.</p>
<p>This function is needed to compute data for C1 mappings. The default implementation calls <a class="el" href="classManifold.html#a8f737627dc946fb68c097d6ec83419d4">normal_vector()</a> on each vertex.</p>
<p>Note that when computing normal vectors at a vertex where the boundary is not differentiable, you have to make sure that you compute the one-sided limits, i.e. limit with respect to points inside the given face. </p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00614">614</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="ae944375afbf9370708422e520c6969e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae944375afbf9370708422e520c6969e5">&#9670;&nbsp;</a></span>get_normals_at_vertices() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classManifold.html">Manifold</a>&lt; 2, 2 &gt;::get_normals_at_vertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00251">251</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a1e3477908d71618cfc0c2de81e8ad474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e3477908d71618cfc0c2de81e8ad474">&#9670;&nbsp;</a></span>get_normals_at_vertices() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classManifold.html">Manifold</a>&lt; 3, 3 &gt;::get_normals_at_vertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00273">273</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a0e291ba17bd296e1c79d053649e288f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e291ba17bd296e1c79d053649e288f5">&#9670;&nbsp;</a></span>triangulation</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;* <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a>&lt; dim, spacedim &gt;::triangulation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The underlying triangulation. </p>

<p class="definition">Definition at line <a class="el" href="grid_2manifold__lib_8h_source.html#l01126">1126</a> of file <a class="el" href="grid_2manifold__lib_8h_source.html">manifold_lib.h</a>.</p>

</div>
</div>
<a id="a750316fe04841cfe30a11a9c0b407a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a750316fe04841cfe30a11a9c0b407a96">&#9670;&nbsp;</a></span>level_coarse</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a>&lt; dim, spacedim &gt;::level_coarse</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The level of the mesh cells where the transfinite approximation is applied, usually level 0. </p>

<p class="definition">Definition at line <a class="el" href="grid_2manifold__lib_8h_source.html#l01132">1132</a> of file <a class="el" href="grid_2manifold__lib_8h_source.html">manifold_lib.h</a>.</p>

</div>
</div>
<a id="aeb1f6697bd23c98a60e99a0084019fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb1f6697bd23c98a60e99a0084019fab">&#9670;&nbsp;</a></span>coarse_cell_is_flat</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classbool.html">bool</a>&gt; <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a>&lt; dim, spacedim &gt;::coarse_cell_is_flat</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>In case there all surrounding manifolds are the transfinite manifold or have default (invalid) manifold id, the manifold degenerates to a flat manifold and we can choose cheaper algorithms for the push_forward method. </p>

<p class="definition">Definition at line <a class="el" href="grid_2manifold__lib_8h_source.html#l01139">1139</a> of file <a class="el" href="grid_2manifold__lib_8h_source.html">manifold_lib.h</a>.</p>

</div>
</div>
<a id="a8a71680361d03d27cb966a057e9978bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a71680361d03d27cb966a057e9978bc">&#9670;&nbsp;</a></span>chart_manifold</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFlatManifold.html">FlatManifold</a>&lt;dim&gt; <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a>&lt; dim, spacedim &gt;::chart_manifold</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A flat manifold used to compute new points in the chart space where we use a <a class="el" href="classFlatManifold.html">FlatManifold</a> description. </p>

<p class="definition">Definition at line <a class="el" href="grid_2manifold__lib_8h_source.html#l01145">1145</a> of file <a class="el" href="grid_2manifold__lib_8h_source.html">manifold_lib.h</a>.</p>

</div>
</div>
<a id="a95d85cd77d90a38a4f01ea9ba062cb99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d85cd77d90a38a4f01ea9ba062cb99">&#9670;&nbsp;</a></span>quadratic_approximation</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;internal::MappingQGenericImplementation:: InverseQuadraticApproximation&lt;dim, spacedim&gt; &gt; <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a>&lt; dim, spacedim &gt;::quadratic_approximation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A vector of quadratic approximations to the inverse map from real points to chart points for each of the coarse mesh cells. </p>

<p class="definition">Definition at line <a class="el" href="grid_2manifold__lib_8h_source.html#l01153">1153</a> of file <a class="el" href="grid_2manifold__lib_8h_source.html">manifold_lib.h</a>.</p>

</div>
</div>
<a id="a1347d7c35a8ea2fa557bc0a74322feb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1347d7c35a8ea2fa557bc0a74322feb0">&#9670;&nbsp;</a></span>clear_signal</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::connection <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a>&lt; dim, spacedim &gt;::clear_signal</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The connection to Triangulation::signals::clear that must be reset once this class goes out of scope. </p>

<p class="definition">Definition at line <a class="el" href="grid_2manifold__lib_8h_source.html#l01159">1159</a> of file <a class="el" href="grid_2manifold__lib_8h_source.html">manifold_lib.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/grid/<a class="el" href="grid_2manifold__lib_8h_source.html">manifold_lib.h</a></li>
<li>source/grid/<a class="el" href="grid_2manifold__lib_8cc_source.html">manifold_lib.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
