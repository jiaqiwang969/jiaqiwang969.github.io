<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_49.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-49 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.3.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.3.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">The step-49 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_1.html">step-1</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Generalconcernsaboutmeshes">General concerns about meshes</a>
        <li><a href="#Howtocreatemeshes">How to create meshes</a>
      <ul>
        <li><a href="#UsingGridGenerator">Using GridGenerator</a>
        <li><a href="#Constructingyourownmeshprogrammatically">Constructing your own mesh programmatically</a>
        <li><a href="#Importingfromexternalprograms">Importing from external programs</a>
      </ul>
        <li><a href="#ModifyingaMesh">Modifying a Mesh</a>
      <ul>
        <li><a href="#Transformations">Transformations</a>
        <li><a href="#MergingMeshes">Merging Meshes</a>
        <li><a href="#MovingVertices">Moving Vertices</a>
        <li><a href="#ExtrudingMeshes">Extruding Meshes</a>
      </ul>
        <li><a href="#Afteryouhaveacoarsemesh"> After you have a coarse mesh </a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#Generatingoutputforagivenmesh">Generating output for a given mesh</a>
        <li><a href="#Mainroutines">Main routines</a>
      <ul>
        <li><a href="#grid_1Loadingameshgeneratedbygmsh">grid_1: Loading a mesh generated by gmsh</a>
        <li><a href="#grid_2Mergingtriangulations">grid_2: Merging triangulations</a>
        <li><a href="#grid_3Movingvertices">grid_3: Moving vertices</a>
        <li><a href="#grid_4Demonstratingextrude_triangulation">grid_4: Demonstrating extrude_triangulation</a>
        <li><a href="#grid_5DemonstratingGridToolstransformpart1">grid_5: Demonstrating GridTools::transform, part 1</a>
        <li><a href="#grid_6DemonstratingGridToolstransformpart2">grid_6: Demonstrating GridTools::transform, part 2</a>
        <li><a href="#grid_7Demonstratingdistort_random">grid_7: Demonstrating distort_random</a>
      </ul>
        <li><a href="#Themainfunction">The main function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#NextstepsCurvedCells">Next steps: Curved Cells</a>
        <li><a href="#Possibilitiesforextensions"> Possibilities for extensions </a>
      <ul>
        <li><a href="#Assigningdifferentboundaryids"> Assigning different boundary ids </a>
        <li><a href="#Extractingaboundarymesh"> Extracting a boundary mesh </a>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <em>This program was contributed by Timo Heister. Parts of the results section were contributed by Yuhan Zhou, Wolfgang Bangerth, and David Wells.</em></p>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction </h1>
<p>This tutorial is an extension to <a class="el" href="step_1.html">step-1</a> and demonstrates several ways to obtain more involved meshes than the ones shown there.</p>
<dl class="section note"><dt>Note</dt><dd>This tutorial is also available as a Jupyter Python notebook that uses the deal.II python interface. The notebook is available in the same directory as the original C++ program.</dd></dl>
<p>Generating complex geometries is a challenging task, especially in three space dimensions. We will discuss several ways to do this, but this list is not exhaustive. Additionally, there is not one approach that fits all problems.</p>
<p>This example program shows some of ways to create and modify meshes for computations and outputs them as <code>.vtu</code> files in much the same way as we do in <a class="el" href="step_1.html">step-1</a>. No other computations or adaptive refinements are done; the idea is that you can use the techniques used here as building blocks in other, more involved simulators. Please note that the example program does not show all the ways to generate meshes that are discussed in this introduction.</p>
<p><a class="anchor" id="Generalconcernsaboutmeshes"></a></p><h3>General concerns about meshes</h3>
<p>When you use adaptive mesh refinement, you definitely want the initial mesh to be as coarse as possible. The reason is that you can make it as fine as you want using adaptive refinement as long as you have memory and CPU time available. However, this requires that you don't waste mesh cells in parts of the domain where they don't pay off. As a consequence, you don't want to start with a mesh that is too fine to start with, because that takes up a good part of your cell budget already, and because you can't coarsen away cells that are in the initial mesh.</p>
<p>That said, your mesh needs to capture the given geometry adequately.</p>
<p><a class="anchor" id="Howtocreatemeshes"></a></p><h3>How to create meshes</h3>
<p>There are several ways to create an initial mesh. Meshes can be modified or combined in many ways as discussed later on.</p>
<p><a class="anchor" id="UsingGridGenerator"></a></p><h4>Using <a class="el" href="namespaceGridGenerator.html">GridGenerator</a></h4>
<p>The easiest way to generate meshes is to use the functions in namespace <a class="el" href="namespaceGridGenerator.html">GridGenerator</a>, as already discussed in <a class="el" href="step_1.html">step-1</a>. There are many different helper functions available, including <a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube()</a>, <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell()</a>, <a class="el" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball()</a>, and <a class="el" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole()</a>.</p>
<p><a class="anchor" id="Constructingyourownmeshprogrammatically"></a></p><h4>Constructing your own mesh programmatically</h4>
<p>If there is no good fit in the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace for what you want to do, you can always create a <a class="el" href="classTriangulation.html">Triangulation</a> in your program "by hand". For that, you need a list of vertices with their coordinates and a list of cells referencing those vertices. You can find an example in the function <code>create_coarse_grid()</code> in <a class="el" href="step_14.html">step-14</a>. All the functions in <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> are implemented in this fashion.</p>
<p>We are happy to accept more functions to be added to <a class="el" href="namespaceGridGenerator.html">GridGenerator</a>. So, if you end up writing a function that might be useful for a larger audience, please contribute it.</p>
<p><a class="anchor" id="Importingfromexternalprograms"></a></p><h4>Importing from external programs</h4>
<p>The class <a class="el" href="classGridIn.html">GridIn</a> can read many different mesh formats from a file from disk. How this is done is explained in <a class="el" href="step_5.html">step-5</a> and can be seen in the function <code>grid_1</code> in this example, see the code below.</p>
<p>Meshes can be generated from different tools like <a href="http://gmsh.info" target="_top">gmsh</a>, <a href="https://lagrit.lanl.gov/" target="_top">lagrit</a> and <a href="http://cubit.sandia.gov/" target="_top">cubit</a>. See the documentation of <a class="el" href="classGridIn.html">GridIn</a> for more information. The problem is that deal.II needs meshes that only consist of quadrilaterals and hexahedra &ndash; tetrahedral meshes won't work (this means tools like tetgen can not be used directly).</p>
<p>We will describe a possible workflow using Gmsh. Gmsh is the smallest and most quickly set up open source tool we are aware of. It can generate unstructured 2d quad meshes. In 3d, it can extrude 2d meshes to get hexahedral meshes; 3D meshing of unstructured geometry into hexahedra is possible, though there are some issues with the quality of these meshes that imply that these meshes only sometimes work in deal.II.</p>
<p>In Gmsh, a mesh is fundamentally described in a text-based <code>.geo</code> file whose format can contain computations, loops, variables, etc. This format is quite flexible in allowing the description of complex geometries. The mesh is then generated from a surface representation, which is built from a list of line loops, which is built from a list of lines, which are in turn built from points. The <code>.geo</code> script can be written and edited by hand or it can be generated automatically by creating objects graphically inside Gmsh. In many cases it is best to combine both approaches. The file can be easily reloaded by pressing "reload" under the "Geometry" tab if you want to write it by hand and see the effects in the graphical user interface of gmsh.</p>
<p>This tutorial contains an example <code>.geo</code> file that describes a box with two objects cut out in the interior. This is how <code>example.geo</code> looks like in Gmsh (displaying the boundary indicators as well as the mesh discussed further down below):</p>
<p><img src="https://www.dealii.org/images/steps/developer/step-49.gmsh_picture.png" alt="" class="inline"/></p>
<p>You might want to open the <code>example.geo</code> file in a text editor (it is located in the same directory as the <code><a class="el" href="step_49.html">step-49</a>.cc</code> source file) to see how it is structured. You can see how the boundary of the domain is composed of a number of lines and how later on we combine several lines into "physical lines" (or "physical surfaces") that list the logical lines' numbers. "Physical" object are the ones that carry information about the boundary indicator (see <a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">this glossary entry</a>).</p>
<dl class="section note"><dt>Note</dt><dd>It is important that this file contain "physical lines" and "physical
  surfaces". These give the boundary indicators and material ids for use in deal.II. Without these physical entities, nothing will be imported into deal.II.</dd></dl>
<p>deal.II's <a class="el" href="classGridIn.html">GridIn</a> class can read the <code>.msh</code> format written by Gmsh and that contains a mesh created for the geometry described by the <code>.geo</code> file. You generate the <code>.msh</code> from the <code>.geo</code> by running the commands</p>
<div class="fragment"><div class="line">gmsh -2 example.geo</div>
</div><!-- fragment --><p>on the command line, or by clicking "Mesh" and then "2D" inside Gmsh after loading the file. Now this is the mesh read from the <code>.msh</code> file and saved again by deal.II as an image (see the <code>grid_1</code> function of the current program):</p>
<p><img src="https://www.dealii.org/images/steps/developer/step-49.grid-1.png" alt="" class="inline"/></p>
<dl class="section note"><dt>Note</dt><dd>Gmsh has a number of other interfaces by which one can describe geometries to it. In particular, it has the ability to interface with scripting languages like Python and Julia, but it can also be scripted from C++. These interfaces are useful if one doesn't just want to generate a mesh for a single geometry (in which case the graphical interface or, in simple cases, a hand-written <code>.geo</code> file is probably the simplest approach), but instead wants to do parametric studies over the geometry for which it is necessary to generate many meshes for geometries that differ in certain parameters. Another case where this is useful is if there is already a CAD geometry for which one only needs a mesh; indeed, this can be done from within deal.II using the <a class="el" href="namespaceGmsh.html#ab65eb217368d006b66bcfcc6fa0f2894">Gmsh::create_triangulation_from_boundary_curve()</a> function.</dd></dl>
<p><a class="anchor" id="ModifyingaMesh"></a></p><h3>Modifying a Mesh</h3>
<p>After acquiring one (or several) meshes in the ways described above, there are many ways to manipulate them before using them in a finite element computation.</p>
<p><a class="anchor" id="Transformations"></a></p><h4>Transformations</h4>
<p>The <a class="el" href="namespaceGridTools.html">GridTools</a> namespace contains a collection of small functions to transform a given mesh in various ways. The usage of the functions <a class="el" href="namespaceGridTools.html#a4b953611883979e3f920f800bd855df3">GridTools::shift</a>, <a class="el" href="namespaceGridTools.html#a910bb99ec34eac082da97c08e7dd17c3">GridTools::rotate</a>, <a class="el" href="namespaceGridTools.html#a0967563badadd81f77f62622dd8bc2cd">GridTools::scale</a> is fairly obvious, so we won't discuss those functions here.</p>
<p>The function <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a> allows you to transform the vertices of a given mesh using a smooth function. An example of its use is also given in the results section of <a class="el" href="step_38.html">step-38</a> but let us show a simpler example here: In the function <code>grid_5()</code> of the current program, we perturb the y coordinate of a mesh with a sine curve:</p>
<table width="60%" align="center">
<tr>
<td align="center"><img src="https://www.dealii.org/images/steps/developer/step-49.grid-5a.png" alt="" class="inline"/> regular input mesh  </td><td align="center"><img src="https://www.dealii.org/images/steps/developer/step-49.grid-5.png" alt="" class="inline"/> output mesh   </td></tr>
</table>
<p>Similarly, we can transform a regularly refined unit square to a wall-adapted mesh in y direction using the formula \((x,y) \mapsto (x,\tanh(2 y)/\tanh(2))\). This is done in <code>grid_6()</code> of this tutorial: </p><table width="60%" align="center">
<tr>
<td align="center"><img src="https://www.dealii.org/images/steps/developer/step-49.grid-6a.png" alt="" class="inline"/> regular input mesh  </td><td align="center"><img src="https://www.dealii.org/images/steps/developer/step-49.grid-6.png" alt="" class="inline"/> wall-adapted output mesh   </td></tr>
</table>
<p>Finally, the function <a class="el" href="namespaceGridTools.html#ac4e8aecd2cf74d3476e0daa11a00248b">GridTools::distort_random</a> allows you to move vertices in the mesh (optionally ignoring boundary nodes) by a random amount. This is demonstrated in <code>grid_7()</code> and the result is as follows:</p>
<table width="60%" align="center">
<tr>
<td align="center"><img src="https://www.dealii.org/images/steps/developer/step-49.grid-7a.png" alt="" class="inline"/> regular input mesh  </td><td align="center"><img src="https://www.dealii.org/images/steps/developer/step-49.grid-7.png" alt="" class="inline"/> perturbed output mesh   </td></tr>
</table>
<p>This function is primarily intended to negate some of the superconvergence effects one gets when studying convergence on regular meshes, as well as to suppress some optimizations in deal.II that can exploit the fact that cells are similar in shape. (Superconvergence refers to the fact that if a mesh has certain symmetries &ndash; for example, if the edges running into a vertex are symmetric to this vertex, and if this is so for all vertices of a cell &ndash; that the solution is then often convergent with a higher order than one would have expected from the usual error analysis. In the end, this is a result of the fact that if one were to make a Taylor expansion of the error, the symmetry leads to the fact that the expected next term of the expansion happens to be zero, and the error order is determined by the second next* term. A distorted mesh does not have these symmetries and consequently the error reflects what one will see when solving the equation on <em>any</em> kind of mesh, rather than showing something that is only reflective of a particular situation.)</p>
<p><a class="anchor" id="MergingMeshes"></a></p><h4>Merging Meshes</h4>
<p>The function <a class="el" href="namespaceGridGenerator.html#a7cd88e7eacd46697dee80ad2b8438d54">GridGenerator::merge_triangulations()</a> allows you to merge two given <a class="el" href="classTriangulation.html">Triangulation</a> objects into a single one. For this to work, the vertices of the shared edge or face have to match exactly. Lining up the two meshes can be achieved using <a class="el" href="namespaceGridTools.html#a4b953611883979e3f920f800bd855df3">GridTools::shift</a> and <a class="el" href="namespaceGridTools.html#a0967563badadd81f77f62622dd8bc2cd">GridTools::scale</a>. In the function <code>grid_2()</code> of this tutorial, we merge a square with a round hole (generated with <a class="el" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole()</a>) and a rectangle (generated with <a class="el" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle()</a>). The function <a class="el" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle()</a> allows you to specify the number of repetitions and the positions of the corners, so there is no need to shift the triangulation manually here. You should inspect the mesh graphically to make sure that cells line up correctly and no unpaired nodes exist in the merged <a class="el" href="classTriangulation.html">Triangulation</a>.</p>
<p>These are the input meshes and the output mesh:</p>
<table width="80%" align="center">
<tr>
<td align="center"><img src="https://www.dealii.org/images/steps/developer/step-49.grid-2a.png" alt="" height="200px" class="inline"/>input mesh 1 </td><td align="center"><img src="https://www.dealii.org/images/steps/developer/step-49.grid-2b.png" alt="" height="200px" class="inline"/>input mesh 2 </td><td align="center"><img src="https://www.dealii.org/images/steps/developer/step-49.grid-2.png" alt="" height="200px" class="inline"/>merged mesh  </td></tr>
</table>
<p><a class="anchor" id="MovingVertices"></a></p><h4>Moving Vertices</h4>
<p>The function <code>grid_3()</code> demonstrates the ability to pick individual vertices and move them around in an existing mesh. Note that this has the potential to produce degenerate or inverted cells and you shouldn't expect anything useful to come of using such meshes. Here, we create a box with a cylindrical hole that is not exactly centered by moving the top vertices upwards:</p>
<table width="60%" align="center">
<tr>
<td align="center"><img src="https://www.dealii.org/images/steps/developer/step-49.grid-3a.png" alt="" height="200px" class="inline"/> input mesh  </td><td align="center"><img src="https://www.dealii.org/images/steps/developer/step-49.grid-3.png" alt="" height="200px" class="inline"/> top vertices moved upwards   </td></tr>
</table>
<p>For the exact way how this is done, see the code below.</p>
<p><a class="anchor" id="ExtrudingMeshes"></a></p><h4>Extruding Meshes</h4>
<p>If you need a 3d mesh that can be created by extruding a given 2d mesh (that can be created in any of the ways given above), you can use the function <a class="el" href="namespaceGridGenerator.html#a6cc0ff3b4e5226c3e06a4aa6ac79f90c">GridGenerator::extrude_triangulation()</a>. See the <code>grid_4()</code> function in this tutorial for an example. Note that for this particular case, the given result could also be achieved using the 3d version of <a class="el" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole()</a>. The main usage is a 2d mesh, generated for example with Gmsh, that is read in from a <code>.msh</code> file as described above. This is the output from grid_4():</p>
<table width="60%" align="center">
<tr>
<td align="center"><img src="https://www.dealii.org/images/steps/developer/step-49.grid-4base.png" alt="" class="inline"/> input mesh  </td><td align="center"><img src="https://www.dealii.org/images/steps/developer/step-49.grid-4.png" alt="" class="inline"/> extruded output mesh   </td></tr>
</table>
<p><a class="anchor" id="Afteryouhaveacoarsemesh"></a></p><h3>After you have a coarse mesh </h3>
<p>Creating a coarse mesh using the methods discussed above is only the first step. When you have it, it will typically serve as the basis for further mesh refinement. This is not difficult &mdash; in fact, there is nothing else to do &mdash; if your geometry consists of only straight faces. However, this is often not the case if you have a more complex geometry and more steps than just creating the mesh are necessary. We will go over some of these steps in the <a href="#Results">results section</a> below.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>This tutorial program is odd in the sense that, unlike for most other steps, the introduction already provides most of the information on how to use the various strategies to generate meshes. Consequently, there is little that remains to be commented on here, and we intersperse the code with relatively little text. In essence, the code here simply provides a reference implementation of what has already been described in the introduction.</p>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__in_8h.html">deal.II/grid/grid_in.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
<div class="ttc" id="agrid_2manifold__lib_8h_html"><div class="ttname"><a href="grid_2manifold__lib_8h.html">manifold_lib.h</a></div></div>
<div class="ttc" id="agrid_2tria_8h_html"><div class="ttname"><a href="grid_2tria_8h.html">tria.h</a></div></div>
<div class="ttc" id="agrid__generator_8h_html"><div class="ttname"><a href="grid__generator_8h.html">grid_generator.h</a></div></div>
<div class="ttc" id="agrid__in_8h_html"><div class="ttname"><a href="grid__in_8h.html">grid_in.h</a></div></div>
<div class="ttc" id="agrid__out_8h_html"><div class="ttname"><a href="grid__out_8h.html">grid_out.h</a></div></div>
<div class="ttc" id="agrid__tools_8h_html"><div class="ttname"><a href="grid__tools_8h.html">grid_tools.h</a></div></div>
<div class="ttc" id="anamespacedealii_html"><div class="ttname"><a href="namespacedealii.html">dealii</a></div><div class="ttdef"><b>Definition:</b> <a href="namespace__dealii_8h_source.html#l00025">namespace_dealii.h:26</a></div></div>
</div><!-- fragment --><p><a class="anchor" id="Generatingoutputforagivenmesh"></a> </p><h3>Generating output for a given mesh</h3>
<p>The following function generates some output for any of the meshes we will be generating in the remainder of this program. In particular, it generates the following information:</p>
<ul>
<li>Some general information about the number of space dimensions in which this mesh lives and its number of cells.</li>
<li>The number of boundary faces that use each boundary indicator, so that it can be compared with what we expect.</li>
</ul>
<p>Finally, the function outputs the mesh in VTU format that can easily be visualized in Paraview or VisIt.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> print_mesh_info(<span class="keyword">const</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>,</div>
<div class="line">                     <span class="keyword">const</span> std::string &amp;       filename)</div>
<div class="line">{</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Mesh info:&quot;</span> &lt;&lt; std::endl</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot; dimension: &quot;</span> &lt;&lt; dim &lt;&lt; std::endl</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot; no. of cells: &quot;</span> &lt;&lt; <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.n_active_cells() &lt;&lt; std::endl;</div>
<div class="ttc" id="aclassTriangulation_html"><div class="ttname"><a href="classTriangulation.html">Triangulation</a></div><div class="ttdef"><b>Definition:</b> <a href="grid_2tria_8h_source.html#l01127">tria.h:1128</a></div></div>
<div class="ttc" id="ap4est__wrappers_8cc_html_ace00f2f80d9780ef9aa1007e1c22c6a4"><div class="ttname"><a href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a></div><div class="ttdeci">const ::parallel::distributed::Triangulation&lt; dim, spacedim &gt; * triangulation</div><div class="ttdef"><b>Definition:</b> <a href="p4est__wrappers_8cc_source.html#l00069">p4est_wrappers.cc:69</a></div></div>
</div><!-- fragment --><p>Next loop over all faces of all cells and find how often each boundary indicator is used (recall that if you access an element of a std::map object that doesn't exist, it is implicitly created and default initialized &ndash; to zero, in the current case &ndash; before we then increment it):</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  std::map&lt;types::boundary_id, unsigned int&gt; boundary_count;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.active_face_iterators())</div>
<div class="line">    <span class="keywordflow">if</span> (face-&gt;at_boundary())</div>
<div class="line">      boundary_count[face-&gt;boundary_id()]++;</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; boundary indicators: &quot;</span>;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> std::pair&lt;const types::boundary_id, unsigned int&gt; &amp;pair :</div>
<div class="line">       boundary_count)</div>
<div class="line">    {</div>
<div class="line">      std::cout &lt;&lt; pair.first &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; pair.second &lt;&lt; <span class="stringliteral">&quot; times) &quot;</span>;</div>
<div class="line">    }</div>
<div class="line">  std::cout &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Finally, produce a graphical representation of the mesh to an output file :</p>
<div class="fragment"><div class="line">  std::ofstream out(filename);</div>
<div class="line">  <a class="code" href="classGridOut.html">GridOut</a>       grid_out;</div>
<div class="line">  grid_out.<a class="code" href="classGridOut.html#a8bd3a74b86d7c0eb792d2efca7f945f1">write_vtu</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, out);</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; written to &quot;</span> &lt;&lt; filename &lt;&lt; std::endl &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="aclassGridOut_html"><div class="ttname"><a href="classGridOut.html">GridOut</a></div><div class="ttdef"><b>Definition:</b> <a href="grid__out_8h_source.html#l00992">grid_out.h:993</a></div></div>
<div class="ttc" id="aclassGridOut_html_a8bd3a74b86d7c0eb792d2efca7f945f1"><div class="ttname"><a href="classGridOut.html#a8bd3a74b86d7c0eb792d2efca7f945f1">GridOut::write_vtu</a></div><div class="ttdeci">void write_vtu(const Triangulation&lt; dim, spacedim &gt; &amp;tria, std::ostream &amp;out) const</div><div class="ttdef"><b>Definition:</b> <a href="grid__out_8cc_source.html#l03591">grid_out.cc:3591</a></div></div>
</div><!-- fragment --><p><a class="anchor" id="Mainroutines"></a> </p><h3>Main routines</h3>
<p><a class="anchor" id="grid_1Loadingameshgeneratedbygmsh"></a> </p><h4>grid_1: Loading a mesh generated by gmsh</h4>
<p>In this first example, we show how to load the mesh for which we have discussed in the introduction how to generate it. This follows the same pattern as used in <a class="el" href="step_5.html">step-5</a> to load a mesh, although there it was written in a different file format (UCD instead of MSH).</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> grid_1()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classGridIn.html">GridIn&lt;2&gt;</a> gridin;</div>
<div class="line">  gridin.<a class="code" href="classGridIn.html#a82ac1c03b0efe87204ad45d2f1d87f7e">attach_triangulation</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>);</div>
<div class="line">  std::ifstream f(<span class="stringliteral">&quot;example.msh&quot;</span>);</div>
<div class="line">  gridin.<a class="code" href="group__simplex.html#ga83872db02e04f52ac52d578912f6da5e">read_msh</a>(f);</div>
<div class="line"> </div>
<div class="line">  print_mesh_info(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, <span class="stringliteral">&quot;grid-1.vtu&quot;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="aclassGridIn_html"><div class="ttname"><a href="classGridIn.html">GridIn</a></div><div class="ttdef"><b>Definition:</b> <a href="grid__in_8h_source.html#l00306">grid_in.h:307</a></div></div>
<div class="ttc" id="aclassGridIn_html_a82ac1c03b0efe87204ad45d2f1d87f7e"><div class="ttname"><a href="classGridIn.html#a82ac1c03b0efe87204ad45d2f1d87f7e">GridIn::attach_triangulation</a></div><div class="ttdeci">void attach_triangulation(Triangulation&lt; dim, spacedim &gt; &amp;tria)</div><div class="ttdef"><b>Definition:</b> <a href="grid__in_8cc_source.html#l00119">grid_in.cc:119</a></div></div>
<div class="ttc" id="agroup__simplex_html_ga83872db02e04f52ac52d578912f6da5e"><div class="ttname"><a href="group__simplex.html#ga83872db02e04f52ac52d578912f6da5e">GridIn::read_msh</a></div><div class="ttdeci">void read_msh(std::istream &amp;in)</div><div class="ttdef"><b>Definition:</b> <a href="grid__in_8cc_source.html#l01427">grid_in.cc:1427</a></div></div>
</div><!-- fragment --><p><a class="anchor" id="grid_2Mergingtriangulations"></a> </p><h4>grid_2: Merging triangulations</h4>
<p>Here, we first create two triangulations and then merge them into one. As discussed in the introduction, it is important to ensure that the vertices at the common interface are located at the same coordinates.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> grid_2()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> tria1;</div>
<div class="line">  <a class="code" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a>(tria1, 0.25, 1.0);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a>          tria2;</div>
<div class="line">  std::vector&lt;unsigned int&gt; repetitions(2);</div>
<div class="line">  repetitions[0] = 3;</div>
<div class="line">  repetitions[1] = 2;</div>
<div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(tria2,</div>
<div class="line">                                            repetitions,</div>
<div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(1.0, -1.0),</div>
<div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(4.0, 1.0));</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div>
<div class="line">  <a class="code" href="namespaceGridGenerator.html#a7cd88e7eacd46697dee80ad2b8438d54">GridGenerator::merge_triangulations</a>(tria1, tria2, <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>);</div>
<div class="line"> </div>
<div class="line">  print_mesh_info(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, <span class="stringliteral">&quot;grid-2.vtu&quot;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="aclassPoint_html"><div class="ttname"><a href="classPoint.html">Point&lt; 2 &gt;</a></div></div>
<div class="ttc" id="anamespaceGridGenerator_html_a7cd88e7eacd46697dee80ad2b8438d54"><div class="ttname"><a href="namespaceGridGenerator.html#a7cd88e7eacd46697dee80ad2b8438d54">GridGenerator::merge_triangulations</a></div><div class="ttdeci">void merge_triangulations(const Triangulation&lt; dim, spacedim &gt; &amp;triangulation_1, const Triangulation&lt; dim, spacedim &gt; &amp;triangulation_2, Triangulation&lt; dim, spacedim &gt; &amp;result, const double duplicated_vertex_tolerance=1.0e-12, const bool copy_manifold_ids=false)</div></div>
<div class="ttc" id="anamespaceGridGenerator_html_ac76417d7404b75cf53c732f456e6e971"><div class="ttname"><a href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a></div><div class="ttdeci">void subdivided_hyper_rectangle(Triangulation&lt; dim, spacedim &gt; &amp;tria, const std::vector&lt; unsigned int &gt; &amp;repetitions, const Point&lt; dim &gt; &amp;p1, const Point&lt; dim &gt; &amp;p2, const bool colorize=false)</div></div>
<div class="ttc" id="anamespaceGridGenerator_html_add14cab546d033c1eaacc9234c64ebcd"><div class="ttname"><a href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a></div><div class="ttdeci">void hyper_cube_with_cylindrical_hole(Triangulation&lt; dim &gt; &amp;triangulation, const double inner_radius=.25, const double outer_radius=.5, const double L=.5, const unsigned int repetitions=1, const bool colorize=false)</div></div>
</div><!-- fragment --><p><a class="anchor" id="grid_3Movingvertices"></a> </p><h4>grid_3: Moving vertices</h4>
<p>In this function, we move vertices of a mesh. This is simpler than one usually expects: if you ask a cell using <code>cell-&gt;vertex(i)</code> for the coordinates of its <code>i</code>th vertex, it doesn't just provide the location of this vertex but in fact a reference to the location where these coordinates are stored. We can then modify the value stored there.</p>
<p>So this is what we do in the first part of this function: We create a square of geometry \([-1,1]^2\) with a circular hole with radius 0.25 located at the origin. We then loop over all cells and all vertices and if a vertex has a \(y\) coordinate equal to one, we move it upward by 0.5.</p>
<p>Note that this sort of procedure does not usually work this way because one will typically encounter the same vertices multiple times and may move them more than once. It works here because we select the vertices we want to use based on their geometric location, and a vertex moved once will fail this test in the future. A more general approach to this problem would have been to keep a std::set of those vertex indices that we have already moved (which we can obtain using <code>cell-&gt;vertex_index(i)</code> and only move those vertices whose index isn't in the set yet.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> grid_3()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div>
<div class="line">  <a class="code" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, 0.25, 1.0);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.active_cell_iterators())</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : cell-&gt;vertex_indices())</div>
<div class="line">        {</div>
<div class="line">          <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;v = cell-&gt;vertex(i);</div>
<div class="line">          <span class="keywordflow">if</span> (std::abs(v(1) - 1.0) &lt; 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-5)</div>
<div class="line">            v(1) += 0.5;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="ttc" id="anamespacePhysics_1_1Elasticity_1_1Kinematics_html_a9587d5229555daa5b1fa1ba2f8a40adb"><div class="ttname"><a href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">Physics::Elasticity::Kinematics::e</a></div><div class="ttdeci">SymmetricTensor&lt; 2, dim, Number &gt; e(const Tensor&lt; 2, dim, Number &gt; &amp;F)</div></div>
</div><!-- fragment --><p>In the second step we will refine the mesh twice. To do this correctly, we should place new points on the interior boundary along the surface of a circle centered at the origin. Fortunately, <a class="el" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a> already attaches a <a class="el" href="classManifold.html">Manifold</a> object to the interior boundary, so we do not need to do anything but refine the mesh (see the <a href="#Results">results section</a> for a fully worked example where we <em>do</em> attach a <a class="el" href="classManifold.html">Manifold</a> object).</p>
<div class="fragment"><div class="line">  <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.refine_global(2);</div>
<div class="line">  print_mesh_info(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, <span class="stringliteral">&quot;grid-3.vtu&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>There is one snag to doing things as shown above: If one moves the nodes on the boundary as shown here, one often ends up with cells in the interior that are badly distorted since the interior nodes were not moved around. This is not that much of a problem in the current case since the mesh did not contain any internal nodes when the nodes were moved &ndash; it was the coarse mesh and it so happened that all vertices are at the boundary. It's also the case that the movement we had here was, compared to the average cell size not overly dramatic. Nevertheless, sometimes one does want to move vertices by a significant distance, and in that case one needs to move internal nodes as well. One way to do that automatically is to call the function <a class="el" href="namespaceGridTools.html#a7ed2aaa1aea3ac22b1e1807ce6d0b5f3">GridTools::laplace_transform</a> that takes a set of transformed vertex coordinates and moves all of the other vertices in such a way that the resulting mesh has, in some sense, a small distortion.</p>
<p><a class="anchor" id="grid_4Demonstratingextrude_triangulation"></a> </p><h4>grid_4: Demonstrating extrude_triangulation</h4>
<p>This example takes the initial grid from the previous function and simply extrudes it into the third space dimension:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> grid_4()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> out;</div>
<div class="line">  <a class="code" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, 0.25, 1.0);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="namespaceGridGenerator.html#a6cc0ff3b4e5226c3e06a4aa6ac79f90c">GridGenerator::extrude_triangulation</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, 3, 2.0, out);</div>
<div class="line">  print_mesh_info(out, <span class="stringliteral">&quot;grid-4.vtu&quot;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceGridGenerator_html_a6cc0ff3b4e5226c3e06a4aa6ac79f90c"><div class="ttname"><a href="namespaceGridGenerator.html#a6cc0ff3b4e5226c3e06a4aa6ac79f90c">GridGenerator::extrude_triangulation</a></div><div class="ttdeci">void extrude_triangulation(const Triangulation&lt; 2, 2 &gt; &amp;input, const unsigned int n_slices, const double height, Triangulation&lt; 3, 3 &gt; &amp;result, const bool copy_manifold_ids=false, const std::vector&lt; types::manifold_id &gt; &amp;manifold_priorities={})</div></div>
</div><!-- fragment --><p><a class="anchor" id="grid_5DemonstratingGridToolstransformpart1"></a> </p><h4>grid_5: Demonstrating <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>, part 1</h4>
<p>This and the next example first create a mesh and then transform it by moving every node of the mesh according to a function that takes a point and returns a mapped point. In this case, we transform \((x,y) \mapsto (x,y+\sin(\pi x/5))\).</p>
<p><a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform()</a> takes a triangulation and an argument that can be called like a function taking a <a class="el" href="classPoint.html">Point</a> and returning a <a class="el" href="classPoint.html">Point</a>. There are different ways of providing such an argument: It could be a pointer to a function; it could be an object of a class that has an <code>operator()</code>; it could be a lambda function; or it could be anything that is described via a <code>std::function&lt;<a class="el" href="classPoint.html">Point</a>&lt;2&gt;(const <a class="el" href="classPoint.html">Point</a>&lt;2&gt;)&gt;</code> object.</p>
<p>Decidedly the more modern way is to use a lambda function that takes a <a class="el" href="classPoint.html">Point</a> and returns a <a class="el" href="classPoint.html">Point</a>, and that is what we do in the following:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> grid_5()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a>          <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div>
<div class="line">  std::vector&lt;unsigned int&gt; repetitions(2);</div>
<div class="line">  repetitions[0] = 14;</div>
<div class="line">  repetitions[1] = 2;</div>
<div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>,</div>
<div class="line">                                            repetitions,</div>
<div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(0.0, 0.0),</div>
<div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(10.0, 1.0));</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>(</div>
<div class="line">    [](<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;in) {</div>
<div class="line">      <span class="keywordflow">return</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(in[0], in[1] + std::sin(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * in[0] / 5.0));</div>
<div class="line">    },</div>
<div class="line">    <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>);</div>
<div class="line">  print_mesh_info(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, <span class="stringliteral">&quot;grid-5.vtu&quot;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceGridTools_html_a212e99cf0d923cebfa04f1d23fa60b04"><div class="ttname"><a href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a></div><div class="ttdeci">void transform(const Transformation &amp;transformation, Triangulation&lt; dim, spacedim &gt; &amp;triangulation)</div></div>
<div class="ttc" id="anamespacenumbers_html_a3e24f194a9cb9b6ff4442b8a7a877d4a"><div class="ttname"><a href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a></div><div class="ttdeci">static constexpr double PI</div><div class="ttdef"><b>Definition:</b> <a href="numbers_8h_source.html#l00231">numbers.h:231</a></div></div>
</div><!-- fragment --><p><a class="anchor" id="grid_6DemonstratingGridToolstransformpart2"></a> </p><h4>grid_6: Demonstrating <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>, part 2</h4>
<p>In this second example of transforming points from an original to a new mesh, we will use the mapping \((x,y) \mapsto (x,\tanh(2y)/\tanh(2))\). To make things more interesting, rather than doing so in a single function as in the previous example, we here create an object with an <code>operator()</code> that will be called by <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>. Of course, this object may in reality be much more complex: the object may have member variables that play a role in computing the new locations of vertices.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Grid6Func</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">double</span> trans(<span class="keyword">const</span> <span class="keywordtype">double</span> y)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">std::tanh</a>(2 * y) / <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">tanh</a>(2);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classPoint.html">Point&lt;2&gt;</a> operator()(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;in)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keywordflow">return</span> {in(0), trans(in(1))};</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> grid_6()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a>          <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div>
<div class="line">  std::vector&lt;unsigned int&gt; repetitions(2);</div>
<div class="line">  repetitions[0] = repetitions[1] = 40;</div>
<div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>,</div>
<div class="line">                                            repetitions,</div>
<div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(0.0, 0.0),</div>
<div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(1.0, 1.0));</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>(Grid6Func(), <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>);</div>
<div class="line">  print_mesh_info(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, <span class="stringliteral">&quot;grid-6.vtu&quot;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceDifferentiation_1_1SD_html_a86151e4842702eb0b667b22122df4597"><div class="ttname"><a href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">Differentiation::SD::tanh</a></div><div class="ttdeci">Expression tanh(const Expression &amp;x)</div><div class="ttdef"><b>Definition:</b> <a href="symengine__math_8cc_source.html#l00196">symengine_math.cc:196</a></div></div>
</div><!-- fragment --><p><a class="anchor" id="grid_7Demonstratingdistort_random"></a> </p><h4>grid_7: Demonstrating distort_random</h4>
<p>In this last example, we create a mesh and then distort its (interior) vertices by a random perturbation. This is not something you want to do for production computations (because results are generally better on meshes with "nicely shaped" cells than on the deformed cells produced by <a class="el" href="namespaceGridTools.html#ac4e8aecd2cf74d3476e0daa11a00248b">GridTools::distort_random()</a>), but it is a useful tool for testing discretizations and codes to make sure they don't work just by accident because the mesh happens to be uniformly structured and supporting superconvergence properties.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> grid_7()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a>          <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div>
<div class="line">  std::vector&lt;unsigned int&gt; repetitions(2);</div>
<div class="line">  repetitions[0] = repetitions[1] = 16;</div>
<div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>,</div>
<div class="line">                                            repetitions,</div>
<div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(0.0, 0.0),</div>
<div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(1.0, 1.0));</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="namespaceGridTools.html#ac4e8aecd2cf74d3476e0daa11a00248b">GridTools::distort_random</a>(0.3, <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, <span class="keyword">true</span>);</div>
<div class="line">  print_mesh_info(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, <span class="stringliteral">&quot;grid-7.vtu&quot;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceGridTools_html_ac4e8aecd2cf74d3476e0daa11a00248b"><div class="ttname"><a href="namespaceGridTools.html#ac4e8aecd2cf74d3476e0daa11a00248b">GridTools::distort_random</a></div><div class="ttdeci">void distort_random(const double factor, Triangulation&lt; dim, spacedim &gt; &amp;triangulation, const bool keep_boundary=true, const unsigned int seed=boost::random::mt19937::default_seed)</div><div class="ttdef"><b>Definition:</b> <a href="grid__tools_8cc_source.html#l02218">grid_tools.cc:2218</a></div></div>
</div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main function</h3>
<p>Finally, the main function. There isn't much to do here, only to call all the various functions we wrote above.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      grid_1();</div>
<div class="line">      grid_2();</div>
<div class="line">      grid_3();</div>
<div class="line">      grid_4();</div>
<div class="line">      grid_5();</div>
<div class="line">      grid_6();</div>
<div class="line">      grid_7();</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The program produces a series of <code>.vtu</code> files of the triangulations. The methods are discussed above.</p>
<p><a class="anchor" id="NextstepsCurvedCells"></a></p><h3>Next steps: Curved Cells</h3>
<p>As mentioned in the introduction, creating a coarse mesh using the methods discussed here is only the first step. In order to refine a mesh, the <a class="el" href="classTriangulation.html">Triangulation</a> needs to know where to put new vertices on the mid-points of edges, faces, and cells. By default, these new points will be placed at the arithmetic mean of the surrounding points, but this isn't what you want if you need curved boundaries that aren't already adequately resolved by the coarse mesh. For example, for this mesh the central hole is supposed to be round:</p>
<p><img src="https://www.dealii.org/images/steps/developer/step-49.grid-2a.png" alt="" height="200px" class="inline"/></p>
<p>If you simply refine it, the <a class="el" href="classTriangulation.html">Triangulation</a> class can not know whether you wanted the hole to be round or to be an octagon. The default is to place new points along existing straight lines. After two mesh refinement steps, this would yield the following mesh, which is not what we wanted:</p>
<p><img src="https://www.dealii.org/images/steps/developer/step-49.grid-2d-refined.png" alt="" height="200px" class="inline"/></p>
<p>What needs to happen is that you tell the triangulation that you in fact want to use a curved geometry. The way to do this requires three steps:</p><ul>
<li>Create an object that describes the desired geometry. This object will be queried when refining the <a class="el" href="classTriangulation.html">Triangulation</a> for new point placement. It will also be used to calculate shape function values if a high degree mapping, like <a class="el" href="classMappingQ.html">MappingQ</a> or <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>, is used during system assembly. In deal.II the <a class="el" href="classManifold.html">Manifold</a> class and classes inheriting from it (e.g., <a class="el" href="classPolarManifold.html">PolarManifold</a> and <a class="el" href="classFlatManifold.html">FlatManifold</a>) perform these calculations.</li>
<li>Notify the <a class="el" href="classTriangulation.html">Triangulation</a> object which <a class="el" href="classManifold.html">Manifold</a> classes to use. By default, a <a class="el" href="classTriangulation.html">Triangulation</a> uses <a class="el" href="classFlatManifold.html">FlatManifold</a> to do all geometric calculations, which assumes that all cell edges are straight lines and all quadrilaterals are flat. You can attach <a class="el" href="classManifold.html">Manifold</a> classes to a <a class="el" href="classTriangulation.html">Triangulation</a> by calling <a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">Triangulation::set_manifold</a> function, which associates a <code>manifold_id</code> with a <a class="el" href="classManifold.html">Manifold</a> object. For more information on this see the <a class="el" href="DEALGlossary.html#GlossManifoldIndicator">glossary entry on this topic</a>.</li>
<li>Finally, you must mark cells and cell faces with the correct <code>manifold_id</code>. For example, you could get an annular sector with curved cells in Cartesian coordinates (but rectangles in polar coordinates) by doing the following: <div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> tria;</div>
<div class="line"><a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(tria);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> cell = tria.<a class="code" href="classTriangulation.html#afe6c58805fe436a94b141c1585606c7f">begin_active</a>();</div>
<div class="line">cell-&gt;vertex(2) = <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(-0.5, 1.0);</div>
<div class="line">cell-&gt;vertex(3) = <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(1.5, 1.0);</div>
<div class="line">tria.<a class="code" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a>(42);</div>
<div class="line">tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(42, <a class="code" href="classPolarManifold.html">PolarManifold&lt;2&gt;</a>(<a class="code" href="classPoint.html">Point&lt;2&gt;</a>(0.5, -1.0)));</div>
<div class="line">tria.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3);</div>
<div class="ttc" id="aclassPolarManifold_html"><div class="ttname"><a href="classPolarManifold.html">PolarManifold</a></div><div class="ttdef"><b>Definition:</b> <a href="grid_2manifold__lib_8h_source.html#l00070">manifold_lib.h:71</a></div></div>
<div class="ttc" id="aclassTriangulation_html_a6ad0b3fb24aae17f4668427a433dea19"><div class="ttname"><a href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">Triangulation::refine_global</a></div><div class="ttdeci">void refine_global(const unsigned int times=1)</div></div>
<div class="ttc" id="aclassTriangulation_html_afe6c58805fe436a94b141c1585606c7f"><div class="ttname"><a href="classTriangulation.html#afe6c58805fe436a94b141c1585606c7f">Triangulation::begin_active</a></div><div class="ttdeci">active_cell_iterator begin_active(const unsigned int level=0) const</div></div>
<div class="ttc" id="agroup__manifold_html_ga9f9d720f5fbdcdf3dcbb445feefbdb9f"><div class="ttname"><a href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">Triangulation::set_manifold</a></div><div class="ttdeci">void set_manifold(const types::manifold_id number, const Manifold&lt; dim, spacedim &gt; &amp;manifold_object)</div></div>
<div class="ttc" id="agroup__manifold_html_gae2acfbef517fd03855c4b371f3e182f7"><div class="ttname"><a href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">Triangulation::set_all_manifold_ids</a></div><div class="ttdeci">void set_all_manifold_ids(const types::manifold_id number)</div></div>
<div class="ttc" id="anamespaceGridGenerator_html_acea0cbcd68e52ce8113d1134b87de403"><div class="ttname"><a href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a></div><div class="ttdeci">void hyper_cube(Triangulation&lt; dim, spacedim &gt; &amp;tria, const double left=0., const double right=1., const bool colorize=false)</div></div>
</div><!-- fragment --> Now, when the grid is refined, all cell splitting calculations will be done in polar coordinates.</li>
</ul>
<p>All functions in the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace which create a mesh where some cells should be curved also attach the correct <a class="el" href="classManifold.html">Manifold</a> object to the provided <a class="el" href="classTriangulation.html">Triangulation</a>: i.e., for those functions we get the correct behavior by default. For a hand-generated mesh, however, the situation is much more interesting.</p>
<p>To illustrate this process in more detail, let us consider an example created by Yuhan Zhou as part of a 2013 semester project at Texas A&amp;M University. The goal was to generate (and use) a geometry that describes a microstructured electric device. In a CAD program, the geometry looks like this:</p>
<p><img src="https://www.dealii.org/images/steps/developer/step-49.yuhan.1.png" alt="" class="inline"/></p>
<p>In the following, we will walk you through the entire process of creating a mesh for this geometry, including a number of common pitfalls by showing the things that can go wrong.</p>
<p>The first step in getting there was to create a coarse mesh, which was done by creating a 2d coarse mesh for each of cross sections, extruding them into the third direction, and gluing them together. The following code does this, using the techniques previously described:</p>
<div class="fragment"><div class="line"><span class="comment">// Given a list of points and how vertices connect to cells, create a</span></div>
<div class="line"><span class="comment">// mesh. This is in the same way as we do in step 14.</span></div>
<div class="line"><span class="keywordtype">void</span> create_2d_grid(</div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;2&gt;</a>&gt; &amp;<a class="code" href="data__out__base_8cc.html#accc45da40beb7ae1b485306984e904a2">vertices</a>,</div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;</div>
<div class="line">    std::array&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, <a class="code" href="structGeometryInfo.html">GeometryInfo&lt;2&gt;::vertices_per_cell</a>&gt;&gt;</div>
<div class="line">    &amp;               <a class="code" href="grid__tools_8cc.html#a9bb17554c06536e62c37d90eb7a28d6a">vertex_indices</a>,</div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> &amp;coarse_grid)</div>
<div class="line">{</div>
<div class="line">  std::vector&lt;CellData&lt;2&gt;&gt; cells(<a class="code" href="grid__tools_8cc.html#a9bb17554c06536e62c37d90eb7a28d6a">vertex_indices</a>.size());</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; cells.size(); ++i)</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; <a class="code" href="grid__tools_8cc.html#a9bb17554c06536e62c37d90eb7a28d6a">vertex_indices</a>[i].size(); ++j)</div>
<div class="line">        cells[i].<a class="code" href="data__out__base_8cc.html#accc45da40beb7ae1b485306984e904a2">vertices</a>[j] = <a class="code" href="grid__tools_8cc.html#a9bb17554c06536e62c37d90eb7a28d6a">vertex_indices</a>[i][j];</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  coarse_grid.<a class="code" href="classTriangulation.html#a1b191fa3249c9c3641492b6eedebf456">create_triangulation</a>(<a class="code" href="data__out__base_8cc.html#accc45da40beb7ae1b485306984e904a2">vertices</a>, cells, <a class="code" href="structSubCellData.html">SubCellData</a>());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a triangulation that covers the entire volume</span></div>
<div class="line"><span class="keywordtype">void</span> create_3d_grid(<a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> &amp;<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Generate first cross section</span></div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;Point&lt;2&gt;&gt; vertices_1{{-1.5, 0.},</div>
<div class="line">                                         {-0.5, 0.},</div>
<div class="line">                                         {0.5, 0.},</div>
<div class="line">                                         {1.5, 0.},</div>
<div class="line"> </div>
<div class="line">                                         {-1.5, 1.5},</div>
<div class="line">                                         {-0.5, 1.5},</div>
<div class="line">                                         {0.5, 1.5},</div>
<div class="line">                                         {1.5, 1.5},</div>
<div class="line"> </div>
<div class="line">                                         {-1.5, 3.},</div>
<div class="line">                                         {-0.5, 3.},</div>
<div class="line">                                         {0.5, 3.},</div>
<div class="line">                                         {1.5, 3.},</div>
<div class="line"> </div>
<div class="line">                                         {-0.5, 3 + 0.5 * <a class="code" href="classVectorizedArray.html#a935e528bb3b525ac056167a64d7ab71d">sqrt</a>(3)},</div>
<div class="line">                                         {0.5, 3 + 0.5 * <a class="code" href="classVectorizedArray.html#a935e528bb3b525ac056167a64d7ab71d">sqrt</a>(3)},</div>
<div class="line"> </div>
<div class="line">                                         {-0.75, 3 + 0.75 * <a class="code" href="classVectorizedArray.html#a935e528bb3b525ac056167a64d7ab71d">sqrt</a>(3)},</div>
<div class="line">                                         {0.75, 3 + 0.75 * <a class="code" href="classVectorizedArray.html#a935e528bb3b525ac056167a64d7ab71d">sqrt</a>(3)}};</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;std::array&lt;unsigned int, GeometryInfo&lt;2&gt;::vertices_per_cell&gt;&gt;</div>
<div class="line">    cell_vertices_1 = {{{0, 1, 4, 5}},</div>
<div class="line">                       {{1, 2, 5, 6}},</div>
<div class="line">                       {{3, 7, 2, 6}},</div>
<div class="line">                       {{4, 5, 8, 9}},</div>
<div class="line">                       {{5, 6, 9, 10}},</div>
<div class="line">                       {{7, 11, 6, 10}},</div>
<div class="line">                       {{8, 9, 14, 12}},</div>
<div class="line">                       {{9, 10, 12, 13}},</div>
<div class="line">                       {{11, 15, 10, 13}},</div>
<div class="line">                       {{14, 12, 15, 13}}};</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Copy vertices into a 2d triangulation</span></div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation_2d_1;</div>
<div class="line">  create_2d_grid(vertices_1, cell_vertices_1, triangulation_2d_1);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Then extrude it into a 3d piece</span></div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> triangulation_3d_1;</div>
<div class="line">  <a class="code" href="namespaceGridGenerator.html#a6cc0ff3b4e5226c3e06a4aa6ac79f90c">GridGenerator::extrude_triangulation</a>(triangulation_2d_1,</div>
<div class="line">                                       5,</div>
<div class="line">                                       2.5,</div>
<div class="line">                                       triangulation_3d_1);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Now do the same with the second volume</span></div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;Point&lt;2&gt;&gt; vertices_2{{-2.5, 0.},</div>
<div class="line">                                         {-1.5, 0.},</div>
<div class="line">                                         {-0.5, 0.},</div>
<div class="line">                                         {0.5, 0.},</div>
<div class="line">                                         {1.5, 0.},</div>
<div class="line">                                         {2.5, 0.},</div>
<div class="line"> </div>
<div class="line">                                         {-2.5, 1.5},</div>
<div class="line">                                         {-1.5, 1.5},</div>
<div class="line">                                         {-0.5, 1.5},</div>
<div class="line">                                         {0.5, 1.5},</div>
<div class="line">                                         {1.5, 1.5},</div>
<div class="line">                                         {2.5, 1.5},</div>
<div class="line"> </div>
<div class="line">                                         {-2.5, 3.},</div>
<div class="line">                                         {-1.5, 3.},</div>
<div class="line">                                         {-0.5, 3.},</div>
<div class="line">                                         {0.5, 3.},</div>
<div class="line">                                         {1.5, 3.},</div>
<div class="line">                                         {2.5, 3.},</div>
<div class="line"> </div>
<div class="line">                                         {-0.5, 3. + 0.5 * <a class="code" href="classVectorizedArray.html#a935e528bb3b525ac056167a64d7ab71d">sqrt</a>(3)},</div>
<div class="line">                                         {0.5, 3. + 0.5 * <a class="code" href="classVectorizedArray.html#a935e528bb3b525ac056167a64d7ab71d">sqrt</a>(3)},</div>
<div class="line"> </div>
<div class="line">                                         {-0.75, 3. + 0.75 * <a class="code" href="classVectorizedArray.html#a935e528bb3b525ac056167a64d7ab71d">sqrt</a>(3)},</div>
<div class="line">                                         {0.75, 3. + 0.75 * <a class="code" href="classVectorizedArray.html#a935e528bb3b525ac056167a64d7ab71d">sqrt</a>(3)},</div>
<div class="line"> </div>
<div class="line">                                         {-1.25, 3. + 1.25 * <a class="code" href="classVectorizedArray.html#a935e528bb3b525ac056167a64d7ab71d">sqrt</a>(3)},</div>
<div class="line">                                         {1.25, 3. + 1.25 * <a class="code" href="classVectorizedArray.html#a935e528bb3b525ac056167a64d7ab71d">sqrt</a>(3)}};</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;std::array&lt;unsigned int, GeometryInfo&lt;2&gt;::vertices_per_cell&gt;&gt;</div>
<div class="line">    cell_vertices_2 = {{{0, 1, 6, 7}},</div>
<div class="line">                       {{1, 2, 7, 8}},</div>
<div class="line">                       {{2, 3, 8, 9}},</div>
<div class="line">                       {{4, 10, 3, 9}},</div>
<div class="line">                       {{5, 11, 4, 10}},</div>
<div class="line">                       {{6, 7, 12, 13}},</div>
<div class="line">                       {{7, 8, 13, 14}},</div>
<div class="line">                       {{8, 9, 14, 15}},</div>
<div class="line">                       {{10, 16, 9, 15}},</div>
<div class="line">                       {{11, 17, 10, 16}},</div>
<div class="line">                       {{12, 13, 22, 20}},</div>
<div class="line">                       {{13, 14, 20, 18}},</div>
<div class="line">                       {{14, 15, 18, 19}},</div>
<div class="line">                       {{16, 21, 15, 19}},</div>
<div class="line">                       {{17, 23, 16, 21}},</div>
<div class="line">                       {{20, 18, 21, 19}},</div>
<div class="line">                       {{22, 20, 23, 21}}};</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation_2d_2;</div>
<div class="line">  create_2d_grid(vertices_2, cell_vertices_2, triangulation_2d_2);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> triangulation_3d_2;</div>
<div class="line">  <a class="code" href="namespaceGridGenerator.html#a6cc0ff3b4e5226c3e06a4aa6ac79f90c">GridGenerator::extrude_triangulation</a>(triangulation_2d_2,</div>
<div class="line">                                       5,</div>
<div class="line">                                       2.5,</div>
<div class="line">                                       triangulation_3d_2);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Also shift this triangulation in the z-direction so that it matches the</span></div>
<div class="line">  <span class="comment">// end face of the first part</span></div>
<div class="line">  <a class="code" href="namespaceGridTools.html#a4b953611883979e3f920f800bd855df3">GridTools::shift</a>(<a class="code" href="classPoint.html">Point&lt;3&gt;</a>(0, 0, 2.5), triangulation_3d_2);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Now first merge these two pieces, then shift the first piece in</span></div>
<div class="line">  <span class="comment">// z-direction beyond the second, and merge the shifted piece with the two</span></div>
<div class="line">  <span class="comment">// previously merged one into the final one:</span></div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> triangulation_3d_tmp;</div>
<div class="line">  <a class="code" href="namespaceGridGenerator.html#a7cd88e7eacd46697dee80ad2b8438d54">GridGenerator::merge_triangulations</a>(triangulation_3d_1,</div>
<div class="line">                                      triangulation_3d_2,</div>
<div class="line">                                      triangulation_3d_tmp);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="namespaceGridTools.html#a4b953611883979e3f920f800bd855df3">GridTools::shift</a>(<a class="code" href="classPoint.html">Point&lt;3&gt;</a>(0, 0, 5), triangulation_3d_1);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="namespaceGridGenerator.html#a7cd88e7eacd46697dee80ad2b8438d54">GridGenerator::merge_triangulations</a>(triangulation_3d_tmp,</div>
<div class="line">                                      triangulation_3d_1,</div>
<div class="line">                                      <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>);</div>
<div class="line">}</div>
<div class="ttc" id="aclassTriangulation_html_a1b191fa3249c9c3641492b6eedebf456"><div class="ttname"><a href="classTriangulation.html#a1b191fa3249c9c3641492b6eedebf456">Triangulation::create_triangulation</a></div><div class="ttdeci">virtual void create_triangulation(const std::vector&lt; Point&lt; spacedim &gt;&gt; &amp;vertices, const std::vector&lt; CellData&lt; dim &gt;&gt; &amp;cells, const SubCellData &amp;subcelldata)</div></div>
<div class="ttc" id="aclassVectorizedArray_html_a935e528bb3b525ac056167a64d7ab71d"><div class="ttname"><a href="classVectorizedArray.html#a935e528bb3b525ac056167a64d7ab71d">VectorizedArray::sqrt</a></div><div class="ttdeci">VectorizedArray&lt; Number, width &gt; sqrt(const ::VectorizedArray&lt; Number, width &gt; &amp;x)</div><div class="ttdef"><b>Definition:</b> <a href="vectorization_8h_source.html#l05406">vectorization.h:5406</a></div></div>
<div class="ttc" id="adata__out__base_8cc_html_accc45da40beb7ae1b485306984e904a2"><div class="ttname"><a href="data__out__base_8cc.html#accc45da40beb7ae1b485306984e904a2">vertices</a></div><div class="ttdeci">Point&lt; 3 &gt; vertices[4]</div><div class="ttdef"><b>Definition:</b> <a href="data__out__base_8cc_source.html#l00175">data_out_base.cc:175</a></div></div>
<div class="ttc" id="agrid__tools_8cc_html_a9bb17554c06536e62c37d90eb7a28d6a"><div class="ttname"><a href="grid__tools_8cc.html#a9bb17554c06536e62c37d90eb7a28d6a">vertex_indices</a></div><div class="ttdeci">unsigned int vertex_indices[2]</div><div class="ttdef"><b>Definition:</b> <a href="grid__tools_8cc_source.html#l01257">grid_tools.cc:1257</a></div></div>
<div class="ttc" id="anamespaceGridTools_html_a4b953611883979e3f920f800bd855df3"><div class="ttname"><a href="namespaceGridTools.html#a4b953611883979e3f920f800bd855df3">GridTools::shift</a></div><div class="ttdeci">void shift(const Tensor&lt; 1, spacedim &gt; &amp;shift_vector, Triangulation&lt; dim, spacedim &gt; &amp;triangulation)</div><div class="ttdef"><b>Definition:</b> <a href="grid__tools_8cc_source.html#l02023">grid_tools.cc:2023</a></div></div>
<div class="ttc" id="astructGeometryInfo_html"><div class="ttname"><a href="structGeometryInfo.html">GeometryInfo</a></div><div class="ttdef"><b>Definition:</b> <a href="geometry__info_8h_source.html#l01963">geometry_info.h:1964</a></div></div>
<div class="ttc" id="astructSubCellData_html"><div class="ttname"><a href="structSubCellData.html">SubCellData</a></div><div class="ttdef"><b>Definition:</b> <a href="tria__description_8h_source.html#l00202">tria_description.h:203</a></div></div>
</div><!-- fragment --><p>This creates the following mesh:</p>
<p><img src="https://www.dealii.org/images/steps/developer/step-49.yuhan.8.png" alt="" width="400" height="355" class="inline"/></p>
<p>This mesh has the right general shape, but the top cells are now polygonal: their edges are no longer along circles and we do not have a very accurate representation of the original geometry. The next step is to teach the top part of the domain that it should be curved. Put another way, all calculations done on the top boundary cells should be done in cylindrical coordinates rather than Cartesian coordinates. We can do this by creating a <a class="el" href="classCylindricalManifold.html">CylindricalManifold</a> object and associating it with the cells above \(y = 3\). This way, when we refine the cells on top, we will place new points along concentric circles instead of straight lines.</p>
<p>In deal.II we describe all geometries with classes that inherit from <a class="el" href="classManifold.html">Manifold</a>. The default geometry is Cartesian and is implemented in the <a class="el" href="classFlatManifold.html">FlatManifold</a> class. As the name suggests, <a class="el" href="classManifold.html">Manifold</a> and its inheriting classes provide a way to describe curves and curved cells in a general way with ideas and terminology from differential geometry: for example, <a class="el" href="classCylindricalManifold.html">CylindricalManifold</a> inherits from <a class="el" href="classChartManifold.html">ChartManifold</a>, which describes a geometry through pull backs and push forwards. In general, one should think that the <a class="el" href="classTriangulation.html">Triangulation</a> class describes the topology of a domain (in addition, of course, to storing the locations of the vertices) while the <a class="el" href="classManifold.html">Manifold</a> classes describe the geometry of a domain (e.g., whether or not a pair of vertices lie along a circular arc or a straight line). A <a class="el" href="classTriangulation.html">Triangulation</a> will refine cells by doing computations with the <a class="el" href="classManifold.html">Manifold</a> associated with that cell regardless of whether or not the cell is on the boundary. Put another way: the <a class="el" href="classManifold.html">Manifold</a> classes do not need any information about where the boundary of the <a class="el" href="classTriangulation.html">Triangulation</a> actually is: it is up to the <a class="el" href="classTriangulation.html">Triangulation</a> to query the right <a class="el" href="classManifold.html">Manifold</a> for calculations on a cell. Most <a class="el" href="classManifold.html">Manifold</a> functions (e.g., <a class="el" href="classManifold.html#aace84e99db1f4767ce9e524170a1de2c">Manifold::get_intermediate_point</a>) know nothing about the domain itself and just assume that the points given to it lie along a geodesic. In this case, with the <a class="el" href="classCylindricalManifold.html">CylindricalManifold</a> constructed below, the geodesics are arcs along circles orthogonal to the \(z\)-axis centered along the line \((0, 3, z)\).</p>
<p>Since all three top parts of the domain use the same geodesics, we will mark all cells with centers above the \(y = 3\) line as being cylindrical in nature:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a>           axis({0.0, 0.0, 1.0});</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a>               axial_point(0, 3.0, 0.0);</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="classCylindricalManifold.html">CylindricalManifold&lt;3&gt;</a> <a class="code" href="namespaceGridGenerator.html#a5cdda7b4a76d509af7d1a8dc1320ddb0">cylinder</a>(axis, axial_point);</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>     cylinder_id = 8;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div>
<div class="line">create_3d_grid(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>);</div>
<div class="line"><a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.set_manifold(cylinder_id, <a class="code" href="namespaceGridGenerator.html#a5cdda7b4a76d509af7d1a8dc1320ddb0">cylinder</a>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.active_cell_iterators())</div>
<div class="line">  <span class="keywordflow">if</span> (cell-&gt;center()[1] &gt;= 3.0)</div>
<div class="line">    cell-&gt;set_all_manifold_ids(cylinder_id);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.refine_global(1);</div>
<div class="ttc" id="aclassCylindricalManifold_html"><div class="ttname"><a href="classCylindricalManifold.html">CylindricalManifold</a></div><div class="ttdef"><b>Definition:</b> <a href="grid_2manifold__lib_8h_source.html#l00390">manifold_lib.h:391</a></div></div>
<div class="ttc" id="aclassTensor_html"><div class="ttname"><a href="classTensor.html">Tensor</a></div><div class="ttdef"><b>Definition:</b> <a href="tensor_8h_source.html#l00449">tensor.h:450</a></div></div>
<div class="ttc" id="anamespaceGridGenerator_html_a5cdda7b4a76d509af7d1a8dc1320ddb0"><div class="ttname"><a href="namespaceGridGenerator.html#a5cdda7b4a76d509af7d1a8dc1320ddb0">GridGenerator::cylinder</a></div><div class="ttdeci">void cylinder(Triangulation&lt; dim &gt; &amp;tria, const double radius=1., const double half_length=1.)</div></div>
<div class="ttc" id="anamespacetypes_html_a24c02646474836ad4f37ca167e191276"><div class="ttname"><a href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a></div><div class="ttdeci">unsigned int manifold_id</div><div class="ttdef"><b>Definition:</b> <a href="types_8h_source.html#l00141">types.h:141</a></div></div>
</div><!-- fragment --><p>With this code, we get a mesh that looks like this:</p>
<p><img src="https://www.dealii.org/images/steps/developer/step-49.yuhan.9.png" alt="" width="400" height="355" class="inline"/></p>
<p>This change fixes the boundary but creates a new problem: the cells adjacent to the cylinder's axis are badly distorted. We should use Cartesian coordinates for calculations on these central cells to avoid this issue. The cells along the center line all have a face that touches the line \((0, 3, z)\) so, to implement this, we go back and overwrite the <code>manifold_id</code>s on these cells to be zero (which is the default):</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a>           axis({0.0, 0.0, 1.0});</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a>               axial_point(0, 3.0, 0.0);</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="classCylindricalManifold.html">CylindricalManifold&lt;3&gt;</a> <a class="code" href="namespaceGridGenerator.html#a5cdda7b4a76d509af7d1a8dc1320ddb0">cylinder</a>(axis, axial_point);</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>     cylinder_id = 8;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div>
<div class="line">create_3d_grid(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>);</div>
<div class="line"><a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.set_manifold(cylinder_id, <a class="code" href="namespaceGridGenerator.html#a5cdda7b4a76d509af7d1a8dc1320ddb0">cylinder</a>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.active_cell_iterators())</div>
<div class="line">  <span class="keywordflow">if</span> (cell-&gt;center()[1] &gt;= 3.0)</div>
<div class="line">    cell-&gt;set_all_manifold_ids(cylinder_id);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.active_cell_iterators())</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> face_center = face-&gt;center();</div>
<div class="line">      <span class="keywordflow">if</span> (std::abs(face_center[0]) &lt; 1.0e-5 &amp;&amp;</div>
<div class="line">          std::abs(face_center[1] - 3.0) &lt; 1.0e-5)</div>
<div class="line">        cell-&gt;set_all_manifold_ids(<a class="code" href="namespacenumbers.html#a9c39a5de95e4d11173378431dc2131fe">numbers::flat_manifold_id</a>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.refine_global(1);</div>
<div class="ttc" id="anamespacenumbers_html_a9c39a5de95e4d11173378431dc2131fe"><div class="ttname"><a href="namespacenumbers.html#a9c39a5de95e4d11173378431dc2131fe">numbers::flat_manifold_id</a></div><div class="ttdeci">const types::manifold_id flat_manifold_id</div><div class="ttdef"><b>Definition:</b> <a href="types_8h_source.html#l00264">types.h:264</a></div></div>
</div><!-- fragment --><p>This gives us the following grid:</p>
<p><img src="https://www.dealii.org/images/steps/developer/step-49.yuhan.10.png" alt="" width="400" height="355" class="inline"/></p>
<p>This gives us a good mesh, where cells at the center of each circle are still Cartesian and cells around the boundary lie along a circle. We can really see the nice detail of the boundary fitted mesh if we refine two more times:</p>
<p><img src="https://www.dealii.org/images/steps/developer/step-49.yuhan.11.png" alt="" width="400" height="355" class="inline"/></p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions </h3>
<p><a class="anchor" id="Assigningdifferentboundaryids"></a></p><h4>Assigning different boundary ids </h4>
<p>It is often useful to assign different boundary ids to a mesh that is generated in one form or another as described in this tutorial to apply different boundary conditions.</p>
<p>For example, you might want to apply a different boundary condition for the right boundary of the first grid in this program. To do this, iterate over the cells and their faces and identify the correct faces (for example using <code>cell-&gt;<a class="el" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center()</a></code> to query the coordinates of the center of a cell as we do in <a class="el" href="step_1.html">step-1</a>, or using <code>cell-&gt;face(f)-&gt;get_boundary_id()</code> to query the current boundary indicator of the \(f\)th face of the cell). You can then use <code>cell-&gt;face(f)-&gt;set_boundary_id()</code> to set the boundary id to something different. You can take a look back at <a class="el" href="step_1.html">step-1</a> how iteration over the meshes is done there.</p>
<p><a class="anchor" id="Extractingaboundarymesh"></a></p><h4>Extracting a boundary mesh </h4>
<p>Computations on manifolds, like they are done in <a class="el" href="step_38.html">step-38</a>, require a surface mesh embedded into a higher dimensional space. While some can be constructed using the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace or loaded from a file, it is sometimes useful to extract a surface mesh from a volume mesh.</p>
<p>Use the function <a class="el" href="namespaceGridGenerator.html#a45440e91a38475333d937938bbd3b046">GridGenerator::extract_boundary_mesh()</a> to extract the surface elements of a mesh. Using the function on a 3d mesh (a <code><a class="el" href="classTriangulation.html">Triangulation</a>&lt;3,3&gt;</code>, for example from <code>grid_4()</code>), this will return a <code><a class="el" href="classTriangulation.html">Triangulation</a>&lt;2,3&gt;</code> that you can use in <a class="el" href="step_38.html">step-38</a>. Also try extracting the boundary mesh of a <code><a class="el" href="classTriangulation.html">Triangulation</a>&lt;2,2&gt;</code>.</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Copyright (C) 2013 - 2020 by the deal.II authors</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div>
<div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div>
<div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div>
<div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div>
<div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div>
<div class="line"><span class="comment"> * the top level directory of deal.II.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Author: Timo Heister, Texas A&amp;M University, 2013</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__in_8h.html">deal.II/grid/grid_in.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> print_mesh_info(<span class="keyword">const</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>,</div>
<div class="line">                     <span class="keyword">const</span> std::string &amp;       filename)</div>
<div class="line">{</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Mesh info:&quot;</span> &lt;&lt; std::endl</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot; dimension: &quot;</span> &lt;&lt; dim &lt;&lt; std::endl</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot; no. of cells: &quot;</span> &lt;&lt; <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.n_active_cells() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  {</div>
<div class="line">    std::map&lt;types::boundary_id, unsigned int&gt; boundary_count;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.active_face_iterators())</div>
<div class="line">      <span class="keywordflow">if</span> (face-&gt;at_boundary())</div>
<div class="line">        boundary_count[face-&gt;boundary_id()]++;</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; boundary indicators: &quot;</span>;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> std::pair&lt;const types::boundary_id, unsigned int&gt; &amp;pair :</div>
<div class="line">         boundary_count)</div>
<div class="line">      {</div>
<div class="line">        std::cout &lt;&lt; pair.first &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; pair.second &lt;&lt; <span class="stringliteral">&quot; times) &quot;</span>;</div>
<div class="line">      }</div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  std::ofstream out(filename);</div>
<div class="line">  <a class="code" href="classGridOut.html">GridOut</a>       grid_out;</div>
<div class="line">  grid_out.<a class="code" href="classGridOut.html#a8bd3a74b86d7c0eb792d2efca7f945f1">write_vtu</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, out);</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; written to &quot;</span> &lt;&lt; filename &lt;&lt; std::endl &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> grid_1()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classGridIn.html">GridIn&lt;2&gt;</a> gridin;</div>
<div class="line">  gridin.<a class="code" href="classGridIn.html#a82ac1c03b0efe87204ad45d2f1d87f7e">attach_triangulation</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>);</div>
<div class="line">  std::ifstream f(<span class="stringliteral">&quot;example.msh&quot;</span>);</div>
<div class="line">  gridin.<a class="code" href="group__simplex.html#ga83872db02e04f52ac52d578912f6da5e">read_msh</a>(f);</div>
<div class="line"> </div>
<div class="line">  print_mesh_info(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, <span class="stringliteral">&quot;grid-1.vtu&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> grid_2()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> tria1;</div>
<div class="line">  <a class="code" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a>(tria1, 0.25, 1.0);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a>          tria2;</div>
<div class="line">  std::vector&lt;unsigned int&gt; repetitions(2);</div>
<div class="line">  repetitions[0] = 3;</div>
<div class="line">  repetitions[1] = 2;</div>
<div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(tria2,</div>
<div class="line">                                            repetitions,</div>
<div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(1.0, -1.0),</div>
<div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(4.0, 1.0));</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div>
<div class="line">  <a class="code" href="namespaceGridGenerator.html#a7cd88e7eacd46697dee80ad2b8438d54">GridGenerator::merge_triangulations</a>(tria1, tria2, <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>);</div>
<div class="line"> </div>
<div class="line">  print_mesh_info(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, <span class="stringliteral">&quot;grid-2.vtu&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> grid_3()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div>
<div class="line">  <a class="code" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, 0.25, 1.0);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.active_cell_iterators())</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : cell-&gt;vertex_indices())</div>
<div class="line">        {</div>
<div class="line">          <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;v = cell-&gt;vertex(i);</div>
<div class="line">          <span class="keywordflow">if</span> (std::abs(v(1) - 1.0) &lt; 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-5)</div>
<div class="line">            v(1) += 0.5;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.refine_global(2);</div>
<div class="line">  print_mesh_info(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, <span class="stringliteral">&quot;grid-3.vtu&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> grid_4()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> out;</div>
<div class="line">  <a class="code" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, 0.25, 1.0);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="namespaceGridGenerator.html#a6cc0ff3b4e5226c3e06a4aa6ac79f90c">GridGenerator::extrude_triangulation</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, 3, 2.0, out);</div>
<div class="line">  print_mesh_info(out, <span class="stringliteral">&quot;grid-4.vtu&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> grid_5()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a>          <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div>
<div class="line">  std::vector&lt;unsigned int&gt; repetitions(2);</div>
<div class="line">  repetitions[0] = 14;</div>
<div class="line">  repetitions[1] = 2;</div>
<div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>,</div>
<div class="line">                                            repetitions,</div>
<div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(0.0, 0.0),</div>
<div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(10.0, 1.0));</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>(</div>
<div class="line">    [](<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;in) {</div>
<div class="line">      <span class="keywordflow">return</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(in[0], in[1] + std::sin(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * in[0] / 5.0));</div>
<div class="line">    },</div>
<div class="line">    <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>);</div>
<div class="line">  print_mesh_info(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, <span class="stringliteral">&quot;grid-5.vtu&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Grid6Func</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">double</span> trans(<span class="keyword">const</span> <span class="keywordtype">double</span> y)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">std::tanh</a>(2 * y) / <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">tanh</a>(2);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classPoint.html">Point&lt;2&gt;</a> operator()(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;in)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keywordflow">return</span> {in(0), trans(in(1))};</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> grid_6()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a>          <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div>
<div class="line">  std::vector&lt;unsigned int&gt; repetitions(2);</div>
<div class="line">  repetitions[0] = repetitions[1] = 40;</div>
<div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>,</div>
<div class="line">                                            repetitions,</div>
<div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(0.0, 0.0),</div>
<div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(1.0, 1.0));</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>(Grid6Func(), <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>);</div>
<div class="line">  print_mesh_info(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, <span class="stringliteral">&quot;grid-6.vtu&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> grid_7()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a>          <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div>
<div class="line">  std::vector&lt;unsigned int&gt; repetitions(2);</div>
<div class="line">  repetitions[0] = repetitions[1] = 16;</div>
<div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>,</div>
<div class="line">                                            repetitions,</div>
<div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(0.0, 0.0),</div>
<div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(1.0, 1.0));</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="namespaceGridTools.html#ac4e8aecd2cf74d3476e0daa11a00248b">GridTools::distort_random</a>(0.3, <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, <span class="keyword">true</span>);</div>
<div class="line">  print_mesh_info(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, <span class="stringliteral">&quot;grid-7.vtu&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      grid_1();</div>
<div class="line">      grid_2();</div>
<div class="line">      grid_3();</div>
<div class="line">      grid_4();</div>
<div class="line">      grid_5();</div>
<div class="line">      grid_6();</div>
<div class="line">      grid_7();</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
