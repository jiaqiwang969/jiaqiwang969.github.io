<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceOpenCASCADE.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: OpenCASCADE Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.3.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.3.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">OpenCASCADE Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenCASCADE_1_1NormalProjectionManifold.html">NormalProjectionManifold</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenCASCADE_1_1DirectionalProjectionManifold.html">DirectionalProjectionManifold</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">NormalToMeshProjectionManifold</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenCASCADE_1_1ArclengthProjectionLineManifold.html">ArclengthProjectionLineManifold</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html">NURBSPatchManifold</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3e3e0df474c0e4f9abb627753c8754e9"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; unsigned int, unsigned int, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a3e3e0df474c0e4f9abb627753c8754e9">count_elements</a> (const TopoDS_Shape &amp;shape)</td></tr>
<tr class="separator:a3e3e0df474c0e4f9abb627753c8754e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe07b496f4edf844d5f4e8d7a540295"><td class="memItemLeft" align="right" valign="top">TopoDS_Shape&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#affe07b496f4edf844d5f4e8d7a540295">read_IGES</a> (const std::string &amp;filename, const <a class="el" href="classdouble.html">double</a> scale_factor=1e-3)</td></tr>
<tr class="separator:affe07b496f4edf844d5f4e8d7a540295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd63e8b33d9ed7a231da9212f6acc391"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#afd63e8b33d9ed7a231da9212f6acc391">write_IGES</a> (const TopoDS_Shape &amp;shape, const std::string &amp;filename)</td></tr>
<tr class="separator:afd63e8b33d9ed7a231da9212f6acc391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e15bf85bc1c9565ab2418bc70ca826"><td class="memItemLeft" align="right" valign="top">TopoDS_Shape&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#ad4e15bf85bc1c9565ab2418bc70ca826">read_STL</a> (const std::string &amp;filename)</td></tr>
<tr class="separator:ad4e15bf85bc1c9565ab2418bc70ca826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30b48a943a55104e5233b5a97b34eee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#ad30b48a943a55104e5233b5a97b34eee">write_STL</a> (const TopoDS_Shape &amp;shape, const std::string &amp;filename, const <a class="el" href="classdouble.html">double</a> deflection, const <a class="el" href="classbool.html">bool</a> sew_different_faces=false, const <a class="el" href="classdouble.html">double</a> sewer_tolerance=1e-6, const <a class="el" href="classbool.html">bool</a> is_relative=false, const <a class="el" href="classdouble.html">double</a> angular_deflection=0.5, const <a class="el" href="classbool.html">bool</a> in_parallel=false)</td></tr>
<tr class="separator:ad30b48a943a55104e5233b5a97b34eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614ec9f581086ad423513dd407e9e520"><td class="memItemLeft" align="right" valign="top">TopoDS_Shape&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a614ec9f581086ad423513dd407e9e520">read_STEP</a> (const std::string &amp;filename, const <a class="el" href="classdouble.html">double</a> scale_factor=1e-3)</td></tr>
<tr class="separator:a614ec9f581086ad423513dd407e9e520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42404c99252b6da0977f40a4eccf05d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a42404c99252b6da0977f40a4eccf05d9">write_STEP</a> (const TopoDS_Shape &amp;shape, const std::string &amp;filename)</td></tr>
<tr class="separator:a42404c99252b6da0977f40a4eccf05d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed838d4999b4707c48781b8d732058fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#aed838d4999b4707c48781b8d732058fe">get_shape_tolerance</a> (const TopoDS_Shape &amp;shape)</td></tr>
<tr class="separator:aed838d4999b4707c48781b8d732058fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7143020c8f7d45356e6fe0b347f73d7"><td class="memItemLeft" align="right" valign="top">TopoDS_Shape&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#ad7143020c8f7d45356e6fe0b347f73d7">intersect_plane</a> (const TopoDS_Shape &amp;in_shape, const <a class="el" href="classdouble.html">double</a> c_x, const <a class="el" href="classdouble.html">double</a> c_y, const <a class="el" href="classdouble.html">double</a> c_z, const <a class="el" href="classdouble.html">double</a> c, const <a class="el" href="classdouble.html">double</a> tolerance=1e-7)</td></tr>
<tr class="separator:ad7143020c8f7d45356e6fe0b347f73d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c5d614d74c4091fe75f61de5242b0a"><td class="memItemLeft" align="right" valign="top">TopoDS_Edge&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a59c5d614d74c4091fe75f61de5242b0a">join_edges</a> (const TopoDS_Shape &amp;in_shape, const <a class="el" href="classdouble.html">double</a> tolerance=1e-7)</td></tr>
<tr class="separator:a59c5d614d74c4091fe75f61de5242b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d772fdfdfe4d8cbeab798389737932"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a89d772fdfdfe4d8cbeab798389737932"><td class="memTemplItemLeft" align="right" valign="top">TopoDS_Edge&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a89d772fdfdfe4d8cbeab798389737932">interpolation_curve</a> (std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;curve_points, const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &amp;direction=<a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;(), const <a class="el" href="classbool.html">bool</a> closed=false, const <a class="el" href="classdouble.html">double</a> tolerance=1e-7)</td></tr>
<tr class="separator:a89d772fdfdfe4d8cbeab798389737932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d463f21e1fedb10a8c64eb9aefe2e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a54d463f21e1fedb10a8c64eb9aefe2e6">extract_geometrical_shapes</a> (const TopoDS_Shape &amp;shape, std::vector&lt; TopoDS_Face &gt; &amp;faces, std::vector&lt; TopoDS_Edge &gt; &amp;edges, std::vector&lt; TopoDS_Vertex &gt; &amp;<a class="el" href="data__out__base_8cc.html#accc45da40beb7ae1b485306984e904a2">vertices</a>)</td></tr>
<tr class="separator:a54d463f21e1fedb10a8c64eb9aefe2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad437c01354d11be7891457b24f64f31b"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:ad437c01354d11be7891457b24f64f31b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#ad437c01354d11be7891457b24f64f31b">create_triangulation</a> (const TopoDS_Face &amp;face, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, spacedim &gt; &amp;tria)</td></tr>
<tr class="separator:ad437c01354d11be7891457b24f64f31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a2b7eda01f714fd2efa446b6216107"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:ad7a2b7eda01f714fd2efa446b6216107"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; TopoDS_Edge &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#ad7a2b7eda01f714fd2efa446b6216107">create_curves_from_triangulation_boundary</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, spacedim &gt; &amp;<a class="el" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, const <a class="el" href="classMapping.html">Mapping</a>&lt; 2, spacedim &gt; &amp;mapping=<a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt; 2, spacedim &gt;::mapping)</td></tr>
<tr class="separator:ad7a2b7eda01f714fd2efa446b6216107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e49f50433c835c841eed35f40862560"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a1e49f50433c835c841eed35f40862560">extract_compound_shapes</a> (const TopoDS_Shape &amp;shape, std::vector&lt; TopoDS_Compound &gt; &amp;compounds, std::vector&lt; TopoDS_CompSolid &gt; &amp;compsolids, std::vector&lt; TopoDS_Solid &gt; &amp;solids, std::vector&lt; TopoDS_Shell &gt; &amp;shells, std::vector&lt; TopoDS_Wire &gt; &amp;wires)</td></tr>
<tr class="separator:a1e49f50433c835c841eed35f40862560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb3e8e294b26a9d1122739fb6c05bf39"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:acb3e8e294b26a9d1122739fb6c05bf39"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;, TopoDS_Shape, <a class="el" href="classdouble.html">double</a>, <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#acb3e8e294b26a9d1122739fb6c05bf39">project_point_and_pull_back</a> (const TopoDS_Shape &amp;in_shape, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;origin, const <a class="el" href="classdouble.html">double</a> tolerance=1e-7)</td></tr>
<tr class="separator:acb3e8e294b26a9d1122739fb6c05bf39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c26d2fd39062b95c4dc0394dc9a70c"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a94c26d2fd39062b95c4dc0394dc9a70c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a94c26d2fd39062b95c4dc0394dc9a70c">closest_point</a> (const TopoDS_Shape &amp;in_shape, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;origin, const <a class="el" href="classdouble.html">double</a> tolerance=1e-7)</td></tr>
<tr class="separator:a94c26d2fd39062b95c4dc0394dc9a70c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20fe08fce46ef1e86665c9c50cc96684"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a20fe08fce46ef1e86665c9c50cc96684"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a20fe08fce46ef1e86665c9c50cc96684">push_forward</a> (const TopoDS_Shape &amp;in_shape, const <a class="el" href="classdouble.html">double</a> u, const <a class="el" href="classdouble.html">double</a> v)</td></tr>
<tr class="separator:a20fe08fce46ef1e86665c9c50cc96684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c7b59ea0d1fee16c815c7e40237aa5"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;, <a class="el" href="classTensor.html">Tensor</a>&lt; 1, 3 &gt;, <a class="el" href="classdouble.html">double</a>, <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a17c7b59ea0d1fee16c815c7e40237aa5">push_forward_and_differential_forms</a> (const TopoDS_Face &amp;face, const <a class="el" href="classdouble.html">double</a> u, const <a class="el" href="classdouble.html">double</a> v, const <a class="el" href="classdouble.html">double</a> tolerance=1e-7)</td></tr>
<tr class="separator:a17c7b59ea0d1fee16c815c7e40237aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476712b60ff6cb2ad783f34552ef9843"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;, <a class="el" href="classTensor.html">Tensor</a>&lt; 1, 3 &gt;, <a class="el" href="classdouble.html">double</a>, <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a476712b60ff6cb2ad783f34552ef9843">closest_point_and_differential_forms</a> (const TopoDS_Shape &amp;in_shape, const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;origin, const <a class="el" href="classdouble.html">double</a> tolerance=1e-7)</td></tr>
<tr class="separator:a476712b60ff6cb2ad783f34552ef9843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e467e8f4db2ca53322908dec25b42d"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ad2e467e8f4db2ca53322908dec25b42d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#ad2e467e8f4db2ca53322908dec25b42d">line_intersection</a> (const TopoDS_Shape &amp;in_shape, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;origin, const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &amp;direction, const <a class="el" href="classdouble.html">double</a> tolerance=1e-7)</td></tr>
<tr class="separator:ad2e467e8f4db2ca53322908dec25b42d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0b2393711bae58d859be1bb9761781"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:a7b0b2393711bae58d859be1bb9761781"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a7b0b2393711bae58d859be1bb9761781">point</a> (const gp_Pnt &amp;p, const <a class="el" href="classdouble.html">double</a> tolerance=1e-10)</td></tr>
<tr class="separator:a7b0b2393711bae58d859be1bb9761781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c9ea93645e89d325289cb9d8b14788"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:aa3c9ea93645e89d325289cb9d8b14788"><td class="memTemplItemLeft" align="right" valign="top">gp_Pnt&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#aa3c9ea93645e89d325289cb9d8b14788">point</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p)</td></tr>
<tr class="separator:aa3c9ea93645e89d325289cb9d8b14788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a919a5ebb75e67a4baa0ddd0caf8f15"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a7a919a5ebb75e67a4baa0ddd0caf8f15"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a7a919a5ebb75e67a4baa0ddd0caf8f15">point_compare</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p1, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p2, const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &amp;direction=<a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;(), const <a class="el" href="classdouble.html">double</a> tolerance=1e-10)</td></tr>
<tr class="separator:a7a919a5ebb75e67a4baa0ddd0caf8f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b12d7bcebbf27eba1e6322a3894ef2f"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ga9b12d7bcebbf27eba1e6322a3894ef2f"><td class="memTemplItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga9b12d7bcebbf27eba1e6322a3894ef2f">ExcPointNotOnManifold</a> (<a class="el" href="classPoint.html">Point</a>&lt; dim &gt; arg1)</td></tr>
<tr class="separator:ga9b12d7bcebbf27eba1e6322a3894ef2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21fa7fc7002aedd36ac53d6218afea99"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ga21fa7fc7002aedd36ac53d6218afea99"><td class="memTemplItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga21fa7fc7002aedd36ac53d6218afea99">ExcProjectionFailed</a> (<a class="el" href="classPoint.html">Point</a>&lt; dim &gt; arg1)</td></tr>
<tr class="separator:ga21fa7fc7002aedd36ac53d6218afea99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb77e4ae52d70b5263f508ef00b756ad"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gabb77e4ae52d70b5263f508ef00b756ad">ExcOCCError</a> (IFSelect_ReturnStatus arg1)</td></tr>
<tr class="separator:gabb77e4ae52d70b5263f508ef00b756ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99845071d7346e7872220ff0a9655fbd"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga99845071d7346e7872220ff0a9655fbd">ExcEdgeIsDegenerate</a> ()</td></tr>
<tr class="separator:ga99845071d7346e7872220ff0a9655fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada877c8a8be9c236964764de479245d9"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gada877c8a8be9c236964764de479245d9">ExcUnsupportedShape</a> ()</td></tr>
<tr class="separator:gada877c8a8be9c236964764de479245d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>We collect in this namespace all utilities which operate on <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> entities. <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> splits every object into a topological description and a geometrical entity. The basic topological description is a TopoDS_Shape. TopoDS_Shapes are light objects, and can be copied around. The closest deal.II analog is a <a class="el" href="classTriaIterator.html">TriaIterator</a>.</p>
<p>The <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> topology is designed with reference to the STEP standard ISO-10303-42. The structure is an oriented one-way graph, where parents refer to their children, and there are no back references. Abstract structure is implemented as C++ classes from the TopoDS package. A TopoDS_Shape is manipulated by value and contains 3 fields: location, orientation and a myTShape handle (of the TopoDS_TShape type). According to <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> documentation, myTShape and Location are used to share data between various shapes to save memory. For example, an edge belonging to two faces has equal Locations and myTShape fields but different Orientations (Forward in context of one face and Reversed in one of the other).</p>
<p>Valid shapes include collection of other shapes, solids, faces, edges, vertices, etc.</p>
<p>Once a topological description is available, if a concrete geometrical object can be created, the BRep classes allow one to extract the actual geometrical information from a shape.</p>
<p>This is done by inheriting abstract topology classes from the TopoDS package by those implementing a boundary representation model (from the BRep package). Only 3 types of topological objects have geometric representations - vertex, edge, and face.</p>
<p>Every TopoDS_Shape can be queried to figure out what type of shape it is, and actual geometrical objects, like surfaces, curves or points, can be extracted using BRepTools.</p>
<p>In this namespace we provide readers and writers that read standard CAD files, and return a TopoDS_Shape, or that write a CAD file, given a TopoDS_Shape. Most of the functions in the <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> namespace deal with TopoDS_Shapes of one type or another, and provide interfaces to common deal.II objects, like <a class="el" href="classTriangulation.html">Triangulation</a>, <a class="el" href="classManifold.html">Manifold</a>, and so on.</p>
<p>Notice that most of these tools are only useful when spacedim is equal to three, since <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> only operates in three-dimensional mode. In some cases they can be used in two dimensions as well, and the third dimension will be set to zero.</p>
<p>If you wish to use these tools when the dimension of the space is two, then make sure your CAD files are actually flat and that all z coordinates are equal to zero, as otherwise you will get many exceptions. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a3e3e0df474c0e4f9abb627753c8754e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e3e0df474c0e4f9abb627753c8754e9">&#9670;&nbsp;</a></span>count_elements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; unsigned int, unsigned int, unsigned int &gt; OpenCASCADE::count_elements </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count the subobjects of a shape. This function is useful to gather information about the TopoDS_Shape passed as argument. It returns the number of faces, edges and vertices (the only topological entities associated with actual geometries) which are contained in the given shape. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00088">88</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="affe07b496f4edf844d5f4e8d7a540295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affe07b496f4edf844d5f4e8d7a540295">&#9670;&nbsp;</a></span>read_IGES()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TopoDS_Shape OpenCASCADE::read_IGES </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>scale_factor</em> = <code>1e-3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read IGES files and translate their content into openCascade topological entities. The option scale_factor is used to compensate for different units being used in the IGES files and in the target application. The standard unit for IGES files is millimiters. The return object is a TopoDS_Shape which contains all objects from the file. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00238">238</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="afd63e8b33d9ed7a231da9212f6acc391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd63e8b33d9ed7a231da9212f6acc391">&#9670;&nbsp;</a></span>write_IGES()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenCASCADE::write_IGES </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the given topological shape into an IGES file. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00267">267</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="ad4e15bf85bc1c9565ab2418bc70ca826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4e15bf85bc1c9565ab2418bc70ca826">&#9670;&nbsp;</a></span>read_STL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TopoDS_Shape OpenCASCADE::read_STL </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read STL files and translate their content into openCascade topological entities. The return object is a TopoDS_Shape which contains all objects from the file. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00280">280</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="ad30b48a943a55104e5233b5a97b34eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad30b48a943a55104e5233b5a97b34eee">&#9670;&nbsp;</a></span>write_STL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenCASCADE::write_STL </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>deflection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>sew_different_faces</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>sewer_tolerance</em> = <code>1e-6</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>is_relative</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>angular_deflection</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>in_parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the given topological shape into an STL file. In order to do so the shape must contain a mesh structure, the function checks if all the faces of the shape have an attached mesh, if this is not the case it proceeds to mesh it automatically. We remark that the automatic mesh generation in <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> takes care only of the geometrical resemblance between the shape and the mesh, to control the shape and regularity of the triangles you should use other meshing softwares. The two arguments <code>deflection</code> and <code>angular_deflection</code> select the accuracy of the created triangulation with respect to the orginal topological shape. The argument <code>sew_different_faces</code> gives the possibility to use a Sewer from <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> to create a watertight closed STL using the argument <code>sewer_tolerance</code>. The argument <code>is_relative</code> specifies if distance are relative and <code>in_parallel</code> if the execution should be in parallel. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00290">290</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a614ec9f581086ad423513dd407e9e520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614ec9f581086ad423513dd407e9e520">&#9670;&nbsp;</a></span>read_STEP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TopoDS_Shape OpenCASCADE::read_STEP </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>scale_factor</em> = <code>1e-3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read STEP files and translate their content into openCascade topological entities. The option scale_factor is used to compensate for different units being used in the STEP files and in the target application. The standard unit for STEP files is millimiters. The return object is a TopoDS_Shape which contains all objects from the file. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00355">355</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a42404c99252b6da0977f40a4eccf05d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42404c99252b6da0977f40a4eccf05d9">&#9670;&nbsp;</a></span>write_STEP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenCASCADE::write_STEP </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the given topological shape into an STEP file. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00384">384</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="aed838d4999b4707c48781b8d732058fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed838d4999b4707c48781b8d732058fe">&#9670;&nbsp;</a></span>get_shape_tolerance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> OpenCASCADE::get_shape_tolerance </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the tolerance associated with the shape. Each CAD geometrical object is defined along with a tolerance, which indicates possible inaccuracy of its placement. For instance, the tolerance of a vertex indicates that it can be located in any point contained in a sphere centered in the nominal position and having radius tol. While carrying out an operation such as projecting a point onto a surface (which will in turn have its tolerance) we must keep in mind that the precision of the projection will be limited by the tolerance with which the surface is built. The tolerance is computed taking the maximum tolerance among the subshapes composing the shape. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00400">400</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="ad7143020c8f7d45356e6fe0b347f73d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7143020c8f7d45356e6fe0b347f73d7">&#9670;&nbsp;</a></span>intersect_plane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TopoDS_Shape OpenCASCADE::intersect_plane </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>in_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1e-7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform the intersection of the given topological shape with the plane \(c_x x + c_y y + c_z z +c = 0\). The returned topological shape will contain as few bsplines as possible. An exception is thrown if the intersection produces an empty shape. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00424">424</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a59c5d614d74c4091fe75f61de5242b0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c5d614d74c4091fe75f61de5242b0a">&#9670;&nbsp;</a></span>join_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TopoDS_Edge OpenCASCADE::join_edges </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>in_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1e-7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Try to join all edges contained in the given TopoDS_Shape into a single TopoDS_Edge, containing as few BSPlines as possible. If the input shape contains faces, they will be ignored by this function. If the contained edges cannot be joined into a single one, i.e., they form disconnected curves, an exception will be thrown. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00438">438</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a89d772fdfdfe4d8cbeab798389737932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89d772fdfdfe4d8cbeab798389737932">&#9670;&nbsp;</a></span>interpolation_curve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TopoDS_Edge OpenCASCADE::interpolation_curve </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>curve_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em> = <code><a class="el" href="classTensor.html">Tensor</a>&lt;1,&#160;dim&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>closed</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1e-7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a smooth BSpline curve passing through the points in the assigned vector, and store it in the returned TopoDS_Shape (which is of type TopoDS_Edge). The points are reordered internally according to their scalar product with the direction, if direction is different from zero, otherwise they are used as passed. Notice that this function changes the input points if required by the algorithm.</p>
<p>This class is used to interpolate a BsplineCurve passing through an array of points, with a C2 Continuity. If the optional parameter <code>closed</code> is set to true, then the curve will be C2 at all points except the first (where only C1 continuity will be given), and it will be a closed curve.</p>
<p>The curve is guaranteed to be at distance <code>tolerance</code> from the input points. If the algorithm fails in generating such a curve, an exception is thrown. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00552">552</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a54d463f21e1fedb10a8c64eb9aefe2e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54d463f21e1fedb10a8c64eb9aefe2e6">&#9670;&nbsp;</a></span>extract_geometrical_shapes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenCASCADE::extract_geometrical_shapes </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; TopoDS_Face &gt; &amp;&#160;</td>
          <td class="paramname"><em>faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; TopoDS_Edge &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; TopoDS_Vertex &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract all subshapes from a TopoDS_Shape, and store the results into standard containers. If the shape does not contain a certain type of shape, the respective container will be empty. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00107">107</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="ad437c01354d11be7891457b24f64f31b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad437c01354d11be7891457b24f64f31b">&#9670;&nbsp;</a></span>create_triangulation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void OpenCASCADE::create_triangulation </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Face &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a triangulation from a single face. This class extracts the first u and v parameter of the parametric surface making up this face, and creates a Triangulation&lt;2,spacedim&gt; containing a single coarse cell reflecting this face. If the surface is not a trimmed surface, the vertices of this cell will coincide with the TopoDS_Vertex vertices of the original TopoDS_Face. This, however, is often not the case, and the user should be careful on how this mesh is used.</p>
<p>If you call this function with a Triangulation&lt;2,2&gt;, make sure that the input face has all z coordinates set to zero, or you'll get an exception. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00885">885</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="ad7a2b7eda01f714fd2efa446b6216107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7a2b7eda01f714fd2efa446b6216107">&#9670;&nbsp;</a></span>create_curves_from_triangulation_boundary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; TopoDS_Edge &gt; OpenCASCADE::create_curves_from_triangulation_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; 2, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em> = <code><a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt;2,&#160;spacedim&gt;::mapping</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a <a class="el" href="classTriangulation.html">Triangulation</a> and an optional <a class="el" href="classMapping.html" title="Abstract base class for mapping classes.">Mapping</a>, create a vector of smooth curves that interpolate the connected parts of the boundary vertices of the <a class="el" href="classTriangulation.html">Triangulation</a> and return them as a vector of TopoDS_Edge objects.</p>
<p>This function constructs closed Bspline curve objects passing through all vertices of the boundary of the triangulation, with \(C^2\) Continuity on each vertex except the first, where only \(C^1\) continuity is guaranteed.</p>
<p>The returned curves are ordered with respect to the indices of the faces that make up the triangulation boundary, i.e., the first curve is the one extracted starting from the face with the lowest index, and so on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">triangulation</td><td>Input triangulation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping</td><td>Optional input mapping </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An std::vector of TopoDS_Edge objects representing the smooth interpolation of the boundary of the <code>triangulation</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00595">595</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a1e49f50433c835c841eed35f40862560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e49f50433c835c841eed35f40862560">&#9670;&nbsp;</a></span>extract_compound_shapes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenCASCADE::extract_compound_shapes </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; TopoDS_Compound &gt; &amp;&#160;</td>
          <td class="paramname"><em>compounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; TopoDS_CompSolid &gt; &amp;&#160;</td>
          <td class="paramname"><em>compsolids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; TopoDS_Solid &gt; &amp;&#160;</td>
          <td class="paramname"><em>solids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; TopoDS_Shell &gt; &amp;&#160;</td>
          <td class="paramname"><em>shells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; TopoDS_Wire &gt; &amp;&#160;</td>
          <td class="paramname"><em>wires</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract all compound shapes from a TopoDS_Shape, and store the results into standard containers. If the shape does not contain a certain type of compound, the respective container will be empty. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00133">133</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="acb3e8e294b26a9d1122739fb6c05bf39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb3e8e294b26a9d1122739fb6c05bf39">&#9670;&nbsp;</a></span>project_point_and_pull_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;, TopoDS_Shape, <a class="el" href="classdouble.html">double</a>, <a class="el" href="classdouble.html">double</a> &gt; OpenCASCADE::project_point_and_pull_back </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>in_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1e-7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Project the point <code>origin</code> on the topological shape given by <code>in_shape</code>, and returns the projected point, the subshape which contains the point and the parametric u and v coordinates of the point within the resulting shape. If the shape is not elementary, all its subshapes are iterated, faces first, then edges, and the returned shape is the closest one to the point <code>origin</code>. If the returned shape is an edge, then only the u coordinate is filled with sensible information, and the v coordinate is set to zero.</p>
<p>This function returns a tuple containing the projected point, the shape, the u coordinate and the v coordinate (which is different from zero only if the resulting shape is a face). </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00698">698</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a94c26d2fd39062b95c4dc0394dc9a70c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94c26d2fd39062b95c4dc0394dc9a70c">&#9670;&nbsp;</a></span>closest_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; dim &gt; OpenCASCADE::closest_point </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>in_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1e-7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the projection of the point <code>origin</code> on the topological shape given by <code>in_shape</code>. If the shape is not elementary, all its subshapes are iterated, faces first, then edges, and the returned point is the closest one to the <code>in_shape</code>, regardless of its type. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00781">781</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a20fe08fce46ef1e86665c9c50cc96684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20fe08fce46ef1e86665c9c50cc96684">&#9670;&nbsp;</a></span>push_forward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; dim &gt; OpenCASCADE::push_forward </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>in_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given an elementary shape <code>in_shape</code> and the reference coordinates within the shape, returns the corresponding point in real space. If the shape is a TopoDS_Edge, the <code>v</code> coordinate is ignored. Only edges or faces, as returned by the function <a class="el" href="namespaceOpenCASCADE.html#acb3e8e294b26a9d1122739fb6c05bf39">project_point_and_pull_back()</a>, can be used as input to this function. If this is not the case, an Exception is thrown. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00827">827</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a17c7b59ea0d1fee16c815c7e40237aa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17c7b59ea0d1fee16c815c7e40237aa5">&#9670;&nbsp;</a></span>push_forward_and_differential_forms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;, <a class="el" href="classTensor.html">Tensor</a>&lt; 1, 3 &gt;, <a class="el" href="classdouble.html">double</a>, <a class="el" href="classdouble.html">double</a> &gt; OpenCASCADE::push_forward_and_differential_forms </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Face &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1e-7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a TopoDS_Face <code>face</code> and the reference coordinates within this face, returns the corresponding point in real space, the normal to the surface at that point and the min and max curvatures as a tuple. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00848">848</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a476712b60ff6cb2ad783f34552ef9843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a476712b60ff6cb2ad783f34552ef9843">&#9670;&nbsp;</a></span>closest_point_and_differential_forms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;, <a class="el" href="classTensor.html">Tensor</a>&lt; 1, 3 &gt;, <a class="el" href="classdouble.html">double</a>, <a class="el" href="classdouble.html">double</a> &gt; OpenCASCADE::closest_point_and_differential_forms </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>in_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1e-7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the closest point to the given topological shape, together with the normal and the min and max curvatures at that point. If the shape is not elementary, all its sub-faces (only the faces) are iterated, faces first, and only the closest point is returned. This function will throw an exception if the <code>in_shape</code> does not contain at least one face. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00791">791</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="ad2e467e8f4db2ca53322908dec25b42d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2e467e8f4db2ca53322908dec25b42d">&#9670;&nbsp;</a></span>line_intersection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; dim &gt; OpenCASCADE::line_intersection </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>in_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1e-7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Intersect a line passing through the given <code>origin</code> point along <code>direction</code> and the given topological shape. If there is more than one intersection, it will return the closest one.</p>
<p>The optional <code>tolerance</code> parameter is used to compute distances. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00506">506</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a7b0b2393711bae58d859be1bb9761781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b0b2393711bae58d859be1bb9761781">&#9670;&nbsp;</a></span>point() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; OpenCASCADE::point </td>
          <td>(</td>
          <td class="paramtype">const gp_Pnt &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1e-10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> point into a <a class="el" href="classPoint.html">Point&lt;spacedim&gt;</a>.</p>
<p>The tolerance argument is used to check if the non used components of the <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> point are close to zero. If this is not the case, an assertion is thrown in debug mode. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00188">188</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="aa3c9ea93645e89d325289cb9d8b14788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3c9ea93645e89d325289cb9d8b14788">&#9670;&nbsp;</a></span>point() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">gp_Pnt OpenCASCADE::point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert <a class="el" href="classPoint.html">Point&lt;3&gt;</a> into <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> point. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00171">171</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a7a919a5ebb75e67a4baa0ddd0caf8f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a919a5ebb75e67a4baa0ddd0caf8f15">&#9670;&nbsp;</a></span>point_compare()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> OpenCASCADE::point_compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em> = <code><a class="el" href="classTensor.html">Tensor</a>&lt;1,&#160;dim&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1e-10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort two points according to their scalar product with direction. If the norm of the direction is zero, then use lexicographical ordering. The optional parameter is used as a relative tolerance when comparing objects. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00215">215</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
