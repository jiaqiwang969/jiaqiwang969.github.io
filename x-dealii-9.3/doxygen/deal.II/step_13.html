<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_13.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-13 tutorial program  。</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.3.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.3.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">The step-13 tutorial program 。 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>本教程取决于 <a class="el" href="step_6.html">step-6</a> 。</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Backgroundandpurpose">Background and purpose</a><a href="#Backgroundandpurpose">Background and purpose</a>
        <li><a href="#Whattheprogramdoes">What the program does</a><a href="#Whattheprogramdoes">What the program does</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a><a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Evaluationofthesolution">Evaluation of the solution</a><a href="#Evaluationofthesolution">Evaluation of the solution</a>
      <ul>
        <li><a href="#Pointevaluation">%Point evaluation</a><a href="#Pointevaluation">%Point evaluation</a>
        <li><a href="#Generatingoutput">Generating output</a><a href="#Generatingoutput">Generating output</a>
        <li><a href="#Otherevaluations">Other evaluations</a><a href="#Otherevaluations">Other evaluations</a>
      </ul>
        <li><a href="#TheLaplacesolverclasses">The Laplace solver classes</a><a href="#TheLaplacesolverclasses">The Laplace solver classes</a>
      <ul>
        <li><a href="#Anabstractbaseclass">An abstract base class</a><a href="#Anabstractbaseclass">An abstract base class</a>
        <li><a href="#Ageneralsolverclass">A general solver class</a><a href="#Ageneralsolverclass">A general solver class</a>
        <li><a href="#Aprimalsolver">A primal solver</a><a href="#Aprimalsolver">A primal solver</a>
        <li><a href="#Globalrefinement">Global refinement</a><a href="#Globalrefinement">Global refinement</a>
        <li><a href="#LocalrefinementbytheKellyerrorindicator">Local refinement by the Kelly error indicator</a><a href="#LocalrefinementbytheKellyerrorindicator">Local refinement by the Kelly error indicator</a>
      </ul>
        <li><a href="#Equationdata">Equation data</a><a href="#Equationdata">Equation data</a>
        <li><a href="#Thedriverroutines">The driver routines</a><a href="#Thedriverroutines">The driver routines</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results" class=bold>Results</a>
    <ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a><a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
</p>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a> </p><h1>Introduction</h1>
<p><a class="anchor" id="Backgroundandpurpose"></a></p><h3>Background and purpose</h3>
<p>在这个例子程序中，我们将不太关注描述如何使用deal.II及其设施的新方法，而是介绍编写模块化和可扩展有限元程序的方法。其主要原因是现代研究软件的规模和复杂性：实现现代误差估计概念和自适应求解方法的应用程序往往变得相当大。例如，当本程序在2002年编写时，deal.II的主要作者的三个最大的应用程序，在编写本示例程序时。 </p><ol>
<li>
一个用非连续加尔金有限元法解决守恒双曲方程的程序。33,775行代码； </li>
<li>
一个参数估计程序。28,980行代码； </li>
<li>
一个波浪方程求解器：21,020行代码。 </li>
</ol>
<p><br  />
</p>
<p>这个库本身&ndash;不包括例子程序和测试套件&ndash;到2002年春天为止有略多于15万行的代码。当然，现在已经大了好几倍了）。) 这些应用程序的规模是一个人，甚至是一个有经验的程序员，所能处理的边缘。</p>
<p>上面的数字说明了一个问题：如果不把单体程序分解成较小的、大部分独立的部分，就没有办法生存下去，因为即使是作者也会很快失去对程序不同部分之间各种依赖关系的概述。只有数据封装，例如使用面向对象的编程方法，以及通过定义小而固定的接口来实现模块化，才能帮助构造数据流和相互之间的依赖关系。如果一个以上的人在开发一个程序，这也是一个绝对的先决条件，因为否则的话，很快就会出现混乱，因为如果一个开发人员需要知道另一个人是否改变了不同模块的内部结构，如果它们没有被干净地分开的话。</p>
<p>在以前的例子中，你已经看到库本身是如何被分成几个复合体的，每个复合体都建立在底层的基础上，但相对独立于其他复合体。 </p><ol>
<li>
三角形类复合物，以及相关的迭代器类； </li>
<li>
有限元类； </li>
<li>
DoFHandler类复合物，以及相关的迭代器，建立在三角形和有限元类之上； </li>
<li>
实现单元和实单元之间映射的类； </li>
<li>
FEValues类复合物，建立在有限元和映射的之上。 </li>
</ol>
<p>除了这些，还有大量的小类，当然还有以下的 "工具 "模块。 </p><ol>
<li>
以各种图形格式输出； </li>
<li>
线性代数类。 </li>
</ol>
<p>这些复数也可以在deal.II手册网站的首页上以流程图的形式找到。</p>
<p>现在这个程序的目标是给出一个例子，说明如何将一个相对简单的有限元程序结构化，使我们最终得到一组尽可能相互独立的模块。这使得我们可以在一端改变程序，而不必担心另一端的程序会被破坏，只要我们不触及两端交流的接口。当然，C++中的接口是抽象基类的声明。</p>
<p>在这里，我们将（再次）实现一个拉普拉斯求解器，尽管与以前的例子程序相比，有一些不同之处。 </p><ol>
<li>
实现数值求解方程过程的类不再负责驱动 "求解-估计误差-再求解 "的过程，而是将其委托给外部函数。这首先允许在更大的范围内将其作为一个构件，在这里拉普拉斯方程的解可能只是其中的一部分（例如，在非线性问题中，拉普拉斯方程可能要在每个非线性步骤中解决）。它还允许围绕该类建立一个框架，允许使用其他方程的求解器（但具有相同的外部接口），以备对不同类型的偏微分方程评估一些技术。 </li>
<li>
它将评估计算出的解的过程分割成一组单独的类。原因是，人们通常对偏微分方程的解本身不感兴趣，而是对它的某些方面感兴趣。例如，人们可能希望在弹性计算中计算某一边界的牵引力，或者在某一位置的接收器上计算地震波的信号。有时，人们可能对这些方面中的几个方面感兴趣。由于解的评估是通常不影响解的过程，我们把它拆成一个单独的模块，以便独立于解算器类的开发来开发这种评估过滤器。 </li>
<li>
将实现网格细化的类与计算解的类分开。 </li>
<li>
将测试案例的描述与程序的其他部分分开，我们将用它来展示程序。 </li>
<li>
使用WorkStream设施对线性系统的装配进行并行化。这是在 <a class="el" href="group__threads.html">多处理器访问共享内存的并行计算 </a>文档模块中可以找到的广泛描述。该实现基本上遵循了 <a class="el" href="step_9.html">step-9</a> 中已经描述的内容。 </li>
</ol>
<p><br  />
</p>
<p>该程序所做的事情并不新鲜。事实上，这更像是以前程序的混合体，从早期的例子中拆解了各种部分和功能。读者应该关注的是它们在这个程序中的安排方式，即程序中为实现所需数学方法的目标而采用的软件设计技术。然而，我们必须强调，软件设计在某种程度上也是一个主观的问题：不同的人有不同的编程背景，对编程的 "正确 "风格有不同的看法；因此，这个程序只表达了作者认为有用的做法，如果你对所选择的方式感到不舒服，不一定要采用这种风格来编写成功的数值软件。不过，它应该作为一个案例研究，用启发读者的想法来达到预期的目的。</p>
<p>一旦你完成了这个程序，你会注意到它的结构已经有些复杂了。然而，它只有大约850行的代码，没有注释。在真正的应用程序中，当然会有注释和类文件，这将使其达到1200行。然而，与上面列出的应用程序相比，这仍然是很小的，因为它们的规模是它们的20到25倍。对于这么大的程序，从一开始就进行适当的设计是不可缺少的。否则，一旦它变得过于庞大而无法管理，就必须在其生命中的某一时刻重新设计它。</p>
<p>尽管如此，上面列出的三个程序都经历了重大的修改，甚至是重写。例如，波浪程序，在它还明显较小的时候，曾经被完全撕成碎片，只是为了以更多的模块化形式再次组装起来。那时，已经不可能在不影响代码的旧部分的情况下增加功能了（代码的主要问题是数据流：在时间依赖的应用中，主要的问题是什么时候把数据存储到磁盘，什么时候再重新加载；如果这不是以一种有组织的方式进行的，那么你最终会发现数据释放得太早，加载得太晚，或者根本没有释放）。尽管本例程序因此吸取了几年的经验，但它的设计肯定不是没有缺陷的，特别是可能不适合目标不同的应用。它应该作为一种灵感，让你以模块化的方式编写自己的应用程序，以避免过于紧密耦合的代码的陷阱。</p>
<p><a class="anchor" id="Whattheprogramdoes"></a></p><h3>What the program does</h3>
<p>程序实际做什么甚至不是这个程序的重点，程序的结构更重要。然而，用几句话来描述就是：解给定右手边的拉普拉斯方程，使其解为函数 \(u(x,t)=\exp(x+\sin(10y+5x^2))\) 。计算的目的是得到解在点 \(x_0=(0.5,0.5)\) 处的值，并比较我们在两种细化标准下解决这个值的准确性，即全局细化和由Kelly等人提出的误差指标的细化，我们在以前的例子中已经使用过。</p>
<p>像往常一样，结果将在本文件的相应章节中讨论。在这样做的时候，我们会发现一个关于这两种细化标准的相对性能的略带刺激性的观察。在以后的例子程序中，在这个例子的基础上，我们将设计一个不同的方法，希望它能比这里讨论的技术表现得更好。</p>
<p>现在，所有的理论和传闻背景都已经说完了。了解一个程序的最好方法是看它，所以它就在这里。<a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>和所有的程序一样，我们从库中的include文件列表开始，和往常一样，它们的标准顺序是 <code>base</code> &ndash; <code>lac</code> &ndash; <code>grid</code> &ndash; <code>dofs</code> &ndash; <code>fe</code> &ndash; <code>numerics</code> （因为每一类大致都是建立在前面的基础上），然后是C++标准头文件。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="table__handler_8h.html">deal.II/base/table_handler.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="thread__management_8h.html">deal.II/base/thread_management.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="work__stream_8h.html">deal.II/base/work_stream.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div>
<div class="ttc" id="aaffine__constraints_8h_html"><div class="ttname"><a href="affine__constraints_8h.html">affine_constraints.h</a></div></div>
<div class="ttc" id="adof__tools_8h_html"><div class="ttname"><a href="dof__tools_8h.html">dof_tools.h</a></div></div>
<div class="ttc" id="adofs_2dof__handler_8h_html"><div class="ttname"><a href="dofs_2dof__handler_8h.html">dof_handler.h</a></div></div>
<div class="ttc" id="adynamic__sparsity__pattern_8h_html"><div class="ttname"><a href="dynamic__sparsity__pattern_8h.html">dynamic_sparsity_pattern.h</a></div></div>
<div class="ttc" id="aerror__estimator_8h_html"><div class="ttname"><a href="error__estimator_8h.html">error_estimator.h</a></div></div>
<div class="ttc" id="afe_2fe__values_8h_html"><div class="ttname"><a href="fe_2fe__values_8h.html">fe_values.h</a></div></div>
<div class="ttc" id="afe__q_8h_html"><div class="ttname"><a href="fe__q_8h.html">fe_q.h</a></div></div>
<div class="ttc" id="afull__matrix_8h_html"><div class="ttname"><a href="full__matrix_8h.html">full_matrix.h</a></div></div>
<div class="ttc" id="afunction_8h_html"><div class="ttname"><a href="function_8h.html">function.h</a></div></div>
<div class="ttc" id="agrid_2grid__refinement_8h_html"><div class="ttname"><a href="grid_2grid__refinement_8h.html">grid_refinement.h</a></div></div>
<div class="ttc" id="agrid_2tria_8h_html"><div class="ttname"><a href="grid_2tria_8h.html">tria.h</a></div></div>
<div class="ttc" id="agrid__generator_8h_html"><div class="ttname"><a href="grid__generator_8h.html">grid_generator.h</a></div></div>
<div class="ttc" id="alogstream_8h_html"><div class="ttname"><a href="logstream_8h.html">logstream.h</a></div></div>
<div class="ttc" id="amatrix__tools_8h_html"><div class="ttname"><a href="matrix__tools_8h.html">matrix_tools.h</a></div></div>
<div class="ttc" id="anumerics_2data__out_8h_html"><div class="ttname"><a href="numerics_2data__out_8h.html">data_out.h</a></div></div>
<div class="ttc" id="aprecondition_8h_html"><div class="ttname"><a href="precondition_8h.html">precondition.h</a></div></div>
<div class="ttc" id="aquadrature__lib_8h_html"><div class="ttname"><a href="quadrature__lib_8h.html">quadrature_lib.h</a></div></div>
<div class="ttc" id="asolver__cg_8h_html"><div class="ttname"><a href="solver__cg_8h.html">solver_cg.h</a></div></div>
<div class="ttc" id="asparse__matrix_8h_html"><div class="ttname"><a href="sparse__matrix_8h.html">sparse_matrix.h</a></div></div>
<div class="ttc" id="atable__handler_8h_html"><div class="ttname"><a href="table__handler_8h.html">table_handler.h</a></div></div>
<div class="ttc" id="athread__management_8h_html"><div class="ttname"><a href="thread__management_8h.html">thread_management.h</a></div></div>
<div class="ttc" id="avector_8h_html"><div class="ttname"><a href="vector_8h.html">vector.h</a></div></div>
<div class="ttc" id="avector__tools_8h_html"><div class="ttname"><a href="vector__tools_8h.html">vector_tools.h</a></div></div>
<div class="ttc" id="awork__stream_8h_html"><div class="ttname"><a href="work__stream_8h.html">work_stream.h</a></div></div>
</div><!-- fragment --><p>现在是C++标准头文件。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div>
</div><!-- fragment --><p>最后一步和以前的所有程序一样。</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step13</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
<div class="ttc" id="anamespacedealii_html"><div class="ttname"><a href="namespacedealii.html">dealii</a></div><div class="ttdef"><b>Definition:</b> <a href="namespace__dealii_8h_source.html#l00025">namespace_dealii.h:26</a></div></div>
</div><!-- fragment --><p><a class="anchor" id="Evaluationofthesolution"></a> </p><h3>Evaluation of the solution</h3>
<p>至于程序本身，我们首先定义了评估拉普拉斯方程解的类。事实上，它们可以评估每一种解，只要它由一个 <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> 对象和一个解向量来描述。我们在这里首先定义它们，甚至在实际生成要评估的解的类之前，因为我们需要声明一个抽象的基类，以便解算器类可以引用。 <br  />
</p>
<p>从抽象的角度来看，我们声明一个纯粹的基类，它提供了一个评估算子（），它将对解进行评估（无论派生类如何考虑 <code>evaluation</code> ）。由于这是该基类的唯一真正的功能（除了一些记账机器），我们通常把这样一个只有 <code>operator()</code> 的类称为C++术语中的 <code>functor</code> ，因为它的使用就像一个函数对象。 <br  />
</p>
<p>这种漏斗类型的对象随后将被传递给求解器对象，后者将其应用于刚刚计算的解决方案。然后，评估对象可以从解决方案中提取他们喜欢的任何数量。将这些评估函数放入一个单独的类的层次结构的好处是，在设计上它们不能使用求解器对象的内部结构，因此独立于求解器工作方式的变化。此外，在不修改求解器类的情况下编写另一个评价类是很容易的，这就加快了编程速度（不能使用另一个类的内部结构也意味着你不必担心它们&ndash;对评价器的编程通常是一个相当快的任务），以及编译速度（如果求解器和评价类被放在不同的文件中：求解器只需要看到抽象基类的声明，因此在增加一个新的评价类或修改一个旧的类时不需要被重新编译）。 与此相关的是，你可以在其他项目中重复使用评估类，解决不同的方程。 <br  />
</p>
<p>为了提高代码在不同模块中的分离度，我们把评估类放到了一个自己的命名空间中。这使得在同一个程序中实际解决不同的方程变得更加容易，通过从现有的构建块中进行组装。这样做的原因是，用于类似目的的类往往具有相同的名称，尽管它们是在不同的背景下开发的。为了能够在一个程序中一起使用它们，有必要将它们放在不同的命名空间中。我们在这里就是这样做的。</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Evaluation</div>
<div class="line">{</div>
</div><!-- fragment --><p>现在是评估类的抽象基类：它的主要目的是声明一个纯虚函数 <code>operator()</code> ，取一个 <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> 对象，和解向量。为了能够只使用指向这个基类的指针，它还必须声明一个虚拟的析构器，但这个析构器什么也不做。除此之外，它只提供了一点簿记功能：由于我们通常想在后续的细化水平上评估解决方案，我们存储了当前细化周期的编号，并提供了一个函数来改变这个编号。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>EvaluationBase</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">virtual</span> ~EvaluationBase() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> set_refinement_cycle(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div>
<div class="line">                          <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp; solution) <span class="keyword">const</span> = 0;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> EvaluationBase&lt;dim&gt;::set_refinement_cycle(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> step)</div>
<div class="line">{</div>
<div class="line">  refinement_cycle = step;</div>
<div class="line">}</div>
<div class="ttc" id="aclassDoFHandler_html"><div class="ttname"><a href="classDoFHandler.html">DoFHandler</a></div><div class="ttdef"><b>Definition:</b> <a href="dofs_2dof__handler_8h_source.html#l00314">dof_handler.h:315</a></div></div>
<div class="ttc" id="aclassVector_html"><div class="ttname"><a href="classVector.html">Vector&lt; double &gt;</a></div></div>
</div><!-- fragment --><p><a class="anchor" id="Pointevaluation"></a> </p><h4>Point evaluation</h4>
<p>下一件事是实现实际的评估类。正如介绍中指出的，我们想从解决方案中提取一个点值，所以第一个类在其 <code>operator()</code> 中做了这个工作。实际的点是通过构造函数给这个类的，还有一个表对象，它将把它的发现放入其中。 <br  />
</p>
<p>如果我们不能依靠知道实际使用的有限元，那么找出一个任意点的有限元场的值是相当困难的，因为这样我们就不能，例如，在节点之间进行插值。因此，为了简单起见，我们在这里假设我们要评估场的点实际上是一个节点。如果在求解的过程中，我们发现我们在所有顶点上循环时没有遇到这个点，那么我们就必须抛出一个异常，以便向调用的函数发出出错的信号，而不是沉默地忽略这个错误。 <br  />
</p>
<p>在 <a class="el" href="step_9.html">step-9</a> 示例程序中，我们已经看到如何使用 <code>DeclExceptionN</code> 宏来声明这样一个异常类。我们在这里再次使用这一机制。 <br  />
</p>
<p>由此可见，这个类的实际声明应该是很明显的。请注意，即使我们没有明确地列出一个析构器，编译器也会生成一个隐含的析构器，而且它和基类的析构器一样是虚拟的。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>PointValueEvaluation : <span class="keyword">public</span> EvaluationBase&lt;dim&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  PointValueEvaluation(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;evaluation_point,</div>
<div class="line">                       <a class="code" href="classTableHandler.html">TableHandler</a> &amp;    results_table);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div>
<div class="line">                          <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp; solution) <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <a class="code" href="group__Exceptions.html#gad107d8d5ae0baa7083cd2e932f9056dd">DeclException1</a>(</div>
<div class="line">    ExcEvaluationPointNotFound,</div>
<div class="line">    <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>,</div>
<div class="line">    &lt;&lt; <span class="stringliteral">&quot;The evaluation point &quot;</span> &lt;&lt; arg1</div>
<div class="line">    &lt;&lt; <span class="stringliteral">&quot; was not found among the vertices of the present grid.&quot;</span>);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> evaluation_point;</div>
<div class="line">  <a class="code" href="classTableHandler.html">TableHandler</a> &amp;   results_table;</div>
<div class="line">};</div>
<div class="ttc" id="aclassPoint_html"><div class="ttname"><a href="classPoint.html">Point</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2point_8h_source.html#l00110">point.h:111</a></div></div>
<div class="ttc" id="aclassTableHandler_html"><div class="ttname"><a href="classTableHandler.html">TableHandler</a></div><div class="ttdef"><b>Definition:</b> <a href="table__handler_8h_source.html#l00295">table_handler.h:296</a></div></div>
<div class="ttc" id="agroup__Exceptions_html_gad107d8d5ae0baa7083cd2e932f9056dd"><div class="ttname"><a href="group__Exceptions.html#gad107d8d5ae0baa7083cd2e932f9056dd">DeclException1</a></div><div class="ttdeci">#define DeclException1(Exception1, type1, outsequence)</div><div class="ttdef"><b>Definition:</b> <a href="include_2deal_8II_2base_2exceptions_8h_source.html#l00515">exceptions.h:515</a></div></div>
</div><!-- fragment --><p>至于定义，构造函数是微不足道的，只是接收数据并将其存储在对象本地的。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">PointValueEvaluation&lt;dim&gt;::PointValueEvaluation(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;evaluation_point,</div>
<div class="line">  <a class="code" href="classTableHandler.html">TableHandler</a> &amp;    results_table)</div>
<div class="line">  : evaluation_point(evaluation_point)</div>
<div class="line">  , results_table(results_table)</div>
<div class="line">{}</div>
</div><!-- fragment --><p>现在是这个类中主要感兴趣的功能，即点值的计算。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> PointValueEvaluation&lt;dim&gt;::</div>
<div class="line">     operator()(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div>
<div class="line">           <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp; solution)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
</div><!-- fragment --><p>首先分配一个变量，用来保存点值。用一个明显是假的值来初始化它，这样如果我们不能把它设置成一个合理的值，我们就会马上注意到。这在像这个函数这样小的函数中可能没有必要，因为我们在这里可以很容易地看到所有可能的执行路径，但事实证明这对更复杂的情况是有帮助的，所以我们在这里也采用这种策略。</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> <a class="code" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">point_value</a> = 1e20;</div>
<div class="ttc" id="anamespaceVectorTools_html_acd358e9b110ccbf4a7f76796d206b9c7"><div class="ttname"><a href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">VectorTools::point_value</a></div><div class="ttdeci">void point_value(const DoFHandler&lt; dim, spacedim &gt; &amp;dof, const VectorType &amp;fe_function, const Point&lt; spacedim, double &gt; &amp;point, Vector&lt; typename VectorType::value_type &gt; &amp;value)</div></div>
</div><!-- fragment --><p>然后在所有单元格及其所有顶点上循环，并检查顶点是否与评估点相匹配。如果是这样，则提取该点的值，设置一个标志，表明我们已经找到了感兴趣的点，然后退出循环。</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> evaluation_point_found = <span class="keyword">false</span>;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gaace8c98aca00e7e48a619bb5e08084aa">active_cell_iterators</a>())</div>
<div class="line">  <span class="keywordflow">if</span> (!evaluation_point_found)</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> vertex : cell-&gt;vertex_indices())</div>
<div class="line">      <span class="keywordflow">if</span> (cell-&gt;vertex(vertex) == evaluation_point)</div>
<div class="line">        {</div>
<div class="ttc" id="agroup__CPP11_html_gaace8c98aca00e7e48a619bb5e08084aa"><div class="ttname"><a href="group__CPP11.html#gaace8c98aca00e7e48a619bb5e08084aa">DoFHandler::active_cell_iterators</a></div><div class="ttdeci">IteratorRange&lt; active_cell_iterator &gt; active_cell_iterators() const</div></div>
</div><!-- fragment --><p>为了从全局解决方案矢量中提取点值，挑选属于感兴趣的顶点的分量，如果解决方案是矢量值的，则取其第一个分量。</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">point_value</a> = solution(cell-&gt;vertex_dof_index(vertex, 0));</div>
</div><!-- fragment --><p>请注意，我们做了一个假设，这个假设并不总是有效的，如果这是实际应用的代码，而不是一个教程程序，就应该在类声明中记录下来：我们假设用于我们试图评估的解决方案的有限元实际上有与顶点相关的自由度。例如，这对不连续元素来说是不成立的，因为形状函数的支持点恰好位于顶点，但不与顶点相关，而是与单元内部相关，因为与顶点相关意味着那里的连续性。这对于面向边缘的元素等也是不成立的。 <br  />
</p>
<p>理想情况下，我们会在函数开始时检查这一点，例如通过一个类似<code>Assert (dof_handler.get_fe().dofs_per_vertex &gt; 0, <a class="el" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented()</a>)</code>的语句，当异常被触发时，这应该很清楚是什么出了问题。在这种情况下，我们省略了它（这确实是不好的风格），但知道这在这里并没有什么坏处，因为如果我们要求它给我们顶点的DoF索引，如果没有的话，语句 <code>cell-&gt;vertex_dof_index(vertex,0)</code> 将失败。 <br  />
</p>
<p>我们再次强调，这种对允许的有限元的限制应该在类的文档中说明。</p>
<p>由于我们找到了正确的点，我们现在设置相应的标志并退出最里面的循环。由于设置了标志，外循环也将被终止。</p>
<div class="fragment"><div class="line">  evaluation_point_found = <span class="keyword">true</span>;</div>
<div class="line">  <span class="keywordflow">break</span>;</div>
<div class="line">};</div>
</div><!-- fragment --><p>最后，我们要确保我们确实找到了评估点，因为如果不是这样，我们就不能在那里给出一个合理的解的值，反正剩下的计算也是无用的。所以通过 <code>AssertThrow</code> 程序中已经使用的 <a class="el" href="step_9.html">step-9</a> 宏，确保我们确实找到了这个点。如果不是这样，这个宏就会抛出一个作为第二个参数给它的类型的异常，但与直接的 <code>throw</code> 语句相比，它在异常对象中填充了一组额外的信息，例如，产生异常的源文件和行号，以及失败的条件。如果你在你的主函数里有一个 <code>catch</code> 子句（就像这个程序一样），你会捕捉到所有没有在中间某个地方捕捉到的、因而已经处理过的异常，这些额外的信息会帮助你找出发生了什么以及哪里出了问题。</p>
<div class="fragment"><div class="line"><a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(evaluation_point_found,</div>
<div class="line">            ExcEvaluationPointNotFound(evaluation_point));</div>
<div class="ttc" id="agroup__Exceptions_html_gafc0ca7ad85b3ebd64e8e51689ac85caf"><div class="ttname"><a href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a></div><div class="ttdeci">#define AssertThrow(cond, exc)</div><div class="ttdef"><b>Definition:</b> <a href="include_2deal_8II_2base_2exceptions_8h_source.html#l01583">exceptions.h:1583</a></div></div>
</div><!-- fragment --><p>请注意，我们在其他示例程序中也使用了 <code>Assert</code> 宏。它与这里使用的 <code>AssertThrow</code> 宏不同的是，它只是中止程序，而不是抛出一个异常，而且它只在调试模式下这样做。它是用来检查作为参数传递给函数的向量大小的正确宏，等等。 <br  />
</p>
<p>然而，这里的情况不同：我们是否找到了评估点，可能会随着细化的进行而改变（例如，如果点周围的四个单元被粗化掉了，那么在细化和粗化之后，点可能会消失）。这是在调试模式下无法预测的事情，但应该经常检查，在生产运行中也是如此。因此，这里使用了 <code>AssertThrow</code> 宏。</p>
<p>现在，如果我们确定我们已经找到了评估点，我们可以将结果添加到结果表中。</p>
<div class="fragment"><div class="line">  results_table.add_value(<span class="stringliteral">&quot;DoFs&quot;</span>, dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div>
<div class="line">  results_table.add_value(<span class="stringliteral">&quot;u(x_0)&quot;</span>, <a class="code" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">point_value</a>);</div>
<div class="line">}</div>
<div class="ttc" id="aclassDoFHandler_html_aa5b8d3c4b9deb0774dde5c2851e07e1e"><div class="ttname"><a href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">DoFHandler::n_dofs</a></div><div class="ttdeci">types::global_dof_index n_dofs() const</div></div>
</div><!-- fragment --><p><a class="anchor" id="Generatingoutput"></a> </p><h4>Generating output</h4>
<p>一种不同的，也许略显古怪的 <code>evaluation</code> 的解决方案是将其以图形的形式输出到文件中。由于在评估函数中，我们得到了一个 <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> 对象和解决方案的向量，我们有所有需要做的事情，所以我们可以在评估类中做这个。实际上这样做而不是把它放到计算解决方案的类中的原因是，这样我们有更多的灵活性：如果我们选择只输出它的某些方面，或者根本不输出它。在任何情况下，我们都不需要修改求解器类，我们只需要修改其中的一个模块，就可以构建这个程序了。如上所述，这种形式的封装可以帮助我们保持程序的每一部分都相当简单，因为接口保持简单，而且不可能访问隐藏的数据。 <br  />
</p>
<p>由于这个生成输出的类是由普通的 <code>EvaluationBase</code> 基类派生出来的，所以它的主要接口是 <code>operator()</code> 函数。此外，它有一个构造函数，接收一个字符串，该字符串将被用作文件名的基本部分，输出将被发送到该文件名（我们将用一个数字来增加它，表示细化周期的数量&ndash;基类手头有这个信息&ndash;以及一个后缀），构造函数还接收一个值，表示要求的格式，即我们将为哪个图形程序生成输出（然后我们也将从中生成我们写入的文件名的后缀）。 <br  />
</p>
<p>关于输出格式，DataOutBase命名空间提供了一个枚举字段 <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> ，列出了所有支持的输出格式名称。在编写本程序时，支持的图形格式由枚举值 <code>ucd</code> 、 <code>gnuplot</code>, <code>povray</code>, <code>eps</code> 、 <code>gmv</code>, <code>tecplot</code>, <code>tecplot_binary</code> 、 <code>dx</code>, <code>vtk</code> 等表示，但这个列表肯定会随着时间而增加。现在，在该基类的各种函数中，你可以使用这种类型的值来获得关于这些图形格式的信息（例如每种格式的文件所使用的默认后缀），你可以调用一个通用的 <code>write</code> 函数，然后根据给它的第二个参数的值表示所需的输出格式，将其分支到我们在以前的例子中已经使用的 <code>write_gnuplot</code>, <code>write_ucd</code> 等函数。这种机制使得编写一个可扩展的程序变得很简单，它可以在运行时决定使用哪种输出格式，同时也使得编写程序的方式变得相当简单，它可以利用新实现的输出格式，而不需要改变应用程序。 <br  />
</p>
<p>在这两个字段中，基名和输出格式描述符，构造函数取值并存储它们，以便以后由实际的评估函数使用。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>SolutionOutput : <span class="keyword">public</span> EvaluationBase&lt;dim&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  SolutionOutput(<span class="keyword">const</span> std::string &amp;             output_name_base,</div>
<div class="line">                 <span class="keyword">const</span> <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> output_format);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div>
<div class="line">                          <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp; solution) <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keyword">const</span> std::string               output_name_base;</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> output_format;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">SolutionOutput&lt;dim&gt;::SolutionOutput(</div>
<div class="line">  <span class="keyword">const</span> std::string &amp;             output_name_base,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> output_format)</div>
<div class="line">  : output_name_base(output_name_base)</div>
<div class="line">  , output_format(output_format)</div>
<div class="line">{}</div>
<div class="ttc" id="anamespaceDataOutBase_html_aa3cbced9f1d4ae661f13018f4c980aa1"><div class="ttname"><a href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a></div><div class="ttdeci">OutputFormat</div><div class="ttdef"><b>Definition:</b> <a href="data__out__base_8h_source.html#l01545">data_out_base.h:1546</a></div></div>
</div><!-- fragment --><p>按照上面的描述，现在生成实际输出的函数是相对简单的。与以前的例子程序相比，唯一特别有趣的特征是使用了 <a class="el" href="namespaceDataOutBase.html#aed25a6ddf928a6904fd1ac942125ec86">DataOutBase::default_suffix</a> 函数，为给定格式的文件返回通常的后缀（例如，".eps "用于封装的postscript文件，".gnuplot "用于Gnuplot文件），以及带有第二个参数的通用 <a class="el" href="group__Exceptions.html#ga78e73ad285a8792ff0f9f227b82eb108">DataOut::write()</a> 函数，根据作为第二个参数传递的格式描述符的值，内部分支到不同图形格式的实际产出函数。 <br  />
</p>
<p>还要注意的是，我们必须在 <code>this-&gt;</code> 前面加上前缀，才能访问依赖模板的基类的成员变量。这里的原因，以及在程序中进一步描述的原因，与 <a class="el" href="step_7.html">step-7</a> 示例程序中描述的相同（在那里寻找 <code>two-stage name lookup</code> ）。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> SolutionOutput&lt;dim&gt;::operator()(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div>
<div class="line">                                     <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp; solution)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div>
<div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a>(dof_handler);</div>
<div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div>
<div class="line">  data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a>();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  std::ofstream out(output_name_base + <span class="stringliteral">&quot;-&quot;</span> +</div>
<div class="line">                    <a class="code" href="group__Exceptions.html#ga72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(this-&gt;refinement_cycle) +</div>
<div class="line">                    data_out.<a class="code" href="group__Exceptions.html#ga36120ca3f536c90709e135161030f16c">default_suffix</a>(output_format));</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  data_out.<a class="code" href="group__Exceptions.html#ga78e73ad285a8792ff0f9f227b82eb108">write</a>(out, output_format);</div>
<div class="line">}</div>
<div class="ttc" id="aclassDataOut__DoFData_html_ac1eb26168177faa30ffbcf9cbb9c3cd5"><div class="ttname"><a href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">DataOut_DoFData::attach_dof_handler</a></div><div class="ttdeci">void attach_dof_handler(const DoFHandlerType &amp;)</div></div>
<div class="ttc" id="aclassDataOut__DoFData_html_ace4b76e565ba0701c4d32c26075ed3b9"><div class="ttname"><a href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">DataOut_DoFData::add_data_vector</a></div><div class="ttdeci">void add_data_vector(const VectorType &amp;data, const std::vector&lt; std::string &gt; &amp;names, const DataVectorType type=type_automatic, const std::vector&lt; DataComponentInterpretation::DataComponentInterpretation &gt; &amp;data_component_interpretation=std::vector&lt; DataComponentInterpretation::DataComponentInterpretation &gt;())</div><div class="ttdef"><b>Definition:</b> <a href="data__out__dof__data_8h_source.html#l01087">data_out_dof_data.h:1087</a></div></div>
<div class="ttc" id="aclassDataOut_html"><div class="ttname"><a href="classDataOut.html">DataOut</a></div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__out_8h_source.html#l00147">data_out.h:150</a></div></div>
<div class="ttc" id="aclassDataOut_html_a5eb51872b8736849bb7e8d2007fae086"><div class="ttname"><a href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">DataOut::build_patches</a></div><div class="ttdeci">virtual void build_patches(const unsigned int n_subdivisions=0)</div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__out_8cc_source.html#l01085">data_out.cc:1085</a></div></div>
<div class="ttc" id="agroup__Exceptions_html_ga36120ca3f536c90709e135161030f16c"><div class="ttname"><a href="group__Exceptions.html#ga36120ca3f536c90709e135161030f16c">DataOutInterface::default_suffix</a></div><div class="ttdeci">std::string default_suffix(const DataOutBase::OutputFormat output_format=DataOutBase::default_format) const</div><div class="ttdef"><b>Definition:</b> <a href="data__out__base_8cc_source.html#l08201">data_out_base.cc:8201</a></div></div>
<div class="ttc" id="agroup__Exceptions_html_ga72743302dcb1a0fb1f2f8dc5122d299e"><div class="ttname"><a href="group__Exceptions.html#ga72743302dcb1a0fb1f2f8dc5122d299e">Patterns::Tools::to_string</a></div><div class="ttdeci">std::string to_string(const T &amp;t)</div><div class="ttdef"><b>Definition:</b> <a href="patterns_8h_source.html#l02329">patterns.h:2329</a></div></div>
<div class="ttc" id="agroup__Exceptions_html_ga78e73ad285a8792ff0f9f227b82eb108"><div class="ttname"><a href="group__Exceptions.html#ga78e73ad285a8792ff0f9f227b82eb108">DataOutInterface::write</a></div><div class="ttdeci">void write(std::ostream &amp;out, const DataOutBase::OutputFormat output_format=DataOutBase::default_format) const</div><div class="ttdef"><b>Definition:</b> <a href="data__out__base_8cc_source.html#l08090">data_out_base.cc:8090</a></div></div>
</div><!-- fragment --><p><a class="anchor" id="Otherevaluations"></a> </p><h4>Other evaluations</h4>
<p>在实际应用中，人们会在这里添加一个其他可能的评价类的列表，代表人们可能感兴趣的数量。对于这个例子来说，这些就足够了，所以我们关闭这个命名空间。</p>
<div class="fragment"><div class="line">} <span class="comment">// namespace Evaluation</span></div>
</div><!-- fragment --><p><a class="anchor" id="TheLaplacesolverclasses"></a> </p><h3>The Laplace solver classes</h3>
<p>在定义了我们想知道的解决方案之后，我们现在应该关心如何获得它。我们将把所有我们需要的东西都打包到一个自己的命名空间中，原因和上面的评估差不多。 <br  />
</p>
<p>由于我们在以前的例子中已经相当详细地讨论了拉普拉斯求解器，所以下面没有什么新的东西。相反，我们在很大程度上拆解了以前的例子，并以稍微不同的形式把它们放到这个例子程序中。因此，我们将主要讨论与以前的例子的区别。 <br  />
</p>
<p>基本上，正如在介绍中已经说过的，这个例子中缺乏新的东西是故意的，因为它更多地是为了展示软件设计的实践，而不是数学。因此，下面解释的重点将更多地放在实际的实现上。</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>LaplaceSolver</div>
<div class="line">{</div>
</div><!-- fragment --><p><a class="anchor" id="Anabstractbaseclass"></a> </p><h4>An abstract base class</h4>
<p>在定义拉普拉斯求解器时，我们首先声明一个抽象的基类，它本身没有任何功能，只是接受并存储一个指向三角形的指针，以便以后使用。 <br  />
</p>
<p>这个基类非常通用，也可以用于任何其他静止问题。它提供了一些函数的声明，这些函数将在派生类中分别解决一个问题，用评估对象的列表对解决方案进行后处理，以及细化网格。这些函数都没有在基类中实际做一些事情。 <br  />
</p>
<p>由于缺乏实际功能，声明非常抽象的基类的编程风格类似于Smalltalk或Java程序中使用的风格，所有的类都是从完全抽象的类派生出来的 <code>Object</code> ，甚至是数字表示。作者承认，他并不特别喜欢在C++中使用这种风格，因为它将风格置于理性之上。此外，它提倡对一切事物使用虚拟函数（例如，在Java中，所有的函数本身就是虚拟的），然而，这在许多应用中被证明是相当低效的，在这些应用中，函数往往只是访问数据，而不是进行计算，因此很快就会返回；这样，虚拟函数的开销就会很大。笔者的观点是，只要至少有一部分实际实现的代码可以被共享，从而被分离到基类中，就应该有抽象的基类。 <br  />
</p>
<p>除了所有这些理论上的问题，我们这里还有一个很好的理由，这个理由在下面会让读者更清楚。基本上，我们希望能够有一个不同的拉普拉斯求解器家族，这些求解器差异很大，以至于无法找到更大的共同功能子集。因此，我们只是声明了这样一个抽象的基类，在构造函数中获取一个指向三角形的指针，并从此存储它。由于这个三角剖分将在所有的计算中使用，我们必须确保这个三角剖分在最后使用之前是有效的。我们通过为这个三角剖分保留一个 <code><a class="el" href="classSmartPointer.html">SmartPointer</a></code> 来做到这一点，正如 <a class="el" href="step_7.html">step-7</a> 中所解释的。 <br  />
</p>
<p>请注意，虽然指针本身被声明为常数（即在这个对象的整个生命周期中，指针指向同一个对象），但它没有被声明为指向常数三角的指针。事实上，通过这种方式，我们允许派生类在 <code>refine_grid</code> 函数中细化或粗化三角化。 <br  />
</p>
<p>最后，我们有一个函数 <code>n_dofs</code> 只是驱动函数的一个工具，用来决定我们是否要继续进行网格细化。它返回当前模拟的自由度数量。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>Base</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  Base(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;coarse_grid);</div>
<div class="line">  <span class="keyword">virtual</span> ~Base() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> solve_problem() = 0;</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> postprocess(</div>
<div class="line">    <span class="keyword">const</span> Evaluation::EvaluationBase&lt;dim&gt; &amp;postprocessor) <span class="keyword">const</span> = 0;</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span>         refine_grid()                            = 0;</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs() <span class="keyword">const</span>                           = 0;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;Triangulation&lt;dim&gt;</a>&gt; <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div>
<div class="line">};</div>
<div class="ttc" id="aclassSmartPointer_html"><div class="ttname"><a href="classSmartPointer.html">SmartPointer</a></div><div class="ttdef"><b>Definition:</b> <a href="smartpointer_8h_source.html#l00067">smartpointer.h:68</a></div></div>
<div class="ttc" id="aclassTriangulation_html"><div class="ttname"><a href="classTriangulation.html">Triangulation</a></div><div class="ttdef"><b>Definition:</b> <a href="grid_2tria_8h_source.html#l01127">tria.h:1128</a></div></div>
<div class="ttc" id="ap4est__wrappers_8cc_html_ace00f2f80d9780ef9aa1007e1c22c6a4"><div class="ttname"><a href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a></div><div class="ttdeci">const ::parallel::distributed::Triangulation&lt; dim, spacedim &gt; * triangulation</div><div class="ttdef"><b>Definition:</b> <a href="p4est__wrappers_8cc_source.html#l00069">p4est_wrappers.cc:69</a></div></div>
</div><!-- fragment --><p>那么仅有的两个非抽象函数的实现就相当无聊了。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">Base&lt;dim&gt;::Base(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;coarse_grid)</div>
<div class="line">  : <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>(&amp;coarse_grid)</div>
<div class="line">{}</div>
</div><!-- fragment --><p><a class="anchor" id="Ageneralsolverclass"></a> </p><h4>A general solver class</h4>
<p>下面是主类，它实现了线性系统矩阵的组装、求解以及在求解中调用后处理器对象。它实现了基类中声明的 <code>solve_problem</code> 和 <code>postprocess</code> 函数。然而，它并没有实现 <code>refine_grid</code> 方法，因为网格细化将在一些派生类中实现。 <br  />
</p>
<p>它还声明了一个新的抽象虚函数， <code>assemble_rhs</code> ，需要在子类中重载。原因是我们将实现两个不同的类，它们将实现不同的方法来组装右手边的向量。这个函数在以下情况下可能也很有趣：右手边不仅仅取决于一个连续函数，还取决于其他东西，例如另一个离散问题的解，等等。后者在非线性问题中经常发生。 <br  />
</p>
<p>正如我们之前提到的，这一类的实际内容并不是新的，而是以前的例子中已经使用过的各种技术的混合。因此，我们将不详细讨论它们，而是让读者参考这些程序。 <br  />
</p>
<p>基本上，用几句话来说，这个类的构造函数接收指向一个三角形、一个有限元和一个代表边界值的函数对象的指针。这些都被传递给基类的构造函数，或者被存储起来并在以后用于生成一个 <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> 对象。由于有限元和正交公式应该匹配，所以也会传递一个正交对象。 <br  />
</p>
<p><code>solve_problem</code> 为实际求解设置数据结构，调用函数来组装线性系统，并求解它。 <br  />
</p>
<p><code>postprocess</code> 函数最后接收一个评估对象并将其应用于计算出的解决方案。 <br  />
</p>
<p><code>n_dofs</code> 函数最后实现了基类的纯虚拟函数。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>Solver : <span class="keyword">public</span> <span class="keyword">virtual</span> Base&lt;dim&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  Solver(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>,</div>
<div class="line">         <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div>
<div class="line">         <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div>
<div class="line">         <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values);</div>
<div class="line">  <span class="keyword">virtual</span> ~Solver() <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> solve_problem() <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> postprocess(</div>
<div class="line">    <span class="keyword">const</span> Evaluation::EvaluationBase&lt;dim&gt; &amp;postprocessor) <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs() <span class="keyword">const override</span>;</div>
<div class="ttc" id="aclassFiniteElement_html"><div class="ttname"><a href="classFiniteElement.html">FiniteElement</a></div><div class="ttdef"><b>Definition:</b> <a href="include_2deal_8II_2fe_2fe_8h_source.html#l00645">fe.h:646</a></div></div>
<div class="ttc" id="aclassFunction_html"><div class="ttname"><a href="classFunction.html">Function</a></div><div class="ttdef"><b>Definition:</b> <a href="function_8h_source.html#l00150">function.h:153</a></div></div>
<div class="ttc" id="aclassQuadrature_html"><div class="ttname"><a href="classQuadrature.html">Quadrature</a></div><div class="ttdef"><b>Definition:</b> <a href="include_2deal_8II_2base_2quadrature_8h_source.html#l00083">quadrature.h:84</a></div></div>
</div><!-- fragment --><p>在这个类的保护部分，我们首先有一些成员变量，其用途在前面的例子中应该很清楚。</p>
<div class="fragment"><div class="line"><span class="keyword">protected</span>:</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const FiniteElement&lt;dim&gt;</a>&gt; fe;</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const Quadrature&lt;dim&gt;</a>&gt;    quadrature;</div>
<div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>                              dof_handler;</div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                               solution;</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const Function&lt;dim&gt;</a>&gt;      boundary_values;</div>
</div><!-- fragment --><p>然后我们声明了一个抽象函数，它将被用来组装右手边。正如上面所解释的，在各种情况下，这个动作的必要性有很大的不同，所以我们把它推迟到派生类。</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> assemble_rhs(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;rhs) <span class="keyword">const</span> = 0;</div>
</div><!-- fragment --><p>接下来，在私有部分，我们有一个小类，它表示整个线性系统，即一个矩阵、一个右手边和一个解向量，以及应用于它的约束条件，如那些由于悬空的节点。它的构造函数初始化了各种子对象，并且有一个函数实现了共轭梯度法作为求解器。</p>
<div class="fragment"><div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keyword">struct </span>LinearSystem</div>
<div class="line">  {</div>
<div class="line">    LinearSystem(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> solve(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;solution) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> hanging_node_constraints;</div>
<div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>           sparsity_pattern;</div>
<div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>      <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>;</div>
<div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>            rhs;</div>
<div class="line">  };</div>
<div class="ttc" id="aclassAffineConstraints_html"><div class="ttname"><a href="classAffineConstraints.html">AffineConstraints&lt; double &gt;</a></div></div>
<div class="ttc" id="aclassSparseMatrix_html"><div class="ttname"><a href="classSparseMatrix.html">SparseMatrix&lt; double &gt;</a></div></div>
<div class="ttc" id="aclassSparsityPattern_html"><div class="ttname"><a href="classSparsityPattern.html">SparsityPattern</a></div><div class="ttdef"><b>Definition:</b> <a href="sparsity__pattern_8h_source.html#l00868">sparsity_pattern.h:869</a></div></div>
<div class="ttc" id="anamespaceLAPACKSupport_html_a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003"><div class="ttname"><a href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">LAPACKSupport::matrix</a></div><div class="ttdeci">@ matrix</div><div class="ttdoc">Contents is actually a matrix.</div><div class="ttdef"><b>Definition:</b> <a href="lapack__support_8h_source.html#l00058">lapack_support.h:58</a></div></div>
</div><!-- fragment --><p>最后，有一组函数将被用来组装实际的系统矩阵。这一组的主要函数， <code>assemble_linear_system()</code> 使用以下两个辅助函数，在多核系统上并行计算矩阵。这样做的机制与 <a class="el" href="step_9.html">step-9</a> 示例程序相同，并遵循 <a class="el" href="group__threads.html">Parallel computing with multiple processors accessing shared memory</a> 中概述的 <a class="el" href="namespaceWorkStream.html">WorkStream</a> 概念。主函数还调用了组装右手边的虚拟函数。</p>
<div class="fragment"><div class="line">  <span class="keyword">struct </span>AssemblyScratchData</div>
<div class="line">  {</div>
<div class="line">    AssemblyScratchData(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div>
<div class="line">                        <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature);</div>
<div class="line">    AssemblyScratchData(<span class="keyword">const</span> AssemblyScratchData &amp;scratch_data);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">struct </span>AssemblyCopyData</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div>
<div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> assemble_linear_system(LinearSystem &amp;linear_system);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> local_assemble_matrix(</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__Iterators.html#ga6b8bbcafed8847f3030ea30c6990eb2d">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div>
<div class="line">    AssemblyScratchData &amp;                                 scratch_data,</div>
<div class="line">    AssemblyCopyData &amp;                                    copy_data) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> copy_local_to_global(<span class="keyword">const</span> AssemblyCopyData &amp;copy_data,</div>
<div class="line">                            LinearSystem &amp;          linear_system) <span class="keyword">const</span>;</div>
<div class="line">};</div>
<div class="ttc" id="aclassFEValues_html"><div class="ttname"><a href="classFEValues.html">FEValues</a></div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__values_8h_source.html#l03905">fe_values.h:3906</a></div></div>
<div class="ttc" id="aclassFullMatrix_html"><div class="ttname"><a href="classFullMatrix.html">FullMatrix&lt; double &gt;</a></div></div>
<div class="ttc" id="agroup__Iterators_html_ga6b8bbcafed8847f3030ea30c6990eb2d"><div class="ttname"><a href="group__Iterators.html#ga6b8bbcafed8847f3030ea30c6990eb2d">DoFHandler::active_cell_iterator</a></div><div class="ttdeci">typename ActiveSelector::active_cell_iterator active_cell_iterator</div><div class="ttdef"><b>Definition:</b> <a href="dofs_2dof__handler_8h_source.html#l00438">dof_handler.h:438</a></div></div>
<div class="ttc" id="anamespaceLocalIntegrators_1_1Advection_html_a8bc7b8136646134f73a4193adefe15f8"><div class="ttname"><a href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">LocalIntegrators::Advection::cell_matrix</a></div><div class="ttdeci">void cell_matrix(FullMatrix&lt; double &gt; &amp;M, const FEValuesBase&lt; dim &gt; &amp;fe, const FEValuesBase&lt; dim &gt; &amp;fetest, const ArrayView&lt; const std::vector&lt; double &gt;&gt; &amp;velocity, const double factor=1.)</div><div class="ttdef"><b>Definition:</b> <a href="advection_8h_source.html#l00075">advection.h:75</a></div></div>
</div><!-- fragment --><p>现在是该类的构造函数。它没有做什么，只是存储了给定对象的指针，并生成 <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> 对象，初始化了给定的三角形的指针。这将导致DoF处理程序存储该指针，但并不已经生成有限元编号（我们只在 <code>solve_problem</code> 函数中要求这样做）。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">Solver&lt;dim&gt;::Solver(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>,</div>
<div class="line">                    <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div>
<div class="line">                    <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div>
<div class="line">                    <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values)</div>
<div class="line">  : Base&lt;dim&gt;(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>)</div>
<div class="line">  , fe(&amp;fe)</div>
<div class="line">  , quadrature(&amp;quadrature)</div>
<div class="line">  , dof_handler(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>)</div>
<div class="line">  , boundary_values(&amp;boundary_values)</div>
<div class="line">{}</div>
</div><!-- fragment --><p>解构器很简单，它只是清除存储在DoF处理程序对象中的信息以释放内存。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">Solver&lt;dim&gt;::~Solver()</div>
<div class="line">{</div>
<div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#ad316958f8045d9a48094335b23a03a53">clear</a>();</div>
<div class="line">}</div>
<div class="ttc" id="aclassDoFHandler_html_ad316958f8045d9a48094335b23a03a53"><div class="ttname"><a href="classDoFHandler.html#ad316958f8045d9a48094335b23a03a53">DoFHandler::clear</a></div><div class="ttdeci">void clear()</div></div>
</div><!-- fragment --><p>下一个函数代表了解决问题的主要工作：它用给这个对象的构造函数的有限元来设置DoF处理程序对象，创建一个表示线性系统的对象（即矩阵、右手向量和解向量），调用函数来组装它，最后解决它。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> Solver&lt;dim&gt;::solve_problem()</div>
<div class="line">{</div>
<div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(*fe);</div>
<div class="line">  solution.<a class="code" href="group__Vectors.html#gac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  LinearSystem linear_system(dof_handler);</div>
<div class="line">  assemble_linear_system(linear_system);</div>
<div class="line">  linear_system.solve(solution);</div>
<div class="line">}</div>
<div class="ttc" id="aclassDoFHandler_html_a553ca864aaf70330d9be86bc78f36d1e"><div class="ttname"><a href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">DoFHandler::distribute_dofs</a></div><div class="ttdeci">void distribute_dofs(const FiniteElement&lt; dim, spacedim &gt; &amp;fe)</div></div>
<div class="ttc" id="agroup__Vectors_html_gac4a4dbef7dd65ef8ad35ae56b57d7c05"><div class="ttname"><a href="group__Vectors.html#gac4a4dbef7dd65ef8ad35ae56b57d7c05">Vector::reinit</a></div><div class="ttdeci">virtual void reinit(const size_type N, const bool omit_zeroing_entries=false)</div></div>
</div><!-- fragment --><p>如上所述， <code>postprocess</code> 函数接收一个评估对象，并将其应用于计算出的解。这个函数可以被多次调用，为用户所需的每一个解的评价调用一次。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> Solver&lt;dim&gt;::postprocess(</div>
<div class="line">  <span class="keyword">const</span> Evaluation::EvaluationBase&lt;dim&gt; &amp;postprocessor)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  postprocessor(dof_handler, solution);</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>n_dofs</code> 函数应该是不言自明的。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Solver&lt;dim&gt;::n_dofs()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <span class="keywordflow">return</span> dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><p>下面的函数在每一步中组装矩阵和要解决的线性系统的右手边。我们将在几个层面上并行地做事情。首先，请注意，我们需要组装矩阵和右手边。这些都是独立的操作，我们应该并行地进行这些操作。为此，我们使用 <a class="el" href="group__threads.html">Parallel computing with multiple processors accessing shared memory</a> 文档模块中讨论的 "任务 "概念。本质上，我们想说的是 "这里有一些需要处理的事情，只要有CPU核可用就去做"，然后再做其他事情，当我们需要第一个操作的结果时，就等待它的完成。在第二层，我们想用我们在 <a class="el" href="step_9.html">step-9</a> 中已经使用过的完全相同的策略，即WorkStream概念来组装矩阵。 <br  />
</p>
<p>虽然我们可以考虑在做另一件事的时候在后台组装右侧或组装矩阵，但我们将选择前一种方法，只是因为对 <code>Solver::assemble_rhs</code> 的调用比对 <a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a> 的调用及其许多参数要简单得多。在任何情况下，代码看起来像这样，以组装整个线性系统。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> Solver&lt;dim&gt;::assemble_linear_system(LinearSystem &amp;linear_system)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classThreads_1_1Task.html">Threads::Task&lt;void&gt;</a> rhs_task =</div>
<div class="line">    <a class="code" href="group__threads.html#ga8c1e15b84e1bb58a8029fc6d6ddf3cbf">Threads::new_task</a>(&amp;Solver&lt;dim&gt;::assemble_rhs, *<span class="keyword">this</span>, linear_system.rhs);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> worker =</div>
<div class="line">    [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__Iterators.html#ga6b8bbcafed8847f3030ea30c6990eb2d">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div>
<div class="line">           AssemblyScratchData &amp;scratch_data,</div>
<div class="line">           AssemblyCopyData &amp;   copy_data) {</div>
<div class="line">      this-&gt;local_assemble_matrix(cell, scratch_data, copy_data);</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> copier = [<span class="keyword">this</span>, &amp;linear_system](<span class="keyword">const</span> AssemblyCopyData &amp;copy_data) {</div>
<div class="line">    this-&gt;copy_local_to_global(copy_data, linear_system);</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>(dof_handler.<a class="code" href="classDoFHandler.html#a9a3bef554c6d22abe312e10e9475eecf">begin_active</a>(),</div>
<div class="line">                  dof_handler.<a class="code" href="classDoFHandler.html#a042c4bf0f59fef5e72dbcfbdd56b2782">end</a>(),</div>
<div class="line">                  worker,</div>
<div class="line">                  copier,</div>
<div class="line">                  AssemblyScratchData(*fe, *quadrature),</div>
<div class="line">                  AssemblyCopyData());</div>
<div class="line">  linear_system.hanging_node_constraints.condense(linear_system.matrix);</div>
<div class="ttc" id="aclassDoFHandler_html_a042c4bf0f59fef5e72dbcfbdd56b2782"><div class="ttname"><a href="classDoFHandler.html#a042c4bf0f59fef5e72dbcfbdd56b2782">DoFHandler::end</a></div><div class="ttdeci">cell_iterator end() const</div></div>
<div class="ttc" id="aclassDoFHandler_html_a9a3bef554c6d22abe312e10e9475eecf"><div class="ttname"><a href="classDoFHandler.html#a9a3bef554c6d22abe312e10e9475eecf">DoFHandler::begin_active</a></div><div class="ttdeci">active_cell_iterator begin_active(const unsigned int level=0) const</div></div>
<div class="ttc" id="aclassThreads_1_1Task_html"><div class="ttname"><a href="classThreads_1_1Task.html">Threads::Task&lt; void &gt;</a></div></div>
<div class="ttc" id="agroup__threads_html_ga8c1e15b84e1bb58a8029fc6d6ddf3cbf"><div class="ttname"><a href="group__threads.html#ga8c1e15b84e1bb58a8029fc6d6ddf3cbf">Threads::new_task</a></div><div class="ttdeci">Task&lt; RT &gt; new_task(const std::function&lt; RT()&gt; &amp;function)</div><div class="ttdef"><b>Definition:</b> <a href="thread__management_8h_source.html#l01324">thread_management.h:1324</a></div></div>
<div class="ttc" id="anamespaceWorkStream_html_ab8ceb010811941c351803b671a19fb73"><div class="ttname"><a href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a></div><div class="ttdeci">void run(const std::vector&lt; std::vector&lt; Iterator &gt;&gt; &amp;colored_iterators, Worker worker, Copier copier, const ScratchData &amp;sample_scratch_data, const CopyData &amp;sample_copy_data, const unsigned int queue_length=2 *MultithreadInfo::n_threads(), const unsigned int chunk_size=8)</div><div class="ttdef"><b>Definition:</b> <a href="work__stream_8h_source.html#l01337">work_stream.h:1337</a></div></div>
</div><!-- fragment --><p>上面的语法需要一些解释。有多个版本的 <a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a> 期待不同的参数。在 <a class="el" href="step_9.html">step-9</a> 中，我们使用了一个版本，它需要一对迭代器、一对具有非常具体的参数列表的成员函数指针、一个指向这些成员函数必须工作的对象的指针或引用，以及一个抓取和复制数据对象。这有点限制性，因为这样调用的成员函数的参数列表必须与 <a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a> 所期望的完全一致：本地装配函数需要接收一个迭代器、一个抓取对象和一个复制对象；而复制-本地-全局函数需要接收的正是一个复制对象。但是，如果我们想要的东西稍微更通用一些呢？例如，在目前的程序中，copy-local-to-global函数需要知道将本地贡献写入哪个线性系统对象，也就是说，它还必须接受一个 <code>LinearSystem</code> 参数。这在使用成员函数指针的方法中是行不通的。 <br  />
</p>
<p>幸运的是，C++提供了一条出路。这些被称为函数对象。从本质上讲， <a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a> 想要做的不是调用成员函数。它想调用一些函数，这些函数在第一种情况下需要一个迭代器、一个抓取对象和一个拷贝对象，而在第二种情况下需要一个拷贝对象。不管这些是成员函数、全局函数，还是其他什么，对WorkStream来说，真的不是很关心。因此，有第二个版本的函数只接收函数对象&ndash;具有 <code>operator()</code> 的对象，因此可以像函数一样被调用，不管它们真正代表什么。产生这种函数对象的典型方法是使用一个<a href="http://en.wikipedia.org/wiki/Anonymous_function">lambda function</a>，它用固定的值来包装函数调用，包括各个参数。所有属于外层函数签名的参数在lambda函数中被指定为常规的函数参数。固定值使用捕获列表（<code>[...]</code>）传递到lambda函数中。可以使用捕获默认值，也可以明确列出所有要绑定到lambda的变量。为了清楚起见，我们决定在这里省略捕获默认值，但是捕获列表同样可以是<code>[&amp;]</code>，这意味着所有使用的变量都通过引用被复制到λ中。 <br  />
</p>
<p>在这一点上，我们已经组装好了矩阵，并将其浓缩。右手边可能已经完全组装好了，也可能还没有，但是我们接下来想浓缩右手边的向量。我们只有在这个向量的组装完成后才能这样做，所以我们必须等待任务的完成；在计算机科学中，等待任务通常被称为 "加入 "任务，解释了我们下面调用的函数的名称。 <br  />
</p>
<p>既然这个任务可能已经完成，也可能没有完成，既然我们可能要等待它完成，那么我们不妨试着把其他需要做的事情打包到这个空隙中。因此，在等待右手边的工作之前，我们首先插值边界值。当然，另一种可能性是在一个单独的任务中也插值边界值，因为这样做与我们到目前为止在这个函数中所做的其他事情无关。请自由地找到正确的语法，为这个插值创建一个任务，并在这个函数的顶部启动它，同时装配右手边。(你会发现这稍微有点复杂，因为 <a class="el" href="namespaceVectorTools.html#ab2562d41bb26f362043f9719a8cd9b87">VectorTools::interpolate_boundary_values()</a>, 有多个版本，所以简单地取地址 <code>&amp;<a class="el" href="namespaceVectorTools.html#ab2562d41bb26f362043f9719a8cd9b87">VectorTools::interpolate_boundary_values</a></code> 会产生一组重载函数，不能马上传递给 <a class="el" href="group__threads.html#ga8c1e15b84e1bb58a8029fc6d6ddf3cbf">Threads::new_task()</a> &ndash;你必须通过将地址表达式转换为函数指针类型，选择你想要的这个重载集合中的哪一个元素，这是你想在任务中调用的函数的特定版本。)</p>
<div class="fragment"><div class="line">std::map&lt;types::global_dof_index, double&gt; boundary_value_map;</div>
<div class="line"><a class="code" href="namespaceVectorTools.html#ab2562d41bb26f362043f9719a8cd9b87">VectorTools::interpolate_boundary_values</a>(dof_handler,</div>
<div class="line">                                         0,</div>
<div class="line">                                         *boundary_values,</div>
<div class="line">                                         boundary_value_map);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">rhs_task.<a class="code" href="classThreads_1_1Task.html#a9aed8f99d2b88bd0d6cfff95e38c3ac7">join</a>();</div>
<div class="line">linear_system.hanging_node_constraints.condense(linear_system.rhs);</div>
<div class="ttc" id="aclassThreads_1_1Task_html_a9aed8f99d2b88bd0d6cfff95e38c3ac7"><div class="ttname"><a href="classThreads_1_1Task.html#a9aed8f99d2b88bd0d6cfff95e38c3ac7">Threads::Task::join</a></div><div class="ttdeci">void join() const</div><div class="ttdef"><b>Definition:</b> <a href="thread__management_8h_source.html#l01077">thread_management.h:1077</a></div></div>
<div class="ttc" id="anamespaceVectorTools_html_ab2562d41bb26f362043f9719a8cd9b87"><div class="ttname"><a href="namespaceVectorTools.html#ab2562d41bb26f362043f9719a8cd9b87">VectorTools::interpolate_boundary_values</a></div><div class="ttdeci">void interpolate_boundary_values(const Mapping&lt; dim, spacedim &gt; &amp;mapping, const DoFHandler&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; types::boundary_id, const Function&lt; spacedim, number &gt; * &gt; &amp;function_map, std::map&lt; types::global_dof_index, number &gt; &amp;boundary_values, const ComponentMask &amp;component_mask=ComponentMask())</div></div>
</div><!-- fragment --><p>现在我们有了完整的线性系统，我们也可以处理边界值，需要从矩阵和右手边消除边界值了。</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_value_map,</div>
<div class="line">                                     linear_system.matrix,</div>
<div class="line">                                     solution,</div>
<div class="line">                                     linear_system.rhs);</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceMatrixTools_html_a9ad0eb7a8662628534586716748d62fb"><div class="ttname"><a href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a></div><div class="ttdeci">void apply_boundary_values(const std::map&lt; types::global_dof_index, number &gt; &amp;boundary_values, SparseMatrix&lt; number &gt; &amp;matrix, Vector&lt; number &gt; &amp;solution, Vector&lt; number &gt; &amp;right_hand_side, const bool eliminate_columns=true)</div><div class="ttdef"><b>Definition:</b> <a href="matrix__tools_8cc_source.html#l00081">matrix_tools.cc:81</a></div></div>
</div><!-- fragment --><p>这组函数的后半部分处理每个单元上的局部装配，并将局部贡献复制到全局矩阵对象中。这与 <a class="el" href="step_9.html">step-9</a> 中描述的工作方式完全相同。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">Solver&lt;dim&gt;::AssemblyScratchData::AssemblyScratchData(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature)</div>
<div class="line">  : fe_values(fe, quadrature, <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div>
<div class="line">{}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">Solver&lt;dim&gt;::AssemblyScratchData::AssemblyScratchData(</div>
<div class="line">  <span class="keyword">const</span> AssemblyScratchData &amp;scratch_data)</div>
<div class="line">  : fe_values(scratch_data.fe_values.get_fe(),</div>
<div class="line">              scratch_data.fe_values.get_quadrature(),</div>
<div class="line">              <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div>
<div class="line">{}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> Solver&lt;dim&gt;::local_assemble_matrix(</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__Iterators.html#ga6b8bbcafed8847f3030ea30c6990eb2d">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div>
<div class="line">  AssemblyScratchData &amp;                                 scratch_data,</div>
<div class="line">  AssemblyCopyData &amp;                                    copy_data)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe-&gt;n_dofs_per_cell();</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature-&gt;size();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  copy_data.cell_matrix.reinit(dofs_per_cell, dofs_per_cell);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  copy_data.local_dof_indices.resize(dofs_per_cell);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  scratch_data.fe_values.reinit(cell);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div>
<div class="line">        copy_data.cell_matrix(i, j) +=</div>
<div class="line">          (scratch_data.fe_values.shape_grad(i, q_point) *</div>
<div class="line">           scratch_data.fe_values.shape_grad(j, q_point) *</div>
<div class="line">           scratch_data.fe_values.JxW(q_point));</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  cell-&gt;get_dof_indices(copy_data.local_dof_indices);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> Solver&lt;dim&gt;::copy_local_to_global(<span class="keyword">const</span> AssemblyCopyData &amp;copy_data,</div>
<div class="line">                                       LinearSystem &amp;linear_system)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; copy_data.local_dof_indices.size(); ++i)</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; copy_data.local_dof_indices.size(); ++j)</div>
<div class="line">      linear_system.matrix.add(copy_data.local_dof_indices[i],</div>
<div class="line">                               copy_data.local_dof_indices[j],</div>
<div class="line">                               copy_data.cell_matrix(i, j));</div>
<div class="line">}</div>
<div class="ttc" id="afe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85"><div class="ttname"><a href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a></div><div class="ttdeci">@ update_JxW_values</div><div class="ttdoc">Transformed quadrature weights.</div><div class="ttdef"><b>Definition:</b> <a href="fe__update__flags_8h_source.html#l00129">fe_update_flags.h:129</a></div></div>
<div class="ttc" id="afe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20"><div class="ttname"><a href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a></div><div class="ttdeci">@ update_gradients</div><div class="ttdoc">Shape function gradients.</div><div class="ttdef"><b>Definition:</b> <a href="fe__update__flags_8h_source.html#l00084">fe_update_flags.h:84</a></div></div>
</div><!-- fragment --><p>现在来看看线性系统类中实现动作的函数。首先，构造函数将所有数据元素初始化为正确的大小，并设置了一些额外的数据结构，例如由于悬挂节点而产生的约束。由于设置悬空节点和找出矩阵的非零元素是独立的，所以我们以并行方式进行（如果库被配置为使用并发，至少是这样；否则，这些动作是按顺序执行的）。注意，我们只启动一个线程，并在主线程中做第二个动作。由于只生成了一个线程，我们在这里不使用 <code><a class="el" href="classThreads_1_1ThreadGroup.html">Threads::ThreadGroup</a></code> 类，而是直接使用创建的一个线程对象来等待这个特定线程的退出。 <br  />
</p>
<p>注意，占用 <code><a class="el" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a></code> 函数的地址有点麻烦，因为实际上有三个，每个支持的空间维度都有一个。在C++中，获取重载函数的地址有些复杂，因为在这种情况下，操作符 <code>&amp;</code> 返回的更像是一组值（所有具有该名称的函数的地址），然后选择合适的函数是下一步。如果上下文决定采取哪一个（例如通过分配给一个已知类型的函数指针），那么编译器可以自己做，但如果这组指针应作为一个采取模板的函数的参数，编译器可以选择所有的，而不偏向于一个。因此，我们必须向编译器说明我们想要哪一个；为此，我们可以使用cast，但为了更清楚，我们把它分配给一个具有正确类型的临时 <code>mhnc_p</code> （简称<code>pointer to make_hanging_node_constraints</code>），并使用这个指针代替。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">Solver&lt;dim&gt;::LinearSystem::LinearSystem(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler)</div>
<div class="line">{</div>
<div class="line">  hanging_node_constraints.clear();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  void (*mhnc_p)(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;, <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> &amp;) =</div>
<div class="line">    &amp;<a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>;</div>
<div class="ttc" id="agroup__constraints_html_ga3b4ea7dfd313e388d868c4e4aa685799"><div class="ttname"><a href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a></div><div class="ttdeci">void make_hanging_node_constraints(const DoFHandler&lt; dim, spacedim &gt; &amp;dof_handler, AffineConstraints&lt; number &gt; &amp;constraints)</div><div class="ttdef"><b>Definition:</b> <a href="dof__tools__constraints_8cc_source.html#l01787">dof_tools_constraints.cc:1787</a></div></div>
</div><!-- fragment --><p>启动一个辅助任务，然后在主线程上继续进行</p>
<div class="fragment"><div class="line"><a class="code" href="classThreads_1_1Task.html">Threads::Task&lt;void&gt;</a> side_task =</div>
<div class="line">  <a class="code" href="group__threads.html#ga8c1e15b84e1bb58a8029fc6d6ddf3cbf">Threads::new_task</a>(mhnc_p, dof_handler, hanging_node_constraints);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div>
<div class="line"><a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div>
<div class="ttc" id="aclassDynamicSparsityPattern_html"><div class="ttname"><a href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a></div><div class="ttdef"><b>Definition:</b> <a href="dynamic__sparsity__pattern_8h_source.html#l00318">dynamic_sparsity_pattern.h:319</a></div></div>
<div class="ttc" id="agroup__constraints_html_gaf78e864edbfba7e0a7477457bfb96b26"><div class="ttname"><a href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a></div><div class="ttdeci">void make_sparsity_pattern(const DoFHandler&lt; dim, spacedim &gt; &amp;dof_handler, SparsityPatternType &amp;sparsity_pattern, const AffineConstraints&lt; number &gt; &amp;constraints=AffineConstraints&lt; number &gt;(), const bool keep_constrained_dofs=true, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id)</div><div class="ttdef"><b>Definition:</b> <a href="dof__tools__sparsity_8cc_source.html#l00064">dof_tools_sparsity.cc:64</a></div></div>
</div><!-- fragment --><p>等到边上的任务完成后再继续前进</p>
<div class="fragment"><div class="line">side_task.<a class="code" href="classThreads_1_1Task.html#a9aed8f99d2b88bd0d6cfff95e38c3ac7">join</a>();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">hanging_node_constraints.close();</div>
<div class="line">hanging_node_constraints.condense(dsp);</div>
<div class="line">sparsity_pattern.copy_from(dsp);</div>
</div><!-- fragment --><p>最后初始化矩阵和右手边的向量</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>.reinit(sparsity_pattern);</div>
<div class="line">  rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div>
<div class="line">}</div>
</div><!-- fragment --><p>该类的第二个函数只是通过预设条件的共轭梯度法来解决线性系统。这在以前已经有了广泛的讨论，所以我们不再赘述。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> Solver&lt;dim&gt;::LinearSystem::solve(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;solution)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12);</div>
<div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classPreconditionSSOR.html">PreconditionSSOR&lt;SparseMatrix&lt;double&gt;</a>&gt; preconditioner;</div>
<div class="line">  preconditioner.<a class="code" href="group__Preconditioners.html#ga7a3d66b17bb0ea1b16606e222474c2ea">initialize</a>(<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, 1.2);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  cg.solve(<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, solution, rhs, preconditioner);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  hanging_node_constraints.distribute(solution);</div>
<div class="line">}</div>
<div class="ttc" id="aclassPreconditionSSOR_html"><div class="ttname"><a href="classPreconditionSSOR.html">PreconditionSSOR</a></div><div class="ttdef"><b>Definition:</b> <a href="precondition_8h_source.html#l00650">precondition.h:651</a></div></div>
<div class="ttc" id="aclassSolverCG_html"><div class="ttname"><a href="classSolverCG.html">SolverCG</a></div><div class="ttdef"><b>Definition:</b> <a href="solver__cg_8h_source.html#l00095">solver_cg.h:96</a></div></div>
<div class="ttc" id="aclassSolverControl_html"><div class="ttname"><a href="classSolverControl.html">SolverControl</a></div><div class="ttdef"><b>Definition:</b> <a href="solver__control_8h_source.html#l00065">solver_control.h:66</a></div></div>
<div class="ttc" id="agroup__Preconditioners_html_ga7a3d66b17bb0ea1b16606e222474c2ea"><div class="ttname"><a href="group__Preconditioners.html#ga7a3d66b17bb0ea1b16606e222474c2ea">PreconditionSSOR::initialize</a></div><div class="ttdeci">void initialize(const MatrixType &amp;A, const typename BaseClass::AdditionalData &amp;parameters=typename BaseClass::AdditionalData())</div></div>
<div class="ttc" id="anamespacePhysics_1_1Elasticity_1_1Kinematics_html_a9587d5229555daa5b1fa1ba2f8a40adb"><div class="ttname"><a href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">Physics::Elasticity::Kinematics::e</a></div><div class="ttdeci">SymmetricTensor&lt; 2, dim, Number &gt; e(const Tensor&lt; 2, dim, Number &gt; &amp;F)</div></div>
</div><!-- fragment --><p><a class="anchor" id="Aprimalsolver"></a> </p><h4>A primal solver</h4>
<p>在上一节中，我们实现了一个拉普拉斯求解器的基类，它缺乏组装右手边向量的功能，然而，原因已经在那里解释过了。现在我们实现了一个相应的类，它可以在问题的右边以函数对象的形式给出的情况下做到这一点。 <br  />
</p>
<p>这个类的动作和你在以前的例子中已经看到的差不多，所以简单解释一下就够了：构造函数和底层类的数据一样（它把所有的信息传递给底层类），除了一个表示问题的右边的函数对象。这个对象的指针被存储起来（同样作为 <code><a class="el" href="classSmartPointer.html">SmartPointer</a></code> ，以确保只要这个类还在使用，函数对象就不会被删除）。 <br  />
</p>
<p>这个类的唯一功能部分是 <code>assemble_rhs</code> 方法，它的作用与它的名字一样。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>PrimalSolver : <span class="keyword">public</span> Solver&lt;dim&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  PrimalSolver(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>,</div>
<div class="line">               <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div>
<div class="line">               <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div>
<div class="line">               <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     rhs_function,</div>
<div class="line">               <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const Function&lt;dim&gt;</a>&gt; rhs_function;</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> assemble_rhs(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;rhs) <span class="keyword">const override</span>;</div>
<div class="line">};</div>
</div><!-- fragment --><p>这个类的构造函数基本上做了上面宣布的事情......</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">PrimalSolver&lt;dim&gt;::PrimalSolver(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>,</div>
<div class="line">                                <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div>
<div class="line">                                <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div>
<div class="line">                                <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     rhs_function,</div>
<div class="line">                                <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values)</div>
<div class="line">  : Base&lt;dim&gt;(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>)</div>
<div class="line">  , Solver&lt;dim&gt;(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, fe, quadrature, boundary_values)</div>
<div class="line">  , rhs_function(&amp;rhs_function)</div>
<div class="line">{}</div>
</div><!-- fragment --><p>...正如 <code>assemble_rhs</code> 函数那样。因为这在前面的几个例子程序中已经解释过了，所以我们就不多说了。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> PrimalSolver&lt;dim&gt;::assemble_rhs(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;rhs)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(*this-&gt;fe,</div>
<div class="line">                          *this-&gt;quadrature,</div>
<div class="line">                          <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div>
<div class="line">                            <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = this-&gt;fe-&gt;n_dofs_per_cell();</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = this-&gt;quadrature-&gt;size();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                       cell_rhs(dofs_per_cell);</div>
<div class="line">  std::vector&lt;double&gt;                  rhs_values(n_q_points);</div>
<div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : this-&gt;dof_handler.<a class="code" href="group__CPP11.html#gaace8c98aca00e7e48a619bb5e08084aa">active_cell_iterators</a>())</div>
<div class="line">    {</div>
<div class="line">      cell_rhs = 0;</div>
<div class="line">      fe_values.reinit(cell);</div>
<div class="line">      rhs_function-&gt;value_list(fe_values.get_quadrature_points(),</div>
<div class="line">                               rhs_values);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div>
<div class="line">          cell_rhs(i) += fe_values.shape_value(i, q_point) * </div>
<div class="line">                         rhs_values[q_point] *               </div>
<div class="line">                         fe_values.JxW(q_point);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div>
<div class="line">        rhs(local_dof_indices[i]) += cell_rhs(i);</div>
<div class="line">    };</div>
<div class="line">}</div>
<div class="ttc" id="afe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea"><div class="ttname"><a href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a></div><div class="ttdeci">@ update_values</div><div class="ttdoc">Shape function values.</div><div class="ttdef"><b>Definition:</b> <a href="fe__update__flags_8h_source.html#l00078">fe_update_flags.h:78</a></div></div>
<div class="ttc" id="afe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a"><div class="ttname"><a href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a></div><div class="ttdeci">@ update_quadrature_points</div><div class="ttdoc">Transformed quadrature points.</div><div class="ttdef"><b>Definition:</b> <a href="fe__update__flags_8h_source.html#l00122">fe_update_flags.h:122</a></div></div>
</div><!-- fragment --><p><a class="anchor" id="Globalrefinement"></a> </p><h4>Global refinement</h4>
<p>至此，除了 <code>refine_grid</code> 函数外，抽象基类的所有函数都已实现。现在我们将有两个类为 <code>PrimalSolver</code> 类实现这个函数，一个做全局细化，一个做局部细化的形式。 <br  />
</p>
<p>第一个做全局细化的类相当简单：它的主函数只是调用 <code>triangulation-&gt;refine_global (1);</code> ，它做所有的工作。 <br  />
</p>
<p>请注意，由于 <code>Base</code> 类的基类是虚拟的，我们必须声明一个构造函数来初始化直接的基类和抽象的虚拟类。 <br  />
</p>
<p>除了这个技术上的复杂性之外，这个类可能很简单，可以不做进一步的评论。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>RefinementGlobal : <span class="keyword">public</span> PrimalSolver&lt;dim&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  RefinementGlobal(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      coarse_grid,</div>
<div class="line">                   <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div>
<div class="line">                   <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div>
<div class="line">                   <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     rhs_function,</div>
<div class="line">                   <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> refine_grid() <span class="keyword">override</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">RefinementGlobal&lt;dim&gt;::RefinementGlobal(</div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      coarse_grid,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     rhs_function,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values)</div>
<div class="line">  : Base&lt;dim&gt;(coarse_grid)</div>
<div class="line">  , PrimalSolver&lt;dim&gt;(coarse_grid,</div>
<div class="line">                      fe,</div>
<div class="line">                      quadrature,</div>
<div class="line">                      rhs_function,</div>
<div class="line">                      boundary_values)</div>
<div class="line">{}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> RefinementGlobal&lt;dim&gt;::refine_grid()</div>
<div class="line">{</div>
<div class="line">  this-&gt;<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>-&gt;refine_global(1);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="LocalrefinementbytheKellyerrorindicator"></a></p><h4>Local refinement by the Kelly error indicator</h4>
<p>第二个实现细化策略的类使用了之前各种示例程序中使用的Kelly细化指标。因为这个指标已经在deal.II库中的一个类中实现了，所以这里没有什么可做的，只是调用计算指标的函数，然后用它来选择一些单元进行细化和粗化，并相应地细化网格。 <br  />
</p>
<p>同样，这应该是足够标准的，可以省略进一步的评论。</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keyword">class </span>RefinementKelly : <span class="keyword">public</span> PrimalSolver&lt;dim&gt;</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    RefinementKelly(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      coarse_grid,</div>
<div class="line">                    <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div>
<div class="line">                    <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div>
<div class="line">                    <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     rhs_function,</div>
<div class="line">                    <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> refine_grid() <span class="keyword">override</span>;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  RefinementKelly&lt;dim&gt;::RefinementKelly(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      coarse_grid,</div>
<div class="line">                                        <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div>
<div class="line">                                        <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div>
<div class="line">                                        <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;rhs_function,</div>
<div class="line">                                        <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;boundary_values)</div>
<div class="line">    : Base&lt;dim&gt;(coarse_grid)</div>
<div class="line">    , PrimalSolver&lt;dim&gt;(coarse_grid,</div>
<div class="line">                        fe,</div>
<div class="line">                        quadrature,</div>
<div class="line">                        rhs_function,</div>
<div class="line">                        boundary_values)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> RefinementKelly&lt;dim&gt;::refine_grid()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(</div>
<div class="line">      this-&gt;<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>-&gt;n_active_cells());</div>
<div class="line">    <a class="code" href="classKellyErrorEstimator.html#aa0917e696d4f8ddb983223a68c512357">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div>
<div class="line">      this-&gt;dof_handler,</div>
<div class="line">      <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(this-&gt;fe-&gt;degree + 1),</div>
<div class="line">      std::map&lt;<a class="code" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div>
<div class="line">      this-&gt;solution,</div>
<div class="line">      estimated_error_per_cell);</div>
<div class="line">    <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(*this-&gt;<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>,</div>
<div class="line">                                                    estimated_error_per_cell,</div>
<div class="line">                                                    0.3,</div>
<div class="line">                                                    0.03);</div>
<div class="line">    this-&gt;<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>-&gt;execute_coarsening_and_refinement();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace LaplaceSolver</span></div>
<div class="ttc" id="aclassKellyErrorEstimator_html_aa0917e696d4f8ddb983223a68c512357"><div class="ttname"><a href="classKellyErrorEstimator.html#aa0917e696d4f8ddb983223a68c512357">KellyErrorEstimator::estimate</a></div><div class="ttdeci">static void estimate(const Mapping&lt; dim, spacedim &gt; &amp;mapping, const DoFHandler&lt; dim, spacedim &gt; &amp;dof, const Quadrature&lt; dim - 1 &gt; &amp;quadrature, const std::map&lt; types::boundary_id, const Function&lt; spacedim, typename InputVector::value_type &gt; * &gt; &amp;neumann_bc, const InputVector &amp;solution, Vector&lt; float &gt; &amp;error, const ComponentMask &amp;component_mask=ComponentMask(), const Function&lt; spacedim &gt; *coefficients=nullptr, const unsigned int n_threads=numbers::invalid_unsigned_int, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id, const types::material_id material_id=numbers::invalid_material_id, const Strategy strategy=cell_diameter_over_24)</div></div>
<div class="ttc" id="aclassQGauss_html"><div class="ttname"><a href="classQGauss.html">QGauss</a></div><div class="ttdef"><b>Definition:</b> <a href="quadrature__lib_8h_source.html#l00038">quadrature_lib.h:39</a></div></div>
<div class="ttc" id="anamespaceGridRefinement_html_a48e5395381ed87155942a61a1edd134d"><div class="ttname"><a href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a></div><div class="ttdeci">void refine_and_coarsen_fixed_number(Triangulation&lt; dim, spacedim &gt; &amp;triangulation, const Vector&lt; Number &gt; &amp;criteria, const double top_fraction_of_cells, const double bottom_fraction_of_cells, const unsigned int max_n_cells=std::numeric_limits&lt; unsigned int &gt;::max())</div><div class="ttdef"><b>Definition:</b> <a href="grid_2grid__refinement_8cc_source.html#l00322">grid_refinement.cc:322</a></div></div>
<div class="ttc" id="anamespacetypes_html_aed8813fee8c8a2edcc6005e6a48c321a"><div class="ttname"><a href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a></div><div class="ttdeci">unsigned int boundary_id</div><div class="ttdef"><b>Definition:</b> <a href="types_8h_source.html#l00129">types.h:129</a></div></div>
</div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>由于这又是一个学术性的例子，我们想把精确解和计算解相互比较。为此，我们需要声明代表精确解的函数类（用于比较和Dirichlet边界值），以及一个表示方程右边的类（这只是应用于我们想要恢复的精确解的拉普拉斯算子）。 <br  />
</p>
<p>对于这个例子，让我们选择函数 \(u(x,y)=exp(x+sin(10y+5x^2))\) 作为精确解。在超过两个维度的情况下，只需用 <code>y</code> replaced by <code>z</code> 重复正弦系数，以此类推。鉴于此，以下两类可能是直接从以前的例子中得出的。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>Solution : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div>
<div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component) <span class="keyword">const override</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">double</span> Solution&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div>
<div class="line">                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  (void)component;</div>
<div class="line">  <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(component, 1);</div>
<div class="line">  <span class="keywordtype">double</span> q = p(0);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; dim; ++i)</div>
<div class="line">    q += std::sin(10 * p(i) + 5 * p(0) * p(0));</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> exponential = <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">std::exp</a>(q);</div>
<div class="line">  <span class="keywordflow">return</span> exponential;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div>
<div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component) <span class="keyword">const override</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div>
<div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  (void)component;</div>
<div class="line">  <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(component, 1);</div>
<div class="line">  <span class="keywordtype">double</span> q = p(0);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; dim; ++i)</div>
<div class="line">    q += std::sin(10 * p(i) + 5 * p(0) * p(0));</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> u  = <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">std::exp</a>(q);</div>
<div class="line">  <span class="keywordtype">double</span>       t1 = 1, t2 = 0, t3 = 0;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; dim; ++i)</div>
<div class="line">    {</div>
<div class="line">      t1 += <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">std::cos</a>(10 * p(i) + 5 * p(0) * p(0)) * 10 * p(0);</div>
<div class="line">      t2 += 10 * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">std::cos</a>(10 * p(i) + 5 * p(0) * p(0)) -</div>
<div class="line">            100 * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">std::sin</a>(10 * p(i) + 5 * p(0) * p(0)) * p(0) * p(0);</div>
<div class="line">      t3 += 100 * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">std::cos</a>(10 * p(i) + 5 * p(0) * p(0)) *</div>
<div class="line">              <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">std::cos</a>(10 * p(i) + 5 * p(0) * p(0)) -</div>
<div class="line">            100 * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">std::sin</a>(10 * p(i) + 5 * p(0) * p(0));</div>
<div class="line">    };</div>
<div class="line">  t1 = t1 * t1;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> -u * (t1 + t2 + t3);</div>
<div class="line">}</div>
<div class="ttc" id="aclassFunction_html_acbfcab66b2fc63bfea59268f40772bb4"><div class="ttname"><a href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">Function::value</a></div><div class="ttdeci">virtual RangeNumberType value(const Point&lt; dim &gt; &amp;p, const unsigned int component=0) const</div></div>
<div class="ttc" id="agroup__Exceptions_html_gaafbb69cc2a791ae55880fd8d57d0c1b0"><div class="ttname"><a href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a></div><div class="ttdeci">#define AssertIndexRange(index, range)</div><div class="ttdef"><b>Definition:</b> <a href="include_2deal_8II_2base_2exceptions_8h_source.html#l01698">exceptions.h:1698</a></div></div>
<div class="ttc" id="anumbers_8h_html_a02761f62f66f685e954daed42bcb3a1b"><div class="ttname"><a href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">std::cos</a></div><div class="ttdeci">::VectorizedArray&lt; Number, width &gt; cos(const ::VectorizedArray&lt; Number, width &gt; &amp;)</div><div class="ttdef"><b>Definition:</b> <a href="vectorization_8h_source.html#l05318">vectorization.h:5318</a></div></div>
<div class="ttc" id="anumbers_8h_html_a27989bdc7b4b828564982787d126bd91"><div class="ttname"><a href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">std::sin</a></div><div class="ttdeci">::VectorizedArray&lt; Number, width &gt; sin(const ::VectorizedArray&lt; Number, width &gt; &amp;)</div><div class="ttdef"><b>Definition:</b> <a href="vectorization_8h_source.html#l05291">vectorization.h:5291</a></div></div>
<div class="ttc" id="anumbers_8h_html_a372e01cd9d1d07fdf136f4f40975d5cf"><div class="ttname"><a href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">std::exp</a></div><div class="ttdeci">::VectorizedArray&lt; Number, width &gt; exp(const ::VectorizedArray&lt; Number, width &gt; &amp;)</div><div class="ttdef"><b>Definition:</b> <a href="vectorization_8h_source.html#l05362">vectorization.h:5362</a></div></div>
</div><!-- fragment --><p><a class="anchor" id="Thedriverroutines"></a> </p><h3>The driver routines</h3>
<p>现在缺少的只是实际选择各种选项的函数，并在连续的更细的网格上运行模拟，以监测网格细化的进展。 <br  />
</p>
<p>我们在下面的函数中做到了这一点：它接收一个求解器对象和一个后处理（评估）对象的列表，并在间歇性的网格细化中运行它们。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> run_simulation(</div>
<div class="line">  LaplaceSolver::Base&lt;dim&gt; &amp;                          solver,</div>
<div class="line">  <span class="keyword">const</span> std::list&lt;Evaluation::EvaluationBase&lt;dim&gt; *&gt; &amp;postprocessor_list)</div>
<div class="line">{</div>
</div><!-- fragment --><p>我们将给出一个我们目前正在计算的步骤的指示器，以便让用户知道一些事情仍在发生，并且程序没有处于无尽的循环中。这是该状态行的标题。</p>
<div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Refinement cycle: &quot;</span>;</div>
</div><!-- fragment --><p>然后启动一个循环，只有当自由度数大于20,000时才会结束（当然你可以改变这个限制，如果你需要更多&ndash;或者更少&ndash;你的程序的精度）。</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> step = 0; <span class="keyword">true</span>; ++step)</div>
<div class="line">  {</div>
</div><!-- fragment --><p>然后给出本次迭代的 <code>alive</code> 指示。注意， <code>std::flush</code> 是需要的，以使文本真正出现在屏幕上，而不是只出现在某个缓冲区，而这个缓冲区只有在我们下一次发出端线时才会被刷新。</p>
<div class="fragment"><div class="line">std::cout &lt;&lt; step &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; std::flush;</div>
</div><!-- fragment --><p>现在在现在的网格上解决问题，并在其上运行评估器。迭代器进入列表的长类型名称有点烦人，但如果需要的话，可以用别名来缩短。</p>
<div class="fragment"><div class="line">solver.solve_problem();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;postprocessor : postprocessor_list)</div>
<div class="line">  {</div>
<div class="line">    postprocessor-&gt;set_refinement_cycle(step);</div>
<div class="line">    solver.postprocess(*postprocessor);</div>
<div class="line">  };</div>
</div><!-- fragment --><p>现在检查是否需要更多的迭代，或者是否应结束循环。</p>
<div class="fragment"><div class="line">  <span class="keywordflow">if</span> (solver.n_dofs() &lt; 20000)</div>
<div class="line">    solver.refine_grid();</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">};</div>
</div><!-- fragment --><p>最后结束我们显示状态报告的那一行。</p>
<div class="fragment"><div class="line">  std::cout &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p>最后一个函数是接受一个求解器的名字（目前允许使用 "kelly "和 "global"），用一个粗网格（这里是无处不在的单位方格）和一个有限元对象（这里也是无处不在的双线性对象）创建一个求解器对象，并使用该求解器来要求在一连串的细化网格上解决问题。 <br  />
</p>
<p>该函数还设置了两个评估函数，一个在点（0.5,0.5）处评估解，另一个将解写入文件。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> solve_problem(<span class="keyword">const</span> std::string &amp;solver_name)</div>
<div class="line">{</div>
</div><!-- fragment --><p>第一个小任务：告诉用户将发生什么。因此，写一个标题行，并在下面写上与第一个标题行相同长度的所有'-'字符的行。</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::string header =</div>
<div class="line">  <span class="stringliteral">&quot;Running tests with \&quot;&quot;</span> + solver_name + <span class="stringliteral">&quot;\&quot; refinement criterion:&quot;</span>;</div>
<div class="line">std::cout &lt;&lt; header &lt;&lt; std::endl</div>
<div class="line">          &lt;&lt; std::string(header.size(), <span class="charliteral">&#39;-&#39;</span>) &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>然后设置三角测量、有限元等。</p>
<div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div>
<div class="line"><a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, -1, 1);</div>
<div class="line"><a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.refine_global(2);</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>    fe(1);</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature(4);</div>
<div class="line">RightHandSide&lt;dim&gt; rhs_function;</div>
<div class="line">Solution&lt;dim&gt;      boundary_values;</div>
<div class="ttc" id="aclassFE__Q_html"><div class="ttname"><a href="classFE__Q.html">FE_Q</a></div><div class="ttdef"><b>Definition:</b> <a href="fe__q_8h_source.html#l00548">fe_q.h:549</a></div></div>
<div class="ttc" id="anamespaceGridGenerator_html_acea0cbcd68e52ce8113d1134b87de403"><div class="ttname"><a href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a></div><div class="ttdeci">void hyper_cube(Triangulation&lt; dim, spacedim &gt; &amp;tria, const double left=0., const double right=1., const bool colorize=false)</div></div>
</div><!-- fragment --><p>创建一个由该函数参数指示的解算器对象。如果该名称不被识别，则抛出一个异常! 各自的求解器对象被存储在一个 <code>std::unique_ptr</code> 中，以避免使用后不得不删除指针。</p>
<div class="fragment"><div class="line">std::unique_ptr&lt;LaplaceSolver::Base&lt;dim&gt;&gt; solver;</div>
<div class="line"><span class="keywordflow">if</span> (solver_name == <span class="stringliteral">&quot;global&quot;</span>)</div>
<div class="line">  solver = std::make_unique&lt;LaplaceSolver::RefinementGlobal&lt;dim&gt;&gt;(</div>
<div class="line">    <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, fe, quadrature, rhs_function, boundary_values);</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (solver_name == <span class="stringliteral">&quot;kelly&quot;</span>)</div>
<div class="line">  solver = std::make_unique&lt;LaplaceSolver::RefinementKelly&lt;dim&gt;&gt;(</div>
<div class="line">    <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, fe, quadrature, rhs_function, boundary_values);</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div>
<div class="ttc" id="agroup__Exceptions_html_ga7b52b286796c23ef9ff178faf7a4b68f"><div class="ttname"><a href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">StandardExceptions::ExcNotImplemented</a></div><div class="ttdeci">static ::ExceptionBase &amp; ExcNotImplemented()</div></div>
</div><!-- fragment --><p>接下来创建一个表对象，其中将存储点（0.5,0.5）处的数值解的值，并创建各自的评估对象。</p>
<div class="fragment"><div class="line"><a class="code" href="classTableHandler.html">TableHandler</a>                          results_table;</div>
<div class="line">Evaluation::PointValueEvaluation&lt;dim&gt; postprocessor1(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.5),</div>
<div class="line">                                                     results_table);</div>
</div><!-- fragment --><p>同时生成一个评估器，将解写出来。</p>
<div class="fragment"><div class="line">Evaluation::SolutionOutput&lt;dim&gt; postprocessor2(std::string(<span class="stringliteral">&quot;solution-&quot;</span>) +</div>
<div class="line">                                                 solver_name,</div>
<div class="line">                                               <a class="code" href="group__Exceptions.html#gaa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">DataOutBase::gnuplot</a>);</div>
<div class="ttc" id="agroup__Exceptions_html_gaa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1"><div class="ttname"><a href="group__Exceptions.html#gaa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">DataOutBase::gnuplot</a></div><div class="ttdeci">@ gnuplot</div><div class="ttdef"><b>Definition:</b> <a href="data__out__base_8h_source.html#l01570">data_out_base.h:1570</a></div></div>
</div><!-- fragment --><p>把这两个评价对象放在一个列表中...</p>
<div class="fragment"><div class="line">std::list&lt;Evaluation::EvaluationBase&lt;dim&gt; *&gt; postprocessor_list;</div>
<div class="line">postprocessor_list.push_back(&amp;postprocessor1);</div>
<div class="line">postprocessor_list.push_back(&amp;postprocessor2);</div>
</div><!-- fragment --><p>...然后我们可以将其传递给在连续细化的网格上实际运行模拟的函数。</p>
<div class="fragment"><div class="line">run_simulation(*solver, postprocessor_list);</div>
</div><!-- fragment --><p>当这一切完成后，写出点评估的结果。</p>
<div class="fragment"><div class="line">results_table.<a class="code" href="classTableHandler.html#a45c4ec9981f3880c6c852ed3aceb08fe">write_text</a>(std::cout);</div>
<div class="ttc" id="aclassTableHandler_html_a45c4ec9981f3880c6c852ed3aceb08fe"><div class="ttname"><a href="classTableHandler.html#a45c4ec9981f3880c6c852ed3aceb08fe">TableHandler::write_text</a></div><div class="ttdeci">void write_text(std::ostream &amp;out, const TextOutputFormat format=table_with_headers) const</div><div class="ttdef"><b>Definition:</b> <a href="table__handler_8cc_source.html#l00384">table_handler.cc:384</a></div></div>
</div><!-- fragment --><p>在所有的结果之后还有一行空白。</p>
<div class="fragment"><div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">} <span class="comment">// namespace Step13</span></div>
</div><!-- fragment --><p>关于主函数没有什么可说的。它与之前所有的例子一样，试图捕捉被抛出的异常，并在我们得到一些信息时尽可能多地显示出来。其余的都是不言自明的。</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      Step13::solve_problem&lt;2&gt;(<span class="stringliteral">&quot;global&quot;</span>);</div>
<div class="line">      Step13::solve_problem&lt;2&gt;(<span class="stringliteral">&quot;kelly&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>这个程序的结果并不那么有趣&ndash;毕竟它的目的不是为了演示一些新的数学思想，也不是为了演示如何用deal.II编程，而是为了使用我们在前面的例子中开发的材料，形成一些演示以模块化和可扩展的方式建立现代有限元软件的方法。</p>
<p>然而，我们当然会展示程序的结果。最感兴趣的是点值计算，我们已经为它实现了相应的评估类。该程序的结果（即输出）看起来如下。</p>
<div class="fragment"><div class="line">Running tests with <span class="stringliteral">&quot;global&quot;</span> refinement criterion:</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">-------------------------------------------------</div>
<div class="line">Refinement cycle: 0 1 2 3 4 5 6</div>
<div class="line">DoFs  u(x_0)</div>
<div class="line">   25 1.2868</div>
<div class="line">   81 1.6945</div>
<div class="line">  289 1.4658</div>
<div class="line"> 1089 1.5679</div>
<div class="line"> 4225 1.5882</div>
<div class="line">16641 1.5932</div>
<div class="line">66049 1.5945</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">Running tests with <span class="stringliteral">&quot;kelly&quot;</span> refinement criterion:</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">------------------------------------------------</div>
<div class="line">Refinement cycle: 0 1 2 3 4 5 6 7 8 9 10 11</div>
<div class="line">DoFs  u(x_0)</div>
<div class="line">   25 1.2868</div>
<div class="line">   47 0.8775</div>
<div class="line">   89 1.5365</div>
<div class="line">  165 1.2974</div>
<div class="line">  316 1.6442</div>
<div class="line">  589 1.5221</div>
<div class="line"> 1093 1.5724</div>
<div class="line"> 2042 1.5627</div>
<div class="line"> 3766 1.5916</div>
<div class="line"> 7124 1.5876</div>
<div class="line">13111 1.5942</div>
<div class="line">24838 1.5932</div>
</div><!-- fragment --><p>这里令人惊讶的是，确切的数值是1.59491554......，而且计算该解显然出奇的复杂，甚至只有百分之一的精度，尽管该解是平滑的（实际上是无限常可微）。这种平滑性显示在程序生成的图形输出中，这里是粗略的网格和凯利细化指标的前9个细化步骤。</p>
<table width="80%" align="center">
<tr>
<td><img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-0.png" alt="" class="inline"/>  </td><td><img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-1.png" alt="" class="inline"/>   </td></tr>
<tr>
<td><img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-2.png" alt="" class="inline"/>  </td><td><img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-3.png" alt="" class="inline"/>   </td></tr>
<tr>
<td><img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-4.png" alt="" class="inline"/>  </td><td><img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-5.png" alt="" class="inline"/>   </td></tr>
<tr>
<td><img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-6.png" alt="" class="inline"/>  </td><td><img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-7.png" alt="" class="inline"/>   </td></tr>
<tr>
<td><img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-8.png" alt="" class="inline"/>  </td><td><img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-9.png" alt="" class="inline"/>   </td></tr>
</table>
<p><br  />
</p>
<p>当我们已经在观看图片时，这是第八个网格，从上面看。</p>
<p><img src="https://www.dealii.org/images/steps/developer/step-13.grid-kelly-8.png" alt="" class="inline"/> <br  />
</p>
<p>然而，我们还没有完成对点值计算的评估。事实上，将两个细化标准的误差 \(e=|u(x_0)-u_h(x_0)|\) 绘制出来，可以得到以下图片。</p>
<p><img src="https://www.dealii.org/images/steps/developer/step-13.error.png" alt="" class="inline"/> <br  />
</p>
<p>这幅图 <em> 令人不安的是，自适应网格细化不仅没有像人们通常期望的那样优于全局细化，甚至明显更差，因为它的收敛是不规则的，在使用后续网格的值时，阻止了所有的外推技术！另一方面，全局细化也是如此。另一方面，全局细化提供了一个完美的 \(1/N\) 或 \(h^{-2}\) 收敛历史，并提供了各种机会，甚至可以通过外推法来改善点值。因此，在这个例子中，全局网格细化必须被认为是优越的! 这更令人惊讶，因为评估点不是在左边的某个地方，那里的网格是粗糙的，而是在右边，自适应细化也应该细化评估点周围的网格。</em></p>
<p><em>因此，我们以一个问题来结束对这个例子程序的讨论。</em></p>
<p align="center"><em></em></p>
<p><em> <b> <em> 如果自适应不比全局细化好，那自适应有什么问题？ </em> </b></em></p>
<p><em> <em> 在这个例子的末尾进行练习。 </em> 有一个简单的原因导致适应性网格解决方案的不良和不规则行为。通过观察每个步骤中评估点周围的网格，可以很简单地找到这个原因&ndash;这个数据在程序的输出文件中。因此，一个练习是修改网格细化程序，使问题（一旦你注意到它）得以避免。第二个练习是检查结果是否比全局细化好，如果是的话，是否能达到更好的收敛顺序(以自由度数计)，或者只达到一个更好的常数。</em></p>
<p><em>( <em> 对于没有耐心的人来说，非常简短的答案。 </em> 在误差较大的步骤中，网格在评估点是不规则的，即一些相邻的单元有悬空的节点；这破坏了一些超级近似的效果，而全局细化的网格可以从中受益。答案2：这个快速黑客</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> refinement_indicated = <span class="keyword">false</span>;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.active_cell_iterators())</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> v : cell-&gt;vertex_indices())</div>
<div class="line">        <span class="keywordflow">if</span> (cell-&gt;vertex(v) == <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(.5,.5))</div>
<div class="line">          {</div>
<div class="line">            cell-&gt;clear_coarsen_flag();</div>
<div class="line">            refinement_indicated |= cell-&gt;refine_flag_set();</div>
<div class="line">          }</div>
<div class="line"><span class="keywordflow">if</span> (refinement_indicated)</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.active_cell_iterators())</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> v : cell-&gt;vertex_indices())</div>
<div class="line">          <span class="keywordflow">if</span> (cell-&gt;vertex(v) == <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(.5,.5))</div>
<div class="line">            cell-&gt;set_refine_flag ();</div>
</div><!-- fragment --><p></em></p>
<p><em>在执行细化之前，在Kelly细化类的细化函数中的这一快速黑客行为将改善结果（练习：代码是怎么做的），使其始终比全局细化好。但行为仍然是不规则的，所以不可能有关于收敛顺序的结果）。) <a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<p></em></p>
<p><em> </p><div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Copyright (C) 2001 - 2020 by the deal.II authors</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div>
<div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div>
<div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div>
<div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div>
<div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div>
<div class="line"><span class="comment"> * the top level directory of deal.II.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Author: Wolfgang Bangerth, University of Heidelberg, 2001, 2002</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="table__handler_8h.html">deal.II/base/table_handler.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="thread__management_8h.html">deal.II/base/thread_management.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="work__stream_8h.html">deal.II/base/work_stream.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>Step13</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">namespace </span>Evaluation</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keyword">class </span>EvaluationBase</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">      <span class="keyword">virtual</span> ~EvaluationBase() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">void</span> set_refinement_cycle(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle);</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div>
<div class="line">                              <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp; solution) <span class="keyword">const</span> = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">protected</span>:</div>
<div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> EvaluationBase&lt;dim&gt;::set_refinement_cycle(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> step)</div>
<div class="line">    {</div>
<div class="line">      refinement_cycle = step;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keyword">class </span>PointValueEvaluation : <span class="keyword">public</span> EvaluationBase&lt;dim&gt;</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">      PointValueEvaluation(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;evaluation_point,</div>
<div class="line">                           <a class="code" href="classTableHandler.html">TableHandler</a> &amp;    results_table);</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div>
<div class="line">                              <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp; solution) <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="group__Exceptions.html#gad107d8d5ae0baa7083cd2e932f9056dd">DeclException1</a>(</div>
<div class="line">        ExcEvaluationPointNotFound,</div>
<div class="line">        <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>,</div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;The evaluation point &quot;</span> &lt;&lt; arg1</div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot; was not found among the vertices of the present grid.&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> evaluation_point;</div>
<div class="line">      <a class="code" href="classTableHandler.html">TableHandler</a> &amp;   results_table;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    PointValueEvaluation&lt;dim&gt;::PointValueEvaluation(</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;evaluation_point,</div>
<div class="line">      <a class="code" href="classTableHandler.html">TableHandler</a> &amp;    results_table)</div>
<div class="line">      : evaluation_point(evaluation_point)</div>
<div class="line">      , results_table(results_table)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> PointValueEvaluation&lt;dim&gt;::</div>
<div class="line">         operator()(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div>
<div class="line">               <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp; solution)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <span class="keywordtype">double</span> <a class="code" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">point_value</a> = 1e20;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">bool</span> evaluation_point_found = <span class="keyword">false</span>;</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gaace8c98aca00e7e48a619bb5e08084aa">active_cell_iterators</a>())</div>
<div class="line">        <span class="keywordflow">if</span> (!evaluation_point_found)</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> vertex : cell-&gt;vertex_indices())</div>
<div class="line">            <span class="keywordflow">if</span> (cell-&gt;vertex(vertex) == evaluation_point)</div>
<div class="line">              {</div>
<div class="line">                <a class="code" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">point_value</a> = solution(cell-&gt;vertex_dof_index(vertex, 0));</div>
<div class="line"> </div>
<div class="line">                evaluation_point_found = <span class="keyword">true</span>;</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">              };</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(evaluation_point_found,</div>
<div class="line">                  ExcEvaluationPointNotFound(evaluation_point));</div>
<div class="line"> </div>
<div class="line">      results_table.add_value(<span class="stringliteral">&quot;DoFs&quot;</span>, dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div>
<div class="line">      results_table.add_value(<span class="stringliteral">&quot;u(x_0)&quot;</span>, <a class="code" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">point_value</a>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keyword">class </span>SolutionOutput : <span class="keyword">public</span> EvaluationBase&lt;dim&gt;</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">      SolutionOutput(<span class="keyword">const</span> std::string &amp;             output_name_base,</div>
<div class="line">                     <span class="keyword">const</span> <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> output_format);</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div>
<div class="line">                              <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp; solution) <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">      <span class="keyword">const</span> std::string               output_name_base;</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> output_format;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    SolutionOutput&lt;dim&gt;::SolutionOutput(</div>
<div class="line">      <span class="keyword">const</span> std::string &amp;             output_name_base,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> output_format)</div>
<div class="line">      : output_name_base(output_name_base)</div>
<div class="line">      , output_format(output_format)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> SolutionOutput&lt;dim&gt;::operator()(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div>
<div class="line">                                         <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp; solution)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div>
<div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a>(dof_handler);</div>
<div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div>
<div class="line">      data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a>();</div>
<div class="line"> </div>
<div class="line">      std::ofstream out(output_name_base + <span class="stringliteral">&quot;-&quot;</span> +</div>
<div class="line">                        <a class="code" href="group__Exceptions.html#ga72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(this-&gt;refinement_cycle) +</div>
<div class="line">                        data_out.<a class="code" href="group__Exceptions.html#ga36120ca3f536c90709e135161030f16c">default_suffix</a>(output_format));</div>
<div class="line"> </div>
<div class="line">      data_out.<a class="code" href="group__Exceptions.html#ga78e73ad285a8792ff0f9f227b82eb108">write</a>(out, output_format);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  } <span class="comment">// namespace Evaluation</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">namespace </span>LaplaceSolver</div>
<div class="line">  {</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keyword">class </span>Base</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">      Base(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;coarse_grid);</div>
<div class="line">      <span class="keyword">virtual</span> ~Base() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> solve_problem() = 0;</div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> postprocess(</div>
<div class="line">        <span class="keyword">const</span> Evaluation::EvaluationBase&lt;dim&gt; &amp;postprocessor) <span class="keyword">const</span> = 0;</div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span>         refine_grid()                            = 0;</div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs() <span class="keyword">const</span>                           = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">protected</span>:</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;Triangulation&lt;dim&gt;</a>&gt; <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    Base&lt;dim&gt;::Base(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;coarse_grid)</div>
<div class="line">      : <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>(&amp;coarse_grid)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keyword">class </span>Solver : <span class="keyword">public</span> <span class="keyword">virtual</span> Base&lt;dim&gt;</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">      Solver(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>,</div>
<div class="line">             <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div>
<div class="line">             <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div>
<div class="line">             <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values);</div>
<div class="line">      <span class="keyword">virtual</span> ~Solver() <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> solve_problem() <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> postprocess(</div>
<div class="line">        <span class="keyword">const</span> Evaluation::EvaluationBase&lt;dim&gt; &amp;postprocessor) <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs() <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">protected</span>:</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const FiniteElement&lt;dim&gt;</a>&gt; fe;</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const Quadrature&lt;dim&gt;</a>&gt;    quadrature;</div>
<div class="line">      <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>                              dof_handler;</div>
<div class="line">      <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                               solution;</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const Function&lt;dim&gt;</a>&gt;      boundary_values;</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> assemble_rhs(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;rhs) <span class="keyword">const</span> = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">      <span class="keyword">struct </span>LinearSystem</div>
<div class="line">      {</div>
<div class="line">        LinearSystem(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">void</span> solve(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;solution) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> hanging_node_constraints;</div>
<div class="line">        <a class="code" href="classSparsityPattern.html">SparsityPattern</a>           sparsity_pattern;</div>
<div class="line">        <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>      <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>;</div>
<div class="line">        <a class="code" href="classVector.html">Vector&lt;double&gt;</a>            rhs;</div>
<div class="line">      };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">      <span class="keyword">struct </span>AssemblyScratchData</div>
<div class="line">      {</div>
<div class="line">        AssemblyScratchData(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div>
<div class="line">                            <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature);</div>
<div class="line">        AssemblyScratchData(<span class="keyword">const</span> AssemblyScratchData &amp;scratch_data);</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values;</div>
<div class="line">      };</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">struct </span>AssemblyCopyData</div>
<div class="line">      {</div>
<div class="line">        <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div>
<div class="line">        std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div>
<div class="line">      };</div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">void</span> assemble_linear_system(LinearSystem &amp;linear_system);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">void</span> local_assemble_matrix(</div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__Iterators.html#ga6b8bbcafed8847f3030ea30c6990eb2d">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div>
<div class="line">        AssemblyScratchData &amp;                                 scratch_data,</div>
<div class="line">        AssemblyCopyData &amp;                                    copy_data) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">void</span> copy_local_to_global(<span class="keyword">const</span> AssemblyCopyData &amp;copy_data,</div>
<div class="line">                                LinearSystem &amp;          linear_system) <span class="keyword">const</span>;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    Solver&lt;dim&gt;::Solver(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>,</div>
<div class="line">                        <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div>
<div class="line">                        <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div>
<div class="line">                        <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values)</div>
<div class="line">      : Base&lt;dim&gt;(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>)</div>
<div class="line">      , fe(&amp;fe)</div>
<div class="line">      , quadrature(&amp;quadrature)</div>
<div class="line">      , dof_handler(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>)</div>
<div class="line">      , boundary_values(&amp;boundary_values)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    Solver&lt;dim&gt;::~Solver()</div>
<div class="line">    {</div>
<div class="line">      dof_handler.<a class="code" href="classDoFHandler.html#ad316958f8045d9a48094335b23a03a53">clear</a>();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> Solver&lt;dim&gt;::solve_problem()</div>
<div class="line">    {</div>
<div class="line">      dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(*fe);</div>
<div class="line">      solution.<a class="code" href="group__Vectors.html#gac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div>
<div class="line"> </div>
<div class="line">      LinearSystem linear_system(dof_handler);</div>
<div class="line">      assemble_linear_system(linear_system);</div>
<div class="line">      linear_system.solve(solution);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> Solver&lt;dim&gt;::postprocess(</div>
<div class="line">      <span class="keyword">const</span> Evaluation::EvaluationBase&lt;dim&gt; &amp;postprocessor)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      postprocessor(dof_handler, solution);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Solver&lt;dim&gt;::n_dofs()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <span class="keywordflow">return</span> dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> Solver&lt;dim&gt;::assemble_linear_system(LinearSystem &amp;linear_system)</div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="classThreads_1_1Task.html">Threads::Task&lt;void&gt;</a> rhs_task =</div>
<div class="line">        <a class="code" href="group__threads.html#ga8c1e15b84e1bb58a8029fc6d6ddf3cbf">Threads::new_task</a>(&amp;Solver&lt;dim&gt;::assemble_rhs, *<span class="keyword">this</span>, linear_system.rhs);</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">auto</span> worker =</div>
<div class="line">        [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__Iterators.html#ga6b8bbcafed8847f3030ea30c6990eb2d">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div>
<div class="line">               AssemblyScratchData &amp;scratch_data,</div>
<div class="line">               AssemblyCopyData &amp;   copy_data) {</div>
<div class="line">          this-&gt;local_assemble_matrix(cell, scratch_data, copy_data);</div>
<div class="line">        };</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">auto</span> copier = [<span class="keyword">this</span>, &amp;linear_system](<span class="keyword">const</span> AssemblyCopyData &amp;copy_data) {</div>
<div class="line">        this-&gt;copy_local_to_global(copy_data, linear_system);</div>
<div class="line">      };</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>(dof_handler.<a class="code" href="classDoFHandler.html#a9a3bef554c6d22abe312e10e9475eecf">begin_active</a>(),</div>
<div class="line">                      dof_handler.<a class="code" href="classDoFHandler.html#a042c4bf0f59fef5e72dbcfbdd56b2782">end</a>(),</div>
<div class="line">                      worker,</div>
<div class="line">                      copier,</div>
<div class="line">                      AssemblyScratchData(*fe, *quadrature),</div>
<div class="line">                      AssemblyCopyData());</div>
<div class="line">      linear_system.hanging_node_constraints.condense(linear_system.matrix);</div>
<div class="line"> </div>
<div class="line">      std::map&lt;types::global_dof_index, double&gt; boundary_value_map;</div>
<div class="line">      <a class="code" href="namespaceVectorTools.html#ab2562d41bb26f362043f9719a8cd9b87">VectorTools::interpolate_boundary_values</a>(dof_handler,</div>
<div class="line">                                               0,</div>
<div class="line">                                               *boundary_values,</div>
<div class="line">                                               boundary_value_map);</div>
<div class="line"> </div>
<div class="line">      rhs_task.<a class="code" href="classThreads_1_1Task.html#a9aed8f99d2b88bd0d6cfff95e38c3ac7">join</a>();</div>
<div class="line">      linear_system.hanging_node_constraints.condense(linear_system.rhs);</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_value_map,</div>
<div class="line">                                         linear_system.matrix,</div>
<div class="line">                                         solution,</div>
<div class="line">                                         linear_system.rhs);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    Solver&lt;dim&gt;::AssemblyScratchData::AssemblyScratchData(</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature)</div>
<div class="line">      : fe_values(fe, quadrature, <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    Solver&lt;dim&gt;::AssemblyScratchData::AssemblyScratchData(</div>
<div class="line">      <span class="keyword">const</span> AssemblyScratchData &amp;scratch_data)</div>
<div class="line">      : fe_values(scratch_data.fe_values.get_fe(),</div>
<div class="line">                  scratch_data.fe_values.get_quadrature(),</div>
<div class="line">                  <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> Solver&lt;dim&gt;::local_assemble_matrix(</div>
<div class="line">      <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__Iterators.html#ga6b8bbcafed8847f3030ea30c6990eb2d">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div>
<div class="line">      AssemblyScratchData &amp;                                 scratch_data,</div>
<div class="line">      AssemblyCopyData &amp;                                    copy_data)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe-&gt;n_dofs_per_cell();</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature-&gt;size();</div>
<div class="line"> </div>
<div class="line">      copy_data.cell_matrix.reinit(dofs_per_cell, dofs_per_cell);</div>
<div class="line"> </div>
<div class="line">      copy_data.local_dof_indices.resize(dofs_per_cell);</div>
<div class="line"> </div>
<div class="line">      scratch_data.fe_values.reinit(cell);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div>
<div class="line">            copy_data.cell_matrix(i, j) +=</div>
<div class="line">              (scratch_data.fe_values.shape_grad(i, q_point) *</div>
<div class="line">               scratch_data.fe_values.shape_grad(j, q_point) *</div>
<div class="line">               scratch_data.fe_values.JxW(q_point));</div>
<div class="line"> </div>
<div class="line">      cell-&gt;get_dof_indices(copy_data.local_dof_indices);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> Solver&lt;dim&gt;::copy_local_to_global(<span class="keyword">const</span> AssemblyCopyData &amp;copy_data,</div>
<div class="line">                                           LinearSystem &amp;linear_system)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; copy_data.local_dof_indices.size(); ++i)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; copy_data.local_dof_indices.size(); ++j)</div>
<div class="line">          linear_system.matrix.add(copy_data.local_dof_indices[i],</div>
<div class="line">                                   copy_data.local_dof_indices[j],</div>
<div class="line">                                   copy_data.cell_matrix(i, j));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    Solver&lt;dim&gt;::LinearSystem::LinearSystem(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler)</div>
<div class="line">    {</div>
<div class="line">      hanging_node_constraints.<a class="code" href="classDoFHandler.html#ad316958f8045d9a48094335b23a03a53">clear</a>();</div>
<div class="line"> </div>
<div class="line">      void (*mhnc_p)(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;, <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> &amp;) =</div>
<div class="line">        &amp;<a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>;</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classThreads_1_1Task.html">Threads::Task&lt;void&gt;</a> side_task =</div>
<div class="line">        <a class="code" href="group__threads.html#ga8c1e15b84e1bb58a8029fc6d6ddf3cbf">Threads::new_task</a>(mhnc_p, dof_handler, hanging_node_constraints);</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div>
<div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">      side_task.<a class="code" href="classThreads_1_1Task.html#a9aed8f99d2b88bd0d6cfff95e38c3ac7">join</a>();</div>
<div class="line"> </div>
<div class="line">      hanging_node_constraints.close();</div>
<div class="line">      hanging_node_constraints.condense(dsp);</div>
<div class="line">      sparsity_pattern.copy_from(dsp);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">      <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>.reinit(sparsity_pattern);</div>
<div class="line">      rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> Solver&lt;dim&gt;::LinearSystem::solve(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;solution)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12);</div>
<div class="line">      <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classPreconditionSSOR.html">PreconditionSSOR&lt;SparseMatrix&lt;double&gt;</a>&gt; preconditioner;</div>
<div class="line">      preconditioner.<a class="code" href="group__Preconditioners.html#ga7a3d66b17bb0ea1b16606e222474c2ea">initialize</a>(<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, 1.2);</div>
<div class="line"> </div>
<div class="line">      cg.solve(<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, solution, rhs, preconditioner);</div>
<div class="line"> </div>
<div class="line">      hanging_node_constraints.distribute(solution);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keyword">class </span>PrimalSolver : <span class="keyword">public</span> Solver&lt;dim&gt;</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">      PrimalSolver(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>,</div>
<div class="line">                   <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div>
<div class="line">                   <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div>
<div class="line">                   <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     rhs_function,</div>
<div class="line">                   <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">protected</span>:</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const Function&lt;dim&gt;</a>&gt; rhs_function;</div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> assemble_rhs(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;rhs) <span class="keyword">const override</span>;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    PrimalSolver&lt;dim&gt;::PrimalSolver(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>,</div>
<div class="line">                                    <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div>
<div class="line">                                    <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div>
<div class="line">                                    <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     rhs_function,</div>
<div class="line">                                    <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values)</div>
<div class="line">      : Base&lt;dim&gt;(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>)</div>
<div class="line">      , Solver&lt;dim&gt;(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, fe, quadrature, boundary_values)</div>
<div class="line">      , rhs_function(&amp;rhs_function)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> PrimalSolver&lt;dim&gt;::assemble_rhs(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;rhs)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(*this-&gt;fe,</div>
<div class="line">                              *this-&gt;quadrature,</div>
<div class="line">                              <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div>
<div class="line">                                <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = this-&gt;fe-&gt;n_dofs_per_cell();</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = this-&gt;quadrature-&gt;size();</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                       cell_rhs(dofs_per_cell);</div>
<div class="line">      std::vector&lt;double&gt;                  rhs_values(n_q_points);</div>
<div class="line">      std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : this-&gt;dof_handler.<a class="code" href="group__CPP11.html#gaace8c98aca00e7e48a619bb5e08084aa">active_cell_iterators</a>())</div>
<div class="line">        {</div>
<div class="line">          cell_rhs = 0;</div>
<div class="line">          fe_values.reinit(cell);</div>
<div class="line">          rhs_function-&gt;value_list(fe_values.get_quadrature_points(),</div>
<div class="line">                                   rhs_values);</div>
<div class="line"> </div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div>
<div class="line">              cell_rhs(i) += fe_values.shape_value(i, q_point) * </div>
<div class="line">                             rhs_values[q_point] *               </div>
<div class="line">                             fe_values.JxW(q_point);</div>
<div class="line"> </div>
<div class="line">          cell-&gt;get_dof_indices(local_dof_indices);</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div>
<div class="line">            rhs(local_dof_indices[i]) += cell_rhs(i);</div>
<div class="line">        };</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keyword">class </span>RefinementGlobal : <span class="keyword">public</span> PrimalSolver&lt;dim&gt;</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">      RefinementGlobal(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      coarse_grid,</div>
<div class="line">                       <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div>
<div class="line">                       <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div>
<div class="line">                       <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     rhs_function,</div>
<div class="line">                       <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values);</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> refine_grid() <span class="keyword">override</span>;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    RefinementGlobal&lt;dim&gt;::RefinementGlobal(</div>
<div class="line">      <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      coarse_grid,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     rhs_function,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values)</div>
<div class="line">      : Base&lt;dim&gt;(coarse_grid)</div>
<div class="line">      , PrimalSolver&lt;dim&gt;(coarse_grid,</div>
<div class="line">                          fe,</div>
<div class="line">                          quadrature,</div>
<div class="line">                          rhs_function,</div>
<div class="line">                          boundary_values)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> RefinementGlobal&lt;dim&gt;::refine_grid()</div>
<div class="line">    {</div>
<div class="line">      this-&gt;<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>-&gt;refine_global(1);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keyword">class </span>RefinementKelly : <span class="keyword">public</span> PrimalSolver&lt;dim&gt;</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">      RefinementKelly(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      coarse_grid,</div>
<div class="line">                      <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div>
<div class="line">                      <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div>
<div class="line">                      <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     rhs_function,</div>
<div class="line">                      <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values);</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> refine_grid() <span class="keyword">override</span>;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    RefinementKelly&lt;dim&gt;::RefinementKelly(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      coarse_grid,</div>
<div class="line">                                          <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div>
<div class="line">                                          <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div>
<div class="line">                                          <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;rhs_function,</div>
<div class="line">                                          <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;boundary_values)</div>
<div class="line">      : Base&lt;dim&gt;(coarse_grid)</div>
<div class="line">      , PrimalSolver&lt;dim&gt;(coarse_grid,</div>
<div class="line">                          fe,</div>
<div class="line">                          quadrature,</div>
<div class="line">                          rhs_function,</div>
<div class="line">                          boundary_values)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keywordtype">void</span> RefinementKelly&lt;dim&gt;::refine_grid()</div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(</div>
<div class="line">        this-&gt;<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>-&gt;n_active_cells());</div>
<div class="line">      <a class="code" href="classKellyErrorEstimator.html#aa0917e696d4f8ddb983223a68c512357">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div>
<div class="line">        this-&gt;dof_handler,</div>
<div class="line">        <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(this-&gt;fe-&gt;degree + 1),</div>
<div class="line">        std::map&lt;<a class="code" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div>
<div class="line">        this-&gt;solution,</div>
<div class="line">        estimated_error_per_cell);</div>
<div class="line">      <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(*this-&gt;<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>,</div>
<div class="line">                                                      estimated_error_per_cell,</div>
<div class="line">                                                      0.3,</div>
<div class="line">                                                      0.03);</div>
<div class="line">      this-&gt;<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>-&gt;execute_coarsening_and_refinement();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  } <span class="comment">// namespace LaplaceSolver</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keyword">class </span>Solution : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div>
<div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component) <span class="keyword">const override</span>;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">double</span> Solution&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div>
<div class="line">                              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    (void)component;</div>
<div class="line">    <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(component, 1);</div>
<div class="line">    <span class="keywordtype">double</span> q = p(0);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; dim; ++i)</div>
<div class="line">      q += std::sin(10 * p(i) + 5 * p(0) * p(0));</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> exponential = <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">std::exp</a>(q);</div>
<div class="line">    <span class="keywordflow">return</span> exponential;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div>
<div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component) <span class="keyword">const override</span>;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div>
<div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    (void)component;</div>
<div class="line">    <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(component, 1);</div>
<div class="line">    <span class="keywordtype">double</span> q = p(0);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; dim; ++i)</div>
<div class="line">      q += std::sin(10 * p(i) + 5 * p(0) * p(0));</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> u  = <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">std::exp</a>(q);</div>
<div class="line">    <span class="keywordtype">double</span>       t1 = 1, t2 = 0, t3 = 0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; dim; ++i)</div>
<div class="line">      {</div>
<div class="line">        t1 += <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">std::cos</a>(10 * p(i) + 5 * p(0) * p(0)) * 10 * p(0);</div>
<div class="line">        t2 += 10 * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">std::cos</a>(10 * p(i) + 5 * p(0) * p(0)) -</div>
<div class="line">              100 * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">std::sin</a>(10 * p(i) + 5 * p(0) * p(0)) * p(0) * p(0);</div>
<div class="line">        t3 += 100 * <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">std::cos</a>(10 * p(i) + 5 * p(0) * p(0)) *</div>
<div class="line">                <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">std::cos</a>(10 * p(i) + 5 * p(0) * p(0)) -</div>
<div class="line">              100 * <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">std::sin</a>(10 * p(i) + 5 * p(0) * p(0));</div>
<div class="line">      };</div>
<div class="line">    t1 = t1 * t1;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> -u * (t1 + t2 + t3);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> run_simulation(</div>
<div class="line">    LaplaceSolver::Base&lt;dim&gt; &amp;                          solver,</div>
<div class="line">    <span class="keyword">const</span> std::list&lt;Evaluation::EvaluationBase&lt;dim&gt; *&gt; &amp;postprocessor_list)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Refinement cycle: &quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> step = 0; <span class="keyword">true</span>; ++step)</div>
<div class="line">      {</div>
<div class="line">        std::cout &lt;&lt; step &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; std::flush;</div>
<div class="line"> </div>
<div class="line">        solver.solve_problem();</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;postprocessor : postprocessor_list)</div>
<div class="line">          {</div>
<div class="line">            postprocessor-&gt;set_refinement_cycle(step);</div>
<div class="line">            solver.postprocess(*postprocessor);</div>
<div class="line">          };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (solver.n_dofs() &lt; 20000)</div>
<div class="line">          solver.refine_grid();</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">          <span class="keywordflow">break</span>;</div>
<div class="line">      };</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> solve_problem(<span class="keyword">const</span> std::string &amp;solver_name)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">const</span> std::string header =</div>
<div class="line">      <span class="stringliteral">&quot;Running tests with \&quot;&quot;</span> + solver_name + <span class="stringliteral">&quot;\&quot; refinement criterion:&quot;</span>;</div>
<div class="line">    std::cout &lt;&lt; header &lt;&lt; std::endl</div>
<div class="line">              &lt;&lt; std::string(header.size(), <span class="charliteral">&#39;-&#39;</span>) &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div>
<div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, -1, 1);</div>
<div class="line">    <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.refine_global(2);</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>    fe(1);</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature(4);</div>
<div class="line">    RightHandSide&lt;dim&gt; rhs_function;</div>
<div class="line">    Solution&lt;dim&gt;      boundary_values;</div>
<div class="line"> </div>
<div class="line">    std::unique_ptr&lt;LaplaceSolver::Base&lt;dim&gt;&gt; solver;</div>
<div class="line">    <span class="keywordflow">if</span> (solver_name == <span class="stringliteral">&quot;global&quot;</span>)</div>
<div class="line">      solver = std::make_unique&lt;LaplaceSolver::RefinementGlobal&lt;dim&gt;&gt;(</div>
<div class="line">        <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, fe, quadrature, rhs_function, boundary_values);</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (solver_name == <span class="stringliteral">&quot;kelly&quot;</span>)</div>
<div class="line">      solver = std::make_unique&lt;LaplaceSolver::RefinementKelly&lt;dim&gt;&gt;(</div>
<div class="line">        <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, fe, quadrature, rhs_function, boundary_values);</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classTableHandler.html">TableHandler</a>                          results_table;</div>
<div class="line">    Evaluation::PointValueEvaluation&lt;dim&gt; postprocessor1(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.5),</div>
<div class="line">                                                         results_table);</div>
<div class="line"> </div>
<div class="line">    Evaluation::SolutionOutput&lt;dim&gt; postprocessor2(std::string(<span class="stringliteral">&quot;solution-&quot;</span>) +</div>
<div class="line">                                                     solver_name,</div>
<div class="line">                                                   <a class="code" href="group__Exceptions.html#gaa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">DataOutBase::gnuplot</a>);</div>
<div class="line"> </div>
<div class="line">    std::list&lt;Evaluation::EvaluationBase&lt;dim&gt; *&gt; postprocessor_list;</div>
<div class="line">    postprocessor_list.push_back(&amp;postprocessor1);</div>
<div class="line">    postprocessor_list.push_back(&amp;postprocessor2);</div>
<div class="line"> </div>
<div class="line">    run_simulation(*solver, postprocessor_list);</div>
<div class="line"> </div>
<div class="line">    results_table.<a class="code" href="classTableHandler.html#a45c4ec9981f3880c6c852ed3aceb08fe">write_text</a>(std::cout);</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">} <span class="comment">// namespace Step13</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      Step13::solve_problem&lt;2&gt;(<span class="stringliteral">&quot;global&quot;</span>);</div>
<div class="line">      Step13::solve_problem&lt;2&gt;(<span class="stringliteral">&quot;kelly&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> 。 </em></p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
