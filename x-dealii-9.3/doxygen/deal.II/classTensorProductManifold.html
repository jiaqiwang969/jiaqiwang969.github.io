<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classTensorProductManifold.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: TensorProductManifold&lt; dim, dim_A, spacedim_A, chartdim_A, dim_B, spacedim_B, chartdim_B &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.3.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.3.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classTensorProductManifold-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TensorProductManifold&lt; dim, dim_A, spacedim_A, chartdim_A, dim_B, spacedim_B, chartdim_B &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classTensor.html">Tensor</a> product manifold of two ChartManifolds.  
 <a href="classTensorProductManifold.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="tensor__product__manifold_8h_source.html">deal.II/grid/tensor_product_manifold.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for TensorProductManifold&lt; dim, dim_A, spacedim_A, chartdim_A, dim_B, spacedim_B, chartdim_B &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classTensorProductManifold__inherit__graph.svg" width="351" height="547"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a79eb483936cd38a0a9d42bf2071ee9ce"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> = std::array&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::vertices_per_face &gt;</td></tr>
<tr class="separator:a79eb483936cd38a0a9d42bf2071ee9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac690a6b2c5d93618e685c150ed871162"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductManifold.html#ac690a6b2c5d93618e685c150ed871162">TensorProductManifold</a> (const <a class="el" href="classChartManifold.html">ChartManifold</a>&lt; dim_A, spacedim_A, chartdim_A &gt; &amp;<a class="el" href="classTensorProductManifold.html#afc1ab2ece2899b85a51067af5ff5b823">manifold_A</a>, const <a class="el" href="classChartManifold.html">ChartManifold</a>&lt; dim_B, spacedim_B, chartdim_B &gt; &amp;<a class="el" href="classTensorProductManifold.html#adb096c74d502dbaff2d21d3364ce7e81">manifold_B</a>)</td></tr>
<tr class="separator:ac690a6b2c5d93618e685c150ed871162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfbc99450c4f60a3a8facf24ba4605d4"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim_A+spacedim_B &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductManifold.html#acfbc99450c4f60a3a8facf24ba4605d4">clone</a> () const override</td></tr>
<tr class="separator:acfbc99450c4f60a3a8facf24ba4605d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaafaeb47143310c753b638292e04408f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="classTensorProductManifold.html#a0158d20054556ad1f00af2b0a413c036">chartdim</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductManifold.html#aaafaeb47143310c753b638292e04408f">pull_back</a> (const <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt; &amp;space_point) const override</td></tr>
<tr class="separator:aaafaeb47143310c753b638292e04408f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b47ad4ec00a1747f6dea2a37d10671"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductManifold.html#a05b47ad4ec00a1747f6dea2a37d10671">push_forward</a> (const <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="classTensorProductManifold.html#a0158d20054556ad1f00af2b0a413c036">chartdim</a> &gt; &amp;chart_point) const override</td></tr>
<tr class="separator:a05b47ad4ec00a1747f6dea2a37d10671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4f972062c0932e6ec8e57031721ab0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 1, <a class="el" href="classTensorProductManifold.html#a0158d20054556ad1f00af2b0a413c036">chartdim</a>, <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductManifold.html#a6e4f972062c0932e6ec8e57031721ab0">push_forward_gradient</a> (const <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="classTensorProductManifold.html#a0158d20054556ad1f00af2b0a413c036">chartdim</a> &gt; &amp;chart_point) const override</td></tr>
<tr class="separator:a6e4f972062c0932e6ec8e57031721ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af255b3dfb6c1f38eaece0e995a85ec86"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChartManifold.html#af255b3dfb6c1f38eaece0e995a85ec86">get_intermediate_point</a> (const <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt; &amp;p1, const <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt; &amp;p2, const <a class="el" href="classdouble.html">double</a> w) const override</td></tr>
<tr class="separator:af255b3dfb6c1f38eaece0e995a85ec86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9207f06d5bd518383353ebee3f046c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChartManifold.html#a1e9207f06d5bd518383353ebee3f046c">get_new_point</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt;&gt; &amp;surrounding_points, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classdouble.html">double</a> &gt; &amp;weights) const override</td></tr>
<tr class="separator:a1e9207f06d5bd518383353ebee3f046c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac43e53bca8079f105415141b556111ae"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChartManifold.html#ac43e53bca8079f105415141b556111ae">get_new_points</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt;&gt; &amp;surrounding_points, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classdouble.html">double</a> &gt; &amp;weights, <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt;&gt; new_points) const override</td></tr>
<tr class="separator:ac43e53bca8079f105415141b556111ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9577b9723c8d6fb8481ca99daec95682"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChartManifold.html#a9577b9723c8d6fb8481ca99daec95682">get_tangent_vector</a> (const <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt; &amp;x1, const <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt; &amp;x2) const override</td></tr>
<tr class="separator:a9577b9723c8d6fb8481ca99daec95682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5684d6440642e8ec40ed840a7f381b5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="classTensorProductManifold.html#a0158d20054556ad1f00af2b0a413c036">chartdim</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChartManifold.html#ab5684d6440642e8ec40ed840a7f381b5">get_periodicity</a> () const</td></tr>
<tr class="separator:ab5684d6440642e8ec40ed840a7f381b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f1d301d7950f55b59e1c2982dfe942"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a73f1d301d7950f55b59e1c2982dfe942">get_new_point_on_quad</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 1 &gt;::quad_iterator &amp;) const</td></tr>
<tr class="separator:a73f1d301d7950f55b59e1c2982dfe942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1adb7e5b4a0feeeef7f9ec087e23d376"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a1adb7e5b4a0feeeef7f9ec087e23d376">get_new_point_on_quad</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 2 &gt;::quad_iterator &amp;) const</td></tr>
<tr class="separator:a1adb7e5b4a0feeeef7f9ec087e23d376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd7186dfb0ea938abda62e962d5f867"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a4bd7186dfb0ea938abda62e962d5f867">get_new_point_on_quad</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 3 &gt;::quad_iterator &amp;) const</td></tr>
<tr class="separator:a4bd7186dfb0ea938abda62e962d5f867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada653729888b24eb140a382512167163"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#ada653729888b24eb140a382512167163">get_new_point_on_hex</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt;::hex_iterator &amp;hex) const</td></tr>
<tr class="separator:ada653729888b24eb140a382512167163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a38fc3f140d54aa80195831a27c499"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#ae6a38fc3f140d54aa80195831a27c499">get_new_point_on_face</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 1 &gt;::face_iterator &amp;) const</td></tr>
<tr class="separator:ae6a38fc3f140d54aa80195831a27c499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bba395b8edbb4703d2e77689266436f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a9bba395b8edbb4703d2e77689266436f">get_new_point_on_face</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 2 &gt;::face_iterator &amp;) const</td></tr>
<tr class="separator:a9bba395b8edbb4703d2e77689266436f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd6859a4858667c7d37838276c8e8b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a4dd6859a4858667c7d37838276c8e8b2">get_new_point_on_face</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 3 &gt;::face_iterator &amp;) const</td></tr>
<tr class="separator:a4dd6859a4858667c7d37838276c8e8b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464ae5e689877ac0d06b08b33f718caa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a464ae5e689877ac0d06b08b33f718caa">normal_vector</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt;::face_iterator &amp;face, const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;p) const</td></tr>
<tr class="separator:a464ae5e689877ac0d06b08b33f718caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95b06b088819df6a9305d0009495d3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#ad95b06b088819df6a9305d0009495d3d">normal_vector</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt;::face_iterator &amp;face, const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;p) const</td></tr>
<tr class="separator:ad95b06b088819df6a9305d0009495d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae944375afbf9370708422e520c6969e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#ae944375afbf9370708422e520c6969e5">get_normals_at_vertices</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt;::face_iterator &amp;face, <a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;n) const</td></tr>
<tr class="separator:ae944375afbf9370708422e520c6969e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3477908d71618cfc0c2de81e8ad474"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a1e3477908d71618cfc0c2de81e8ad474">get_normals_at_vertices</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt;::face_iterator &amp;face, <a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;n) const</td></tr>
<tr class="separator:a1e3477908d71618cfc0c2de81e8ad474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Computing the location of points.</div></td></tr>
<tr class="memitem:a29c25e5d735160e0d846aab01d918e86"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a29c25e5d735160e0d846aab01d918e86">project_to_manifold</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt;&gt; &amp;surrounding_points, const <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt; &amp;candidate) const</td></tr>
<tr class="separator:a29c25e5d735160e0d846aab01d918e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af518522b81bdfe059b88bb557f7a60ba"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#af518522b81bdfe059b88bb557f7a60ba">get_new_point_on_line</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt;::line_iterator &amp;line) const</td></tr>
<tr class="separator:af518522b81bdfe059b88bb557f7a60ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a7a18b04151504883074c24108266f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a59a7a18b04151504883074c24108266f">get_new_point_on_quad</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt;::quad_iterator &amp;quad) const</td></tr>
<tr class="separator:a59a7a18b04151504883074c24108266f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d8365135405a1f057020d84a315ffa6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a8d8365135405a1f057020d84a315ffa6">get_new_point_on_hex</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt;::hex_iterator &amp;hex) const</td></tr>
<tr class="separator:a8d8365135405a1f057020d84a315ffa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79c3a0f002136b483b50722ea6690d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#ab79c3a0f002136b483b50722ea6690d9">get_new_point_on_face</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt;::face_iterator &amp;face) const</td></tr>
<tr class="separator:ab79c3a0f002136b483b50722ea6690d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36b25e230fefc6eb32d53cb6e69cbba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#af36b25e230fefc6eb32d53cb6e69cbba">get_new_point_on_cell</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt;::cell_iterator &amp;cell) const</td></tr>
<tr class="separator:af36b25e230fefc6eb32d53cb6e69cbba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Computing normal vectors</div></td></tr>
<tr class="memitem:a8f737627dc946fb68c097d6ec83419d4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a8f737627dc946fb68c097d6ec83419d4">normal_vector</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt;::face_iterator &amp;face, const <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt; &amp;p) const</td></tr>
<tr class="separator:a8f737627dc946fb68c097d6ec83419d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8317a03ab0c13971ff53bcb38b49e9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a2f8317a03ab0c13971ff53bcb38b49e9">get_normals_at_vertices</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt;::face_iterator &amp;face, <a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;face_vertex_normals) const</td></tr>
<tr class="separator:a2f8317a03ab0c13971ff53bcb38b49e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a0158d20054556ad1f00af2b0a413c036"><td class="memItemLeft" align="right" valign="top">static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductManifold.html#a0158d20054556ad1f00af2b0a413c036">chartdim</a> = chartdim_A + chartdim_B</td></tr>
<tr class="separator:a0158d20054556ad1f00af2b0a413c036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a837ba00d9a8940603373132ec9d7e191"><td class="memItemLeft" align="right" valign="top">static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> = spacedim_A + spacedim_B</td></tr>
<tr class="separator:a837ba00d9a8940603373132ec9d7e191"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:afc1ab2ece2899b85a51067af5ff5b823"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; const <a class="el" href="classChartManifold.html">ChartManifold</a>&lt; dim_A, spacedim_A, chartdim_A &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductManifold.html#afc1ab2ece2899b85a51067af5ff5b823">manifold_A</a></td></tr>
<tr class="separator:afc1ab2ece2899b85a51067af5ff5b823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb096c74d502dbaff2d21d3364ce7e81"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; const <a class="el" href="classChartManifold.html">ChartManifold</a>&lt; dim_B, spacedim_B, chartdim_B &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorProductManifold.html#adb096c74d502dbaff2d21d3364ce7e81">manifold_B</a></td></tr>
<tr class="separator:adb096c74d502dbaff2d21d3364ce7e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e657cebc576b3f47d5d1334317b9af9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFlatManifold.html">FlatManifold</a>&lt; <a class="el" href="classTensorProductManifold.html#a0158d20054556ad1f00af2b0a413c036">chartdim</a>, <a class="el" href="classTensorProductManifold.html#a0158d20054556ad1f00af2b0a413c036">chartdim</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChartManifold.html#a2e657cebc576b3f47d5d1334317b9af9">sub_manifold</a></td></tr>
<tr class="separator:a2e657cebc576b3f47d5d1334317b9af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Subscriptor functionality</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp8d6bc922eebec0b76272099aee4a220d"></a>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</td></tr>
<tr class="memitem:ga20658b60d6ef2d530fafa076efa9f503"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga20658b60d6ef2d530fafa076efa9f503">counter</a></td></tr>
<tr class="separator:ga20658b60d6ef2d530fafa076efa9f503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73f9f8936b61e6e17ab2a82e9516e95b"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga73f9f8936b61e6e17ab2a82e9516e95b">counter_map</a></td></tr>
<tr class="separator:ga73f9f8936b61e6e17ab2a82e9516e95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga094d5932c6c004c2a2b1b966950fb2f7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga094d5932c6c004c2a2b1b966950fb2f7">validity_pointers</a></td></tr>
<tr class="separator:ga094d5932c6c004c2a2b1b966950fb2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44e13f7984b31af8d7c54921175a75ff"><td class="memItemLeft" align="right" valign="top">const std::type_info *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga44e13f7984b31af8d7c54921175a75ff">object_info</a></td></tr>
<tr class="separator:ga44e13f7984b31af8d7c54921175a75ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned int version)</td></tr>
<tr class="separator:ga68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaeb9ac67567aa7d837f25debd33cd4ce5">map_value_type</a> = decltype(<a class="el" href="group__Exceptions.html#ga73f9f8936b61e6e17ab2a82e9516e95b">counter_map</a>)::value_type</td></tr>
<tr class="separator:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacebdc2d11f8522e4d9e8b7d73ac3f491">map_iterator</a> = decltype(<a class="el" href="group__Exceptions.html#ga73f9f8936b61e6e17ab2a82e9516e95b">counter_map</a>)::iterator</td></tr>
<tr class="separator:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e0d86893427a935e46d5bd6dcbc3f78"><td class="memItemLeft" align="right" valign="top">static std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7e0d86893427a935e46d5bd6dcbc3f78">mutex</a></td></tr>
<tr class="separator:ga7e0d86893427a935e46d5bd6dcbc3f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (int arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga300c593ea0f9422dcbce1445903e6c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga300c593ea0f9422dcbce1445903e6c12">check_no_subscribers</a> () const noexcept</td></tr>
<tr class="separator:ga300c593ea0f9422dcbce1445903e6c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int dim_A, int spacedim_A, int chartdim_A, int dim_B, int spacedim_B, int chartdim_B&gt;<br />
class TensorProductManifold&lt; dim, dim_A, spacedim_A, chartdim_A, dim_B, spacedim_B, chartdim_B &gt;</h3>

<p><a class="el" href="classTensor.html">Tensor</a> product manifold of two ChartManifolds. </p>
<p>This manifold will combine the ChartManifolds <code>A</code> and <code>B</code> given in the constructor to form a new <a class="el" href="classChartManifold.html">ChartManifold</a> by building the tensor product \(A\otimes B\). The first <code>spacedim_A</code> dimensions in the real space and the first <code>chartdim_A</code> dimensions of the chart will be given by manifold <code>A</code>, while the remaining coordinates are given by <code>B</code>. The manifold is to be used by a <code><a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, space_dim_A+space_dim_B&gt;</code>.</p>
<p>An example usage would be the combination of a <a class="el" href="classSphericalManifold.html">SphericalManifold</a> with space dimension 2 and a <a class="el" href="classFlatManifold.html">FlatManifold</a> with space dimension 1 to form a cylindrical manifold.</p>
<p><a class="el" href="classTensorProductManifold.html#aaafaeb47143310c753b638292e04408f">pull_back()</a>, <a class="el" href="classTensorProductManifold.html#a05b47ad4ec00a1747f6dea2a37d10671">push_forward()</a>, and <a class="el" href="classTensorProductManifold.html#a6e4f972062c0932e6ec8e57031721ab0">push_forward_gradient()</a> are implemented by splitting the input argument into inputs for <code>A</code> and <code>B</code> according to the given dimensions and applying the corresponding operations before concatenating the result.</p>
<dl class="section note"><dt>Note</dt><dd>The dimension arguments <code>dim_A</code> and <code>dim_B</code> are not used.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td>Dimension of cells (needs to match first template argument of the <a class="el" href="classTriangulation.html">Triangulation</a> to be attached to. </td></tr>
    <tr><td class="paramname">dim_A</td><td>Dimension of <a class="el" href="classChartManifold.html">ChartManifold</a> A. </td></tr>
    <tr><td class="paramname">spacedim_A</td><td>Spacial dimension of <a class="el" href="classChartManifold.html">ChartManifold</a> A. </td></tr>
    <tr><td class="paramname">chartdim_A</td><td>Chart dimension of <a class="el" href="classChartManifold.html">ChartManifold</a> A. </td></tr>
    <tr><td class="paramname">dim_B</td><td>Dimension of <a class="el" href="classChartManifold.html">ChartManifold</a> B. </td></tr>
    <tr><td class="paramname">spacedim_B</td><td>Spacial dimension of <a class="el" href="classChartManifold.html">ChartManifold</a> B. </td></tr>
    <tr><td class="paramname">chartdim_B</td><td>Chart dimension of <a class="el" href="classChartManifold.html">ChartManifold</a> B. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor__product__manifold_8h_source.html#l00070">70</a> of file <a class="el" href="tensor__product__manifold_8h_source.html">tensor_product_manifold.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a79eb483936cd38a0a9d42bf2071ee9ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79eb483936cd38a0a9d42bf2071ee9ce">&#9670;&nbsp;</a></span>FaceVertexNormals</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classManifold.html">Manifold</a>&lt; dim, <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt;::<a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> =  std::array&lt;<a class="el" href="classTensor.html">Tensor</a>&lt;1, <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a>&gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim&gt;::vertices_per_face&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Type keeping information about the normals at the vertices of a face of a cell. Thus, there are <code><a class="el" href="structGeometryInfo.html#aad8410f6471e4ac443b51f6c20809bfb">GeometryInfo&lt;dim&gt;::vertices_per_face</a></code> normal vectors, that define the tangent spaces of the boundary at the vertices. Note that the vectors stored in this object are not required to be normalized, nor to actually point outward, as one often will only want to check for orthogonality to define the tangent plane; if a function requires the normals to be normalized, then it must do so itself.</p>
<p>For obvious reasons, this type is not useful in 1d. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2grid_2manifold_8h_source.html#l00306">306</a> of file <a class="el" href="include_2deal_8II_2grid_2manifold_8h_source.html">manifold.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac690a6b2c5d93618e685c150ed871162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac690a6b2c5d93618e685c150ed871162">&#9670;&nbsp;</a></span>TensorProductManifold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int dim_A, int spacedim_A, int chartdim_A, int dim_B, int spacedim_B, int chartdim_B&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorProductManifold.html">TensorProductManifold</a>&lt; dim, dim_A, spacedim_A, chartdim_A, dim_B, spacedim_B, chartdim_B &gt;::<a class="el" href="classTensorProductManifold.html">TensorProductManifold</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChartManifold.html">ChartManifold</a>&lt; dim_A, spacedim_A, chartdim_A &gt; &amp;&#160;</td>
          <td class="paramname"><em>manifold_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classChartManifold.html">ChartManifold</a>&lt; dim_B, spacedim_B, chartdim_B &gt; &amp;&#160;</td>
          <td class="paramname"><em>manifold_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. </p>

<p class="definition">Definition at line <a class="el" href="tensor__product__manifold_8h_source.html#l00186">186</a> of file <a class="el" href="tensor__product__manifold_8h_source.html">tensor_product_manifold.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acfbc99450c4f60a3a8facf24ba4605d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfbc99450c4f60a3a8facf24ba4605d4">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int dim_A, int spacedim_A, int chartdim_A, int dim_B, int spacedim_B, int chartdim_B&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim_A+spacedim_B &gt; &gt; <a class="el" href="classTensorProductManifold.html">TensorProductManifold</a>&lt; dim, dim_A, spacedim_A, chartdim_A, dim_B, spacedim_B, chartdim_B &gt;::clone</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clone this manifold. </p>

<p>Implements <a class="el" href="classManifold.html#a140e1b7c7334d16f99aa7ad0dbabb44a">Manifold&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="tensor__product__manifold_8h_source.html#l00216">216</a> of file <a class="el" href="tensor__product__manifold_8h_source.html">tensor_product_manifold.h</a>.</p>

</div>
</div>
<a id="aaafaeb47143310c753b638292e04408f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaafaeb47143310c753b638292e04408f">&#9670;&nbsp;</a></span>pull_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int dim_A, int spacedim_A, int chartdim_A, int dim_B, int spacedim_B, int chartdim_B&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="classTensorProductManifold.html">TensorProductManifold</a>&lt; dim, dim_A, spacedim_A, chartdim_A, dim_B, spacedim_B, chartdim_B &gt;::<a class="el" href="classTensorProductManifold.html#a0158d20054556ad1f00af2b0a413c036">chartdim</a> &gt; <a class="el" href="classTensorProductManifold.html">TensorProductManifold</a>&lt; dim, dim_A, spacedim_A, chartdim_A, dim_B, spacedim_B, chartdim_B &gt;::pull_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>space_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pull back operation. </p>

<p>Implements <a class="el" href="classChartManifold.html#a5113d1d256ef1777f91eafe5f7d5fa35">ChartManifold&lt; dim, spacedim_A+spacedim_B, chartdim_A+chartdim_B &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="tensor__product__manifold_8h_source.html#l00248">248</a> of file <a class="el" href="tensor__product__manifold_8h_source.html">tensor_product_manifold.h</a>.</p>

</div>
</div>
<a id="a05b47ad4ec00a1747f6dea2a37d10671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05b47ad4ec00a1747f6dea2a37d10671">&#9670;&nbsp;</a></span>push_forward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int dim_A, int spacedim_A, int chartdim_A, int dim_B, int spacedim_B, int chartdim_B&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="classTensorProductManifold.html">TensorProductManifold</a>&lt; dim, dim_A, spacedim_A, chartdim_A, dim_B, spacedim_B, chartdim_B &gt;::<a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt; <a class="el" href="classTensorProductManifold.html">TensorProductManifold</a>&lt; dim, dim_A, spacedim_A, chartdim_A, dim_B, spacedim_B, chartdim_B &gt;::push_forward </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="classTensorProductManifold.html#a0158d20054556ad1f00af2b0a413c036">chartdim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>chart_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Push forward operation. </p>

<p>Implements <a class="el" href="classChartManifold.html#a713fbbf4271f9539bb2406f7029ab239">ChartManifold&lt; dim, spacedim_A+spacedim_B, chartdim_A+chartdim_B &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="tensor__product__manifold_8h_source.html#l00291">291</a> of file <a class="el" href="tensor__product__manifold_8h_source.html">tensor_product_manifold.h</a>.</p>

</div>
</div>
<a id="a6e4f972062c0932e6ec8e57031721ab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4f972062c0932e6ec8e57031721ab0">&#9670;&nbsp;</a></span>push_forward_gradient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int dim_A, int spacedim_A, int chartdim_A, int dim_B, int spacedim_B, int chartdim_B&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 1, <a class="el" href="classTensorProductManifold.html">TensorProductManifold</a>&lt; dim, dim_A, spacedim_A, chartdim_A, dim_B, spacedim_B, chartdim_B &gt;::<a class="el" href="classTensorProductManifold.html#a0158d20054556ad1f00af2b0a413c036">chartdim</a>, <a class="el" href="classTensorProductManifold.html">TensorProductManifold</a>&lt; dim, dim_A, spacedim_A, chartdim_A, dim_B, spacedim_B, chartdim_B &gt;::<a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt; <a class="el" href="classTensorProductManifold.html">TensorProductManifold</a>&lt; dim, dim_A, spacedim_A, chartdim_A, dim_B, spacedim_B, chartdim_B &gt;::push_forward_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="classTensorProductManifold.html#a0158d20054556ad1f00af2b0a413c036">chartdim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>chart_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gradient. </p>

<p>Reimplemented from <a class="el" href="classChartManifold.html#a9f6141f9a6780c6c271c73cb1c74e5b4">ChartManifold&lt; dim, spacedim_A+spacedim_B, chartdim_A+chartdim_B &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="tensor__product__manifold_8h_source.html#l00343">343</a> of file <a class="el" href="tensor__product__manifold_8h_source.html">tensor_product_manifold.h</a>.</p>

</div>
</div>
<a id="af255b3dfb6c1f38eaece0e995a85ec86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af255b3dfb6c1f38eaece0e995a85ec86">&#9670;&nbsp;</a></span>get_intermediate_point()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt; <a class="el" href="classChartManifold.html">ChartManifold</a>&lt; dim, <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a>, <a class="el" href="classTensorProductManifold.html#a0158d20054556ad1f00af2b0a413c036">chartdim</a> &gt;::get_intermediate_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Refer to the general documentation of this class and the documentation of the base class for more information. </p>

<p>Reimplemented from <a class="el" href="classManifold.html#aace84e99db1f4767ce9e524170a1de2c">Manifold&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00934">934</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a1e9207f06d5bd518383353ebee3f046c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e9207f06d5bd518383353ebee3f046c">&#9670;&nbsp;</a></span>get_new_point()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt; <a class="el" href="classChartManifold.html">ChartManifold</a>&lt; dim, <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a>, <a class="el" href="classTensorProductManifold.html#a0158d20054556ad1f00af2b0a413c036">chartdim</a> &gt;::get_new_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>surrounding_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Refer to the general documentation of this class and the documentation of the base class for more information. </p>

<p>Reimplemented from <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00943">943</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="ac43e53bca8079f105415141b556111ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac43e53bca8079f105415141b556111ae">&#9670;&nbsp;</a></span>get_new_points()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classChartManifold.html">ChartManifold</a>&lt; dim, <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a>, <a class="el" href="classTensorProductManifold.html#a0158d20054556ad1f00af2b0a413c036">chartdim</a> &gt;::get_new_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>surrounding_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt;&#160;</td>
          <td class="paramname"><em>new_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute a new set of points that interpolate between the given points <code>surrounding_points</code>. <code>weights</code> is a table with as many columns as <code>surrounding_points.size()</code>. The number of rows in <code>weights</code> must match the length of <code>new_points</code>.</p>
<p>The implementation of this function first transforms the <code>surrounding_points</code> to the chart space by calling <a class="el" href="classTensorProductManifold.html#aaafaeb47143310c753b638292e04408f">pull_back()</a>. Then, new points are computed on the chart by usual interpolation according to the given <code>weights</code>, which are finally transformed to the image space by <a class="el" href="classTensorProductManifold.html#a05b47ad4ec00a1747f6dea2a37d10671">push_forward()</a>.</p>
<p>This implementation can be much more efficient for computing multiple new points from the same surrounding points than separate calls to <a class="el" href="classChartManifold.html#a1e9207f06d5bd518383353ebee3f046c">get_new_point()</a> in case the <a class="el" href="classTensorProductManifold.html#aaafaeb47143310c753b638292e04408f">pull_back()</a> operation is expensive. This is because <a class="el" href="classTensorProductManifold.html#aaafaeb47143310c753b638292e04408f">pull_back()</a> is only called once for the surrounding points and the interpolation is done for all given weights using this set of points. Often, <a class="el" href="classTensorProductManifold.html#aaafaeb47143310c753b638292e04408f">pull_back()</a> is also more expensive than <a class="el" href="classTensorProductManifold.html#a05b47ad4ec00a1747f6dea2a37d10671">push_forward()</a> because the former might involve some kind of Newton iteration in non-trivial manifolds. </p>

<p>Reimplemented from <a class="el" href="classManifold.html#a09b9fa8b80707d686b5929d0f27732a7">Manifold&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00968">968</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a9577b9723c8d6fb8481ca99daec95682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9577b9723c8d6fb8481ca99daec95682">&#9670;&nbsp;</a></span>get_tangent_vector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt; <a class="el" href="classChartManifold.html">ChartManifold</a>&lt; dim, <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a>, <a class="el" href="classTensorProductManifold.html#a0158d20054556ad1f00af2b0a413c036">chartdim</a> &gt;::get_tangent_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a vector that, at \(\mathbf x_1\), is tangential to the geodesic that connects two points \(\mathbf x_1,\mathbf x_2\). See the documentation of the <a class="el" href="classManifold.html">Manifold</a> class and of <a class="el" href="classManifold.html#adff3c7c6851d64d1839964f7ebbfc787">Manifold::get_tangent_vector()</a> for a more detailed description.</p>
<p>For the current class, we assume that this geodesic is the image under the <a class="el" href="classTensorProductManifold.html#a05b47ad4ec00a1747f6dea2a37d10671">push_forward()</a> operation of a straight line of the pre-images of <code>x1</code> and <code>x2</code> (where pre-images are computed by pulling back the locations <code>x1</code> and <code>x2</code>). In other words, if these preimages are \(\xi_1=F^{-1}(\mathbf x_1), \xi_2=F^{-1}(\mathbf x_2)\), then the geodesic in preimage (the chartdim-dimensional Euclidean) space is </p><p class="formulaDsp">
\begin{align*} \zeta(t) &amp;= \xi_1 + t (\xi_2-\xi_1) \\ &amp;= F^{-1}(\mathbf x_1) + t\left[F^{-1}(\mathbf x_2) -F^{-1}(\mathbf x_1)\right] \end{align*}
</p>
<p> In image space, i.e., in the space in which we operate, this leads to the curve </p><p class="formulaDsp">
\begin{align*} \mathbf s(t) &amp;= F(\zeta(t)) \\ &amp;= F(\xi_1 + t (\xi_2-\xi_1)) \\ &amp;= F\left(F^{-1}(\mathbf x_1) + t\left[F^{-1}(\mathbf x_2) -F^{-1}(\mathbf x_1)\right]\right). \end{align*}
</p>
<p> What the current function is supposed to return is \(\mathbf s&#39;(0)\). By the chain rule, this is equal to </p><p class="formulaDsp">
\begin{align*} \mathbf s&#39;(0) &amp;= \frac{d}{dt}\left. F\left(F^{-1}(\mathbf x_1) + t\left[F^{-1}(\mathbf x_2) -F^{-1}(\mathbf x_1)\right]\right) \right|_{t=0} \\ &amp;= \nabla_\xi F\left(F^{-1}(\mathbf x_1)\right) \left[F^{-1}(\mathbf x_2) -F^{-1}(\mathbf x_1)\right]. \end{align*}
</p>
<p> This formula may then have to be slightly modified by considering any periodicity that was assumed in the call to the constructor.</p>
<p>Thus, the computation of tangent vectors also requires the implementation of <em>derivatives</em> \(\nabla_\xi F(\xi)\) of the push-forward mapping. Here, \(F^{-1}(\mathbf x_2)-F^{-1}(\mathbf x_1)\) is a chartdim-dimensional vector, and \(\nabla_\xi F\left(F^{-1}(\mathbf x_1)\right) = \nabla_\xi F\left(\xi_1\right)\) is a spacedim-times-chartdim-dimensional matrix. Consequently, and as desired, the operation results in a spacedim-dimensional vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>The first point that describes the geodesic, and the one at which the "direction" is to be evaluated. </td></tr>
    <tr><td class="paramname">x2</td><td>The second point that describes the geodesic. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A "direction" vector tangential to the geodesic. </dd></dl>

<p>Reimplemented from <a class="el" href="classManifold.html#adff3c7c6851d64d1839964f7ebbfc787">Manifold&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l01064">1064</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="ab5684d6440642e8ec40ed840a7f381b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5684d6440642e8ec40ed840a7f381b5">&#9670;&nbsp;</a></span>get_periodicity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="classTensorProductManifold.html#a0158d20054556ad1f00af2b0a413c036">chartdim</a> &gt; &amp; <a class="el" href="classChartManifold.html">ChartManifold</a>&lt; dim, <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a>, <a class="el" href="classTensorProductManifold.html#a0158d20054556ad1f00af2b0a413c036">chartdim</a> &gt;::get_periodicity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the periodicity associated with the submanifold. </p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l01071">1071</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a29c25e5d735160e0d846aab01d918e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29c25e5d735160e0d846aab01d918e86">&#9670;&nbsp;</a></span>project_to_manifold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt;::project_to_manifold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>surrounding_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>candidate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a point which lies close to the given manifold, it modifies it and projects it to manifold itself.</p>
<p>This class is used by the default implementation of the function <a class="el" href="classChartManifold.html#a1e9207f06d5bd518383353ebee3f046c">get_new_point()</a> and should be implemented by derived classes. The default implementation simply throws an exception if called.</p>
<p>If your manifold is simple, you could implement this function only, and the default behavior should work out of the box. </p>

<p>Reimplemented in <a class="el" href="group__OpenCASCADE.html#ga436f8e7fa132333ae5ed0d6f1b3f04f6">OpenCASCADE::NormalToMeshProjectionManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="group__OpenCASCADE.html#ga2c823dd4ef420dfd0de8e097d2be2bf2">OpenCASCADE::DirectionalProjectionManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="group__OpenCASCADE.html#gac7b0d16828cc077c45a2bd26b1d6544d">OpenCASCADE::NormalProjectionManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classFlatManifold.html#a8f30acedc685f5263d5924e7dbbaa478">FlatManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classFlatManifold.html#a8f30acedc685f5263d5924e7dbbaa478">FlatManifold&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFlatManifold.html#a8f30acedc685f5263d5924e7dbbaa478">FlatManifold&lt; dim, dim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00040">40</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="af518522b81bdfe059b88bb557f7a60ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af518522b81bdfe059b88bb557f7a60ba">&#9670;&nbsp;</a></span>get_new_point_on_line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt;::get_new_point_on_line </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::line_iterator &amp;&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Return the point which shall become the new middle vertex of the two children of a regular line. In 2D, this line is a line at the boundary, while in 3d, it is bounding a face at the boundary (the lines therefore is also on the boundary).</p>
<p>The default implementation of this function passes its argument to the <a class="el" href="namespaceManifolds.html#aa3ae330e2a2d8030955d5a395f3f1d18">Manifolds::get_default_points_and_weights()</a> function, and then calls the <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> function. User derived classes can overload <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> or <a class="el" href="classManifold.html#a29c25e5d735160e0d846aab01d918e86">Manifold&lt;dim,spacedim&gt;::project_to_manifold()</a>, which is called by the default implementation of <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a>. </p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00318">318</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a59a7a18b04151504883074c24108266f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a7a18b04151504883074c24108266f">&#9670;&nbsp;</a></span>get_new_point_on_quad() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt;::get_new_point_on_quad </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::quad_iterator &amp;&#160;</td>
          <td class="paramname"><em>quad</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Return the point which shall become the common point of the four children of a quad at the boundary in three or more spatial dimensions. This function therefore is only useful in at least three dimensions and should not be called for lower dimensions.</p>
<p>This function is called after the four lines bounding the given <code>quad</code> are refined, so you may want to use the information provided by <code>quad-&gt;line(i)-&gt;child(j)</code>, <code>i=0...3</code>, <code>j=0,1</code>.</p>
<p>The default implementation of this function passes its argument to the <a class="el" href="namespaceManifolds.html#aa3ae330e2a2d8030955d5a395f3f1d18">Manifolds::get_default_points_and_weights()</a> function, and then calls the <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> function. User derived classes can overload <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> or <a class="el" href="classManifold.html#a29c25e5d735160e0d846aab01d918e86">Manifold&lt;dim,spacedim&gt;::project_to_manifold()</a>, which is called by the default implementation of <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a>. </p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00332">332</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a73f1d301d7950f55b59e1c2982dfe942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f1d301d7950f55b59e1c2982dfe942">&#9670;&nbsp;</a></span>get_new_point_on_quad() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; 1 &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; 1, 1 &gt;::get_new_point_on_quad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 1 &gt;::quad_iterator &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00419">419</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a1adb7e5b4a0feeeef7f9ec087e23d376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1adb7e5b4a0feeeef7f9ec087e23d376">&#9670;&nbsp;</a></span>get_new_point_on_quad() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; 1, 2 &gt;::get_new_point_on_quad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 2 &gt;::quad_iterator &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00430">430</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a4bd7186dfb0ea938abda62e962d5f867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd7186dfb0ea938abda62e962d5f867">&#9670;&nbsp;</a></span>get_new_point_on_quad() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; 1, 3 &gt;::get_new_point_on_quad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 3 &gt;::quad_iterator &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00441">441</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a8d8365135405a1f057020d84a315ffa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d8365135405a1f057020d84a315ffa6">&#9670;&nbsp;</a></span>get_new_point_on_hex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt;::get_new_point_on_hex </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::hex_iterator &amp;&#160;</td>
          <td class="paramname"><em>hex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Return the point which shall become the common point of the eight children of a hex in three or spatial dimensions. This function therefore is only useful in at least three dimensions and should not be called for lower dimensions.</p>
<p>This function is called after the all the bounding objects of the given <code>hex</code> are refined, so you may want to use the information provided by <code>hex-&gt;quad(i)-&gt;line(j)-&gt;child(k)</code>, <code>i=0...5</code>, <code>j=0...3</code>, <code>k=0,1</code>.</p>
<p>The default implementation of this function passes its argument to the <a class="el" href="namespaceManifolds.html#aa3ae330e2a2d8030955d5a395f3f1d18">Manifolds::get_default_points_and_weights()</a> function, and then calls the <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> function. User derived classes can overload <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> or <a class="el" href="classManifold.html#a29c25e5d735160e0d846aab01d918e86">Manifold&lt;dim,spacedim&gt;::project_to_manifold()</a>, which is called by the default implementation of <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a>. </p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00452">452</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="ada653729888b24eb140a382512167163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada653729888b24eb140a382512167163">&#9670;&nbsp;</a></span>get_new_point_on_hex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; 3, 3 &gt;::get_new_point_on_hex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt;::hex_iterator &amp;&#160;</td>
          <td class="paramname"><em>hex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00463">463</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="ab79c3a0f002136b483b50722ea6690d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab79c3a0f002136b483b50722ea6690d9">&#9670;&nbsp;</a></span>get_new_point_on_face() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt;::get_new_point_on_face </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Depending on <code>dim=2</code> or <code>dim=3</code> this function calls the get_new_point_on_line or the get_new_point_on_quad function. It throws an exception for <code>dim=1</code>. This wrapper allows dimension independent programming. </p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00346">346</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="ae6a38fc3f140d54aa80195831a27c499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a38fc3f140d54aa80195831a27c499">&#9670;&nbsp;</a></span>get_new_point_on_face() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; 1 &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; 1, 1 &gt;::get_new_point_on_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 1 &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00386">386</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a9bba395b8edbb4703d2e77689266436f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bba395b8edbb4703d2e77689266436f">&#9670;&nbsp;</a></span>get_new_point_on_face() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; 1, 2 &gt;::get_new_point_on_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 2 &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00397">397</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a4dd6859a4858667c7d37838276c8e8b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dd6859a4858667c7d37838276c8e8b2">&#9670;&nbsp;</a></span>get_new_point_on_face() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; 1, 3 &gt;::get_new_point_on_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 3 &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00408">408</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="af36b25e230fefc6eb32d53cb6e69cbba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36b25e230fefc6eb32d53cb6e69cbba">&#9670;&nbsp;</a></span>get_new_point_on_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt;::get_new_point_on_cell </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Depending on <code>dim=1</code>, <code>dim=2</code> or <code>dim=3</code> this function calls the get_new_point_on_line, get_new_point_on_quad or the get_new_point_on_hex function. This wrapper allows dimension independent programming. </p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00366">366</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a8f737627dc946fb68c097d6ec83419d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f737627dc946fb68c097d6ec83419d4">&#9670;&nbsp;</a></span>normal_vector() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt;::normal_vector </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the normal vector to a face embedded in this manifold, at the point p. If p is not in fact on the surface, but only close-by, try to return something reasonable, for example the normal vector at the surface point closest to p. (The point p will in fact not normally lie on the actual surface, but rather be a quadrature point mapped by some polynomial mapping; the mapped surface, however, will not usually coincide with the actual surface.)</p>
<p>This function only makes sense if dim==spacedim because otherwise there is no unique normal vector but in fact a (spacedim-dim+1)-dimensional tangent space of vectors that are all both normal to the face and normal to the dim-dimensional surface that lives in spacedim-dimensional space. For example, think of a two-dimensional mesh that covers a two-dimensional surface in three-dimensional space. In that case, each face (edge) is one-dimensional, and there are two linearly independent vectors that are both normal to the edge: one is normal to the edge and tangent to the surface (intuitively, that would be the one that points from the current cell to the neighboring one, if the surface was locally flat), and the other one is rooted in the edge but points perpendicular to the surface (which is also perpendicular to the edge that lives within the surface). Thus, because there are no obviously correct semantics for this function if spacedim is greater than dim, the function will simply throw an error in that situation.</p>
<p>The face iterator gives an indication which face this function is supposed to compute the normal vector for. This is useful if the boundary of the domain is composed of different nondifferential pieces (for example when using the <a class="el" href="classFlatManifold.html">FlatManifold</a> class to approximate a geometry that is completely described by the coarse mesh, with piecewise (bi-)linear components between the vertices, but where the boundary may have a kink at the vertices itself).</p>
<dl class="section note"><dt>Note</dt><dd>In 2d, the default implementation of this function computes the normal vector by taking the tangent direction from p to the further one of the two vertices that make up an edge, and then rotates it outward (with respect to the coordinate system of the edge) by 90 degrees. In 3d, the default implementation is more complicated, aiming at avoiding problems with numerical round-off for points close to one of the vertices, and avoiding tangent directions that are linearly dependent. </dd></dl>

<p>Reimplemented in <a class="el" href="classSphericalManifold.html#adb333bd42dfb3e7bd933b0f1b9ada0d9">SphericalManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classPolarManifold.html#af0a55c0cb5c01a8f334c8ea7e5bf49ed">PolarManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classFlatManifold.html#aab60f221758b3a32a596dde96fc1188c">FlatManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classFlatManifold.html#aab60f221758b3a32a596dde96fc1188c">FlatManifold&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFlatManifold.html#aab60f221758b3a32a596dde96fc1188c">FlatManifold&lt; dim, dim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00239">239</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a464ae5e689877ac0d06b08b33f718caa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a464ae5e689877ac0d06b08b33f718caa">&#9670;&nbsp;</a></span>normal_vector() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, 2 &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; 2, 2 &gt;::normal_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00145">145</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="ad95b06b088819df6a9305d0009495d3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad95b06b088819df6a9305d0009495d3d">&#9670;&nbsp;</a></span>normal_vector() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, 3 &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; 3, 3 &gt;::normal_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00166">166</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a2f8317a03ab0c13971ff53bcb38b49e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f8317a03ab0c13971ff53bcb38b49e9">&#9670;&nbsp;</a></span>get_normals_at_vertices() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classManifold.html">Manifold</a>&lt; dim, <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a> &gt;::get_normals_at_vertices </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;&#160;</td>
          <td class="paramname"><em>face_vertex_normals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the normal vectors to the boundary at each vertex of the given face embedded in the <a class="el" href="classManifold.html">Manifold</a>. It is not required that the normal vectors be normed somehow. Neither is it required that the normals actually point outward.</p>
<p>This function is needed to compute data for C1 mappings. The default implementation calls <a class="el" href="classManifold.html#a8f737627dc946fb68c097d6ec83419d4">normal_vector()</a> on each vertex.</p>
<p>Note that when computing normal vectors at a vertex where the boundary is not differentiable, you have to make sure that you compute the one-sided limits, i.e. limit with respect to points inside the given face. </p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00303">303</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="ae944375afbf9370708422e520c6969e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae944375afbf9370708422e520c6969e5">&#9670;&nbsp;</a></span>get_normals_at_vertices() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classManifold.html">Manifold</a>&lt; 2, 2 &gt;::get_normals_at_vertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00251">251</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a1e3477908d71618cfc0c2de81e8ad474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e3477908d71618cfc0c2de81e8ad474">&#9670;&nbsp;</a></span>get_normals_at_vertices() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classManifold.html">Manifold</a>&lt; 3, 3 &gt;::get_normals_at_vertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00273">273</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a0158d20054556ad1f00af2b0a413c036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0158d20054556ad1f00af2b0a413c036">&#9670;&nbsp;</a></span>chartdim</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int dim_A, int spacedim_A, int chartdim_A, int dim_B, int spacedim_B, int chartdim_B&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int <a class="el" href="classTensorProductManifold.html">TensorProductManifold</a>&lt; dim, dim_A, spacedim_A, chartdim_A, dim_B, spacedim_B, chartdim_B &gt;::chartdim = chartdim_A + chartdim_B</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The chart dimension is the sum of the chart dimensions of the manifolds <code>A</code> and <code>B</code>. </p>

<p class="definition">Definition at line <a class="el" href="tensor__product__manifold_8h_source.html#l00078">78</a> of file <a class="el" href="tensor__product__manifold_8h_source.html">tensor_product_manifold.h</a>.</p>

</div>
</div>
<a id="a837ba00d9a8940603373132ec9d7e191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a837ba00d9a8940603373132ec9d7e191">&#9670;&nbsp;</a></span>spacedim</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int dim_A, int spacedim_A, int chartdim_A, int dim_B, int spacedim_B, int chartdim_B&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int <a class="el" href="classTensorProductManifold.html">TensorProductManifold</a>&lt; dim, dim_A, spacedim_A, chartdim_A, dim_B, spacedim_B, chartdim_B &gt;::spacedim = spacedim_A + spacedim_B</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The space dimension is the sum of the space dimensions of the manifolds <code>A</code> and <code>B</code>. </p>

<p class="definition">Definition at line <a class="el" href="tensor__product__manifold_8h_source.html#l00083">83</a> of file <a class="el" href="tensor__product__manifold_8h_source.html">tensor_product_manifold.h</a>.</p>

</div>
</div>
<a id="afc1ab2ece2899b85a51067af5ff5b823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc1ab2ece2899b85a51067af5ff5b823">&#9670;&nbsp;</a></span>manifold_A</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int dim_A, int spacedim_A, int chartdim_A, int dim_B, int spacedim_B, int chartdim_B&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;const <a class="el" href="classChartManifold.html">ChartManifold</a>&lt;dim_A, spacedim_A, chartdim_A&gt; &gt; <a class="el" href="classTensorProductManifold.html">TensorProductManifold</a>&lt; dim, dim_A, spacedim_A, chartdim_A, dim_B, spacedim_B, chartdim_B &gt;::manifold_A</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__product__manifold_8h_source.html#l00118">118</a> of file <a class="el" href="tensor__product__manifold_8h_source.html">tensor_product_manifold.h</a>.</p>

</div>
</div>
<a id="adb096c74d502dbaff2d21d3364ce7e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb096c74d502dbaff2d21d3364ce7e81">&#9670;&nbsp;</a></span>manifold_B</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int dim_A, int spacedim_A, int chartdim_A, int dim_B, int spacedim_B, int chartdim_B&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;const <a class="el" href="classChartManifold.html">ChartManifold</a>&lt;dim_B, spacedim_B, chartdim_B&gt; &gt; <a class="el" href="classTensorProductManifold.html">TensorProductManifold</a>&lt; dim, dim_A, spacedim_A, chartdim_A, dim_B, spacedim_B, chartdim_B &gt;::manifold_B</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__product__manifold_8h_source.html#l00121">121</a> of file <a class="el" href="tensor__product__manifold_8h_source.html">tensor_product_manifold.h</a>.</p>

</div>
</div>
<a id="a2e657cebc576b3f47d5d1334317b9af9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e657cebc576b3f47d5d1334317b9af9">&#9670;&nbsp;</a></span>sub_manifold</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFlatManifold.html">FlatManifold</a>&lt;<a class="el" href="classTensorProductManifold.html#a0158d20054556ad1f00af2b0a413c036">chartdim</a>, <a class="el" href="classTensorProductManifold.html#a0158d20054556ad1f00af2b0a413c036">chartdim</a>&gt; <a class="el" href="classChartManifold.html">ChartManifold</a>&lt; dim, <a class="el" href="classTensorProductManifold.html#a837ba00d9a8940603373132ec9d7e191">spacedim</a>, <a class="el" href="classTensorProductManifold.html#a0158d20054556ad1f00af2b0a413c036">chartdim</a> &gt;::sub_manifold</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The sub_manifold object is used to compute the average of the points in the chart coordinates system.</p>
<p>In an ideal world, it would have type FlatManifold&lt;dim,chartdim&gt;. However, this would instantiate cases where dim&gt;spacedim, which leads to invalid situations. We instead use &lt;chartdim,chartdim&gt;, which is (i) always valid, and (ii) does not matter at all since the first (dim) argument of manifolds is, in fact, ignored as far as manifold functionality is concerned. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2grid_2manifold_8h_source.html#l01085">1085</a> of file <a class="el" href="include_2deal_8II_2grid_2manifold_8h_source.html">manifold.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/grid/<a class="el" href="tensor__product__manifold_8h_source.html">tensor_product_manifold.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
