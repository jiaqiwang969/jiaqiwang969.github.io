<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_70.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-70 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.3.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.3.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">The step-70 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_19.html">step-19</a>, <a class="el" href="step_32.html">step-32</a>, <a class="el" href="step_60.html">step-60</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Massivelyparallelnonmatchinggridsimulationsoffluidstructureinteractionproblems">Massively parallel non-matching grid simulations of fluid structure interaction problems</a>
      <ul>
        <li><a href="#Codimensiononecase">Co-dimension one case</a>
        <li><a href="#Codimensionzerocase">Co-dimension zero case</a>
        <li><a href="#Representationofand">Representation of Ω and Γ</a>
        <li><a href="#Usingparticlestotrack">Using particles to track Γ</a>
      </ul>
        <li><a href="#Thetestcase">The testcase</a>
        <li><a href="#Morereferences"> More references</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#Runtimeparameterhandling">Run-time parameter handling</a>
        <li><a href="#TheStokesImmersedProblemclassdeclaration">The StokesImmersedProblem class declaration</a>
        <li><a href="#TheStokesImmersedProblemclassimplementation">The StokesImmersedProblem class implementation</a>
      <ul>
        <li><a href="#Objectconstructionandmeshinitializationfunctions">Object construction and mesh initialization functions</a>
        <li><a href="#Particleinitializationfunctions">Particle initialization functions</a>
        <li><a href="#DoFinitializationfunctions">DoF initialization functions</a>
        <li><a href="#Assemblyfunctions">Assembly functions</a>
        <li><a href="#Solvingthelinearsystem">Solving the linear system</a>
        <li><a href="#Meshrefinement">Mesh refinement</a>
        <li><a href="#Creatingoutputforvisualization">Creating output for visualization</a>
        <li><a href="#Therunfunction">The "run" function</a>
      </ul>
        <li><a href="#Themainfunction">The main() function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Twodimensionaltestcase"> Two dimensional test case </a>
        <li><a href="#Threedimensionaltestcase"> Three dimensional test case </a>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br  />
</p>
<p><em>This program was contributed by Luca Heltai (International School for Advanced Studies, Trieste), Bruno Blais (Polytechnique Montréal), and Rene Gassmöller (University of California Davis) </em></p>
<dl class="section note"><dt>Note</dt><dd>If you use this program as a basis for your own work, please consider citing it in your list of references. The initial version of this work was contributed to the deal.II project by the authors listed in the following citation: <a href="https://doi.org/10.5281/zenodo.3829064"><img src="https://zenodo.org/badge/DOI/10.5281/zenodo.3829064.svg" alt="10.5281/zenodo.3829064"/></a> </dd></dl>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p><a class="anchor" id="Massivelyparallelnonmatchinggridsimulationsoffluidstructureinteractionproblems"></a></p><h3>Massively parallel non-matching grid simulations of fluid structure interaction problems</h3>
<p>In this tutorial we consider a mixing problem in the laminar flow regime. Such problems occur in a wide range of applications ranging from chemical engineering to power generation (e.g. turbomachinery). Mixing problems are particularly hard to solve numerically, because they often involve a container (with fixed boundaries, and possibly complex geometries such as baffles), represented by the domain \(\Omega\), and one (or more) immersed and rotating impellers (represented by the domain \(\Omega^{\text{imp}}\)). The domain in which we would like to solve the flow equations is the (time dependent) difference between the two domains, namely: \(\Omega\setminus\Omega^{\text{imp}}\).</p>
<p>For rotating impellers, the use of Arbitrary Lagrangian Eulerian formulations (in which the fluid domain &ndash; along with the mesh! &ndash; is smoothly deformed to follow the deformations of the immersed solid) is not possible, unless only small times (i.e., small fluid domain deformations) are considered. If one wants to track the evolution of the flow across multiple rotations of the impellers, the resulting deformed grid would simply be too distorted to be useful.</p>
<p>In this case, a viable alternative strategy would be to use non-matching methods (similarly to what we have done in <a class="el" href="step_60.html">step-60</a>), where a background fixed grid (that may or may not be locally refined in time to better capture the solid motion) is coupled with a rotating, independent, grid.</p>
<p>In order to maintain the same notations used in <a class="el" href="step_60.html">step-60</a>, we use \(\Omega\) to denote the domain in \({\mathbb R}^{\text{spacedim}}\) representing the container of both the fluid and the impeller, and we use \(\Gamma\) in \({\mathbb R}^{\text{dim}}\) to denote either the full impeller (when its <code>spacedim</code> measure is non-negligible, i.e., when we can represent it as a grid of dimension <code>dim</code> equal to <code>spacedim</code>), a co-dimension one representation of a thin impeller, or just the boundary of the full impeller.</p>
<p>The domain \(\Gamma\) is embedded in \(\Omega\) ( \(\Gamma \subseteq \Omega\)) and it is non-matching: It does not, in general, align with any of the features of the volume mesh. We solve a partial differential equation on \(\Omega\), enforcing some conditions on the solution of the problem on the embedded domain \(\Gamma\) by some penalization techniques. In the current case, the condition is that the velocity of the fluid at points on \(\Gamma\) equal the velocity of the solid impeller at that point.</p>
<p>The technique we describe here is presented in the literature using one of many names: the <b>immersed finite element method</b> and the <b>fictitious boundary method</b> among others. The main principle is that the discretization of the two grids are kept completely independent. In the present tutorial, this approach is used to solve for the motion of a viscous fluid, described by the Stokes equation, that is agitated by a rigid non-deformable impeller.</p>
<p>Thus, the equations solved in \(\Omega\) are the Stokes equations for a creeping flow (i.e. a flow where \(\text{Re}\rightarrow 0\)) and a no-slip boundary condition is applied on the moving <em>embedded domain</em> \(\Gamma\) associated with the impeller. However, this tutorial could be readily extended to other equations (e.g. the Navier-Stokes equations, linear elasticity equation, etc.). It can be seen as a natural extension of <a class="el" href="step_60.html">step-60</a> that enables the solution of large problems using a distributed parallel computing architecture via MPI.</p>
<p>However, contrary to <a class="el" href="step_60.html">step-60</a>, the Dirichlet boundary conditions on \(\Gamma\) are imposed weakly instead of through the use of Lagrange multipliers, and we concentrate on dealing with the coupling of two fully distributed triangulations (a combination that was not possible in the implementation of <a class="el" href="step_60.html">step-60</a>).</p>
<p>There are two interesting scenarios that occur when one wants to enforce conditions on the embedded domain \(\Gamma\):</p>
<ul>
<li>The geometrical dimension <code>dim</code> of the embedded domain \(\Gamma\) is the same of the domain \(\Omega\) (<code>spacedim</code>), that is, the spacedim-dimensional measure of \(\Gamma\) is not zero. In this case, the imposition of the Dirichlet boundary boundary condition on \(\Gamma\) is done through a volumetric penalization. If the applied penalization only depends on the velocity, this is often referred to as \(\mathcal{L}^2\) penalization whereas if the penalization depends on both the velocity and its gradient, it is an \(\mathcal{H}^1\) penalization. The case of the \(\mathcal{L}^2\) penalization is very similar to a Darcy-type approach. Both \(\mathcal{L}^2\) and \(\mathcal{H}^1\) penalizations have been analyzed extensively (see, for example, <b>[Angot1999]</b>).</li>
<li>The embedded domain \(\Gamma\) has an intrinsic dimension <code>dim</code> which is smaller than that of \(\Omega\) (<code>spacedim</code>), thus its spacedim-dimensional measure is zero; for example it is a curve embedded in a two dimensional domain, or a surface embedded in a three-dimensional domain. This is of course physically impossible, but one may consider very thin sheets of metal moving in a fluid as essentially lower-dimensional if the thickness of the sheet is negligible. In this case, the boundary condition is imposed weakly on \(\Gamma\) by applying the <a href="https://en.wikipedia.org/wiki/Joachim_Nitsche">Nitsche</a> method (see <b>[Freund1995]</b>).</li>
</ul>
<p>Both approaches have very similar requirements and result in highly similar formulations. Thus, we treat them almost in the same way.</p>
<p>In this tutorial program we are not interested in further details on \(\Gamma\): we assume that the dimension of the embedded domain (<code>dim</code>) is always smaller by one or equal with respect to the dimension of the embedding domain \(\Omega\) (<code>spacedim</code>).</p>
<p>We are going to solve the following differential problem: given a sufficiently regular function \(g\) on \(\Gamma\), find the solution \((\textbf{u},p)\) to</p>
<p class="formulaDsp">
\begin{eqnarray*} -\Delta \mathbf{u} + \nabla p &amp;=&amp; 0,\\ -\nabla \cdot \textbf{u} &amp;=&amp; 0,\\ \textbf{u} &amp;=&amp; \textbf{g} \text{ in } \Gamma,\\ \textbf{u} &amp;=&amp; 0 \text{ on } \partial\Omega. \end{eqnarray*}
</p>
<p>This equation, which we have normalized by scaling the time units in such a way that the viscosity has a numerical value of 1, describes slow, viscous flow such as honey or lava. The main goal of this tutorial is to show how to impose the velocity field condition \(\mathbf{u} = \mathbf{g}\) on a non-matching \(\Gamma\) in a weak way, using a penalization method. A more extensive discussion of the Stokes problem including body forces, different boundary conditions, and solution strategies can be found in <a class="el" href="step_22.html">step-22</a>.</p>
<p>Let us start by considering the Stokes problem alone, in the entire domain \(\Omega\). We look for a velocity field \(\mathbf{u}\) and a pressure field \(p\) that satisfy the Stokes equations with homogeneous boundary conditions on \(\partial\Omega\).</p>
<p>The weak form of the Stokes equations is obtained by first writing it in vector form as </p><p class="formulaDsp">
\begin{eqnarray*} \begin{pmatrix} {-\Delta \textbf{u} + \nabla p} \\ {-\textrm{div}\;\textbf{u}} \end{pmatrix} = \begin{pmatrix} 0 \\ 0 \end{pmatrix}, \end{eqnarray*}
</p>
<p> forming the dot product from the left with a vector-valued test function \(\phi = \begin{pmatrix}\textbf{v} \\ q\end{pmatrix}\), and integrating over the domain \(\Omega\), yielding the following set of equations: </p><p class="formulaDsp">
\begin{eqnarray*} (\mathrm v, -\Delta \textbf{u} + \nabla p)_{\Omega} - (q,\textrm{div}\; \textbf{u})_{\Omega} = 0 \end{eqnarray*}
</p>
<p> which has to hold for all test functions \(\phi = \begin{pmatrix}\textbf{v} \\ q\end{pmatrix}\).</p>
<p>Integrating by parts and exploiting the boundary conditions on \(\partial\Omega\), we obtain the following variational problem: </p><p class="formulaDsp">
\begin{eqnarray*} (\nabla \textbf{v}, \nabla \textbf{u})_{\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q, \textrm{div}\; \textbf{u})_{\Omega}&amp;=&amp; 0 \end{eqnarray*}
</p>
<p>where \((\cdot, \cdot)_{\Omega}\) represents the \(L^2\) scalar product. This is the same variational form used in <a class="el" href="step_22.html">step-22</a>.</p>
<p>This variational formulation does not take into account the embedded domain. Contrary to <a class="el" href="step_60.html">step-60</a>, we do not enforce strongly the constraints of \(\textbf{u}\) on \(\Gamma\), but enforce them weakly via a penalization term.</p>
<p>The analysis of this weak imposition of the boundary condition depends on the spacedim-dimensional measure of \(\Gamma\) as either positive (if <code>dim</code> is equal to <code>spacedim</code>) or zero (if <code>dim</code> is smaller than <code>spacedim</code>). We discuss both scenarios.</p>
<p><a class="anchor" id="Codimensiononecase"></a></p><h4>Co-dimension one case</h4>
<p>In this case, we assume that \(\Gamma\) is the boundary of the actual impeller, that is, a closed curve embedded in a two-dimensional domain or a closed surface in a three-dimensional domain. The idea of this method starts by considering a weak imposition of the Dirichlet boundary condition on \(\Gamma\), following the Nitsche method. This is achieved by using the following modified formulation on the fluid domain, where no strong conditions on the test functions on \(\Gamma\) are imposed:</p>
<p class="formulaDsp">
\begin{multline*} (\nabla \textbf{v}, \nabla \textbf{u})_{\Omega\setminus\Omega^{\text{imp}}} - (\textrm{div}\; \textbf{v}, p)_{\Omega\setminus\Omega^{\text{imp}}} - (q, \textrm{div}\; \textbf{u})_{\Omega\setminus\Omega^{\text{imp}}} \\ - (\textbf{v},\nabla \textbf{u} \cdot \textbf{n})_{\Gamma} + (\textbf{v}\cdot \textbf{n},p)_{\Gamma} \\ - (\nabla\textbf{v}\cdot \textbf{n},\textbf{u})_{\Gamma} + (q, \textbf{u} \cdot \textbf{n})_{\Gamma} + \beta (\textbf{v},\textbf{u})_{\Gamma} \\ = - (\nabla\textbf{v}\cdot \textbf{n},\textbf{g})_{\Gamma} + (q, \textbf{g} \cdot \textbf{n})_{\Gamma} + \beta (\textbf{v},\textbf{g})_{\Gamma}. \end{multline*}
</p>
<p>The integrals over \(\Gamma\) are lower-dimensional integrals. It can be shown (see <b>[Freund1995]</b>) that there exists a positive constant \(C_1\) so that if \(\beta &gt; C_1\), the weak imposition of the boundary will be consistent and stable. The first two additional integrals on \(\Gamma\) (the second line in the equation above) appear naturally after integrating by parts, when one does not assume that \(\mathbf{v}\) is zero on \(\Gamma\).</p>
<p>The third line in the equation above contains two terms that are added to ensure consistency of the weak form, and a stabilization term, that is there to enforce the boundary condition with an error which is consistent with the approximation error. The consistency terms and the stabilization term are added to the right hand side with the actual boundary data \(\mathbf{g}\).</p>
<p>When \(\mathbf{u}\) satisfies the condition \(\mathbf{u}=\mathbf{g}\) on \(\Gamma\), all the consistency and stability integrals on \(\Gamma\) cancel out, and one is left with the usual weak form of Stokes flow, that is, the above formulation is consistent.</p>
<p>We note that an alternative (non-symmetric) formulation can be used :</p>
<p class="formulaDsp">
\begin{multline*} (\nabla \textbf{v}, \nabla \textbf{u})_{\Omega\setminus\Omega^{\text{imp}}} - (\textrm{div}\; \textbf{v}, p)_{\Omega\setminus\Omega^{\text{imp}}} - (q, \textrm{div}\; \textbf{u})_{\Omega\setminus\Omega^{\text{imp}}} \\ -(\textbf{v},\nabla \textbf{u} \cdot \textbf{n})_{\Gamma} + (\textbf{v}\cdot \textbf{n},p)_{\Gamma} \\ +(\nabla\textbf{v}\cdot \textbf{n},\textbf{u})_{\Gamma} - (q, \textbf{u} \cdot \textbf{n})_{\Gamma} + \beta (\textbf{v},\textbf{u})_{\Gamma} \\ = (\nabla\textbf{v}\cdot \textbf{n},\textbf{g})_{\Gamma} - (q, \textbf{g} \cdot \textbf{n})_{\Gamma} + \beta (\textbf{v},\textbf{g})_{\Gamma}. \end{multline*}
</p>
<p> Note the different sign of the first terms on the third and fourth lines. In this case, the stability and consistency conditions become \(\beta &gt; 0\). In the symmetric case, the value of \(\beta\) is dependent on \(h\), and it is in general chosen such that \(\beta = C h^{-1} \) with \(h\) a measure of size of the face being integrated and \(C\) a constant such that \(1 \leq C \leq 10\). This is as one usually does with the Nitsche penalty method to enforcing Dirichlet boundary conditions.</p>
<p>The non-symmetric approach, on the other hand, is related to how one enforced continuity for the non-symmetric interior penalty method for discontinuous Galerkin methods (the "NIPG" method <b>[Riviere1999]</b>). Even if the non-symmetric case seems advantageous w.r.t. possible choices of stabilization parameters, we opt for the symmetric discretization, since in this case it can be shown that the dual problem is also consistent, leading to a solution where not only the energy norm of the solution converges with the correct order, but also its \(L^2\) norm. Furthermore, the resulting matrix remains symmetric.</p>
<p>The above formulation works under the assumption that the domain is discretized exactly. However, if the deformation of the impeller is a rigid body motion, it is possible to artificially extend the solution of the Stokes problem inside the propeller itself, since a rigid body motion is also a solution to the Stokes problem. The idea is then to solve the same problem, inside \(\Omega^{\text{imp}}\), imposing the same boundary conditions on \(\Gamma\), using the same penalization technique, and testing with test functions \(\mathbf{v}\) which are globally continuous over \(\Omega\).</p>
<p>This results in the following (intermediate) formulation: </p><p class="formulaDsp">
\begin{multline*} (\nabla \textbf{v}, \nabla \textbf{u})_{\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q, \textrm{div}\; \textbf{u})_{\Omega} \\ - (\textbf{v}, \lbrack \nabla \textbf{u} \rbrack \cdot \textbf{n})_{\Gamma} + (\textbf{v}\cdot \textbf{n},\lbrack p \rbrack )_{\Gamma} \\ - (\lbrack \nabla\textbf{v} \rbrack \cdot \textbf{n},\textbf{u})_{\Gamma} + (\lbrack q \rbrack, \textbf{u} \cdot n)_{\Gamma} + 2\beta (\textbf{v},\textbf{u})_{\Gamma} \\ = - (\lbrack \nabla\textbf{v}\rbrack\cdot \textbf{n},\textbf{g})_{\Gamma} + (\lbrack q\rbrack, \textbf{g} \cdot n)_{\Gamma} + 2\beta (\textbf{v},\textbf{g})_{\Gamma}, \end{multline*}
</p>
<p> where the jump terms, denoted with \(\lbrack \cdot \rbrack\), are computed with respect to a fixed orientation of the normal vector \(\textbf{n}\). The factor of 2 appears in front of \(\beta\) since we see every part of \(\Gamma\) twice, once from within the fluid and once from within the obstacle moving around in it. (For all of the other integrals over \(\Gamma\), we visit each part of \(\Gamma\) twice, but with opposite signs, and consequently get the jump terms.)</p>
<p>Here we notice that, unlike in discontinuous Galerkin methods, the test and trial functions are continuous across \(\Gamma\). Moreover, if \(\Gamma\) is not aligned with cell boundaries, all the jump terms are also zero, since, in general, finite element function spaces are smooth inside each cell, and if \(\Gamma\) cuts through an element intersecting its boundary only at a finite number of points, all the contributions on \(\Gamma\), with the exception of the stabilization ones, can be neglected from the formulation, resulting in the following final form of the variational formulation:</p>
<p class="formulaDsp">
\begin{multline*} (\nabla \textbf{v}, \nabla \textbf{u})_{\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q, \textrm{div}\; \textbf{u})_{\Omega} + 2\beta (\textbf{v},\textbf{u})_{\Gamma} \\ = 2\beta (\textbf{v},\textbf{g})_{\Gamma}. \end{multline*}
</p>
<p>In <a class="el" href="step_60.html">step-60</a>, the imposition of the constraint required the addition of new variables in the form of Lagrange multipliers. This is not the case for this tutorial program. The imposition of the boundary condition using Nitsche's method only modifies the system matrix and the right-hand side without adding additional unknowns. However, the velocity vector \(\textbf{u}\) on the embedded domain will not match exactly the prescribed velocity \(\textbf{g}\), but only up to a numerical error which is in the same order as the interpolation error of the finite element method. Furthermore, as in <a class="el" href="step_60.html">step-60</a>, we still need to integrate over the non-matching embedded grid in order to construct the boundary term necessary to impose the boundary condition over \(\Gamma\).</p>
<p><a class="anchor" id="Codimensionzerocase"></a></p><h4>Co-dimension zero case</h4>
<p>In this case, \(\Gamma\) has the same dimension, but is embedded into \(\Omega\). We can think of this as a thick object moving around in the fluid. In the case of \(\mathcal{L}^2\) penalization, the additional penalization term can be interpreted as a Darcy term within \(\Gamma\), resulting in:</p>
<p class="formulaDsp">
\begin{eqnarray*} (\nabla \textbf{v}, \nabla \textbf{u})_{\Omega} - &amp; (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q, \textrm{div}\; \textbf{u})_{\Omega} + \beta (\textbf{v},\textbf{u})_{\Gamma} = \beta (\textbf{v},\textbf{g})_{\Gamma}. \end{eqnarray*}
</p>
<p>Here, integrals over \(\Gamma\) are simply integrals over a part of the volume. The \(\mathcal{L}^2\) penalization thus consists in adding a volumetric term that constrains the velocity of the fluid to adhere to the velocity of the rigid body within \(\Gamma\). Also in this case, \(\beta\) must be chosen sufficiently large in order to ensure that the Dirichlet boundary condition in \(\Gamma\) is sufficiently respected, but not too high in order to maintain the proper conditioning of the system matrix.</p>
<p>A \(\mathcal{H}^1\) penalization may be constructed in a similar manner, with the addition of a viscous component to the penalization that dampens the velocity gradient within \(\Gamma\):</p>
<p class="formulaDsp">
\begin{eqnarray*} (\nabla \textbf{v}, \nabla \textbf{u})_{\Omega} - &amp; (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q, \textrm{div}\; \textbf{u})_{\Omega} + \beta_1 (\textbf{v},\textbf{u})_{\Gamma} + \beta_2 (\nabla \textbf{v}, \nabla \textbf{u})_{\Gamma} = \beta_1 (\textbf{v},\textbf{g})_{\Gamma} + \beta_2 (\nabla \textbf{v}, \nabla \textbf{g})_{\Gamma}. \end{eqnarray*}
</p>
<p>Notice that the \(L^2\) penalization (<code>dim</code> equal to <code>spacedim</code>) and the Nitsche penalization (<code>dim</code> equal to <code>spacedim-1</code>) result in the exact same numerical implementation, thanks to the dimension independent capabilities of deal.II.</p>
<p><a class="anchor" id="Representationofand"></a></p><h4>Representation of Ω and Γ</h4>
<p>In this tutorial, both the embedded grid \(\Gamma\) and the embedding grid are described using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>. These two triangulations can be built from functions in the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace or by reading a mesh file produced with another application (e.g. GMSH, see the discussion in <a class="el" href="step_49.html">step-49</a>). This is slightly more general than what was previously done in <a class="el" href="step_60.html">step-60</a>.</p>
<p>The addition of the immersed boundary method, whether it is in the <code>dim=spacedim</code> or <code>dim&lt;spacedim</code> case, only introduces additional terms in the system matrix and the right-hand side of the system which result from the integration over \(\Gamma\). This does not modify the number of variables for which the problem must be solved. The challenge is thus related to the integrals that must be carried over \(\Gamma\).</p>
<p>As usual in finite elements we split this integral into contributions from all cells of the triangulation used to discretize \(\Gamma\), we transform the integral on \(K\) to an integral on the reference element \(\hat K\), where \(F_{K}\) is the mapping from \(\hat K\) to \(K\), and compute the integral on \(\hat K\) using a quadrature formula. For example:</p>
<p class="formulaDsp">
\[ \beta (\textbf{v},\textbf{u})_{\Gamma} = \sum_{K\in \Gamma} \int_{\hat K} \hat{\textbf{u}}(\hat x) (\textbf{v} \circ F_{K}) (\hat x) J_K (\hat x) \mathrm{d} \hat x = \sum_{K\in \Gamma} \sum_{i=1}^{n_q} \big(\hat{\textbf{u}}(\hat x_i) (\textbf{v} \circ F_{K}) (\hat x_i) J_K (\hat x_i) w_i \big) \]
</p>
<p>Computing this sum is non-trivial because we have to evaluate \((v_j \circ F_{K}) (\hat x_i)\). In general, if \(\Gamma\) and \(\Omega\) are not aligned, the point \(y_i = F_{K}(\hat x_i)\) is completely arbitrary with respect to \(\Omega\), and unless we figure out a way to interpolate all basis functions of \(V_h(\Omega)\) on an arbitrary point on \(\Omega\), we cannot compute the integral needed.</p>
<p>To evaluate \((v_j \circ F_{K}) (\hat x_i)\) the following steps needs to be taken (as shown in the picture below):</p>
<ul>
<li>For a given cell \(K\) in \(\Gamma\) compute the real point \(y_i \dealcoloneq F_{K} (\hat x_i)\), where \(x_i\) is one of the quadrature points used for the integral on \(K \subseteq \Gamma\). This is the easy part: <a class="el" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">FEValues::quadrature_point()</a> gives us the real-space locations of all quadrature points.</li>
<li>Find the cell of \(\Omega\) in which \(y_i\) lies. We shall call this element \(T\).</li>
<li>Find the reference coordinates within \(T\) of \(y_i\). For this, we need the inverse of the mapping \(G_T\) that transforms the reference element \(\hat T\) into the element \(T\): \(\hat y_i = G^{-1}_{T} (y_i)\).</li>
<li>Evaluate the basis function \(v_j\) of the \(\Omega\) mesh at this point \(\hat y_i\). This is, again, relatively simple using <a class="el" href="classFEValues.html">FEValues</a>.</li>
</ul>
<p align="center"></p>
<p><img src="https://www.dealii.org/images/steps/developer/step-60.C_interpolation.png" alt="" class="inline"/> </p>
<p>In <a class="el" href="step_60.html">step-60</a>, the second through fourth steps above were computed by calling, in turn,</p>
<ul>
<li><a class="el" href="namespaceGridTools.html#a2e10aeb1c8e76110a84b6945eac3aaf0">GridTools::find_active_cell_around_point()</a>, followed by</li>
<li><a class="el" href="classMapping.html#a38ba6aaa1745359910e1b465a0f5fb27">Mapping::transform_real_to_unit_cell()</a>. We then</li>
<li>construct a custom <a class="el" href="classQuadrature.html">Quadrature</a> formula, containing the point in the reference cell and then</li>
<li>construct an <a class="el" href="classFEValues.html">FEValues</a> object, with the given quadrature formula, and initialized with the cell obtained in the first step.</li>
</ul>
<p>Although this approach could work for the present case, it does not lends itself readily to parallel simulations using distributed triangulations. Indeed, since the position of the quadrature points on the cells of the embedded domain \(\Gamma\) do not match that of the embedding triangulation and since \(\Gamma\) is constantly moving, this would require that the triangulation representing \(\Gamma\) be stored in it's entirety for all of the processors. As the number of processor and the number of cells in \(\Gamma\) increases, this leads to a severe bottleneck in terms of memory. Consequently, an alternative strategy is sought in this step.</p>
<p><a class="anchor" id="Usingparticlestotrack"></a></p><h4>Using particles to track Γ</h4>
<p>Remember that for both the penalization approach ( \(\mathcal{L}^2\) or \(\mathcal{H}^1\)) and the Nitsche method, we want to compute integrals that are approximated by the quadrature. That is, we need to compute </p><p class="formulaDsp">
\[ \beta (\textbf{v},\textbf{u})_{\Gamma} = \sum_{K\in \Gamma} \sum_{i=1}^{n_q} \big(\hat{\textbf{u}}(\hat x_i) (\textbf{v} \circ F_{K}) (\hat x_i) J_K (\hat x_i) w_i \big) \]
</p>
<p> If you followed the discussion above, then you will recall that \(\textbf{u}\) and \(\textbf{v}\) are shape functions defined on the fluid mesh. The only things defined on the solid mesh are: \(F_K(\hat x_i)\), which is the location of a quadrature point on a solid cell that is part of \(\Gamma\), \(J_K\) is the determinant of its Jacobian, and \(w_i\) the corresponding quadrature weight.</p>
<p>The important part to realize is now this: \(w_i\) is a property of the quadrature formula and does not change with time. Furthermore, the Jacobian matrix of \(F_K\) itself changes as the solid obstacle moves around in the fluid, but because the solid is considered non-deforming (it only translates and rotates, but doesn't dilate), the determinant of the Jacobian remains constant. As a consequence, the product \(J_K(\hat x_i) w_i\) (which we typically denote by <code>JxW</code>) remains constant for each quadrature point. So the only thing we need keep track of are the positions \(x_i=F_K(\hat x_i)\) &ndash; but these move with the velocity of the solid domain.</p>
<p>In other words, we don't actually need to keep the solid mesh at all. All we need is the positions \(x_i(t)\) and corresponding <code>JxW</code> values. Since both of these properties are point-properties (or point-vectors) that are attached to the solid material, they can be idealized as a set of disconnected infinitesimally small "particles", which carry the required <code>JxW</code> information with the movement of the solid. deal.II has the ability to distribute and store such a set of particles in large-scale parallel computations in the form of the ParticleHandler class (for details on the implementation see <b>[GLHPW2018]</b>), and we will make use of this functionality in this tutorial.</p>
<p>Thus, the approach taken in this step is as follows:</p><ul>
<li>Create a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> for the domain \(\Gamma\);</li>
<li>Create <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a> at the positions of the quadrature points on \(\Gamma\);</li>
<li>Call the <a class="el" href="classParticles_1_1ParticleHandler.html#ac4bae8e82e7a021bd4c269f0df3f8bea">Particles::ParticleHandler::insert_global_particles()</a> function, to distribute the particles across processors, <em>following the solid triangulation</em>;</li>
<li>Attach the <code>JxW</code> values as a "property" to each <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a> object.</li>
</ul>
<p>This structure is relatively expensive to generate, but must only be generated once per simulation. Once the <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> is generated and the required information is attached to the particle, the integrals over \(\Gamma\) can be carried out by exploiting the fact that particles are grouped cellwise inside ParticleHandler, allowing us to:</p><ul>
<li>Looping over all cells of \(\Omega\) that contain at least one particle</li>
<li>Looping over all particles in the given cell</li>
<li>Compute the integrals and fill the global matrix.</li>
</ul>
<p>Since the <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> can manage the exchange of particles from one processor to the other, the embedded triangulation can be moved or deformed by displacing the particles. The only constraint associated with this displacement is that particles should be displaced by a distance that is no larger than the size of one cell. That's because that is the limit to which <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> can track which cell a particle that leaves its current cell now resides in.</p>
<p>Once the entire problem (the Stokes problem and the immersed boundary imposition) is assembled, the final saddle point problem is solved by an iterative solver, applied to the Schur complement \(S\) (whose construction is described, for example, in <a class="el" href="step_22.html">step-22</a>), and we construct \(S\) using <a class="el" href="classLinearOperator.html">LinearOperator</a> classes.</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The testcase</h3>
<p>The problem we solve here is a demonstration of the time-reversibility of Stokes flow. This is often illustrated in science education experiments with a Taylor-Couette flow and dye droplets that revert back to their original shape after the fluid has been displaced in a periodic manner.</p>
<p> 

<iframe width="560" height="315" src="https://www.youtube.com/embed/p08_KlTKP50" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

</p>
<p>In the present problem, a very viscous fluid is agitated by the rotation of an impeller, which, in 2D, is modeled by a rectangular grid. The impeller rotates for a given number of revolutions, after which the flow is reversed such that the same number of revolutions is carried out in the opposite direction. We recall that since the Stokes equations are self-adjoint, creeping flows are reversible. Consequently, if the impeller motion is reversed in the opposite direction, the fluid should return to its original position. In the present case, this is illustrated by inserting a circle of passive tracer particles that are advected by the fluid and which return to their original position, thus demonstrating the time-reversibility of the flow.</p>
<p><a class="anchor" id="Morereferences"></a></p><h3>More references</h3>
<p>This tutorial program uses a number of techniques on imposing velocity conditions on non-matching interfaces in the interior of the fluid. For more background material, you may want to look up the following references: <b>[Freund1995]</b>, <b>[Angot1999]</b>, <b>[Glowinski1999]</b>, <b>[Boffi2008]</b>, <b>[Heltai2012]</b>.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>Most of these have been introduced elsewhere, we'll comment only on the new ones. The switches close to the top that allow selecting between PETSc and Trilinos linear algebra capabilities are similar to the ones in <a class="el" href="step_40.html">step-40</a> and <a class="el" href="step_50.html">step-50</a>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__linear__operator_8h.html">deal.II/lac/block_linear_operator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="generic__linear__algebra_8h.html">deal.II/lac/generic_linear_algebra.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator_8h.html">deal.II/lac/linear_operator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator__tools_8h.html">deal.II/lac/linear_operator_tools.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define FORCE_USE_OF_TRILINOS</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>LA</div>
<div class="line">{</div>
<div class="line"><span class="preprocessor">#if defined(DEAL_II_WITH_PETSC) &amp;&amp; !defined(DEAL_II_PETSC_WITH_COMPLEX) &amp;&amp; \</span></div>
<div class="line"><span class="preprocessor">  !(defined(DEAL_II_WITH_TRILINOS) &amp;&amp; defined(FORCE_USE_OF_TRILINOS))</span></div>
<div class="line">  <span class="keyword">using namespace </span>dealii::LinearAlgebraPETSc;</div>
<div class="line"><span class="preprocessor">#  define USE_PETSC_LA</span></div>
<div class="line"><span class="preprocessor">#elif defined(DEAL_II_WITH_TRILINOS)</span></div>
<div class="line">  <span class="keyword">using namespace </span>dealii::LinearAlgebraTrilinos;</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor">#  error DEAL_II_WITH_PETSC or DEAL_II_WITH_TRILINOS required</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">} <span class="comment">// namespace LA</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="conditional__ostream_8h.html">deal.II/base/conditional_ostream.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__acceptor_8h.html">deal.II/base/parameter_acceptor.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parsed__function_8h.html">deal.II/base/parsed_function.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2grid__refinement_8h.html">deal.II/distributed/grid_refinement.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2solution__transfer_8h.html">deal.II/distributed/solution_transfer.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2tria_8h.html">deal.II/distributed/tria.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__nothing_8h.html">deal.II/fe/fe_nothing.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__fe__field_8h.html">deal.II/fe/mapping_fe_field.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q_8h.html">deal.II/fe/mapping_q.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__in_8h.html">deal.II/grid/grid_in.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__precondition_8h.html">deal.II/lac/petsc_precondition.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__solver_8h.html">deal.II/lac/petsc_solver.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__sparse__matrix_8h.html">deal.II/lac/petsc_sparse_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__vector_8h.html">deal.II/lac/petsc_vector.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__gmres_8h.html">deal.II/lac/solver_gmres.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__minres_8h.html">deal.II/lac/solver_minres.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparsity__tools_8h.html">deal.II/lac/sparsity_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div>
<div class="ttc" id="aaffine__constraints_8h_html"><div class="ttname"><a href="affine__constraints_8h.html">affine_constraints.h</a></div></div>
<div class="ttc" id="ablock__linear__operator_8h_html"><div class="ttname"><a href="block__linear__operator_8h.html">block_linear_operator.h</a></div></div>
<div class="ttc" id="aconditional__ostream_8h_html"><div class="ttname"><a href="conditional__ostream_8h.html">conditional_ostream.h</a></div></div>
<div class="ttc" id="adistributed_2grid__refinement_8h_html"><div class="ttname"><a href="distributed_2grid__refinement_8h.html">grid_refinement.h</a></div></div>
<div class="ttc" id="adistributed_2solution__transfer_8h_html"><div class="ttname"><a href="distributed_2solution__transfer_8h.html">solution_transfer.h</a></div></div>
<div class="ttc" id="adistributed_2tria_8h_html"><div class="ttname"><a href="distributed_2tria_8h.html">tria.h</a></div></div>
<div class="ttc" id="adof__renumbering_8h_html"><div class="ttname"><a href="dof__renumbering_8h.html">dof_renumbering.h</a></div></div>
<div class="ttc" id="adof__tools_8h_html"><div class="ttname"><a href="dof__tools_8h.html">dof_tools.h</a></div></div>
<div class="ttc" id="adofs_2dof__handler_8h_html"><div class="ttname"><a href="dofs_2dof__handler_8h.html">dof_handler.h</a></div></div>
<div class="ttc" id="adynamic__sparsity__pattern_8h_html"><div class="ttname"><a href="dynamic__sparsity__pattern_8h.html">dynamic_sparsity_pattern.h</a></div></div>
<div class="ttc" id="aerror__estimator_8h_html"><div class="ttname"><a href="error__estimator_8h.html">error_estimator.h</a></div></div>
<div class="ttc" id="afe_2fe__values_8h_html"><div class="ttname"><a href="fe_2fe__values_8h.html">fe_values.h</a></div></div>
<div class="ttc" id="afe__nothing_8h_html"><div class="ttname"><a href="fe__nothing_8h.html">fe_nothing.h</a></div></div>
<div class="ttc" id="afe__q_8h_html"><div class="ttname"><a href="fe__q_8h.html">fe_q.h</a></div></div>
<div class="ttc" id="afe__system_8h_html"><div class="ttname"><a href="fe__system_8h.html">fe_system.h</a></div></div>
<div class="ttc" id="afull__matrix_8h_html"><div class="ttname"><a href="full__matrix_8h.html">full_matrix.h</a></div></div>
<div class="ttc" id="afunction_8h_html"><div class="ttname"><a href="function_8h.html">function.h</a></div></div>
<div class="ttc" id="ageneric__linear__algebra_8h_html"><div class="ttname"><a href="generic__linear__algebra_8h.html">generic_linear_algebra.h</a></div></div>
<div class="ttc" id="agrid_2manifold__lib_8h_html"><div class="ttname"><a href="grid_2manifold__lib_8h.html">manifold_lib.h</a></div></div>
<div class="ttc" id="agrid__generator_8h_html"><div class="ttname"><a href="grid__generator_8h.html">grid_generator.h</a></div></div>
<div class="ttc" id="agrid__in_8h_html"><div class="ttname"><a href="grid__in_8h.html">grid_in.h</a></div></div>
<div class="ttc" id="agrid__tools_8h_html"><div class="ttname"><a href="grid__tools_8h.html">grid_tools.h</a></div></div>
<div class="ttc" id="ainclude_2deal_8II_2base_2utilities_8h_html"><div class="ttname"><a href="include_2deal_8II_2base_2utilities_8h.html">utilities.h</a></div></div>
<div class="ttc" id="aindex__set_8h_html"><div class="ttname"><a href="index__set_8h.html">index_set.h</a></div></div>
<div class="ttc" id="alinear__operator_8h_html"><div class="ttname"><a href="linear__operator_8h.html">linear_operator.h</a></div></div>
<div class="ttc" id="alinear__operator__tools_8h_html"><div class="ttname"><a href="linear__operator__tools_8h.html">linear_operator_tools.h</a></div></div>
<div class="ttc" id="amapping__fe__field_8h_html"><div class="ttname"><a href="mapping__fe__field_8h.html">mapping_fe_field.h</a></div></div>
<div class="ttc" id="amapping__q_8h_html"><div class="ttname"><a href="mapping__q_8h.html">mapping_q.h</a></div></div>
<div class="ttc" id="anumerics_2data__out_8h_html"><div class="ttname"><a href="numerics_2data__out_8h.html">data_out.h</a></div></div>
<div class="ttc" id="aparameter__acceptor_8h_html"><div class="ttname"><a href="parameter__acceptor_8h.html">parameter_acceptor.h</a></div></div>
<div class="ttc" id="aparsed__function_8h_html"><div class="ttname"><a href="parsed__function_8h.html">parsed_function.h</a></div></div>
<div class="ttc" id="apetsc__precondition_8h_html"><div class="ttname"><a href="petsc__precondition_8h.html">petsc_precondition.h</a></div></div>
<div class="ttc" id="apetsc__solver_8h_html"><div class="ttname"><a href="petsc__solver_8h.html">petsc_solver.h</a></div></div>
<div class="ttc" id="apetsc__sparse__matrix_8h_html"><div class="ttname"><a href="petsc__sparse__matrix_8h.html">petsc_sparse_matrix.h</a></div></div>
<div class="ttc" id="apetsc__vector_8h_html"><div class="ttname"><a href="petsc__vector_8h.html">petsc_vector.h</a></div></div>
<div class="ttc" id="aquadrature__lib_8h_html"><div class="ttname"><a href="quadrature__lib_8h.html">quadrature_lib.h</a></div></div>
<div class="ttc" id="asolver__cg_8h_html"><div class="ttname"><a href="solver__cg_8h.html">solver_cg.h</a></div></div>
<div class="ttc" id="asolver__gmres_8h_html"><div class="ttname"><a href="solver__gmres_8h.html">solver_gmres.h</a></div></div>
<div class="ttc" id="asolver__minres_8h_html"><div class="ttname"><a href="solver__minres_8h.html">solver_minres.h</a></div></div>
<div class="ttc" id="asparsity__tools_8h_html"><div class="ttname"><a href="sparsity__tools_8h.html">sparsity_tools.h</a></div></div>
<div class="ttc" id="atimer_8h_html"><div class="ttname"><a href="timer_8h.html">timer.h</a></div></div>
<div class="ttc" id="avector_8h_html"><div class="ttname"><a href="vector_8h.html">vector.h</a></div></div>
<div class="ttc" id="avector__tools_8h_html"><div class="ttname"><a href="vector__tools_8h.html">vector_tools.h</a></div></div>
</div><!-- fragment --><p>These are the only new include files with regard to <a class="el" href="step_60.html">step-60</a>. In this tutorial, the non-matching coupling between the solid and the fluid is computed using an intermediate data structure that keeps track of how the locations of quadrature points of the solid evolve within the fluid mesh. This data structure needs to keep track of the position of the quadrature points on each cell describing the solid domain, of the quadrature weights, and possibly of the normal vector to each point, if the solid domain is of co-dimension one.</p>
<p>Deal.II offers these facilities in the <a class="el" href="namespaceParticles.html">Particles</a> namespace, through the ParticleHandler class. ParticleHandler is a class that allows you to manage a collection of particles (objects of type <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a>), representing a collection of points with some attached properties (e.g., an id) floating on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>. The methods and classes in the namespace <a class="el" href="namespaceParticles.html">Particles</a> allows one to easily implement Particle-In-Cell methods and particle tracing on distributed triangulations.</p>
<p>We "abuse" this data structure to store information about the location of solid quadrature points embedded in the surrounding fluid grid, including integration weights, and possibly surface normals. The reason why we use this additional data structure is related to the fact that the solid and the fluid grids might be non-overlapping, and if we were using two separate triangulation objects, would be distributed independently among parallel processes.</p>
<p>In order to couple the two problems, we rely on the ParticleHandler class, storing in each particle the position of a solid quadrature point (which is in general not aligned to any of the fluid quadrature points), its weight, and any other information that may be required to couple the two problems. These locations are then propagated along with the (prescribed) velocity of the solid impeller.</p>
<p>Ownership of the solid quadrature points is initially inherited from the MPI partitioning on the solid mesh itself. The <a class="el" href="namespaceParticles.html">Particles</a> so generated are later distributed to the fluid mesh using the methods of the ParticleHandler class. This allows transparent exchange of information between MPI processes about the overlapping pattern between fluid cells and solid quadrature points.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="particles_2data__out_8h.html">deal.II/particles/data_out.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="generators_8h.html">deal.II/particles/generators.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="particle__handler_8h.html">deal.II/particles/particle_handler.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2particles_2utilities_8h.html">deal.II/particles/utilities.h</a>&gt;</span></div>
<div class="ttc" id="agenerators_8h_html"><div class="ttname"><a href="generators_8h.html">generators.h</a></div></div>
<div class="ttc" id="ainclude_2deal_8II_2particles_2utilities_8h_html"><div class="ttname"><a href="include_2deal_8II_2particles_2utilities_8h.html">utilities.h</a></div></div>
<div class="ttc" id="aparticle__handler_8h_html"><div class="ttname"><a href="particle__handler_8h.html">particle_handler.h</a></div></div>
<div class="ttc" id="aparticles_2data__out_8h_html"><div class="ttname"><a href="particles_2data__out_8h.html">data_out.h</a></div></div>
</div><!-- fragment --><p>When generating the grids, we allow reading it from a file, and if deal.II has been built with <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> support, we also allow reading CAD files and use them as manifold descriptors for the grid (see <a class="el" href="step_54.html">step-54</a> for a detailed description of the various <a class="el" href="classManifold.html">Manifold</a> descriptors that are available in the <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> namespace)</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="opencascade_2manifold__lib_8h.html">deal.II/opencascade/manifold_lib.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2opencascade_2utilities_8h.html">deal.II/opencascade/utilities.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#ifdef DEAL_II_WITH_OPENCASCADE</span></div>
<div class="line"><span class="preprocessor">#  include &lt;TopoDS.hxx&gt;</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>Step70</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
<div class="ttc" id="ainclude_2deal_8II_2opencascade_2utilities_8h_html"><div class="ttname"><a href="include_2deal_8II_2opencascade_2utilities_8h.html">utilities.h</a></div></div>
<div class="ttc" id="anamespacedealii_html"><div class="ttname"><a href="namespacedealii.html">dealii</a></div><div class="ttdef"><b>Definition:</b> <a href="namespace__dealii_8h_source.html#l00025">namespace_dealii.h:26</a></div></div>
<div class="ttc" id="aopencascade_2manifold__lib_8h_html"><div class="ttname"><a href="opencascade_2manifold__lib_8h.html">manifold_lib.h</a></div></div>
</div><!-- fragment --><p><a class="anchor" id="Runtimeparameterhandling"></a> </p><h3>Run-time parameter handling</h3>
<p>Similarly to what we have done in <a class="el" href="step_60.html">step-60</a>, we set up a class that holds all the parameters of our problem and derive it from the <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> class to simplify the management and creation of parameter files.</p>
<p>The <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> paradigm requires all parameters to be writable by the <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> methods. In order to avoid bugs that would be very difficult to track down (such as writing things like <code>time = 0</code> instead of <code>time == 0</code>), we declare all the parameters in an external class, which is initialized before the actual <code>StokesImmersedProblem</code> class, and pass it to the main class as a <code>const</code> reference.</p>
<p>The constructor of the class is responsible for the connection between the members of this class and the corresponding entries in the <a class="el" href="classParameterHandler.html">ParameterHandler</a>. Thanks to the use of the <a class="el" href="classParameterHandler.html#a04b75c02037d19fd7fd781785fcefc79">ParameterHandler::add_parameter()</a> method, this connection is trivial, but requires all members of this class to be writeable.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim = dim&gt;</div>
<div class="line"><span class="keyword">class </span>StokesImmersedProblemParameters : <span class="keyword">public</span> <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  StokesImmersedProblemParameters();</div>
<div class="ttc" id="aclassParameterAcceptor_html"><div class="ttname"><a href="classParameterAcceptor.html">ParameterAcceptor</a></div><div class="ttdef"><b>Definition:</b> <a href="parameter__acceptor_8h_source.html#l00348">parameter_acceptor.h:349</a></div></div>
</div><!-- fragment --><p>however, since this class will be passed as a <code>const</code> reference to the StokesImmersedProblem class, we have to make sure we can still set the time correctly in the objects derived by the <a class="el" href="classFunction.html">Function</a> class defined herein. In order to do so, we declare both the <code>StokesImmersedProblemParameters::rhs</code> and <code>StokesImmersedProblemParameters::angular_velocity</code> members to be <code>mutable</code>, and define the following little helper method that sets their time to the correct value.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> set_time(<span class="keyword">const</span> <span class="keywordtype">double</span> &amp;time)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  rhs.set_time(time);</div>
<div class="line">  angular_velocity.set_time(time);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The remainder of the class consists largely of member variables that describe the details of the simulation and its discretization. The following parameters are about where output should land, the spatial and temporal discretization (the default is the \(Q_2\times Q_1\) Taylor-Hood discretization which uses a polynomial degree of 2 for the velocity), and how many time steps should elapse before we generate graphical output again:</p>
<div class="fragment"><div class="line">std::string output_directory = <span class="stringliteral">&quot;.&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> velocity_degree = 2;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> number_of_time_steps = 501;</div>
<div class="line"><span class="keywordtype">double</span>       final_time           = 1.0;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> output_frequency = 1;</div>
</div><!-- fragment --><p>We allow every grid to be refined independently. In this tutorial, no physics is resolved on the solid grid, and its velocity is given as a datum. However it is relatively straightforward to incorporate some elasticity model in this tutorial, and transform it into a fully fledged FSI solver.</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_fluid_refinement      = 5;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_solid_refinement      = 5;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> particle_insertion_refinement = 3;</div>
</div><!-- fragment --><p>To provide a rough description of the fluid domain, we use the method <a class="el" href="rtree_8h.html#a3591e6e032b1a56920f897a2bc387d43">extract_rtree_level()</a> applied to the tree of bounding boxes of each locally owned cell of the fluid triangulation. The higher the level of the tree, the larger the number of extracted bounding boxes, and the more accurate is the description of the fluid domain. However, a large number of bounding boxes also implies a large communication cost, since the collection of bounding boxes is gathered by all processes.</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fluid_rtree_extraction_level = 1;</div>
</div><!-- fragment --><p>The only two numerical parameters used in the equations are the viscosity of the fluid, and the penalty term \(\beta\) used in the Nitsche formulation:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> viscosity    = 1.0;</div>
<div class="line"><span class="keywordtype">double</span> penalty_term = 100;</div>
</div><!-- fragment --><p>By default, we create a hyper_cube without colorization, and we use homogeneous Dirichlet boundary conditions. In this set we store the boundary ids to use when setting the boundary conditions:</p>
<div class="fragment"><div class="line">std::list&lt;types::boundary_id&gt; homogeneous_dirichlet_ids{0};</div>
</div><!-- fragment --><p>We illustrate here another way to create a <a class="el" href="classTriangulation.html">Triangulation</a> from a parameter file, using the method <a class="el" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments()</a>, that takes the name of a function in the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace, and its arguments as a single string representing the arguments as a tuple.</p>
<p>The mechanism with which the arguments are parsed from and to a string is explained in detail in the <a class="el" href="structPatterns_1_1Tools_1_1Convert.html">Patterns::Tools::Convert</a> class, which is used to translate from strings to most of the basic STL types (vectors, maps, tuples) and basic deal.II types (<a class="el" href="classPoint.html">Point</a>, <a class="el" href="classTensor.html">Tensor</a>, <a class="el" href="classBoundingBox.html">BoundingBox</a>, etc.).</p>
<p>In general objects that can be represented by rank 1 uniform elements (i.e., std::vector&lt;double&gt;, Point&lt;dim&gt;, std::set&lt;int&gt;, etc.) are comma separated. Additional ranks take a semicolon, allowing you to parse strings into objects of type <code>std::vector&lt;std::vector&lt;double&gt;&gt;</code>, or, for example, <code>std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;dim&gt;&gt;</code>, as <code>0.0, 0.1; 0.1, 0.2</code>. This string could be interpreted as a vector of two <a class="el" href="classPoint.html">Point</a> objects, or a vector of vector of doubles.</p>
<p>When the entries are not uniform, as in the tuple case, we use a colon to separate the various entries. For example, a string like <code>5: 0.1, 0.2</code> could be used to parse an object of type <code>std::pair&lt;int, <a class="el" href="classPoint.html">Point</a>&lt;2&gt;&gt;</code> or a <code>std::tuple&lt;int, std::vector&lt;double&gt;&gt;</code>.</p>
<p>In our case most of the arguments are <a class="el" href="classPoint.html">Point</a> objects (representing centers, corners, subdivision elements, etc.), integer values (number of subdivisions), double values (radius, lengths, etc.), or boolean options (such as the <code>colorize</code> option that many <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> functions take).</p>
<p>In the example below, we set reasonable default values, but these can be changed at run time by selecting any other supported function of the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace. If the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> function fails, this program will interpret the name of the grid as a vtk grid filename, and the arguments as a map from manifold_id to the CAD files describing the geometry of the domain. Every CAD file will be analyzed and a <a class="el" href="classManifold.html">Manifold</a> of the <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> namespace will be generated according to the content of the CAD file itself.</p>
<p>To be as generic as possible, we do this for each of the generated grids: the fluid grid, the solid grid, but also the tracer particles which are also generated using a triangulation.</p>
<div class="fragment"><div class="line">std::string name_of_fluid_grid       = <span class="stringliteral">&quot;hyper_cube&quot;</span>;</div>
<div class="line">std::string arguments_for_fluid_grid = <span class="stringliteral">&quot;-1: 1: false&quot;</span>;</div>
<div class="line">std::string name_of_solid_grid       = <span class="stringliteral">&quot;hyper_rectangle&quot;</span>;</div>
<div class="line">std::string arguments_for_solid_grid = spacedim == 2 ?</div>
<div class="line">                                         <span class="stringliteral">&quot;-.5, -.1: .5, .1: false&quot;</span> :</div>
<div class="line">                                         <span class="stringliteral">&quot;-.5, -.1, -.1: .5, .1, .1: false&quot;</span>;</div>
<div class="line">std::string name_of_particle_grid = <span class="stringliteral">&quot;hyper_ball&quot;</span>;</div>
<div class="line">std::string arguments_for_particle_grid =</div>
<div class="line">  spacedim == 2 ? <span class="stringliteral">&quot;0.3, 0.3: 0.1: false&quot;</span> : <span class="stringliteral">&quot;0.3, 0.3, 0.3 : 0.1: false&quot;</span>;</div>
</div><!-- fragment --><p>Similarly, we allow for different local refinement strategies. In particular, we limit the maximum number of refinement levels, in order to control the minimum size of the fluid grid, and guarantee that it is compatible with the solid grid. The minimum number of refinement levels is also controlled to ensured sufficient accuracy in the bulk of the flow. Additionally, we perform local refinement based on standard error estimators on the fluid velocity field.</p>
<p>We permit the user to choose between the two most common refinement strategies, namely <code>fixed_number</code> or <code>fixed_fraction</code>, that refer to the methods <a class="el" href="namespaceGridRefinement.html#ae90dc87c4db158b8d01f6d564ac614e5">GridRefinement::refine_and_coarsen_fixed_fraction()</a> and <a class="el" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number()</a>.</p>
<p>Refinement may be done every few time steps, instead of continuously, and we control this value by the <code>refinement_frequency</code> parameter:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span>          max_level_refinement = 8;</div>
<div class="line"><span class="keywordtype">int</span>          min_level_refinement = 5;</div>
<div class="line">std::string  refinement_strategy  = <span class="stringliteral">&quot;fixed_fraction&quot;</span>;</div>
<div class="line"><span class="keywordtype">double</span>       coarsening_fraction  = 0.3;</div>
<div class="line"><span class="keywordtype">double</span>       refinement_fraction  = 0.3;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_cells            = 20000;</div>
<div class="line"><span class="keywordtype">int</span>          refinement_frequency = 5;</div>
</div><!-- fragment --><p>Finally, the following two function objects are used to control the source term of Stokes flow and the angular velocity at which we move the solid body. In a more realistic simulation, the solid velocity or its deformation would come from the solution of an auxiliary problem on the solid domain. In this example step we leave this part aside, and simply impose a fixed rotational velocity field along the z-axis on the immersed solid, governed by a function that can be specified in the parameter file :</p>
<div class="fragment"><div class="line">  <span class="keyword">mutable</span> <a class="code" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy&lt;Functions::ParsedFunction&lt;spacedim&gt;</a>&gt; rhs;</div>
<div class="line">  <span class="keyword">mutable</span> <a class="code" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy&lt;Functions::ParsedFunction&lt;spacedim&gt;</a>&gt;</div>
<div class="line">    angular_velocity;</div>
<div class="line">};</div>
<div class="ttc" id="aclassParameterAcceptorProxy_html"><div class="ttname"><a href="classParameterAcceptorProxy.html">ParameterAcceptorProxy</a></div><div class="ttdef"><b>Definition:</b> <a href="parameter__acceptor_8h_source.html#l00668">parameter_acceptor.h:669</a></div></div>
</div><!-- fragment --><p>There remains the task of declaring what run-time parameters we can accept in input files. We split the parameters in various categories, by putting them in different sections of the <a class="el" href="classParameterHandler.html">ParameterHandler</a> class. We begin by declaring all the global parameters used by StokesImmersedProblem in the global scope:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">StokesImmersedProblemParameters&lt;dim,</div>
<div class="line">                                spacedim&gt;::StokesImmersedProblemParameters()</div>
<div class="line">  : <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a>(<span class="stringliteral">&quot;Stokes Immersed Problem/&quot;</span>)</div>
<div class="line">  , rhs(<span class="stringliteral">&quot;Right hand side&quot;</span>, spacedim + 1)</div>
<div class="line">  , angular_velocity(<span class="stringliteral">&quot;Angular velocity&quot;</span>)</div>
<div class="line">{</div>
<div class="line">  add_parameter(</div>
<div class="line">    <span class="stringliteral">&quot;Velocity degree&quot;</span>, velocity_degree, <span class="stringliteral">&quot;&quot;</span>, this-&gt;prm, <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1));</div>
<div class="line"> </div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Number of time steps&quot;</span>, number_of_time_steps);</div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Output frequency&quot;</span>, output_frequency);</div>
<div class="line"> </div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Output directory&quot;</span>, output_directory);</div>
<div class="line"> </div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Final time&quot;</span>, final_time);</div>
<div class="line"> </div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Viscosity&quot;</span>, viscosity);</div>
<div class="line"> </div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Nitsche penalty term&quot;</span>, penalty_term);</div>
<div class="line"> </div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Initial fluid refinement&quot;</span>,</div>
<div class="line">                initial_fluid_refinement,</div>
<div class="line">                <span class="stringliteral">&quot;Initial mesh refinement used for the fluid domain Omega&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Initial solid refinement&quot;</span>,</div>
<div class="line">                initial_solid_refinement,</div>
<div class="line">                <span class="stringliteral">&quot;Initial mesh refinement used for the solid domain Gamma&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Fluid bounding boxes extraction level&quot;</span>,</div>
<div class="line">                fluid_rtree_extraction_level,</div>
<div class="line">                <span class="stringliteral">&quot;Extraction level of the rtree used to construct global &quot;</span></div>
<div class="line">                <span class="stringliteral">&quot;bounding boxes&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  add_parameter(</div>
<div class="line">    <span class="stringliteral">&quot;Particle insertion refinement&quot;</span>,</div>
<div class="line">    particle_insertion_refinement,</div>
<div class="line">    <span class="stringliteral">&quot;Refinement of the volumetric mesh used to insert the particles&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  add_parameter(</div>
<div class="line">    <span class="stringliteral">&quot;Homogeneous Dirichlet boundary ids&quot;</span>,</div>
<div class="line">    homogeneous_dirichlet_ids,</div>
<div class="line">    <span class="stringliteral">&quot;Boundary Ids over which homogeneous Dirichlet boundary conditions are applied&quot;</span>);</div>
<div class="ttc" id="aclassPatterns_1_1Integer_html"><div class="ttname"><a href="classPatterns_1_1Integer.html">Patterns::Integer</a></div><div class="ttdef"><b>Definition:</b> <a href="patterns_8h_source.html#l00189">patterns.h:190</a></div></div>
</div><!-- fragment --><p>Next section is dedicated to the parameters used to create the various grids. We will need three different triangulations: <code>Fluid grid</code> is used to define the fluid domain, <code>Solid grid</code> defines the solid domain, and <code>Particle grid</code> is used to distribute some tracer particles, that are advected with the velocity and only used as passive tracers.</p>
<div class="fragment"><div class="line">enter_subsection(<span class="stringliteral">&quot;Grid generation&quot;</span>);</div>
<div class="line">{</div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Fluid grid generator&quot;</span>, name_of_fluid_grid);</div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Fluid grid generator arguments&quot;</span>, arguments_for_fluid_grid);</div>
<div class="line"> </div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Solid grid generator&quot;</span>, name_of_solid_grid);</div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Solid grid generator arguments&quot;</span>, arguments_for_solid_grid);</div>
<div class="line"> </div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Particle grid generator&quot;</span>, name_of_particle_grid);</div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Particle grid generator arguments&quot;</span>,</div>
<div class="line">                arguments_for_particle_grid);</div>
<div class="line">}</div>
<div class="line">leave_subsection();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">enter_subsection(<span class="stringliteral">&quot;Refinement and remeshing&quot;</span>);</div>
<div class="line">{</div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Refinement step frequency&quot;</span>, refinement_frequency);</div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Refinement maximal level&quot;</span>, max_level_refinement);</div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Refinement minimal level&quot;</span>, min_level_refinement);</div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Refinement strategy&quot;</span>,</div>
<div class="line">                refinement_strategy,</div>
<div class="line">                <span class="stringliteral">&quot;&quot;</span>,</div>
<div class="line">                this-&gt;prm,</div>
<div class="line">                <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;fixed_fraction|fixed_number&quot;</span>));</div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Refinement coarsening fraction&quot;</span>, coarsening_fraction);</div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Refinement fraction&quot;</span>, refinement_fraction);</div>
<div class="line">  add_parameter(<span class="stringliteral">&quot;Maximum number of cells&quot;</span>, max_cells);</div>
<div class="line">}</div>
<div class="line">leave_subsection();</div>
<div class="ttc" id="aclassPatterns_1_1Selection_html"><div class="ttname"><a href="classPatterns_1_1Selection.html">Patterns::Selection</a></div><div class="ttdef"><b>Definition:</b> <a href="patterns_8h_source.html#l00382">patterns.h:383</a></div></div>
</div><!-- fragment --><p>The final task is to correct the default dimension for the right hand side function and define a meaningful default angular velocity instead of zero.</p>
<div class="fragment"><div class="line">  rhs.declare_parameters_call_back.connect([&amp;]() {</div>
<div class="line">    <a class="code" href="classFunctions_1_1ParsedFunction.html#a57fd4a680441ae940812431a421c9c40">Functions::ParsedFunction&lt;spacedim&gt;::declare_parameters</a>(this-&gt;prm,</div>
<div class="line">                                                            spacedim + 1);</div>
<div class="line">  });</div>
<div class="line">  angular_velocity.declare_parameters_call_back.connect([&amp;]() {</div>
<div class="line">    this-&gt;prm.set(<span class="stringliteral">&quot;Function expression&quot;</span>,</div>
<div class="line">                  <span class="stringliteral">&quot;t &lt; .500001 ? 6.283185 : -6.283185&quot;</span>);</div>
<div class="line">  });</div>
<div class="line">}</div>
<div class="ttc" id="aclassFunctions_1_1ParsedFunction_html_a57fd4a680441ae940812431a421c9c40"><div class="ttname"><a href="classFunctions_1_1ParsedFunction.html#a57fd4a680441ae940812431a421c9c40">Functions::ParsedFunction::declare_parameters</a></div><div class="ttdeci">static void declare_parameters(ParameterHandler &amp;prm, const unsigned int n_components=1)</div><div class="ttdef"><b>Definition:</b> <a href="parsed__function_8cc_source.html#l00036">parsed_function.cc:36</a></div></div>
</div><!-- fragment --><p>Once the angular velocity is provided as a <a class="el" href="classFunction.html">Function</a> object, we reconstruct the pointwise solid velocity through the following class which derives from the <a class="el" href="classFunction.html">Function</a> class. It provides the value of the velocity of the solid body at a given position by assuming that the body rotates around the origin (or the \(z\) axis in 3d) with a given angular velocity.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line"><span class="keyword">class </span>SolidVelocity : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;spacedim&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  static_assert(spacedim &gt; 1,</div>
<div class="line">                <span class="stringliteral">&quot;Cannot instantiate SolidVelocity for spacedim == 1&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  SolidVelocity(<span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity)</div>
<div class="line">    : angular_velocity(angular_velocity)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;spacedim&gt;</a> &amp;p,</div>
<div class="line">                       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>           component = 0)<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, spacedim&gt;</a> velocity;</div>
<div class="ttc" id="aclassFunction_html"><div class="ttname"><a href="classFunction.html">Function</a></div><div class="ttdef"><b>Definition:</b> <a href="function_8h_source.html#l00150">function.h:153</a></div></div>
<div class="ttc" id="aclassFunction_html_acbfcab66b2fc63bfea59268f40772bb4"><div class="ttname"><a href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">Function::value</a></div><div class="ttdeci">virtual RangeNumberType value(const Point&lt; dim &gt; &amp;p, const unsigned int component=0) const</div></div>
<div class="ttc" id="aclassFunctions_1_1ParsedFunction_html"><div class="ttname"><a href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction</a></div><div class="ttdef"><b>Definition:</b> <a href="parsed__function_8h_source.html#l00080">parsed_function.h:81</a></div></div>
<div class="ttc" id="aclassPoint_html"><div class="ttname"><a href="classPoint.html">Point&lt; spacedim &gt;</a></div></div>
<div class="ttc" id="aclassTensor_html"><div class="ttname"><a href="classTensor.html">Tensor&lt; 1, spacedim &gt;</a></div></div>
</div><!-- fragment --><p>We assume that the angular velocity is directed along the z-axis, i.e., we model the actual angular velocity as if it was a two-dimensional rotation, irrespective of the actual value of <code>spacedim</code>.</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> omega = angular_velocity.value(p);</div>
<div class="line">    velocity[0]        = -omega * p[1];</div>
<div class="line">    velocity[1]        = omega * p[0];</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> velocity[component];</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Similarly, we assume that the solid position can be computed explicitly at each time step, exploiting the knowledge of the angular velocity. We compute the exact position of the solid particle assuming that the solid is rotated by an amount equal to the time step multiplied by the angular velocity computed at the point <code>p</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line"><span class="keyword">class </span>SolidPosition : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;spacedim&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  static_assert(spacedim &gt; 1,</div>
<div class="line">                <span class="stringliteral">&quot;Cannot instantiate SolidPosition for spacedim == 1&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  SolidPosition(<span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity,</div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span>                               time_step)</div>
<div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;spacedim&gt;(spacedim)</div>
<div class="line">    , angular_velocity(angular_velocity)</div>
<div class="line">    , time_step(time_step)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;spacedim&gt;</a> &amp;p,</div>
<div class="line">                       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>           component = 0)<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <a class="code" href="classPoint.html">Point&lt;spacedim&gt;</a> new_position = p;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> dtheta = angular_velocity.value(p) * time_step;</div>
<div class="line"> </div>
<div class="line">    new_position[0] = <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">std::cos</a>(dtheta) * p[0] - <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">std::sin</a>(dtheta) * p[1];</div>
<div class="line">    new_position[1] = <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">std::sin</a>(dtheta) * p[0] + <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">std::cos</a>(dtheta) * p[1];</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> new_position[component];</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> set_time_step(<span class="keyword">const</span> <span class="keywordtype">double</span> new_time_step)</div>
<div class="line">  {</div>
<div class="line">    time_step = new_time_step;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity;</div>
<div class="line">  <span class="keywordtype">double</span>                                     time_step;</div>
<div class="line">};</div>
<div class="ttc" id="anumbers_8h_html_a02761f62f66f685e954daed42bcb3a1b"><div class="ttname"><a href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">std::cos</a></div><div class="ttdeci">::VectorizedArray&lt; Number, width &gt; cos(const ::VectorizedArray&lt; Number, width &gt; &amp;)</div><div class="ttdef"><b>Definition:</b> <a href="vectorization_8h_source.html#l05318">vectorization.h:5318</a></div></div>
<div class="ttc" id="anumbers_8h_html_a27989bdc7b4b828564982787d126bd91"><div class="ttname"><a href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">std::sin</a></div><div class="ttdeci">::VectorizedArray&lt; Number, width &gt; sin(const ::VectorizedArray&lt; Number, width &gt; &amp;)</div><div class="ttdef"><b>Definition:</b> <a href="vectorization_8h_source.html#l05291">vectorization.h:5291</a></div></div>
</div><!-- fragment --><p><a class="anchor" id="TheStokesImmersedProblemclassdeclaration"></a> </p><h3>The StokesImmersedProblem class declaration</h3>
<p>We are now ready to introduce the main class of our tutorial program. As usual, other than the constructor, we leave a single public entry point: the <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> method. Everything else is left <code>private</code>, and accessed through the run method itself.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim = dim&gt;</div>
<div class="line"><span class="keyword">class </span>StokesImmersedProblem</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  StokesImmersedProblem(</div>
<div class="line">    <span class="keyword">const</span> StokesImmersedProblemParameters&lt;dim, spacedim&gt; &amp;par);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div>
<div class="ttc" id="anamespaceWorkStream_1_1internal_1_1tbb__no__coloring_html_a8673698a405bf47aa24002aeb6d76d70"><div class="ttname"><a href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">WorkStream::internal::tbb_no_coloring::run</a></div><div class="ttdeci">void run(const Iterator &amp;begin, const typename identity&lt; Iterator &gt;::type &amp;end, Worker worker, Copier copier, const ScratchData &amp;sample_scratch_data, const CopyData &amp;sample_copy_data, const unsigned int queue_length, const unsigned int chunk_size)</div><div class="ttdef"><b>Definition:</b> <a href="work__stream_8h_source.html#l00691">work_stream.h:691</a></div></div>
</div><!-- fragment --><p>The next section contains the <code>private</code> members of the class. The first method is similar to what is present in previous example. However it not only takes care of generating the grid for the fluid, but also the grid for the solid. The second computes the largest time step that guarantees that each particle moves of at most one cell. This is important to ensure that the <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> can find which cell a particle ends up in, as it can only look from one cell to its immediate neighbors (because, in a parallel setting, every MPI process only knows about the cells it owns as well as their immediate neighbors).</p>
<div class="fragment"><div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">void</span> make_grid();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">double</span> compute_time_step() <span class="keyword">const</span>;</div>
</div><!-- fragment --><p>The next two functions initialize the <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> objects used in this class. We have two such objects: One represents passive tracers, used to plot the trajectories of fluid particles, while the the other represents material particles of the solid, which are placed at quadrature points of the solid grid.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> setup_tracer_particles();</div>
<div class="line"><span class="keywordtype">void</span> setup_solid_particles();</div>
</div><!-- fragment --><p>The remainder of the set up is split in two parts: The first of the following two functions creates all objects that are needed once per simulation, whereas the other sets up all objects that need to be reinitialized at every refinement step.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> initial_setup();</div>
<div class="line"><span class="keywordtype">void</span> setup_dofs();</div>
</div><!-- fragment --><p>The assembly routine is very similar to other Stokes assembly routines, with the exception of the Nitsche restriction part, which exploits one of the particle handlers to integrate on a non-matching part of the fluid domain, corresponding to the position of the solid. We split these two parts into two separate functions.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> assemble_stokes_system();</div>
<div class="line"><span class="keywordtype">void</span> assemble_nitsche_restriction();</div>
</div><!-- fragment --><p>The remaining functions solve the linear system (which looks almost identical to the one in <a class="el" href="step_60.html">step-60</a>) and then postprocess the solution: The refine_and_transfer() method is called only every <code>refinement_frequency</code> steps to adapt the mesh and also make sure that all the fields that were computed on the time step before refinement are transferred correctly to the new grid. This includes vector fields, as well as particle information. Similarly, we call the two output methods only every <code>output_frequency</code> steps.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> solve();</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> refine_and_transfer();</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle, <span class="keyword">const</span> <span class="keywordtype">double</span> time) <span class="keyword">const</span>;</div>
<div class="line"><span class="keywordtype">void</span> output_particles(<span class="keyword">const</span> <a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> &amp;particles,</div>
<div class="line">                      std::string                                 fprefix,</div>
<div class="line">                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                          iter,</div>
<div class="line">                      <span class="keyword">const</span> <span class="keywordtype">double</span> time) <span class="keyword">const</span>;</div>
<div class="ttc" id="aclassParticles_1_1ParticleHandler_html"><div class="ttname"><a href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a></div><div class="ttdef"><b>Definition:</b> <a href="particle__handler_8h_source.html#l00061">particle_handler.h:62</a></div></div>
</div><!-- fragment --><p>Let us then move on to the member functions of the class. The first deals with run-time parameters that are read from a parameter file. As noted before, we make sure we cannot modify this object from within this class, by making it a <code>const</code> reference.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> StokesImmersedProblemParameters&lt;dim, spacedim&gt; &amp;par;</div>
</div><!-- fragment --><p>Then there is also the MPI communicator object that we will use to let processes send information across the network if the program runs in parallel, along with the <code>pcout</code> object and timer information that has also been employed by <a class="el" href="step_40.html">step-40</a>, for example:</p>
<div class="fragment"><div class="line">MPI_Comm mpi_communicator;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">mutable</span> <a class="code" href="classTimerOutput.html">TimerOutput</a> computing_timer;</div>
<div class="ttc" id="aclassConditionalOStream_html"><div class="ttname"><a href="classConditionalOStream.html">ConditionalOStream</a></div><div class="ttdef"><b>Definition:</b> <a href="conditional__ostream_8h_source.html#l00080">conditional_ostream.h:81</a></div></div>
<div class="ttc" id="aclassTimerOutput_html"><div class="ttname"><a href="classTimerOutput.html">TimerOutput</a></div><div class="ttdef"><b>Definition:</b> <a href="timer_8h_source.html#l00544">timer.h:545</a></div></div>
</div><!-- fragment --><p>Next is one of the main novelties with regard to <a class="el" href="step_60.html">step-60</a>. Here we assume that both the solid and the fluid are fully distributed triangulations. This allows the problem to scale to a very large number of degrees of freedom, at the cost of communicating all the overlapping regions between non matching triangulations. This is especially tricky, since we make no assumptions on the relative position or distribution of the various subdomains of the two triangulations. In particular, we assume that every process owns only a part of the <code>solid_tria</code>, and only a part of the <code>fluid_tria</code>, not necessarily in the same physical region, and not necessarily overlapping.</p>
<p>We could in principle try to create the initial subdivisions in such a way that each process's subdomains overlap between the solid and the fluid regions. However, this overlap would be destroyed during the simulation, and we would have to redistribute the DoFs again and again. The approach we follow in this tutorial is more flexible, and not much more expensive. We make two all-to-all communications at the beginning of the simulation to exchange information about an (approximate) information of the geometrical occupancy of each processor (done through a collection of bounding boxes).</p>
<p>This information is used by the <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> class to exchange (using a some-to-some communication pattern) all particles, so that every process knows about the particles that live on the region occupied by the fluid subdomain that it owns.</p>
<p>In order to couple the overlapping regions, we exploit the facilities implemented in the ParticleHandler class.</p>
<div class="fragment"><div class="line"><a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;spacedim&gt;</a>      fluid_tria;</div>
<div class="line"><a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim, spacedim&gt;</a> solid_tria;</div>
<div class="ttc" id="aclassparallel_1_1distributed_1_1Triangulation_html"><div class="ttname"><a href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a></div><div class="ttdef"><b>Definition:</b> <a href="distributed_2tria_8h_source.html#l00252">tria.h:254</a></div></div>
</div><!-- fragment --><p>Next come descriptions of the finite elements in use, along with appropriate quadrature formulas and the corresponding <a class="el" href="classDoFHandler.html">DoFHandler</a> objects. For the current implementation, only <code>fluid_fe</code> is really necessary. For completeness, and to allow easy extension, we also keep the <code>solid_fe</code> around, which is however initialized to a <a class="el" href="classFE__Nothing.html">FE_Nothing</a> finite element space, i.e., one that has no degrees of freedom.</p>
<p>We declare both finite element spaces as <code>std::unique_ptr</code> objects rather than regular member variables, to allow their generation after <code>StokesImmersedProblemParameters</code> has been initialized. In particular, they will be initialized in the <code>initial_setup()</code> method.</p>
<div class="fragment"><div class="line">std::unique_ptr&lt;FiniteElement&lt;spacedim&gt;&gt;      fluid_fe;</div>
<div class="line">std::unique_ptr&lt;FiniteElement&lt;dim, spacedim&gt;&gt; solid_fe;</div>
<div class="line"> </div>
<div class="line">std::unique_ptr&lt;Quadrature&lt;spacedim&gt;&gt; fluid_quadrature_formula;</div>
<div class="line">std::unique_ptr&lt;Quadrature&lt;dim&gt;&gt;      solid_quadrature_formula;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;spacedim&gt;</a>      fluid_dh;</div>
<div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim, spacedim&gt;</a> solid_dh;</div>
<div class="line"> </div>
<div class="line">std::unique_ptr&lt;MappingFEField&lt;dim, spacedim&gt;&gt; solid_mapping;</div>
<div class="ttc" id="aclassDoFHandler_html"><div class="ttname"><a href="classDoFHandler.html">DoFHandler</a></div><div class="ttdef"><b>Definition:</b> <a href="dofs_2dof__handler_8h_source.html#l00314">dof_handler.h:315</a></div></div>
</div><!-- fragment --><p>Similarly to how things are done in <a class="el" href="step_22.html">step-22</a>, we use a block system to treat the Stokes part of the problem, and follow very closely what was done there.</p>
<div class="fragment"><div class="line">std::vector&lt;IndexSet&gt; fluid_owned_dofs;</div>
<div class="line">std::vector&lt;IndexSet&gt; solid_owned_dofs;</div>
<div class="line"> </div>
<div class="line">std::vector&lt;IndexSet&gt; fluid_relevant_dofs;</div>
<div class="line">std::vector&lt;IndexSet&gt; solid_relevant_dofs;</div>
</div><!-- fragment --><p>Using this partitioning of degrees of freedom, we can then define all of the objects necessary to describe the linear systems in question:</p>
<div class="fragment"><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="namespaceLinearAlgebraDealII.html#a34f060e2c5e047fdc12c76d047c7c098">LA::MPI::BlockSparseMatrix</a> system_matrix;</div>
<div class="line"><a class="code" href="namespaceLinearAlgebraDealII.html#a34f060e2c5e047fdc12c76d047c7c098">LA::MPI::BlockSparseMatrix</a> preconditioner_matrix;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="namespaceLinearAlgebraDealII.html#aa4543bb429e129431d48d18c1bfebae3">LA::MPI::BlockVector</a> solution;</div>
<div class="line"><a class="code" href="namespaceLinearAlgebraDealII.html#aa4543bb429e129431d48d18c1bfebae3">LA::MPI::BlockVector</a> locally_relevant_solution;</div>
<div class="line"><a class="code" href="namespaceLinearAlgebraDealII.html#aa4543bb429e129431d48d18c1bfebae3">LA::MPI::BlockVector</a> system_rhs;</div>
<div class="ttc" id="aclassAffineConstraints_html"><div class="ttname"><a href="classAffineConstraints.html">AffineConstraints&lt; double &gt;</a></div></div>
<div class="ttc" id="anamespaceLinearAlgebraDealII_html_a34f060e2c5e047fdc12c76d047c7c098"><div class="ttname"><a href="namespaceLinearAlgebraDealII.html#a34f060e2c5e047fdc12c76d047c7c098">LinearAlgebraDealII::BlockSparseMatrix</a></div><div class="ttdeci">BlockSparseMatrix&lt; double &gt; BlockSparseMatrix</div><div class="ttdef"><b>Definition:</b> <a href="generic__linear__algebra_8h_source.html#l00058">generic_linear_algebra.h:58</a></div></div>
<div class="ttc" id="anamespaceLinearAlgebraDealII_html_aa4543bb429e129431d48d18c1bfebae3"><div class="ttname"><a href="namespaceLinearAlgebraDealII.html#aa4543bb429e129431d48d18c1bfebae3">LinearAlgebraDealII::BlockVector</a></div><div class="ttdeci">BlockVector&lt; double &gt; BlockVector</div><div class="ttdef"><b>Definition:</b> <a href="generic__linear__algebra_8h_source.html#l00048">generic_linear_algebra.h:48</a></div></div>
</div><!-- fragment --><p>Let us move to the particles side of this program. There are two <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> objects used to couple the solid with the fluid, and to describe the passive tracers. These, in many ways, play a role similar to the <a class="el" href="classDoFHandler.html">DoFHandler</a> class used in the discretization, i.e., they provide for an enumeration of particles and allow querying information about each particle.</p>
<div class="fragment"><div class="line"><a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> tracer_particle_handler;</div>
<div class="line"><a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> solid_particle_handler;</div>
</div><!-- fragment --><p>For every tracer particle, we need to compute the velocity field in its current position, and update its position using a discrete time stepping scheme. We do this using distributed linear algebra objects that store the coordinates of each particle's location or velocity. That is, these vectors have <code>tracer_particle_handler.n_global_particles() * spacedim</code> entries that we will store in a way so that parts of the vector are partitioned across all processes. (Implicitly, we here make the assumption that the <code>spacedim</code> coordinates of each particle are stored in consecutive entries of the vector.) Thus, we need to determine who the owner of each vector entry is. We set this owner to be equal to the process that generated that particle at time \(t=0\). This information is stored for every process in the <code>locally_owned_tracer_particle_coordinates</code> <a class="el" href="classIndexSet.html">IndexSet</a>.</p>
<p>Once the particles have been distributed around to match the process that owns the region where the particle lives, we will need read access from that process to the corresponding velocity field. We achieve this by filling a read only velocity vector field that contains the relevant information in ghost entries. This is achieved using the <code>locally_relevant_tracer_particle_coordinates</code> <a class="el" href="classIndexSet.html">IndexSet</a>, that keeps track of how things change during the simulation, i.e., it keeps track of where particles that the current process owns have ended up being, and who owns the particles that ended up in my subdomain.</p>
<p>While this is not the most efficient strategy, we keep it this way to illustrate how things would work in a real fluid-structure interaction (FSI) problem. If a particle is linked to a specific solid degree of freedom, we are not free to choose who owns it, and we have to communicate this information around. We illustrate this here, and show that the communication pattern is point-to-point, and negligible in terms of total cost of the algorithm.</p>
<p>The vectors defined based on these subdivisions are then used to store the particles velocities (read-only, with ghost entries) and their displacement (read/write, no ghost entries).</p>
<div class="fragment"><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a> locally_owned_tracer_particle_coordinates;</div>
<div class="line"><a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_tracer_particle_coordinates;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="namespaceLinearAlgebraDealII.html#a9fe13d579422411556954ab3f28a59be">LA::MPI::Vector</a> tracer_particle_velocities;</div>
<div class="line"><a class="code" href="namespaceLinearAlgebraDealII.html#a9fe13d579422411556954ab3f28a59be">LA::MPI::Vector</a> relevant_tracer_particle_displacements;</div>
<div class="ttc" id="aclassIndexSet_html"><div class="ttname"><a href="classIndexSet.html">IndexSet</a></div><div class="ttdef"><b>Definition:</b> <a href="index__set_8h_source.html#l00072">index_set.h:73</a></div></div>
<div class="ttc" id="anamespaceLinearAlgebraDealII_html_a9fe13d579422411556954ab3f28a59be"><div class="ttname"><a href="namespaceLinearAlgebraDealII.html#a9fe13d579422411556954ab3f28a59be">LinearAlgebraDealII::Vector</a></div><div class="ttdeci">Vector&lt; double &gt; Vector</div><div class="ttdef"><b>Definition:</b> <a href="generic__linear__algebra_8h_source.html#l00043">generic_linear_algebra.h:43</a></div></div>
</div><!-- fragment --><p>One of the key points of this tutorial program is the coupling between two independent <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> objects, one of which may be moving and deforming (with possibly large deformations) with respect to the other. When both the fluid and the solid triangulations are of type <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, every process has access only to its fraction of locally owned cells of each of the two triangulations. As mentioned above, in general, the locally owned domains are not overlapping.</p>
<p>In order to allow for the efficient exchange of information between non-overlapping <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> objects, some algorithms of the library require the user to provide a rough description of the area occupied by the locally owned part of the triangulation, in the form of a collection of axis-aligned bounding boxes for each process, that provide a full covering of the locally owned part of the domain. This kind of information can then be used in situations where one needs to send information to the owner of the cell surrounding a known location, without knowing who that owner may in fact be. But, if one knows a collection of bounding boxes for the geometric area or volume each process owns, then we can determine a subset of all processes that might possibly own the cell in which that location lies: namely, all of those processes whose bounding boxes contain that point. Instead of sending the information associated to that location to all processes, one can then get away with only sending it to a small subset of the processes with point-to-point communication primitives. (You will notice that this also allows for the typical time-vs-memory trade-off: The more data we are willing to store about each process's owned area &ndash; in the form of more refined bounding box information &ndash; the less communication we have to perform.)</p>
<p>We construct this information by gathering a vector (of length <a class="el" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes()</a>) of vectors of <a class="el" href="classBoundingBox.html">BoundingBox</a> objects. We fill this vector using the <a class="el" href="rtree_8h.html#a3591e6e032b1a56920f897a2bc387d43">extract_rtree_level()</a> function, and allow the user to select what level of the tree to extract. The "level" corresponds to how coarse/fine the overlap of the area with bounding boxes should be.</p>
<p>As an example, this is what would be extracted by the <a class="el" href="rtree_8h.html#a3591e6e032b1a56920f897a2bc387d43">extract_rtree_level()</a> function applied to a two dimensional hyper ball, distributed over three processes. Each image shows in green the bounding boxes associated to the locally owned cells of the triangulation on each process, and in violet the bounding boxes extracted from the rtree:</p>
<div class="image">
<img src="rtree-process-0.png" alt=""/>
</div>
 <div class="image">
<img src="rtree-process-1.png" alt=""/>
</div>
 <div class="image">
<img src="rtree-process-2.png" alt=""/>
</div>
<p>We store these boxes in a global member variable, which is updated at every refinement step:</p>
<div class="fragment"><div class="line">  std::vector&lt;std::vector&lt;BoundingBox&lt;spacedim&gt;&gt;&gt; global_fluid_bounding_boxes;</div>
<div class="line">};</div>
</div><!-- fragment --><p><a class="anchor" id="TheStokesImmersedProblemclassimplementation"></a> </p><h3>The StokesImmersedProblem class implementation</h3>
<p><a class="anchor" id="Objectconstructionandmeshinitializationfunctions"></a> </p><h4>Object construction and mesh initialization functions</h4>
<p>In the constructor, we create the mpi_communicator as well as the triangulations and dof_handler for both the fluid and the solid. Using the mpi_communicator, both the <a class="el" href="classConditionalOStream.html">ConditionalOStream</a> and <a class="el" href="classTimerOutput.html">TimerOutput</a> object are constructed.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">StokesImmersedProblem&lt;dim, spacedim&gt;::StokesImmersedProblem(</div>
<div class="line">  <span class="keyword">const</span> StokesImmersedProblemParameters&lt;dim, spacedim&gt; &amp;par)</div>
<div class="line">  : par(par)</div>
<div class="line">  , mpi_communicator(MPI_COMM_WORLD)</div>
<div class="line">  , pcout(std::cout,</div>
<div class="line">          (<a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(mpi_communicator) == 0))</div>
<div class="line">  , computing_timer(mpi_communicator,</div>
<div class="line">                    pcout,</div>
<div class="line">                    <a class="code" href="classTimerOutput.html">TimerOutput</a>::summary,</div>
<div class="line">                    <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div>
<div class="line">  , fluid_tria(mpi_communicator,</div>
<div class="line">               typename <a class="code" href="classTriangulation.html">Triangulation</a>&lt;spacedim&gt;::MeshSmoothing(</div>
<div class="line">                 <a class="code" href="classTriangulation.html">Triangulation</a>&lt;spacedim&gt;::smoothing_on_refinement |</div>
<div class="line">                 <a class="code" href="classTriangulation.html">Triangulation</a>&lt;spacedim&gt;::smoothing_on_coarsening))</div>
<div class="line">  , solid_tria(mpi_communicator,</div>
<div class="line">               typename <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;::MeshSmoothing(</div>
<div class="line">                 <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;::smoothing_on_refinement |</div>
<div class="line">                 <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;::smoothing_on_coarsening))</div>
<div class="line">  , fluid_dh(fluid_tria)</div>
<div class="line">  , solid_dh(solid_tria)</div>
<div class="line">{}</div>
<div class="ttc" id="aclassTriangulation_html"><div class="ttname"><a href="classTriangulation.html">Triangulation</a></div><div class="ttdef"><b>Definition:</b> <a href="grid_2tria_8h_source.html#l01127">tria.h:1128</a></div></div>
<div class="ttc" id="anamespaceUtilities_1_1MPI_html_a895dcd8223a0ee6f0e6a80b80e2d5982"><div class="ttname"><a href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a></div><div class="ttdeci">unsigned int this_mpi_process(const MPI_Comm &amp;mpi_communicator)</div><div class="ttdef"><b>Definition:</b> <a href="mpi_8cc_source.html#l00128">mpi.cc:128</a></div></div>
<div class="ttc" id="anamespaceUtilities_html"><div class="ttname"><a href="namespaceUtilities.html">Utilities</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2communication__pattern__base_8h_source.html#l00030">communication_pattern_base.h:31</a></div></div>
</div><!-- fragment --><p>In order to generate the grid, we first try to use the functions in the deal.II <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace, by leveraging the GridGenerator::generate_from_name_and_argument(). If this function fails, then we use the following method, where the name is interpreted as a filename, and the arguments are interpreted as a map from manifold ids to CAD files, and are converted to <a class="el" href="classManifold.html">Manifold</a> descriptors using the <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> namespace facilities. At the top, we read the file into a triangulation:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line"><span class="keywordtype">void</span> read_grid_and_cad_files(<span class="keyword">const</span> std::string &amp;grid_file_name,</div>
<div class="line">                             <span class="keyword">const</span> std::string &amp;ids_and_cad_file_names,</div>
<div class="line">                             <a class="code" href="classTriangulation.html">Triangulation&lt;dim, spacedim&gt;</a> &amp;tria)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classGridIn.html">GridIn&lt;dim, spacedim&gt;</a> grid_in;</div>
<div class="line">  grid_in.<a class="code" href="classGridIn.html#a82ac1c03b0efe87204ad45d2f1d87f7e">attach_triangulation</a>(tria);</div>
<div class="line">  grid_in.<a class="code" href="classGridIn.html#ad30d9d6f2ff9920c4285e795c4495826">read</a>(grid_file_name);</div>
<div class="ttc" id="aclassGridIn_html"><div class="ttname"><a href="classGridIn.html">GridIn</a></div><div class="ttdef"><b>Definition:</b> <a href="grid__in_8h_source.html#l00306">grid_in.h:307</a></div></div>
<div class="ttc" id="aclassGridIn_html_a82ac1c03b0efe87204ad45d2f1d87f7e"><div class="ttname"><a href="classGridIn.html#a82ac1c03b0efe87204ad45d2f1d87f7e">GridIn::attach_triangulation</a></div><div class="ttdeci">void attach_triangulation(Triangulation&lt; dim, spacedim &gt; &amp;tria)</div><div class="ttdef"><b>Definition:</b> <a href="grid__in_8cc_source.html#l00119">grid_in.cc:119</a></div></div>
<div class="ttc" id="aclassGridIn_html_ad30d9d6f2ff9920c4285e795c4495826"><div class="ttname"><a href="classGridIn.html#ad30d9d6f2ff9920c4285e795c4495826">GridIn::read</a></div><div class="ttdeci">void read(std::istream &amp;in, Format format=Default)</div><div class="ttdef"><b>Definition:</b> <a href="grid__in_8cc_source.html#l03574">grid_in.cc:3574</a></div></div>
</div><!-- fragment --><p>If we got to this point, then the <a class="el" href="classTriangulation.html">Triangulation</a> has been read, and we are ready to attach to it the correct manifold descriptions. We perform the next lines of code only if deal.II has been built with <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> support. For each entry in the map, we try to open the corresponding CAD file, we analyze it, and according to its content, opt for either a OpenCASCADE::ArcLengthProjectionLineManifold (if the CAD file contains a single <code>TopoDS_Edge</code> or a single <code>TopoDS_Wire</code>) or a <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html">OpenCASCADE::NURBSPatchManifold</a>, if the file contains a single face. Notice that if the CAD files do not contain single wires, edges, or faces, an assertion will be throw in the generation of the <a class="el" href="classManifold.html">Manifold</a>.</p>
<p>We use the <a class="el" href="structPatterns_1_1Tools_1_1Convert.html">Patterns::Tools::Convert</a> class to do the conversion from the string to a map between manifold ids and file names for us:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifdef DEAL_II_WITH_OPENCASCADE</span></div>
<div class="line">    <span class="keyword">using</span> map_type  = std::map&lt;types::manifold_id, std::string&gt;;</div>
<div class="line">    <span class="keyword">using</span> Converter = <a class="code" href="structPatterns_1_1Tools_1_1Convert.html">Patterns::Tools::Convert&lt;map_type&gt;</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;pair : <a class="code" href="group__Exceptions.html#ga59da8cbc1fc7db44bebb4fbc9dc4bbe9">Converter::to_value</a>(ids_and_cad_file_names))</div>
<div class="line">      {</div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">manifold_id</a>   = pair.first;</div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;cad_file_name = pair.second;</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> extension = boost::algorithm::to_lower_copy(</div>
<div class="line">          cad_file_name.substr(cad_file_name.find_last_of(<span class="charliteral">&#39;.&#39;</span>) + 1));</div>
<div class="line"> </div>
<div class="line">        TopoDS_Shape shape;</div>
<div class="line">        <span class="keywordflow">if</span> (extension == <span class="stringliteral">&quot;iges&quot;</span> || extension == <span class="stringliteral">&quot;igs&quot;</span>)</div>
<div class="line">          shape = <a class="code" href="namespaceOpenCASCADE.html#affe07b496f4edf844d5f4e8d7a540295">OpenCASCADE::read_IGES</a>(cad_file_name);</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (extension == <span class="stringliteral">&quot;step&quot;</span> || extension == <span class="stringliteral">&quot;stp&quot;</span>)</div>
<div class="line">          shape = <a class="code" href="namespaceOpenCASCADE.html#a614ec9f581086ad423513dd407e9e520">OpenCASCADE::read_STEP</a>(cad_file_name);</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">          <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>,</div>
<div class="line">                      <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>(<span class="stringliteral">&quot;We found an extension that we &quot;</span></div>
<div class="line">                                        <span class="stringliteral">&quot;do not recognize as a CAD file &quot;</span></div>
<div class="line">                                        <span class="stringliteral">&quot;extension. Bailing out.&quot;</span>));</div>
<div class="ttc" id="agroup__Exceptions_html_ga59da8cbc1fc7db44bebb4fbc9dc4bbe9"><div class="ttname"><a href="group__Exceptions.html#ga59da8cbc1fc7db44bebb4fbc9dc4bbe9">Patterns::Tools::to_value</a></div><div class="ttdeci">void to_value(const std::string &amp;s, T &amp;t)</div><div class="ttdef"><b>Definition:</b> <a href="patterns_8h_source.html#l02337">patterns.h:2337</a></div></div>
<div class="ttc" id="agroup__Exceptions_html_ga7b52b286796c23ef9ff178faf7a4b68f"><div class="ttname"><a href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">StandardExceptions::ExcNotImplemented</a></div><div class="ttdeci">static ::ExceptionBase &amp; ExcNotImplemented()</div></div>
<div class="ttc" id="agroup__Exceptions_html_gafc0ca7ad85b3ebd64e8e51689ac85caf"><div class="ttname"><a href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a></div><div class="ttdeci">#define AssertThrow(cond, exc)</div><div class="ttdef"><b>Definition:</b> <a href="include_2deal_8II_2base_2exceptions_8h_source.html#l01583">exceptions.h:1583</a></div></div>
<div class="ttc" id="anamespaceOpenCASCADE_html_a614ec9f581086ad423513dd407e9e520"><div class="ttname"><a href="namespaceOpenCASCADE.html#a614ec9f581086ad423513dd407e9e520">OpenCASCADE::read_STEP</a></div><div class="ttdeci">TopoDS_Shape read_STEP(const std::string &amp;filename, const double scale_factor=1e-3)</div><div class="ttdef"><b>Definition:</b> <a href="opencascade_2utilities_8cc_source.html#l00355">utilities.cc:355</a></div></div>
<div class="ttc" id="anamespaceOpenCASCADE_html_affe07b496f4edf844d5f4e8d7a540295"><div class="ttname"><a href="namespaceOpenCASCADE.html#affe07b496f4edf844d5f4e8d7a540295">OpenCASCADE::read_IGES</a></div><div class="ttdeci">TopoDS_Shape read_IGES(const std::string &amp;filename, const double scale_factor=1e-3)</div><div class="ttdef"><b>Definition:</b> <a href="opencascade_2utilities_8cc_source.html#l00238">utilities.cc:238</a></div></div>
<div class="ttc" id="anamespacetypes_html_a24c02646474836ad4f37ca167e191276"><div class="ttname"><a href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a></div><div class="ttdeci">unsigned int manifold_id</div><div class="ttdef"><b>Definition:</b> <a href="types_8h_source.html#l00141">types.h:141</a></div></div>
<div class="ttc" id="astructPatterns_1_1Tools_1_1Convert_html"><div class="ttname"><a href="structPatterns_1_1Tools_1_1Convert.html">Patterns::Tools::Convert</a></div><div class="ttdef"><b>Definition:</b> <a href="patterns_8h_source.html#l01299">patterns.h:1300</a></div></div>
</div><!-- fragment --><p>Now we check how many faces are contained in the <code>Shape</code>. <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> is intrinsically 3D, so if this number is zero, we interpret this as a line manifold, otherwise as a <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">OpenCASCADE::NormalToMeshProjectionManifold</a> in <code>spacedim</code> = 3, or <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html">OpenCASCADE::NURBSPatchManifold</a> in <code>spacedim</code> = 2.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> n_elements = <a class="code" href="namespaceOpenCASCADE.html#a3e3e0df474c0e4f9abb627753c8754e9">OpenCASCADE::count_elements</a>(shape);</div>
<div class="line"><span class="keywordflow">if</span> ((std::get&lt;0&gt;(n_elements) == 0))</div>
<div class="line">  tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(</div>
<div class="line">    <a class="code" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">manifold_id</a>,</div>
<div class="line">    <a class="code" href="classOpenCASCADE_1_1ArclengthProjectionLineManifold.html">OpenCASCADE::ArclengthProjectionLineManifold&lt;dim, spacedim&gt;</a>(shape));</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (spacedim == 3)</div>
<div class="line">  {</div>
<div class="ttc" id="aclassOpenCASCADE_1_1ArclengthProjectionLineManifold_html"><div class="ttname"><a href="classOpenCASCADE_1_1ArclengthProjectionLineManifold.html">OpenCASCADE::ArclengthProjectionLineManifold</a></div><div class="ttdef"><b>Definition:</b> <a href="opencascade_2manifold__lib_8h_source.html#l00289">manifold_lib.h:290</a></div></div>
<div class="ttc" id="agroup__manifold_html_ga9f9d720f5fbdcdf3dcbb445feefbdb9f"><div class="ttname"><a href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">Triangulation::set_manifold</a></div><div class="ttdeci">void set_manifold(const types::manifold_id number, const Manifold&lt; dim, spacedim &gt; &amp;manifold_object)</div></div>
<div class="ttc" id="anamespaceOpenCASCADE_html_a3e3e0df474c0e4f9abb627753c8754e9"><div class="ttname"><a href="namespaceOpenCASCADE.html#a3e3e0df474c0e4f9abb627753c8754e9">OpenCASCADE::count_elements</a></div><div class="ttdeci">std::tuple&lt; unsigned int, unsigned int, unsigned int &gt; count_elements(const TopoDS_Shape &amp;shape)</div><div class="ttdef"><b>Definition:</b> <a href="opencascade_2utilities_8cc_source.html#l00088">utilities.cc:88</a></div></div>
</div><!-- fragment --><p>We use this trick, because <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">OpenCASCADE::NormalToMeshProjectionManifold</a> is only implemented for spacedim = 3. The check above makes sure that things actually work correctly.</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> t = <span class="keyword">reinterpret_cast&lt;</span><a class="code" href="classTriangulation.html">Triangulation&lt;dim, 3&gt;</a> *<span class="keyword">&gt;</span>(&amp;tria);</div>
<div class="line">    t-&gt;<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(<a class="code" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">manifold_id</a>,</div>
<div class="line">                    <a class="code" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">OpenCASCADE::NormalToMeshProjectionManifold&lt;dim, 3&gt;</a>(</div>
<div class="line">                      shape));</div>
<div class="line">  }</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="ttc" id="aclassOpenCASCADE_1_1NormalToMeshProjectionManifold_html"><div class="ttname"><a href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">OpenCASCADE::NormalToMeshProjectionManifold</a></div><div class="ttdef"><b>Definition:</b> <a href="opencascade_2manifold__lib_8h_source.html#l00228">manifold_lib.h:229</a></div></div>
</div><!-- fragment --><p>We also allow surface descriptions in two dimensional spaces based on single NURBS patches. For this to work, the CAD file must contain a single <code>TopoDS_Face</code>.</p>
<div class="fragment"><div class="line">          tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(<a class="code" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">manifold_id</a>,</div>
<div class="line">                            <a class="code" href="classOpenCASCADE_1_1NURBSPatchManifold.html">OpenCASCADE::NURBSPatchManifold&lt;dim, spacedim&gt;</a>(</div>
<div class="line">                              TopoDS::Face(shape)));</div>
<div class="line">      }</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">    (void)ids_and_cad_file_names;</div>
<div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>(<span class="stringliteral">&quot;Generation of the grid failed.&quot;</span>));</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor">  }</span></div>
<div class="ttc" id="aclassOpenCASCADE_1_1NURBSPatchManifold_html"><div class="ttname"><a href="classOpenCASCADE_1_1NURBSPatchManifold.html">OpenCASCADE::NURBSPatchManifold</a></div><div class="ttdef"><b>Definition:</b> <a href="opencascade_2manifold__lib_8h_source.html#l00348">manifold_lib.h:349</a></div></div>
</div><!-- fragment --><p>Now let's put things together, and make all the necessary grids. As mentioned above, we first try to generate the grid internally, and if we fail (i.e., if we end up in the <code>catch</code> clause), then we proceed with the above function.</p>
<p>We repeat this pattern for both the fluid and the solid mesh.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::make_grid()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments</a>(</div>
<div class="line">        fluid_tria, par.name_of_fluid_grid, par.arguments_for_fluid_grid);</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;Generating from name and argument failed.&quot;</span> &lt;&lt; std::endl</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot;Trying to read from file name.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">      read_grid_and_cad_files(par.name_of_fluid_grid,</div>
<div class="line">                              par.arguments_for_fluid_grid,</div>
<div class="line">                              fluid_tria);</div>
<div class="line">    }</div>
<div class="line">  fluid_tria.refine_global(par.initial_fluid_refinement);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments</a>(</div>
<div class="line">        solid_tria, par.name_of_solid_grid, par.arguments_for_solid_grid);</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">      read_grid_and_cad_files(par.name_of_solid_grid,</div>
<div class="line">                              par.arguments_for_solid_grid,</div>
<div class="line">                              solid_tria);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  solid_tria.refine_global(par.initial_solid_refinement);</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceGridGenerator_html_a1e6c4dcc63863449f08a78a22ec73747"><div class="ttname"><a href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments</a></div><div class="ttdeci">void generate_from_name_and_arguments(Triangulation&lt; dim, spacedim &gt; &amp;tria, const std::string &amp;grid_generator_function_name, const std::string &amp;grid_generator_function_arguments)</div><div class="ttdef"><b>Definition:</b> <a href="grid__generator__from__name_8cc_source.html#l00318">grid_generator_from_name.cc:318</a></div></div>
</div><!-- fragment --><p><a class="anchor" id="Particleinitializationfunctions"></a> </p><h4>Particle initialization functions</h4>
<p>Once the solid and fluid grids have been created, we start filling the <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> objects. The first one we take care of is the one we use to keep track of passive tracers in the fluid. These are simply transported along, and in some sense their locations are unimportant: We just want to use them to see where flow is being transported. We could use any way we choose to determine where they are initially located. A convenient one is to create the initial locations as the vertices of a mesh in a shape of our choice &ndash; a choice determined by one of the run-time parameters in the parameter file.</p>
<p>In this implementation, we create tracers using the support points of a <a class="el" href="classFE__Q.html">FE_Q</a> finite element space defined on a temporary grid, which is then discarded. Of this grid, we only keep around the <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a> objects (stored in a <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> class) associated to the support points.</p>
<p>The <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> class offers the possibility to insert a set of particles that live physically in the part of the domain owned by the active process. However, in this case this function would not suffice. The particles generated as the locally owned support points of an <a class="el" href="classFE__Q.html">FE_Q</a> object on an arbitrary grid (non-matching with regard to the fluid grid) have no reasons to lie in the same physical region of the locally owned subdomain of the fluid grid. In fact this will almost never be the case, especially since we want to keep track of what is happening to the particles themselves.</p>
<p>In particle-in-cell methods (PIC), it is often customary to assign ownership of the particles to the process where the particles lie. In this tutorial we illustrate a different approach, which is useful if one wants to keep track of information related to the particles (for example, if a particle is associated to a given degree of freedom, which is owned by a specific process and not necessarily the same process that owns the fluid cell where the particle happens to be at any given time). In the approach used here, ownership of the particles is assigned once at the beginning, and one-to-one communication happens whenever the original owner needs information from the process that owns the cell where the particle lives. We make sure that we set ownership of the particles using the initial particle distribution, and keep the same ownership throughout the execution of the program.</p>
<p>With this overview out of the way, let us see what the function does. At the top, we create a temporary triangulation and <a class="el" href="classDoFHandler.html">DoFHandler</a> object from which we will take the node locations for initial particle locations:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::setup_tracer_particles()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;spacedim&gt;</a> particle_insert_tria(</div>
<div class="line">    mpi_communicator);</div>
<div class="line">  <a class="code" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments</a>(</div>
<div class="line">    particle_insert_tria,</div>
<div class="line">    par.name_of_particle_grid,</div>
<div class="line">    par.arguments_for_particle_grid);</div>
<div class="line">  particle_insert_tria.refine_global(par.particle_insertion_refinement);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;spacedim&gt;</a>       particles_fe(1);</div>
<div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;spacedim&gt;</a> particles_dof_handler(particle_insert_tria);</div>
<div class="line">  particles_dof_handler.distribute_dofs(particles_fe);</div>
<div class="ttc" id="aclassFE__Q_html"><div class="ttname"><a href="classFE__Q.html">FE_Q</a></div><div class="ttdef"><b>Definition:</b> <a href="fe__q_8h_source.html#l00548">fe_q.h:549</a></div></div>
</div><!-- fragment --><p>This is where things start to get complicated. Since we may run this program in a parallel environment, every parallel process will now have created these temporary triangulations and DoFHandlers. But, in fully distributed triangulations, the active process only knows about the locally owned cells, and has no idea of how other processes have distributed their own cells. This is true for both the temporary triangulation created above as well as the fluid triangulation into which we want to embed the particles below. On the other hand, these locally known portions of the two triangulations will, in general, not overlap. That is, the locations of the particles we will create from the node locations of the temporary mesh are arbitrary, and may fall within a region of the fluid triangulation that the current process doesn't have access to (i.e., a region of the fluid domain where cells are artificial). In order to understand who to send those particles to, we need to have a (rough) idea of how the fluid grid is distributed among processors.</p>
<p>We construct this information by first building an index tree of boxes bounding the locally owned cells, and then extracting one of the first levels of the tree:</p>
<div class="fragment"><div class="line">std::vector&lt;BoundingBox&lt;spacedim&gt;&gt; all_boxes;</div>
<div class="line">all_boxes.reserve(fluid_tria.n_locally_owned_active_cells());</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : fluid_tria.active_cell_iterators())</div>
<div class="line">  <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div>
<div class="line">    all_boxes.emplace_back(cell-&gt;bounding_box());</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> tree = <a class="code" href="rtree_8h.html#a66a9d76ea405b07e60e74aa6159ac7ad">pack_rtree</a>(all_boxes);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> local_boxes =</div>
<div class="line">  <a class="code" href="rtree_8h.html#a3591e6e032b1a56920f897a2bc387d43">extract_rtree_level</a>(tree, par.fluid_rtree_extraction_level);</div>
<div class="ttc" id="artree_8h_html_a3591e6e032b1a56920f897a2bc387d43"><div class="ttname"><a href="rtree_8h.html#a3591e6e032b1a56920f897a2bc387d43">extract_rtree_level</a></div><div class="ttdeci">std::vector&lt; BoundingBox&lt; boost::geometry::dimension&lt; typename Rtree::indexable_type &gt;::value &gt; &gt; extract_rtree_level(const Rtree &amp;tree, const unsigned int level)</div></div>
<div class="ttc" id="artree_8h_html_a66a9d76ea405b07e60e74aa6159ac7ad"><div class="ttname"><a href="rtree_8h.html#a66a9d76ea405b07e60e74aa6159ac7ad">pack_rtree</a></div><div class="ttdeci">RTree&lt; typename LeafTypeIterator::value_type, IndexType, IndexableGetter &gt; pack_rtree(const LeafTypeIterator &amp;begin, const LeafTypeIterator &amp;end)</div></div>
</div><!-- fragment --><p>Each process now has a collection of bounding boxes that completely enclose all locally owned processes (but that may overlap the bounding boxes of other processes). We then exchange this information between all participating processes so that every process knows the bounding boxes of all other processes.</p>
<p>Equipped with this knowledge, we can then initialize the <code>tracer_particle_handler</code> to the fluid mesh and generate the particles from the support points of the (temporary) tracer particles triangulation. This function call uses the <code>global_bounding_boxes</code> object we just constructed to figure out where to send the particles whose locations were derived from the locally owned part of the <code>particles_dof_handler</code>. At the end of this call, every particle will have been distributed to the correct process (i.e., the process that owns the fluid cell where the particle lives). We also output their number to the screen at this point.</p>
<div class="fragment"><div class="line">global_fluid_bounding_boxes =</div>
<div class="line">  <a class="code" href="namespaceUtilities_1_1MPI.html#ac5a7433f594a19070add2afa0f769efb">Utilities::MPI::all_gather</a>(mpi_communicator, local_boxes);</div>
<div class="line"> </div>
<div class="line">tracer_particle_handler.initialize(fluid_tria,</div>
<div class="line">                                   <a class="code" href="structStaticMappingQ1.html">StaticMappingQ1&lt;spacedim&gt;::mapping</a>);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="namespaceParticles_1_1Generators.html#a498c6b70c8c3169a3d1513418beb9e15">Particles::Generators::dof_support_points</a>(particles_dof_handler,</div>
<div class="line">                                          global_fluid_bounding_boxes,</div>
<div class="line">                                          tracer_particle_handler);</div>
<div class="line"> </div>
<div class="line">pcout &lt;&lt; <span class="stringliteral">&quot;Tracer particles: &quot;</span></div>
<div class="line">      &lt;&lt; tracer_particle_handler.n_global_particles() &lt;&lt; std::endl;</div>
<div class="ttc" id="anamespaceParticles_1_1Generators_html_a498c6b70c8c3169a3d1513418beb9e15"><div class="ttname"><a href="namespaceParticles_1_1Generators.html#a498c6b70c8c3169a3d1513418beb9e15">Particles::Generators::dof_support_points</a></div><div class="ttdeci">void dof_support_points(const DoFHandler&lt; dim, spacedim &gt; &amp;dof_handler, const std::vector&lt; std::vector&lt; BoundingBox&lt; spacedim &gt;&gt;&gt; &amp;global_bounding_boxes, ParticleHandler&lt; dim, spacedim &gt; &amp;particle_handler, const Mapping&lt; dim, spacedim &gt; &amp;mapping=(ReferenceCells::get_hypercube&lt; dim &gt;() .template get_default_linear_mapping&lt; dim, spacedim &gt;()), const ComponentMask &amp;components=ComponentMask(), const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;properties={})</div><div class="ttdef"><b>Definition:</b> <a href="generators_8cc_source.html#l00411">generators.cc:411</a></div></div>
<div class="ttc" id="anamespaceUtilities_1_1MPI_html_ac5a7433f594a19070add2afa0f769efb"><div class="ttname"><a href="namespaceUtilities_1_1MPI.html#ac5a7433f594a19070add2afa0f769efb">Utilities::MPI::all_gather</a></div><div class="ttdeci">std::vector&lt; T &gt; all_gather(const MPI_Comm &amp;comm, const T &amp;object_to_send)</div></div>
<div class="ttc" id="astructStaticMappingQ1_html"><div class="ttname"><a href="structStaticMappingQ1.html">StaticMappingQ1</a></div><div class="ttdef"><b>Definition:</b> <a href="mapping__q1_8h_source.html#l00091">mapping_q1.h:92</a></div></div>
</div><!-- fragment --><p>Each particle so created has a unique ID. At some point in the algorithm below, we will need vectors containing position and velocity information for each particle. This vector will have size <code>n_particles * spacedim</code>, and we will have to store the elements of this vector in a way so that each parallel process "owns" those elements that correspond to coordinates of the particles it owns. In other words, we have to partition the index space between zero and <code>n_particles * spacedim</code> among all processes. We can do this by querying the <code>tracer_particle_handler</code> for the IDs of its locally relevant particles, and construct the indices that would be needed to store in a (parallel distributed) vector of the position and velocity of all particles where we implicitly assume that we store the coordinates of each location or velocity in <code>spacedim</code> successive vector elements (this is what the IndexSet::tensor_priduct() function does).</p>
<div class="fragment"><div class="line">locally_owned_tracer_particle_coordinates =</div>
<div class="line">  tracer_particle_handler.locally_relevant_ids().tensor_product(</div>
<div class="line">    <a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(spacedim));</div>
<div class="ttc" id="aclassIndexSet_html_ad28b2e725afda38ffdef1bf61d5cadd4"><div class="ttname"><a href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">IndexSet::complete_index_set</a></div><div class="ttdeci">IndexSet complete_index_set(const IndexSet::size_type N)</div><div class="ttdef"><b>Definition:</b> <a href="index__set_8h_source.html#l01013">index_set.h:1013</a></div></div>
</div><!-- fragment --><p>At the beginning of the simulation, all particles are in their original position. When particles move, they may traverse to a part of the domain which is owned by another process. If this happens, the current process keeps formally "ownership" of the particles, but may need read access from the process where the particle has landed. We keep this information in another index set, which stores the indices of all particles that are currently on the current process's subdomain, independently if they have always been here or not.</p>
<p>Keeping this index set around allows us to leverage linear algebra classes for all communications regarding positions and velocities of the particles. This mimics what would happen in the case where another problem was solved in the solid domain (as in fluid-structure interaction. In this latter case, additional DOFs on the solid domain would be coupled to what is occurring in the fluid domain.</p>
<div class="fragment"><div class="line">locally_relevant_tracer_particle_coordinates =</div>
<div class="line">  locally_owned_tracer_particle_coordinates;</div>
</div><!-- fragment --><p>Finally, we make sure that upon refinement, particles are correctly transferred. When performing local refinement or coarsening, particles will land in another cell. We could in principle redistribute all particles after refining, however this would be overly expensive.</p>
<p>The <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> class has a way to transfer information from a cell to its children or to its parent upon refinement, without the need to reconstruct the entire data structure. This is done by registering two callback functions to the triangulation. These functions will receive a signal when refinement is about to happen, and when it has just happened, and will take care of transferring all information to the newly refined grid with minimal computational cost.</p>
<div class="fragment"><div class="line">  fluid_tria.signals.pre_distributed_refinement.connect(</div>
<div class="line">    [&amp;]() { tracer_particle_handler.register_store_callback_function(); });</div>
<div class="line"> </div>
<div class="line">  fluid_tria.signals.post_distributed_refinement.connect([&amp;]() {</div>
<div class="line">    tracer_particle_handler.register_load_callback_function(<span class="keyword">false</span>);</div>
<div class="line">  });</div>
<div class="line">}</div>
</div><!-- fragment --><p>Similarly to what we have done for passive tracers, we next set up the particles that track the quadrature points of the solid mesh. The main difference here is that we also want to attach a weight value (the "JxW" value of the quadrature point) to each of particle, so that we can compute integrals even without direct access to the original solid grid.</p>
<p>This is achieved by leveraging the "properties" concept of the <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a> class. It is possible to store (in a memory efficient way) an arbitrary number of <code>double</code> numbers for each of the <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a> objects inside a <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> object. We use this possibility to store the JxW values of the quadrature points of the solid grid.</p>
<p>In our case, we only need to store one property per particle: the JxW value of the integration on the solid grid. This is passed at construction time to the solid_particle_handler object as the last argument</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::setup_solid_particles()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature(fluid_fe-&gt;degree + 1);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_properties = 1;</div>
<div class="line">  solid_particle_handler.initialize(fluid_tria,</div>
<div class="line">                                    <a class="code" href="structStaticMappingQ1.html">StaticMappingQ1&lt;spacedim&gt;::mapping</a>,</div>
<div class="line">                                    n_properties);</div>
<div class="ttc" id="aclassQGauss_html"><div class="ttname"><a href="classQGauss.html">QGauss</a></div><div class="ttdef"><b>Definition:</b> <a href="quadrature__lib_8h_source.html#l00038">quadrature_lib.h:39</a></div></div>
</div><!-- fragment --><p>The number of particles that we generate locally is equal to the total number of locally owned cells times the number of quadrature points used in each cell. We store all these points in a vector, and their corresponding properties in a vector of vectors:</p>
<div class="fragment"><div class="line">std::vector&lt;Point&lt;spacedim&gt;&gt; quadrature_points_vec;</div>
<div class="line">quadrature_points_vec.reserve(quadrature.size() *</div>
<div class="line">                              solid_tria.n_locally_owned_active_cells());</div>
<div class="line"> </div>
<div class="line">std::vector&lt;std::vector&lt;double&gt;&gt; properties;</div>
<div class="line">properties.reserve(quadrature.size() *</div>
<div class="line">                   solid_tria.n_locally_owned_active_cells());</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classFEValues.html">FEValues&lt;dim, spacedim&gt;</a> fe_v(*solid_fe,</div>
<div class="line">                             quadrature,</div>
<div class="line">                             <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : solid_dh.active_cell_iterators())</div>
<div class="line">  <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div>
<div class="line">    {</div>
<div class="line">      fe_v.reinit(cell);</div>
<div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;points = fe_v.get_quadrature_points();</div>
<div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;JxW    = fe_v.get_JxW_values();</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; points.size(); ++q)</div>
<div class="line">        {</div>
<div class="line">          quadrature_points_vec.emplace_back(points[q]);</div>
<div class="line">          properties.emplace_back(</div>
<div class="line">            std::vector&lt;double&gt;(n_properties, JxW[q]));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="ttc" id="aclassFEValues_html"><div class="ttname"><a href="classFEValues.html">FEValues&lt; dim, spacedim &gt;</a></div></div>
<div class="ttc" id="afe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85"><div class="ttname"><a href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a></div><div class="ttdeci">@ update_JxW_values</div><div class="ttdoc">Transformed quadrature weights.</div><div class="ttdef"><b>Definition:</b> <a href="fe__update__flags_8h_source.html#l00129">fe_update_flags.h:129</a></div></div>
<div class="ttc" id="afe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a"><div class="ttname"><a href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a></div><div class="ttdeci">@ update_quadrature_points</div><div class="ttdoc">Transformed quadrature points.</div><div class="ttdef"><b>Definition:</b> <a href="fe__update__flags_8h_source.html#l00122">fe_update_flags.h:122</a></div></div>
</div><!-- fragment --><p>We proceed in the same way we did with the tracer particles, reusing the computed bounding boxes. However, we first check that the <code>global_fluid_bounding_boxes</code> object has been actually filled. This should certainly be the case here, since this method is called after the one that initializes the tracer particles. However, we want to make sure that if in the future someone decides (for whatever reason) to initialize first the solid particle handler, or to copy just this part of the tutorial, a meaningful exception is thrown when things don't work as expected</p>
<p>Since we have already stored the position of the quadrature points, we can use these positions to insert the particles directly using the <code>solid_particle_handler</code> instead of having to go through a <a class="el" href="namespaceParticles_1_1Generators.html">Particles::Generators</a> function:</p>
<div class="fragment"><div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(!global_fluid_bounding_boxes.empty(),</div>
<div class="line">       <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>(</div>
<div class="line">         <span class="stringliteral">&quot;I was expecting the &quot;</span></div>
<div class="line">         <span class="stringliteral">&quot;global_fluid_bounding_boxes to be filled at this stage. &quot;</span></div>
<div class="line">         <span class="stringliteral">&quot;Make sure you fill this vector before trying to use it &quot;</span></div>
<div class="line">         <span class="stringliteral">&quot;here. Bailing out.&quot;</span>));</div>
<div class="line"> </div>
<div class="line">solid_particle_handler.insert_global_particles(quadrature_points_vec,</div>
<div class="line">                                               global_fluid_bounding_boxes,</div>
<div class="line">                                               properties);</div>
<div class="ttc" id="agroup__Exceptions_html_ga31978c026b8b6b5116df30b8e748f6b7"><div class="ttname"><a href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">StandardExceptions::ExcInternalError</a></div><div class="ttdeci">static ::ExceptionBase &amp; ExcInternalError()</div></div>
<div class="ttc" id="agroup__Exceptions_html_ga70a0bb353656e704acf927945277bbc6"><div class="ttname"><a href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a></div><div class="ttdeci">#define Assert(cond, exc)</div><div class="ttdef"><b>Definition:</b> <a href="include_2deal_8II_2base_2exceptions_8h_source.html#l01473">exceptions.h:1473</a></div></div>
</div><!-- fragment --><p>As in the previous function, we end by making sure that upon refinement, particles are correctly transferred:</p>
<div class="fragment"><div class="line">  fluid_tria.signals.pre_distributed_refinement.connect(</div>
<div class="line">    [&amp;]() { solid_particle_handler.register_store_callback_function(); });</div>
<div class="line"> </div>
<div class="line">  fluid_tria.signals.post_distributed_refinement.connect(</div>
<div class="line">    [&amp;]() { solid_particle_handler.register_load_callback_function(<span class="keyword">false</span>); });</div>
<div class="line"> </div>
<div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;Solid particles: &quot;</span> &lt;&lt; solid_particle_handler.n_global_particles()</div>
<div class="line">        &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="DoFinitializationfunctions"></a> </p><h4>DoF initialization functions</h4>
<p>We set up the finite element space and the quadrature formula to be used throughout the step. For the fluid, we use Taylor-Hood elements (e.g. \(Q_k \times Q_{k-1}\)). Since we do not solve any equation on the solid domain, an empty finite element space is generated. A natural extension of this program would be to solve a fluid structure interaction problem, which would require that the <code>solid_fe</code> use more useful <a class="el" href="classFiniteElement.html">FiniteElement</a> class.</p>
<p>Like for many other functions, we store the time necessary to carry out the operations we perform here. The current function puts its timing information into a section with label "Initial setup". Numerous other calls to this timer are made in various functions. They allow to monitor the absolute and relative cost of each individual function to identify bottlenecks.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::initial_setup()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Initial setup&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  fluid_fe =</div>
<div class="line">    std::make_unique&lt;FESystem&lt;spacedim&gt;&gt;(<a class="code" href="classFE__Q.html">FE_Q&lt;spacedim&gt;</a>(par.velocity_degree),</div>
<div class="line">                                         spacedim,</div>
<div class="line">                                         <a class="code" href="classFE__Q.html">FE_Q&lt;spacedim&gt;</a>(par.velocity_degree -</div>
<div class="line">                                                        1),</div>
<div class="line">                                         1);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  solid_fe = std::make_unique&lt;FE_Nothing&lt;dim, spacedim&gt;&gt;();</div>
<div class="line">  solid_dh.distribute_dofs(*solid_fe);</div>
<div class="line"> </div>
<div class="line">  fluid_quadrature_formula =</div>
<div class="line">    std::make_unique&lt;QGauss&lt;spacedim&gt;&gt;(par.velocity_degree + 1);</div>
<div class="line">  solid_quadrature_formula =</div>
<div class="line">    std::make_unique&lt;QGauss&lt;dim&gt;&gt;(par.velocity_degree + 1);</div>
<div class="line">}</div>
<div class="ttc" id="aclassTimerOutput_1_1Scope_html"><div class="ttname"><a href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a></div><div class="ttdef"><b>Definition:</b> <a href="timer_8h_source.html#l00552">timer.h:553</a></div></div>
</div><!-- fragment --><p>We next construct the distributed block matrices and vectors which are used to solve the linear equations that arise from the problem. This function is adapted from <a class="el" href="step_55.html">step-55</a> and we refer to this step for a thorough explanation.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::setup_dofs()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup dofs&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  fluid_dh.distribute_dofs(*fluid_fe);</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;unsigned int&gt; stokes_sub_blocks(spacedim + 1, 0);</div>
<div class="line">  stokes_sub_blocks[spacedim] = 1;</div>
<div class="line">  <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(fluid_dh, stokes_sub_blocks);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> dofs_per_block =</div>
<div class="line">    <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(fluid_dh, stokes_sub_blocks);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = dofs_per_block[0], n_p = dofs_per_block[1];</div>
<div class="line"> </div>
<div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; fluid_dh.n_dofs() &lt;&lt; <span class="stringliteral">&quot; (&quot;</span></div>
<div class="line">        &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="stringliteral">&quot; -- &quot;</span></div>
<div class="line">        &lt;&lt; solid_particle_handler.n_global_particles() &lt;&lt; <span class="charliteral">&#39;+&#39;</span></div>
<div class="line">        &lt;&lt; tracer_particle_handler.n_global_particles() &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  fluid_owned_dofs.resize(2);</div>
<div class="line">  fluid_owned_dofs[0] = fluid_dh.locally_owned_dofs().get_view(0, n_u);</div>
<div class="line">  fluid_owned_dofs[1] =</div>
<div class="line">    fluid_dh.locally_owned_dofs().get_view(n_u, n_u + n_p);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs;</div>
<div class="line">  <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(fluid_dh, locally_relevant_dofs);</div>
<div class="line">  fluid_relevant_dofs.resize(2);</div>
<div class="line">  fluid_relevant_dofs[0] = locally_relevant_dofs.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(0, n_u);</div>
<div class="line">  fluid_relevant_dofs[1] = locally_relevant_dofs.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(n_u, n_u + n_p);</div>
<div class="line"> </div>
<div class="line">  {</div>
<div class="line">    constraints.reinit(locally_relevant_dofs);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div>
<div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(fluid_dh, constraints);</div>
<div class="line">    <a class="code" href="namespaceVectorTools.html#ab2562d41bb26f362043f9719a8cd9b87">VectorTools::interpolate_boundary_values</a>(</div>
<div class="line">      fluid_dh,</div>
<div class="line">      0,</div>
<div class="line">      <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;spacedim&gt;</a>(spacedim + 1),</div>
<div class="line">      constraints,</div>
<div class="line">      fluid_fe-&gt;component_mask(velocities));</div>
<div class="line">    constraints.close();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> locally_owned_dofs_per_processor =</div>
<div class="line">    <a class="code" href="namespaceUtilities_1_1MPI.html#ac5a7433f594a19070add2afa0f769efb">Utilities::MPI::all_gather</a>(mpi_communicator,</div>
<div class="line">                               fluid_dh.locally_owned_dofs());</div>
<div class="line">  {</div>
<div class="line">    system_matrix.clear();</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(spacedim + 1, spacedim + 1);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; spacedim + 1; ++c)</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; spacedim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div>
<div class="line">        <span class="keywordflow">if</span> (c == spacedim &amp;&amp; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> == spacedim)</div>
<div class="line">          coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (c == spacedim || <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> == spacedim || c == <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div>
<div class="line">          coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">          coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(dofs_per_block, dofs_per_block);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div>
<div class="line">      fluid_dh, coupling, dsp, constraints, <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="namespaceSparsityTools.html#afbc0c7a206ced91b154666215ea3c218">SparsityTools::distribute_sparsity_pattern</a>(</div>
<div class="line">      dsp,</div>
<div class="line">      locally_owned_dofs_per_processor,</div>
<div class="line">      mpi_communicator,</div>
<div class="line">      locally_relevant_dofs);</div>
<div class="line"> </div>
<div class="line">    system_matrix.reinit(fluid_owned_dofs, dsp, mpi_communicator);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  {</div>
<div class="line">    preconditioner_matrix.clear();</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(spacedim + 1, spacedim + 1);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; spacedim + 1; ++c)</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; spacedim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div>
<div class="line">        <span class="keywordflow">if</span> (c == spacedim &amp;&amp; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> == spacedim)</div>
<div class="line">          coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">          coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(dofs_per_block, dofs_per_block);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div>
<div class="line">      fluid_dh, coupling, dsp, constraints, <span class="keyword">false</span>);</div>
<div class="line">    <a class="code" href="namespaceSparsityTools.html#afbc0c7a206ced91b154666215ea3c218">SparsityTools::distribute_sparsity_pattern</a>(</div>
<div class="line">      dsp,</div>
<div class="line">      locally_owned_dofs_per_processor,</div>
<div class="line">      mpi_communicator,</div>
<div class="line">      locally_relevant_dofs);</div>
<div class="line">    preconditioner_matrix.reinit(fluid_owned_dofs, dsp, mpi_communicator);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  locally_relevant_solution.reinit(fluid_owned_dofs,</div>
<div class="line">                                   fluid_relevant_dofs,</div>
<div class="line">                                   mpi_communicator);</div>
<div class="line">  system_rhs.reinit(fluid_owned_dofs, mpi_communicator);</div>
<div class="line">  solution.reinit(fluid_owned_dofs, mpi_communicator);</div>
<div class="line">}</div>
<div class="ttc" id="aclassBlockDynamicSparsityPattern_html"><div class="ttname"><a href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a></div><div class="ttdef"><b>Definition:</b> <a href="block__sparsity__pattern_8h_source.html#l00524">block_sparsity_pattern.h:526</a></div></div>
<div class="ttc" id="aclassFunctions_1_1ZeroFunction_html"><div class="ttname"><a href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction</a></div><div class="ttdef"><b>Definition:</b> <a href="function_8h_source.html#l00510">function.h:511</a></div></div>
<div class="ttc" id="aclassIndexSet_html_add590b083cdde3fa61e637a058b51835"><div class="ttname"><a href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">IndexSet::get_view</a></div><div class="ttdeci">IndexSet get_view(const size_type begin, const size_type end) const</div><div class="ttdef"><b>Definition:</b> <a href="index__set_8cc_source.html#l00211">index_set.cc:211</a></div></div>
<div class="ttc" id="aclassTable_html"><div class="ttname"><a href="classTable.html">Table</a></div><div class="ttdef"><b>Definition:</b> <a href="table_8h_source.html#l00666">table.h:667</a></div></div>
<div class="ttc" id="agroup__constraints_html_ga3b4ea7dfd313e388d868c4e4aa685799"><div class="ttname"><a href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a></div><div class="ttdeci">void make_hanging_node_constraints(const DoFHandler&lt; dim, spacedim &gt; &amp;dof_handler, AffineConstraints&lt; number &gt; &amp;constraints)</div><div class="ttdef"><b>Definition:</b> <a href="dof__tools__constraints_8cc_source.html#l01787">dof_tools_constraints.cc:1787</a></div></div>
<div class="ttc" id="agroup__constraints_html_gaf78e864edbfba7e0a7477457bfb96b26"><div class="ttname"><a href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a></div><div class="ttdeci">void make_sparsity_pattern(const DoFHandler&lt; dim, spacedim &gt; &amp;dof_handler, SparsityPatternType &amp;sparsity_pattern, const AffineConstraints&lt; number &gt; &amp;constraints=AffineConstraints&lt; number &gt;(), const bool keep_constrained_dofs=true, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id)</div><div class="ttdef"><b>Definition:</b> <a href="dof__tools__sparsity_8cc_source.html#l00064">dof_tools_sparsity.cc:64</a></div></div>
<div class="ttc" id="anamespaceDoFRenumbering_html_a52c1941406d1ce2937e29a46edf111f4"><div class="ttname"><a href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a></div><div class="ttdeci">void component_wise(DoFHandler&lt; dim, spacedim &gt; &amp;dof_handler, const std::vector&lt; unsigned int &gt; &amp;target_component=std::vector&lt; unsigned int &gt;())</div><div class="ttdef"><b>Definition:</b> <a href="dof__renumbering_8cc_source.html#l00681">dof_renumbering.cc:681</a></div></div>
<div class="ttc" id="anamespaceDoFTools_html_a796721b56b3a90e4e3973c7caae4c3d8"><div class="ttname"><a href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a></div><div class="ttdeci">std::vector&lt; types::global_dof_index &gt; count_dofs_per_fe_block(const DoFHandler&lt; dim, spacedim &gt; &amp;dof, const std::vector&lt; unsigned int &gt; &amp;target_block=std::vector&lt; unsigned int &gt;())</div><div class="ttdef"><b>Definition:</b> <a href="dof__tools_8cc_source.html#l02047">dof_tools.cc:2047</a></div></div>
<div class="ttc" id="anamespaceDoFTools_html_acad7e0841b9046eaafddc4c617ab1d9d"><div class="ttname"><a href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a></div><div class="ttdeci">void extract_locally_relevant_dofs(const DoFHandler&lt; dim, spacedim &gt; &amp;dof_handler, IndexSet &amp;dof_set)</div><div class="ttdef"><b>Definition:</b> <a href="dof__tools_8cc_source.html#l01210">dof_tools.cc:1210</a></div></div>
<div class="ttc" id="anamespaceDoFTools_html_ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba"><div class="ttname"><a href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a></div><div class="ttdeci">@ none</div><div class="ttdef"><b>Definition:</b> <a href="dof__tools_8h_source.html#l00231">dof_tools.h:231</a></div></div>
<div class="ttc" id="anamespaceDoFTools_html_ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec"><div class="ttname"><a href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a></div><div class="ttdeci">@ always</div><div class="ttdef"><b>Definition:</b> <a href="dof__tools_8h_source.html#l00235">dof_tools.h:235</a></div></div>
<div class="ttc" id="anamespacePhysics_1_1Elasticity_1_1Kinematics_html_a15728437b942dab0b0042eb06a407d2c"><div class="ttname"><a href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">Physics::Elasticity::Kinematics::d</a></div><div class="ttdeci">SymmetricTensor&lt; 2, dim, Number &gt; d(const Tensor&lt; 2, dim, Number &gt; &amp;F, const Tensor&lt; 2, dim, Number &gt; &amp;dF_dt)</div></div>
<div class="ttc" id="anamespaceSparsityTools_html_afbc0c7a206ced91b154666215ea3c218"><div class="ttname"><a href="namespaceSparsityTools.html#afbc0c7a206ced91b154666215ea3c218">SparsityTools::distribute_sparsity_pattern</a></div><div class="ttdeci">void distribute_sparsity_pattern(DynamicSparsityPattern &amp;dsp, const IndexSet &amp;locally_owned_rows, const MPI_Comm &amp;mpi_comm, const IndexSet &amp;locally_relevant_rows)</div><div class="ttdef"><b>Definition:</b> <a href="sparsity__tools_8cc_source.html#l01045">sparsity_tools.cc:1045</a></div></div>
<div class="ttc" id="anamespaceVectorTools_html_ab2562d41bb26f362043f9719a8cd9b87"><div class="ttname"><a href="namespaceVectorTools.html#ab2562d41bb26f362043f9719a8cd9b87">VectorTools::interpolate_boundary_values</a></div><div class="ttdeci">void interpolate_boundary_values(const Mapping&lt; dim, spacedim &gt; &amp;mapping, const DoFHandler&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; types::boundary_id, const Function&lt; spacedim, number &gt; * &gt; &amp;function_map, std::map&lt; types::global_dof_index, number &gt; &amp;boundary_values, const ComponentMask &amp;component_mask=ComponentMask())</div></div>
<div class="ttc" id="astructFEValuesExtractors_1_1Vector_html"><div class="ttname"><a href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a></div><div class="ttdef"><b>Definition:</b> <a href="fe__values__extractors_8h_source.html#l00150">fe_values_extractors.h:151</a></div></div>
</div><!-- fragment --><p><a class="anchor" id="Assemblyfunctions"></a> </p><h4>Assembly functions</h4>
<p>We assemble the system matrix, the preconditioner matrix, and the right hand side. The code is adapted from <a class="el" href="step_55.html">step-55</a>, which is essentially what <a class="el" href="step_27.html">step-27</a> also has, and is pretty standard if you know what the Stokes equations look like.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::assemble_stokes_system()</div>
<div class="line">{</div>
<div class="line">  system_matrix         = 0;</div>
<div class="line">  preconditioner_matrix = 0;</div>
<div class="line">  system_rhs            = 0;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Assemble Stokes terms&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;spacedim&gt;</a> fe_values(*fluid_fe,</div>
<div class="line">                               *fluid_quadrature_formula,</div>
<div class="line">                               <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div>
<div class="line">                                 <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div>
<div class="line">                                 <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fluid_fe-&gt;n_dofs_per_cell();</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = fluid_quadrature_formula-&gt;size();</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div>
<div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix2(dofs_per_cell, dofs_per_cell);</div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     cell_rhs(dofs_per_cell);</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;Vector&lt;double&gt;&gt; rhs_values(n_q_points,</div>
<div class="line">                                         <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(spacedim + 1));</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;Tensor&lt;2, spacedim&gt;&gt; grad_phi_u(dofs_per_cell);</div>
<div class="line">  std::vector&lt;double&gt;              div_phi_u(dofs_per_cell);</div>
<div class="line">  std::vector&lt;double&gt;              phi_p(dofs_per_cell);</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a>     velocities(0);</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a>     pressure(spacedim);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : fluid_dh.active_cell_iterators())</div>
<div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div>
<div class="line">      {</div>
<div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>  = 0;</div>
<div class="line">        cell_matrix2 = 0;</div>
<div class="line">        cell_rhs     = 0;</div>
<div class="line"> </div>
<div class="line">        fe_values.reinit(cell);</div>
<div class="line">        par.rhs.vector_value_list(fe_values.get_quadrature_points(),</div>
<div class="line">                                  rhs_values);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div>
<div class="line">          {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div>
<div class="line">              {</div>
<div class="line">                grad_phi_u[k] = fe_values[velocities].gradient(k, q);</div>
<div class="line">                div_phi_u[k]  = fe_values[velocities].divergence(k, q);</div>
<div class="line">                phi_p[k]      = fe_values[pressure].value(k, q);</div>
<div class="line">              }</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div>
<div class="line">              {</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div>
<div class="line">                  {</div>
<div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div>
<div class="line">                      (par.viscosity *</div>
<div class="line">                         <a class="code" href="classSymmetricTensor.html#ab14ac27fc9ab74d4de531698b492d8de">scalar_product</a>(grad_phi_u[i], grad_phi_u[j]) -</div>
<div class="line">                       div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j]) *</div>
<div class="line">                      fe_values.JxW(q);</div>
<div class="line"> </div>
<div class="line">                    cell_matrix2(i, j) += 1.0 / par.viscosity * phi_p[i] *</div>
<div class="line">                                          phi_p[j] * fe_values.JxW(q);</div>
<div class="line">                  }</div>
<div class="line"> </div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component_i =</div>
<div class="line">                  fluid_fe-&gt;system_to_component_index(i).first;</div>
<div class="line">                cell_rhs(i) += fe_values.shape_value(i, q) *</div>
<div class="line">                               rhs_values[q](component_i) * fe_values.JxW(q);</div>
<div class="line">              }</div>
<div class="line">          }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div>
<div class="line">        constraints.distribute_local_to_global(<a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>,</div>
<div class="line">                                               cell_rhs,</div>
<div class="line">                                               local_dof_indices,</div>
<div class="line">                                               system_matrix,</div>
<div class="line">                                               system_rhs);</div>
<div class="line"> </div>
<div class="line">        constraints.distribute_local_to_global(cell_matrix2,</div>
<div class="line">                                               local_dof_indices,</div>
<div class="line">                                               preconditioner_matrix);</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">  system_matrix.compress(<a class="code" href="group__Vectors.html#gga40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div>
<div class="line">  preconditioner_matrix.compress(<a class="code" href="group__Vectors.html#gga40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div>
<div class="line">  system_rhs.compress(<a class="code" href="group__Vectors.html#gga40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div>
<div class="line">}</div>
<div class="ttc" id="aclassFullMatrix_html"><div class="ttname"><a href="classFullMatrix.html">FullMatrix&lt; double &gt;</a></div></div>
<div class="ttc" id="aclassSymmetricTensor_html_ab14ac27fc9ab74d4de531698b492d8de"><div class="ttname"><a href="classSymmetricTensor.html#ab14ac27fc9ab74d4de531698b492d8de">SymmetricTensor::scalar_product</a></div><div class="ttdeci">constexpr ProductType&lt; Number, OtherNumber &gt;::type scalar_product(const SymmetricTensor&lt; 2, dim, Number &gt; &amp;t1, const SymmetricTensor&lt; 2, dim, OtherNumber &gt; &amp;t2)</div><div class="ttdef"><b>Definition:</b> <a href="symmetric__tensor_8h_source.html#l03693">symmetric_tensor.h:3693</a></div></div>
<div class="ttc" id="aclassVector_html"><div class="ttname"><a href="classVector.html">Vector&lt; double &gt;</a></div></div>
<div class="ttc" id="afe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea"><div class="ttname"><a href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a></div><div class="ttdeci">@ update_values</div><div class="ttdoc">Shape function values.</div><div class="ttdef"><b>Definition:</b> <a href="fe__update__flags_8h_source.html#l00078">fe_update_flags.h:78</a></div></div>
<div class="ttc" id="afe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20"><div class="ttname"><a href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a></div><div class="ttdeci">@ update_gradients</div><div class="ttdoc">Shape function gradients.</div><div class="ttdef"><b>Definition:</b> <a href="fe__update__flags_8h_source.html#l00084">fe_update_flags.h:84</a></div></div>
<div class="ttc" id="agroup__Vectors_html_gga40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708"><div class="ttname"><a href="group__Vectors.html#gga40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a></div><div class="ttdeci">@ add</div><div class="ttdef"><b>Definition:</b> <a href="vector__operation_8h_source.html#l00053">vector_operation.h:53</a></div></div>
<div class="ttc" id="anamespaceLocalIntegrators_1_1Advection_html_a8bc7b8136646134f73a4193adefe15f8"><div class="ttname"><a href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">LocalIntegrators::Advection::cell_matrix</a></div><div class="ttdeci">void cell_matrix(FullMatrix&lt; double &gt; &amp;M, const FEValuesBase&lt; dim &gt; &amp;fe, const FEValuesBase&lt; dim &gt; &amp;fetest, const ArrayView&lt; const std::vector&lt; double &gt;&gt; &amp;velocity, const double factor=1.)</div><div class="ttdef"><b>Definition:</b> <a href="advection_8h_source.html#l00075">advection.h:75</a></div></div>
<div class="ttc" id="astructFEValuesExtractors_1_1Scalar_html"><div class="ttname"><a href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="ttdef"><b>Definition:</b> <a href="fe__values__extractors_8h_source.html#l00095">fe_values_extractors.h:96</a></div></div>
</div><!-- fragment --><p>The following method is then the one that deals with the penalty terms that result from imposing the velocity on the impeller. It is, in a sense, the heart of the tutorial, but it is relatively straightforward. Here we exploit the <code>solid_particle_handler</code> to compute the Nitsche restriction or the penalization in the embedded domain.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::assemble_nitsche_restriction()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Assemble Nitsche terms&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(spacedim);</div>
<div class="line"> </div>
<div class="line">  SolidVelocity&lt;spacedim&gt; solid_velocity(par.angular_velocity);</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;types::global_dof_index&gt; fluid_dof_indices(</div>
<div class="line">    fluid_fe-&gt;n_dofs_per_cell());</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>     local_matrix(fluid_fe-&gt;n_dofs_per_cell(),</div>
<div class="line">                                  fluid_fe-&gt;n_dofs_per_cell());</div>
<div class="line">  <a class="code" href="classVector.html">::Vector&lt;double&gt;</a> local_rhs(fluid_fe-&gt;n_dofs_per_cell());</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> penalty_parameter =</div>
<div class="line">    1.0 / <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(fluid_tria);</div>
<div class="ttc" id="anamespaceGridTools_html_a47c293eff2ec7ce4b90ba08b35d1f2e2"><div class="ttname"><a href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a></div><div class="ttdeci">double minimal_cell_diameter(const Triangulation&lt; dim, spacedim &gt; &amp;triangulation, const Mapping&lt; dim, spacedim &gt; &amp;mapping=(ReferenceCells::get_hypercube&lt; dim &gt;() .template get_default_linear_mapping&lt; dim, spacedim &gt;()))</div><div class="ttdef"><b>Definition:</b> <a href="grid__tools_8cc_source.html#l04274">grid_tools.cc:4274</a></div></div>
</div><!-- fragment --><p>We loop over all the local particles. Although this could be achieved directly by looping over all the cells, this would force us to loop over numerous cells which do not contain particles. Consequently, we loop over all the particles, but, we get the reference of the cell in which the particle lies and then loop over all particles within that cell. This enables us to skip the cells which do not contain particles, yet to assemble the local matrix and rhs of each cell to apply the Nitsche restriction. Once we are done with all particles on one cell, we advance the <code>particle</code> iterator to the particle past the end of the ones on the current cell (this is the last line of the <code>while</code> loop's body).</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> particle = solid_particle_handler.begin();</div>
<div class="line"><span class="keywordflow">while</span> (particle != solid_particle_handler.end())</div>
<div class="line">  {</div>
<div class="line">    local_matrix = 0;</div>
<div class="line">    local_rhs    = 0;</div>
</div><!-- fragment --><p>We get an iterator to the cell within which the particle lies from the particle itself. We can then assemble the additional terms in the system matrix and the right hand side as we would normally.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell = particle-&gt;get_surrounding_cell(fluid_tria);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;dh_cell =</div>
<div class="line">  <span class="keyword">typename</span> <a class="code" href="group__Iterators.html#ga32b2a057d9abd2e1752bf8a3cb88e644">DoFHandler&lt;spacedim&gt;::cell_iterator</a>(*cell, &amp;fluid_dh);</div>
<div class="line">dh_cell-&gt;get_dof_indices(fluid_dof_indices);</div>
<div class="ttc" id="agroup__Iterators_html_ga32b2a057d9abd2e1752bf8a3cb88e644"><div class="ttname"><a href="group__Iterators.html#ga32b2a057d9abd2e1752bf8a3cb88e644">DoFHandler::cell_iterator</a></div><div class="ttdeci">typename ActiveSelector::cell_iterator cell_iterator</div><div class="ttdef"><b>Definition:</b> <a href="dofs_2dof__handler_8h_source.html#l00466">dof_handler.h:466</a></div></div>
</div><!-- fragment --><p>So then let us get the collection of cells that are located on this cell and iterate over them. From each particle we gather the location and the reference location of the particle as well as the additional information that is attached to the particle. In the present case, this information is the "JxW" of the quadrature points which were used to generate the particles.</p>
<p>Using this information, we can add the contribution of the quadrature point to the local_matrix and local_rhs. We can evaluate the value of the shape function at the position of each particle easily by using its reference location.</p>
<div class="fragment"><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> pic = solid_particle_handler.particles_in_cell(cell);</div>
<div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(pic.begin() == particle, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : pic)</div>
<div class="line">        {</div>
<div class="line">          <span class="keyword">const</span> <span class="keyword">auto</span> &amp;ref_q  = p.get_reference_location();</div>
<div class="line">          <span class="keyword">const</span> <span class="keyword">auto</span> &amp;real_q = p.get_location();</div>
<div class="line">          <span class="keyword">const</span> <span class="keyword">auto</span> &amp;JxW    = p.get_properties()[0];</div>
<div class="line"> </div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; fluid_fe-&gt;n_dofs_per_cell(); ++i)</div>
<div class="line">            {</div>
<div class="line">              <span class="keyword">const</span> <span class="keyword">auto</span> comp_i =</div>
<div class="line">                fluid_fe-&gt;system_to_component_index(i).first;</div>
<div class="line">              <span class="keywordflow">if</span> (comp_i &lt; spacedim)</div>
<div class="line">                {</div>
<div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; fluid_fe-&gt;n_dofs_per_cell();</div>
<div class="line">                       ++j)</div>
<div class="line">                    {</div>
<div class="line">                      <span class="keyword">const</span> <span class="keyword">auto</span> comp_j =</div>
<div class="line">                        fluid_fe-&gt;system_to_component_index(j).first;</div>
<div class="line">                      <span class="keywordflow">if</span> (comp_i == comp_j)</div>
<div class="line">                        local_matrix(i, j) +=</div>
<div class="line">                          penalty_parameter * par.penalty_term *</div>
<div class="line">                          fluid_fe-&gt;shape_value(i, ref_q) *</div>
<div class="line">                          fluid_fe-&gt;shape_value(j, ref_q) * JxW;</div>
<div class="line">                    }</div>
<div class="line">                  local_rhs(i) += penalty_parameter * par.penalty_term *</div>
<div class="line">                                  solid_velocity.value(real_q, comp_i) *</div>
<div class="line">                                  fluid_fe-&gt;shape_value(i, ref_q) * JxW;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">      constraints.distribute_local_to_global(local_matrix,</div>
<div class="line">                                             local_rhs,</div>
<div class="line">                                             fluid_dof_indices,</div>
<div class="line">                                             system_matrix,</div>
<div class="line">                                             system_rhs);</div>
<div class="line">      particle = pic.end();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  system_matrix.compress(<a class="code" href="group__Vectors.html#gga40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div>
<div class="line">  system_rhs.compress(<a class="code" href="group__Vectors.html#gga40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="Solvingthelinearsystem"></a> </p><h4>Solving the linear system</h4>
<p>This function solves the linear system with FGMRES with a block diagonal preconditioner and an algebraic multigrid (AMG) method for the diagonal blocks. The preconditioner applies a V cycle to the \((0,0)\) (i.e., the velocity-velocity) block and a CG with the mass matrix for the \((1,1)\) block (which is our approximation to the Schur complement: the pressure mass matrix assembled above).</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::solve()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Solve&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="namespaceLinearAlgebraPETSc_1_1MPI.html#a41f11f7a1992c6d6aa9367b12c68f791">LA::MPI::PreconditionAMG</a> prec_A;</div>
<div class="line">    {</div>
<div class="line">      LA::MPI::PreconditionAMG::AdditionalData data;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef USE_PETSC_LA</span></div>
<div class="line">      data.symmetric_operator = <span class="keyword">true</span>;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">      prec_A.<a class="code" href="classPETScWrappers_1_1PreconditionBoomerAMG.html#a3c82672eac786d7f369b296439859ff2">initialize</a>(system_matrix.block(0, 0), data);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="namespaceLinearAlgebraPETSc_1_1MPI.html#a41f11f7a1992c6d6aa9367b12c68f791">LA::MPI::PreconditionAMG</a> prec_S;</div>
<div class="line">    {</div>
<div class="line">      LA::MPI::PreconditionAMG::AdditionalData data;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef USE_PETSC_LA</span></div>
<div class="line">      data.symmetric_operator = <span class="keyword">true</span>;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">      prec_S.<a class="code" href="classPETScWrappers_1_1PreconditionBoomerAMG.html#a3c82672eac786d7f369b296439859ff2">initialize</a>(preconditioner_matrix.block(1, 1), data);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a> = linear_operator&lt;LA::MPI::Vector&gt;(system_matrix.block(0, 0));</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> amgA = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>, prec_A);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> S =</div>
<div class="line">      linear_operator&lt;LA::MPI::Vector&gt;(preconditioner_matrix.block(1, 1));</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> amgS = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(S, prec_S);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classReductionControl.html">ReductionControl</a>          inner_solver_control(100,</div>
<div class="line">                                          1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8 * system_rhs.l2_norm(),</div>
<div class="line">                                          1.e-2);</div>
<div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;LA::MPI::Vector&gt;</a> cg(inner_solver_control);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> invS = <a class="code" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a>(S, cg, amgS);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> P = block_diagonal_operator&lt;2, LA::MPI::BlockVector&gt;(</div>
<div class="line">      std::array&lt;</div>
<div class="line">        ::<a class="code" href="classLinearOperator.html">LinearOperator&lt;typename LA::MPI::BlockVector::BlockType&gt;</a>,</div>
<div class="line">        2&gt;{{amgA, amgS}});</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(system_matrix.m(),</div>
<div class="line">                                 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-10 * system_rhs.l2_norm());</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classSolverFGMRES.html">SolverFGMRES&lt;LA::MPI::BlockVector&gt;</a> solver(solver_control);</div>
<div class="line"> </div>
<div class="line">    constraints.set_zero(solution);</div>
<div class="line"> </div>
<div class="line">    solver.solve(system_matrix, solution, system_rhs, P);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Solved in &quot;</span> &lt;&lt; solver_control.last_step() &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span></div>
<div class="line">          &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    constraints.distribute(solution);</div>
<div class="line"> </div>
<div class="line">    locally_relevant_solution = solution;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> mean_pressure =</div>
<div class="line">      <a class="code" href="namespaceVectorTools.html#ad086eb08b8424fd7c853e389a3978a9a">VectorTools::compute_mean_value</a>(fluid_dh,</div>
<div class="line">                                      <a class="code" href="classQGauss.html">QGauss&lt;spacedim&gt;</a>(par.velocity_degree + 2),</div>
<div class="line">                                      locally_relevant_solution,</div>
<div class="line">                                      spacedim);</div>
<div class="line">    solution.block(1).add(-mean_pressure);</div>
<div class="line">    locally_relevant_solution.block(1) = solution.block(1);</div>
<div class="line">  }</div>
<div class="ttc" id="aclassLinearOperator_html"><div class="ttname"><a href="classLinearOperator.html">LinearOperator</a></div><div class="ttdef"><b>Definition:</b> <a href="linear__operator_8h_source.html#l00179">linear_operator.h:180</a></div></div>
<div class="ttc" id="aclassPETScWrappers_1_1PreconditionBoomerAMG_html_a3c82672eac786d7f369b296439859ff2"><div class="ttname"><a href="classPETScWrappers_1_1PreconditionBoomerAMG.html#a3c82672eac786d7f369b296439859ff2">PETScWrappers::PreconditionBoomerAMG::initialize</a></div><div class="ttdeci">void initialize(const MatrixBase &amp;matrix, const AdditionalData &amp;additional_data=AdditionalData())</div><div class="ttdef"><b>Definition:</b> <a href="petsc__precondition_8cc_source.html#l00679">petsc_precondition.cc:679</a></div></div>
<div class="ttc" id="aclassReductionControl_html"><div class="ttname"><a href="classReductionControl.html">ReductionControl</a></div><div class="ttdef"><b>Definition:</b> <a href="solver__control_8h_source.html#l00423">solver_control.h:424</a></div></div>
<div class="ttc" id="aclassSolverCG_html"><div class="ttname"><a href="classSolverCG.html">SolverCG</a></div><div class="ttdef"><b>Definition:</b> <a href="solver__cg_8h_source.html#l00095">solver_cg.h:96</a></div></div>
<div class="ttc" id="aclassSolverControl_html"><div class="ttname"><a href="classSolverControl.html">SolverControl</a></div><div class="ttdef"><b>Definition:</b> <a href="solver__control_8h_source.html#l00065">solver_control.h:66</a></div></div>
<div class="ttc" id="aclassSolverFGMRES_html"><div class="ttname"><a href="classSolverFGMRES.html">SolverFGMRES</a></div><div class="ttdef"><b>Definition:</b> <a href="solver__gmres_8h_source.html#l00459">solver_gmres.h:460</a></div></div>
<div class="ttc" id="agroup__LAOperators_html_ga6b74b7ed76e4aeea2c67c0bbb03e3e24"><div class="ttname"><a href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">LinearOperator::linear_operator</a></div><div class="ttdeci">LinearOperator&lt; Range, Domain, Payload &gt; linear_operator(const Matrix &amp;matrix)</div><div class="ttdef"><b>Definition:</b> <a href="linear__operator_8h_source.html#l01379">linear_operator.h:1379</a></div></div>
<div class="ttc" id="agroup__LAOperators_html_ga87e38fbde431397c069a88692bd24ae7"><div class="ttname"><a href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">LinearOperator::inverse_operator</a></div><div class="ttdeci">LinearOperator&lt; Domain, Range, Payload &gt; inverse_operator(const LinearOperator&lt; Range, Domain, Payload &gt; &amp;op, Solver &amp;solver, const Preconditioner &amp;preconditioner)</div><div class="ttdef"><b>Definition:</b> <a href="linear__operator_8h_source.html#l00701">linear_operator.h:701</a></div></div>
<div class="ttc" id="anamespaceLAPACKSupport_html_a40707d49114d54318c823f3b750e89a4"><div class="ttname"><a href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">LAPACKSupport::A</a></div><div class="ttdeci">static const char A</div><div class="ttdef"><b>Definition:</b> <a href="lapack__support_8h_source.html#l00153">lapack_support.h:153</a></div></div>
<div class="ttc" id="anamespaceLinearAlgebraPETSc_1_1MPI_html_a41f11f7a1992c6d6aa9367b12c68f791"><div class="ttname"><a href="namespaceLinearAlgebraPETSc_1_1MPI.html#a41f11f7a1992c6d6aa9367b12c68f791">LinearAlgebraPETSc::MPI::PreconditionAMG</a></div><div class="ttdeci">PETScWrappers::PreconditionBoomerAMG PreconditionAMG</div><div class="ttdef"><b>Definition:</b> <a href="generic__linear__algebra_8h_source.html#l00133">generic_linear_algebra.h:133</a></div></div>
<div class="ttc" id="anamespacePhysics_1_1Elasticity_1_1Kinematics_html_a9587d5229555daa5b1fa1ba2f8a40adb"><div class="ttname"><a href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">Physics::Elasticity::Kinematics::e</a></div><div class="ttdeci">SymmetricTensor&lt; 2, dim, Number &gt; e(const Tensor&lt; 2, dim, Number &gt; &amp;F)</div></div>
<div class="ttc" id="anamespaceVectorTools_html_ad086eb08b8424fd7c853e389a3978a9a"><div class="ttname"><a href="namespaceVectorTools.html#ad086eb08b8424fd7c853e389a3978a9a">VectorTools::compute_mean_value</a></div><div class="ttdeci">VectorType::value_type compute_mean_value(const Mapping&lt; dim, spacedim &gt; &amp;mapping, const DoFHandler&lt; dim, spacedim &gt; &amp;dof, const Quadrature&lt; dim &gt; &amp;quadrature, const VectorType &amp;v, const unsigned int component)</div></div>
</div><!-- fragment --><p><a class="anchor" id="Meshrefinement"></a> </p><h4>Mesh refinement</h4>
<p>We deal with mesh refinement in a completely standard way:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::refine_and_transfer()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a>               t(computing_timer, <span class="stringliteral">&quot;Refine&quot;</span>);</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocity(0);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> error_per_cell(fluid_tria.n_active_cells());</div>
<div class="line">  <a class="code" href="classKellyErrorEstimator.html#aa0917e696d4f8ddb983223a68c512357">KellyErrorEstimator&lt;spacedim&gt;::estimate</a>(fluid_dh,</div>
<div class="line">                                          <a class="code" href="classQGauss.html">QGauss&lt;spacedim - 1&gt;</a>(</div>
<div class="line">                                            par.velocity_degree + 1),</div>
<div class="line">                                          {},</div>
<div class="line">                                          locally_relevant_solution,</div>
<div class="line">                                          error_per_cell,</div>
<div class="line">                                          fluid_fe-&gt;component_mask(velocity));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (par.refinement_strategy == <span class="stringliteral">&quot;fixed_fraction&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#ae5159e3207f6786f0749fc0b66ab8ca3">parallel::distributed::GridRefinement::</a></div>
<div class="line"><a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#ae5159e3207f6786f0749fc0b66ab8ca3">        refine_and_coarsen_fixed_fraction</a>(fluid_tria,</div>
<div class="line">                                          error_per_cell,</div>
<div class="line">                                          par.refinement_fraction,</div>
<div class="line">                                          par.coarsening_fraction);</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (par.refinement_strategy == <span class="stringliteral">&quot;fixed_number&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#aa2ffb707a796ae6dedb75036606ef2e6">parallel::distributed::GridRefinement::refine_and_coarsen_fixed_number</a>(</div>
<div class="line">        fluid_tria,</div>
<div class="line">        error_per_cell,</div>
<div class="line">        par.refinement_fraction,</div>
<div class="line">        par.coarsening_fraction,</div>
<div class="line">        par.max_cells);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : fluid_tria.active_cell_iterators())</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">if</span> (cell-&gt;refine_flag_set() &amp;&amp;</div>
<div class="line">          cell-&gt;level() == par.max_level_refinement)</div>
<div class="line">        cell-&gt;clear_refine_flag();</div>
<div class="line">      <span class="keywordflow">if</span> (cell-&gt;coarsen_flag_set() &amp;&amp;</div>
<div class="line">          cell-&gt;level() == par.min_level_refinement)</div>
<div class="line">        cell-&gt;clear_coarsen_flag();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer&lt;spacedim, LA::MPI::BlockVector&gt;</a></div>
<div class="line">    transfer(fluid_dh);</div>
<div class="line">  fluid_tria.prepare_coarsening_and_refinement();</div>
<div class="line">  transfer.prepare_for_coarsening_and_refinement(locally_relevant_solution);</div>
<div class="line">  fluid_tria.execute_coarsening_and_refinement();</div>
<div class="line"> </div>
<div class="line">  setup_dofs();</div>
<div class="line"> </div>
<div class="line">  transfer.interpolate(solution);</div>
<div class="line">  constraints.distribute(solution);</div>
<div class="line">  locally_relevant_solution = solution;</div>
<div class="line">}</div>
<div class="ttc" id="aclassKellyErrorEstimator_html_aa0917e696d4f8ddb983223a68c512357"><div class="ttname"><a href="classKellyErrorEstimator.html#aa0917e696d4f8ddb983223a68c512357">KellyErrorEstimator::estimate</a></div><div class="ttdeci">static void estimate(const Mapping&lt; dim, spacedim &gt; &amp;mapping, const DoFHandler&lt; dim, spacedim &gt; &amp;dof, const Quadrature&lt; dim - 1 &gt; &amp;quadrature, const std::map&lt; types::boundary_id, const Function&lt; spacedim, typename InputVector::value_type &gt; * &gt; &amp;neumann_bc, const InputVector &amp;solution, Vector&lt; float &gt; &amp;error, const ComponentMask &amp;component_mask=ComponentMask(), const Function&lt; spacedim &gt; *coefficients=nullptr, const unsigned int n_threads=numbers::invalid_unsigned_int, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id, const types::material_id material_id=numbers::invalid_material_id, const Strategy strategy=cell_diameter_over_24)</div></div>
<div class="ttc" id="aclassparallel_1_1distributed_1_1SolutionTransfer_html"><div class="ttname"><a href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a></div><div class="ttdef"><b>Definition:</b> <a href="distributed_2solution__transfer_8h_source.html#l00224">solution_transfer.h:225</a></div></div>
<div class="ttc" id="anamespaceparallel_1_1distributed_1_1GridRefinement_html_aa2ffb707a796ae6dedb75036606ef2e6"><div class="ttname"><a href="namespaceparallel_1_1distributed_1_1GridRefinement.html#aa2ffb707a796ae6dedb75036606ef2e6">parallel::distributed::GridRefinement::refine_and_coarsen_fixed_number</a></div><div class="ttdeci">void refine_and_coarsen_fixed_number(parallel::distributed::Triangulation&lt; dim, spacedim &gt; &amp;tria, const ::Vector&lt; Number &gt; &amp;criteria, const double top_fraction_of_cells, const double bottom_fraction_of_cells, const types::global_cell_index max_n_cells=std::numeric_limits&lt; types::global_cell_index &gt;::max())</div><div class="ttdef"><b>Definition:</b> <a href="distributed_2grid__refinement_8cc_source.html#l00493">grid_refinement.cc:493</a></div></div>
<div class="ttc" id="anamespaceparallel_1_1distributed_1_1GridRefinement_html_ae5159e3207f6786f0749fc0b66ab8ca3"><div class="ttname"><a href="namespaceparallel_1_1distributed_1_1GridRefinement.html#ae5159e3207f6786f0749fc0b66ab8ca3">parallel::distributed::GridRefinement::refine_and_coarsen_fixed_fraction</a></div><div class="ttdeci">void refine_and_coarsen_fixed_fraction(parallel::distributed::Triangulation&lt; dim, spacedim &gt; &amp;tria, const ::Vector&lt; Number &gt; &amp;criteria, const double top_fraction_of_error, const double bottom_fraction_of_error, const VectorTools::NormType norm_type=VectorTools::NormType::L1_norm)</div><div class="ttdef"><b>Definition:</b> <a href="distributed_2grid__refinement_8cc_source.html#l00566">grid_refinement.cc:566</a></div></div>
</div><!-- fragment --><p><a class="anchor" id="Creatingoutputforvisualization"></a> </p><h4>Creating output for visualization</h4>
<p>We output the results (velocity and pressure) on the fluid domain using the standard parallel capabilities of deal.II. A single compressed vtu file is written that agglomerates the information of all processors. An additional <code>.pvd</code> record is written to associate the physical time to the vtu files.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">StokesImmersedProblem&lt;dim, spacedim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle,</div>
<div class="line">                                                     <span class="keywordtype">double</span> time)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output fluid&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;std::string&gt; solution_names(spacedim, <span class="stringliteral">&quot;velocity&quot;</span>);</div>
<div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;pressure&quot;</span>);</div>
<div class="line">  std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div>
<div class="line">    data_component_interpretation(</div>
<div class="line">      spacedim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div>
<div class="line">  data_component_interpretation.push_back(</div>
<div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;spacedim&gt;</a> data_out;</div>
<div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a>(fluid_dh);</div>
<div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a>(locally_relevant_solution,</div>
<div class="line">                           solution_names,</div>
<div class="line">                           <a class="code" href="classDataOut.html">DataOut&lt;spacedim&gt;::type_dof_data</a>,</div>
<div class="line">                           data_component_interpretation);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> subdomain(fluid_tria.n_active_cells());</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; subdomain.size(); ++i)</div>
<div class="line">    subdomain(i) = fluid_tria.locally_owned_subdomain();</div>
<div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a>(subdomain, <span class="stringliteral">&quot;subdomain&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> std::string filename =</div>
<div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div>
<div class="line">  data_out.<a class="code" href="group__Exceptions.html#ga5df488dad82b811ceb08cb1adf9eafcd">write_vtu_in_parallel</a>(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + filename,</div>
<div class="line">                                 mpi_communicator);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">static</span> std::vector&lt;std::pair&lt;double, std::string&gt;&gt; times_and_names;</div>
<div class="line">  times_and_names.push_back(std::make_pair(time, filename));</div>
<div class="line">  std::ofstream ofile(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + <span class="stringliteral">&quot;solution.pvd&quot;</span>);</div>
<div class="line">  <a class="code" href="namespaceDataOutBase.html#a6f1c052ba49fd44cd8e3f35ba871aebd">DataOutBase::write_pvd_record</a>(ofile, times_and_names);</div>
<div class="line">}</div>
<div class="ttc" id="aclassDataOut__DoFData_html_ac1eb26168177faa30ffbcf9cbb9c3cd5"><div class="ttname"><a href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">DataOut_DoFData::attach_dof_handler</a></div><div class="ttdeci">void attach_dof_handler(const DoFHandlerType &amp;)</div></div>
<div class="ttc" id="aclassDataOut__DoFData_html_ace4b76e565ba0701c4d32c26075ed3b9"><div class="ttname"><a href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">DataOut_DoFData::add_data_vector</a></div><div class="ttdeci">void add_data_vector(const VectorType &amp;data, const std::vector&lt; std::string &gt; &amp;names, const DataVectorType type=type_automatic, const std::vector&lt; DataComponentInterpretation::DataComponentInterpretation &gt; &amp;data_component_interpretation=std::vector&lt; DataComponentInterpretation::DataComponentInterpretation &gt;())</div><div class="ttdef"><b>Definition:</b> <a href="data__out__dof__data_8h_source.html#l01087">data_out_dof_data.h:1087</a></div></div>
<div class="ttc" id="aclassDataOut_html"><div class="ttname"><a href="classDataOut.html">DataOut</a></div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__out_8h_source.html#l00147">data_out.h:150</a></div></div>
<div class="ttc" id="aclassDataOut_html_a5eb51872b8736849bb7e8d2007fae086"><div class="ttname"><a href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">DataOut::build_patches</a></div><div class="ttdeci">virtual void build_patches(const unsigned int n_subdivisions=0)</div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__out_8cc_source.html#l01085">data_out.cc:1085</a></div></div>
<div class="ttc" id="agroup__Exceptions_html_ga5df488dad82b811ceb08cb1adf9eafcd"><div class="ttname"><a href="group__Exceptions.html#ga5df488dad82b811ceb08cb1adf9eafcd">DataOutInterface::write_vtu_in_parallel</a></div><div class="ttdeci">void write_vtu_in_parallel(const std::string &amp;filename, const MPI_Comm &amp;comm) const</div><div class="ttdef"><b>Definition:</b> <a href="data__out__base_8cc_source.html#l07210">data_out_base.cc:7210</a></div></div>
<div class="ttc" id="anamespaceDataComponentInterpretation_html_a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51"><div class="ttname"><a href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a></div><div class="ttdeci">@ component_is_scalar</div><div class="ttdef"><b>Definition:</b> <a href="data__component__interpretation_8h_source.html#l00053">data_component_interpretation.h:53</a></div></div>
<div class="ttc" id="anamespaceDataComponentInterpretation_html_a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0"><div class="ttname"><a href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a></div><div class="ttdeci">@ component_is_part_of_vector</div><div class="ttdef"><b>Definition:</b> <a href="data__component__interpretation_8h_source.html#l00059">data_component_interpretation.h:59</a></div></div>
<div class="ttc" id="anamespaceDataOutBase_html_a6f1c052ba49fd44cd8e3f35ba871aebd"><div class="ttname"><a href="namespaceDataOutBase.html#a6f1c052ba49fd44cd8e3f35ba871aebd">DataOutBase::write_pvd_record</a></div><div class="ttdeci">void write_pvd_record(std::ostream &amp;out, const std::vector&lt; std::pair&lt; double, std::string &gt;&gt; &amp;times_and_names)</div><div class="ttdef"><b>Definition:</b> <a href="data__out__base_8cc_source.html#l05919">data_out_base.cc:5919</a></div></div>
<div class="ttc" id="anamespaceUtilities_html_a6195c5f009ea8c7c536c6ffdf108c32f"><div class="ttname"><a href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a></div><div class="ttdeci">std::string int_to_string(const unsigned int value, const unsigned int digits=numbers::invalid_unsigned_int)</div><div class="ttdef"><b>Definition:</b> <a href="base_2utilities_8cc_source.html#l00473">utilities.cc:473</a></div></div>
</div><!-- fragment --><p>Similarly, we write the particles (either from the solid or the tracers) as a single compressed vtu file through the <a class="el" href="classParticles_1_1DataOut.html">Particles::DataOut</a> object. This simple object does not write the additional information attached as "properties" to the particles, but only writes their id &ndash; but then, we don't care about the "JxW" values of these particle locations anyway, so no information that we may have wanted to visualize is lost.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::output_particles(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> &amp;particles,</div>
<div class="line">  std::string                                 fprefix,</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                          iter,</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                                time)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <a class="code" href="classParticles_1_1DataOut.html">Particles::DataOut&lt;spacedim&gt;</a> particles_out;</div>
<div class="line">  particles_out.<a class="code" href="classParticles_1_1DataOut.html#adf095165dc286310226584b2b9972701">build_patches</a>(particles);</div>
<div class="line">  <span class="keyword">const</span> std::string filename =</div>
<div class="line">    (fprefix + <span class="stringliteral">&quot;-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(iter) + <span class="stringliteral">&quot;.vtu&quot;</span>);</div>
<div class="line">  particles_out.<a class="code" href="group__Exceptions.html#ga5df488dad82b811ceb08cb1adf9eafcd">write_vtu_in_parallel</a>(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + filename,</div>
<div class="line">                                      mpi_communicator);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">static</span> std::map&lt;std::string, std::vector&lt;std::pair&lt;double, std::string&gt;&gt;&gt;</div>
<div class="line">    times_and_names;</div>
<div class="line">  <span class="keywordflow">if</span> (times_and_names.find(fprefix) != times_and_names.end())</div>
<div class="line">    times_and_names[fprefix].push_back(std::make_pair(time, filename));</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    times_and_names[fprefix] = {std::make_pair(time, filename)};</div>
<div class="line">  std::ofstream ofile(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + fprefix + <span class="stringliteral">&quot;.pvd&quot;</span>);</div>
<div class="line">  <a class="code" href="namespaceDataOutBase.html#a6f1c052ba49fd44cd8e3f35ba871aebd">DataOutBase::write_pvd_record</a>(ofile, times_and_names[fprefix]);</div>
<div class="line">}</div>
<div class="ttc" id="aclassParticles_1_1DataOut_html"><div class="ttname"><a href="classParticles_1_1DataOut.html">Particles::DataOut</a></div><div class="ttdef"><b>Definition:</b> <a href="particles_2data__out_8h_source.html#l00044">data_out.h:45</a></div></div>
<div class="ttc" id="aclassParticles_1_1DataOut_html_adf095165dc286310226584b2b9972701"><div class="ttname"><a href="classParticles_1_1DataOut.html#adf095165dc286310226584b2b9972701">Particles::DataOut::build_patches</a></div><div class="ttdeci">void build_patches(const Particles::ParticleHandler&lt; dim, spacedim &gt; &amp;particles, const std::vector&lt; std::string &gt; &amp;data_component_names={}, const std::vector&lt; DataComponentInterpretation::DataComponentInterpretation &gt; &amp;data_component_interpretations={})</div><div class="ttdef"><b>Definition:</b> <a href="particles_2data__out_8cc_source.html#l00028">data_out.cc:28</a></div></div>
</div><!-- fragment --><p><a class="anchor" id="Therunfunction"></a> </p><h4>The "run" function</h4>
<p>This function now orchestrates the entire simulation. It is very similar to the other time dependent tutorial programs &ndash; take <a class="el" href="step_21.html">step-21</a> or <a class="el" href="step_26.html">step-26</a> as an example. At the beginning, we output some status information and also save all current parameters to a file in the output directory, for reproducibility.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">StokesImmersedProblem&lt;dim, spacedim&gt;::run</a>()</div>
<div class="line">  {</div>
<div class="line"><span class="preprocessor">#ifdef USE_PETSC_LA</span></div>
<div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Running StokesImmersedProblem&lt;&quot;</span></div>
<div class="line">          &lt;&lt; <a class="code" href="namespaceUtilities.html#a21aa22d290ce783e37587b6c879b926c">Utilities::dim_string</a>(dim, spacedim) &lt;&lt; <span class="stringliteral">&quot;&gt; using PETSc.&quot;</span></div>
<div class="line">          &lt;&lt; std::endl;</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Running StokesImmersedProblem&lt;&quot;</span></div>
<div class="line">          &lt;&lt; <a class="code" href="namespaceUtilities.html#a21aa22d290ce783e37587b6c879b926c">Utilities::dim_string</a>(dim, spacedim) &lt;&lt; <span class="stringliteral">&quot;&gt; using Trilinos.&quot;</span></div>
<div class="line">          &lt;&lt; std::endl;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">    par.prm.print_parameters(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + <span class="stringliteral">&quot;used_parameters_&quot;</span> +</div>
<div class="line">                               <a class="code" href="group__Exceptions.html#ga72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(dim) + <a class="code" href="group__Exceptions.html#ga72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(spacedim) +</div>
<div class="line">                               <span class="stringliteral">&quot;.prm&quot;</span>,</div>
<div class="line">                             <a class="code" href="group__Exceptions.html#ga8364dda711b93753c6809eefe2a8e827a3c8ad66ea26104112458e2ce35b5028f">ParameterHandler::Short</a>);</div>
<div class="ttc" id="agroup__Exceptions_html_ga72743302dcb1a0fb1f2f8dc5122d299e"><div class="ttname"><a href="group__Exceptions.html#ga72743302dcb1a0fb1f2f8dc5122d299e">Patterns::Tools::to_string</a></div><div class="ttdeci">std::string to_string(const T &amp;t)</div><div class="ttdef"><b>Definition:</b> <a href="patterns_8h_source.html#l02329">patterns.h:2329</a></div></div>
<div class="ttc" id="agroup__Exceptions_html_ga8364dda711b93753c6809eefe2a8e827a3c8ad66ea26104112458e2ce35b5028f"><div class="ttname"><a href="group__Exceptions.html#ga8364dda711b93753c6809eefe2a8e827a3c8ad66ea26104112458e2ce35b5028f">ParameterHandler::Short</a></div><div class="ttdeci">@ Short</div><div class="ttdef"><b>Definition:</b> <a href="parameter__handler_8h_source.html#l00870">parameter_handler.h:870</a></div></div>
<div class="ttc" id="anamespaceUtilities_html_a21aa22d290ce783e37587b6c879b926c"><div class="ttname"><a href="namespaceUtilities.html#a21aa22d290ce783e37587b6c879b926c">Utilities::dim_string</a></div><div class="ttdeci">std::string dim_string(const int dim, const int spacedim)</div><div class="ttdef"><b>Definition:</b> <a href="base_2utilities_8cc_source.html#l00558">utilities.cc:558</a></div></div>
</div><!-- fragment --><p>We then start the time loop. We initialize all the elements of the simulation in the first cycle</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> time_step    = par.final_time / (par.number_of_time_steps - 1);</div>
<div class="line"><span class="keywordtype">double</span>       time         = 0;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> output_cycle = 0;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; par.number_of_time_steps;</div>
<div class="line">     ++cycle, time += time_step)</div>
<div class="line">  {</div>
<div class="line">    par.set_time(time);</div>
<div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl</div>
<div class="line">          &lt;&lt; <span class="stringliteral">&quot;Time : &quot;</span> &lt;&lt; time &lt;&lt; <span class="stringliteral">&quot;, time step: &quot;</span> &lt;&lt; time_step &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (cycle == 0)</div>
<div class="line">      {</div>
<div class="line">        make_grid();</div>
<div class="line">        initial_setup();</div>
<div class="line">        setup_dofs();</div>
<div class="line">        setup_tracer_particles();</div>
<div class="line">        setup_solid_particles();</div>
<div class="line">        tracer_particle_velocities.reinit(</div>
<div class="line">          locally_owned_tracer_particle_coordinates, mpi_communicator);</div>
<div class="line">        output_results(output_cycle, time);</div>
<div class="line">        {</div>
<div class="line">          <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output tracer particles&quot;</span>);</div>
<div class="line">          output_particles(tracer_particle_handler,</div>
<div class="line">                           <span class="stringliteral">&quot;tracer&quot;</span>,</div>
<div class="line">                           output_cycle,</div>
<div class="line">                           time);</div>
<div class="line">        }</div>
<div class="line">        {</div>
<div class="line">          <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output solid particles&quot;</span>);</div>
<div class="line">          output_particles(solid_particle_handler,</div>
<div class="line">                           <span class="stringliteral">&quot;solid&quot;</span>,</div>
<div class="line">                           output_cycle,</div>
<div class="line">                           time);</div>
<div class="line">        }</div>
<div class="line">      }</div>
</div><!-- fragment --><p>After the first time step, we displace the solid body at the beginning of each time step to take into account the fact that is has moved.</p>
<div class="fragment"><div class="line"><span class="keywordflow">else</span></div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer,</div>
<div class="line">                         <span class="stringliteral">&quot;Set solid particle position&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    SolidPosition&lt;spacedim&gt; solid_position(par.angular_velocity,</div>
<div class="line">                                           time_step);</div>
<div class="line">    solid_particle_handler.set_particle_positions(solid_position,</div>
<div class="line">                                                  <span class="keyword">false</span>);</div>
<div class="line">  }</div>
</div><!-- fragment --><p>In order to update the state of the system, we first interpolate the fluid velocity at the position of the tracer particles and, with a naive explicit Euler scheme, advect the massless tracer particles.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Set tracer particle motion&quot;</span>);</div>
<div class="line">  <a class="code" href="namespaceParticles_1_1Utilities.html#a054f60295f7694c31a30b0019d94df73">Particles::Utilities::interpolate_field_on_particles</a>(</div>
<div class="line">    fluid_dh,</div>
<div class="line">    tracer_particle_handler,</div>
<div class="line">    locally_relevant_solution,</div>
<div class="line">    tracer_particle_velocities,</div>
<div class="line">    fluid_fe-&gt;component_mask(<a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a>(0)));</div>
<div class="line"> </div>
<div class="line">  tracer_particle_velocities *= time_step;</div>
<div class="line"> </div>
<div class="line">  locally_relevant_tracer_particle_coordinates =</div>
<div class="line">    tracer_particle_handler.locally_relevant_ids().tensor_product(</div>
<div class="line">      <a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(spacedim));</div>
<div class="line"> </div>
<div class="line">  relevant_tracer_particle_displacements.reinit(</div>
<div class="line">    locally_owned_tracer_particle_coordinates,</div>
<div class="line">    locally_relevant_tracer_particle_coordinates,</div>
<div class="line">    mpi_communicator);</div>
<div class="line"> </div>
<div class="line">  relevant_tracer_particle_displacements = tracer_particle_velocities;</div>
<div class="line"> </div>
<div class="line">  tracer_particle_handler.set_particle_positions(</div>
<div class="line">    relevant_tracer_particle_displacements);</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceParticles_1_1Utilities_html_a054f60295f7694c31a30b0019d94df73"><div class="ttname"><a href="namespaceParticles_1_1Utilities.html#a054f60295f7694c31a30b0019d94df73">Particles::Utilities::interpolate_field_on_particles</a></div><div class="ttdeci">void interpolate_field_on_particles(const DoFHandler&lt; dim, spacedim &gt; &amp;field_dh, const Particles::ParticleHandler&lt; dim, spacedim &gt; &amp;particle_handler, const InputVectorType &amp;field_vector, OutputVectorType &amp;interpolated_field, const ComponentMask &amp;field_comps=ComponentMask())</div><div class="ttdef"><b>Definition:</b> <a href="include_2deal_8II_2particles_2utilities_8h_source.html#l00187">utilities.h:187</a></div></div>
</div><!-- fragment --><p>Using these new locations, we can then assemble the Stokes system and solve it.</p>
<div class="fragment"><div class="line">assemble_stokes_system();</div>
<div class="line">assemble_nitsche_restriction();</div>
<div class="line">solve();</div>
</div><!-- fragment --><p>With the appropriate frequencies, we then write the information of the solid particles, the tracer particles, and the fluid domain into files for visualization, and end the time step by adapting the mesh.</p>
<div class="fragment"><div class="line">        <span class="keywordflow">if</span> (cycle % par.output_frequency == 0)</div>
<div class="line">          {</div>
<div class="line">            output_results(output_cycle, time);</div>
<div class="line">            {</div>
<div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output tracer particles&quot;</span>);</div>
<div class="line">              output_particles(tracer_particle_handler,</div>
<div class="line">                               <span class="stringliteral">&quot;tracer&quot;</span>,</div>
<div class="line">                               output_cycle,</div>
<div class="line">                               time);</div>
<div class="line">            }</div>
<div class="line">            {</div>
<div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output solid particles&quot;</span>);</div>
<div class="line">              output_particles(solid_particle_handler,</div>
<div class="line">                               <span class="stringliteral">&quot;solid&quot;</span>,</div>
<div class="line">                               output_cycle,</div>
<div class="line">                               time);</div>
<div class="line">            }</div>
<div class="line">            ++output_cycle;</div>
<div class="line">          }</div>
<div class="line">        <span class="keywordflow">if</span> (cycle % par.refinement_frequency == 0 &amp;&amp;</div>
<div class="line">            cycle != par.number_of_time_steps - 1)</div>
<div class="line">          refine_and_transfer();</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace Step70</span></div>
</div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main() function</h3>
<p>The remainder of the code, the <code>main()</code> function, is standard, with the exception of the handling of input parameter files. We allow the user to specify an optional parameter file as an argument to the program. If nothing is specified, we use the default file "parameters.prm", which is created if non existent. The file name is scanned for the the string "23" first, and "3" afterwards. If the filename contains the string "23", the problem classes are instantiated with template arguments 2 and 3 respectively. If only the string "3" is found, then both template arguments are set to 3, otherwise both are set to 2.</p>
<p>If the program is called without any command line arguments (i.e., <code>argc==1</code>), then we just use "parameters.prm" by default.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span>Step70;</div>
<div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
<div class="line">  <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a>.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a>(1);</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv, 1);</div>
<div class="line"> </div>
<div class="line">      std::string prm_file;</div>
<div class="line">      <span class="keywordflow">if</span> (argc &gt; 1)</div>
<div class="line">        prm_file = argv[1];</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">        prm_file = <span class="stringliteral">&quot;parameters.prm&quot;</span>;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">if</span> (prm_file.find(<span class="stringliteral">&quot;23&quot;</span>) != std::string::npos)</div>
<div class="line">        {</div>
<div class="line">          StokesImmersedProblemParameters&lt;2, 3&gt; par;</div>
<div class="line">          <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(prm_file);</div>
<div class="line"> </div>
<div class="line">          StokesImmersedProblem&lt;2, 3&gt; problem(par);</div>
<div class="line">          problem.run();</div>
<div class="line">        }</div>
<div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (prm_file.find(<span class="stringliteral">&quot;3&quot;</span>) != std::string::npos)</div>
<div class="line">        {</div>
<div class="line">          StokesImmersedProblemParameters&lt;3&gt; par;</div>
<div class="line">          <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(prm_file);</div>
<div class="line"> </div>
<div class="line">          StokesImmersedProblem&lt;3&gt; problem(par);</div>
<div class="line">          problem.run();</div>
<div class="line">        }</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">          StokesImmersedProblemParameters&lt;2&gt; par;</div>
<div class="line">          <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(prm_file);</div>
<div class="line"> </div>
<div class="line">          StokesImmersedProblem&lt;2&gt; problem(par);</div>
<div class="line">          problem.run();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassLogStream_html_a8028e970ad8388596d625ed463894e98"><div class="ttname"><a href="classLogStream.html#a8028e970ad8388596d625ed463894e98">LogStream::depth_console</a></div><div class="ttdeci">unsigned int depth_console(const unsigned int n)</div><div class="ttdef"><b>Definition:</b> <a href="logstream_8cc_source.html#l00350">logstream.cc:350</a></div></div>
<div class="ttc" id="aclassParameterAcceptor_html_a8c735525d2865112e5d67f9ba697224e"><div class="ttname"><a href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a></div><div class="ttdeci">static void initialize(const std::string &amp;filename=&quot;&quot;, const std::string &amp;output_filename=&quot;&quot;, const ParameterHandler::OutputStyle output_style_for_output_filename=ParameterHandler::Short, ParameterHandler &amp;prm=ParameterAcceptor::prm, const ParameterHandler::OutputStyle output_style_for_filename=ParameterHandler::DefaultStyle)</div><div class="ttdef"><b>Definition:</b> <a href="parameter__acceptor_8cc_source.html#l00060">parameter_acceptor.cc:60</a></div></div>
<div class="ttc" id="aclassUtilities_1_1MPI_1_1MPI__InitFinalize_html"><div class="ttname"><a href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a></div><div class="ttdef"><b>Definition:</b> <a href="mpi_8h_source.html#l00902">mpi.h:903</a></div></div>
<div class="ttc" id="alogstream_8h_html_ac643e79bd992f1a9bd0dca5b9f2859fb"><div class="ttname"><a href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a></div><div class="ttdeci">LogStream deallog</div><div class="ttdef"><b>Definition:</b> <a href="logstream_8cc_source.html#l00037">logstream.cc:37</a></div></div>
</div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The directory in which this program is run contains a number of sample parameter files that you can use to reproduce the results presented in this section. If you do not specify a parameter file as an argument on the command line, the program will try to read the file "`parameters.prm`" by default, and will execute the two dimensional version of the code. As explained in the discussion of the source code, if your file name contains the string "23", then the program will run a three dimensional problem, with immersed solid of co-dimension one. If it contains the string "3", it will run a three dimensional problem, with immersed solid of co-dimension zero, otherwise it will run a two dimensional problem with immersed solid of co-dimension zero.</p>
<p>Regardless of the specific parameter file name, if the specified file does not exist, when you execute the program you will get an exception that no such file can be found:</p>
<div class="fragment"><div class="line">----------------------------------------------------</div>
<div class="line">Exception on processing:</div>
<div class="line"> </div>
<div class="line">--------------------------------------------------------</div>
<div class="line">An error occurred in line &lt;74&gt; of file &lt;../source/base/parameter_acceptor.cc&gt; in <span class="keyword">function</span></div>
<div class="line">    <span class="keyword">static</span> void ::ParameterAcceptor::initialize(<span class="keyword">const</span> std::string &amp;, <span class="keyword">const</span> std::string &amp;, <span class="keyword">const</span> <a class="code" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">ParameterHandler::OutputStyle</a>, ::<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;)</div>
<div class="line">The violated condition was:</div>
<div class="line">    <span class="keyword">false</span></div>
<div class="line">Additional information:</div>
<div class="line">    You specified &lt;parameters.prm&gt; as input parameter file, but it does not exist. We created it <span class="keywordflow">for</span> you.</div>
<div class="line">--------------------------------------------------------</div>
<div class="line"> </div>
<div class="line">Aborting!</div>
<div class="line">----------------------------------------------------</div>
<div class="ttc" id="aclassParameterHandler_html"><div class="ttname"><a href="classParameterHandler.html">ParameterHandler</a></div><div class="ttdef"><b>Definition:</b> <a href="parameter__handler_8h_source.html#l00840">parameter_handler.h:841</a></div></div>
<div class="ttc" id="aclassParameterHandler_html_a8364dda711b93753c6809eefe2a8e827"><div class="ttname"><a href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">ParameterHandler::OutputStyle</a></div><div class="ttdeci">OutputStyle</div><div class="ttdef"><b>Definition:</b> <a href="parameter__handler_8h_source.html#l00858">parameter_handler.h:859</a></div></div>
</div><!-- fragment --><p>However, as the error message already states, the code that triggers the exception will also generate the specified file ("`parameters.prm`" in this case) that simply contains the default values for all parameters this program cares about (for the correct dimension and co-dimension, according to the whether a string "23" or "3" is contained in the file name). By inspection of the default parameter file, we see the following:</p>
<div class="fragment"><div class="line"><span class="preprocessor"># Listing of Parameters</span></div>
<div class="line"><span class="preprocessor"># ---------------------</span></div>
<div class="line">subsection Stokes Immersed Problem</div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Final time                            = 1</div>
<div class="line"><span class="preprocessor">  # Extraction level of the rtree used to construct global bounding boxes</span></div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Fluid bounding boxes extraction <a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a> = 1</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">  # Boundary Ids over which homogeneous Dirichlet boundary conditions are</span></div>
<div class="line"><span class="preprocessor">  # applied</span></div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Homogeneous Dirichlet boundary ids    = 0</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">  # Initial mesh refinement used for the fluid domain Omega</span></div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Initial fluid refinement              = 5</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">  # Initial mesh refinement used for the solid domain Gamma</span></div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Initial solid refinement              = 5</div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Nitsche penalty term                  = 100</div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Number of time steps                  = 501</div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Output directory                      = .</div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Output frequency                      = 1</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">  # Refinement of the volumetric mesh used to insert the particles</span></div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Particle insertion refinement         = 3</div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Velocity degree                       = 2</div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Viscosity                             = 1</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  subsection Angular velocity</div>
<div class="line"><span class="preprocessor">    # Sometimes it is convenient to use symbolic constants in the expression</span></div>
<div class="line"><span class="preprocessor">    # that describes the function, rather than having to use its numeric value</span></div>
<div class="line"><span class="preprocessor">    # everywhere the constant appears. These values can be defined using this</span></div>
<div class="line"><span class="preprocessor">    # parameter, in the form `var1=value1, var2=value2, ...&#39;.</span></div>
<div class="line"><span class="preprocessor">    #</span></div>
<div class="line"><span class="preprocessor">    # A typical example would be to set this runtime parameter to</span></div>
<div class="line"><span class="preprocessor">    # `pi=3.1415926536&#39; and then use `pi&#39; in the expression of the actual</span></div>
<div class="line"><span class="preprocessor">    # formula. (That said, for convenience this class actually defines both</span></div>
<div class="line"><span class="preprocessor">    # `pi&#39; and `Pi&#39; by default, but you get the idea.)</span></div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> <a class="code" href="classFunction.html">Function</a> constants  =</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">    # The formula that denotes the function you want to evaluate for</span></div>
<div class="line"><span class="preprocessor">    # particular values of the independent variables. This expression may</span></div>
<div class="line"><span class="preprocessor">    # contain any of the usual operations such as addition or multiplication,</span></div>
<div class="line"><span class="preprocessor">    # as well as all of the common functions such as `sin&#39; or `cos&#39;. In</span></div>
<div class="line"><span class="preprocessor">    # addition, it may contain expressions like `if(x&gt;0, 1, -1)&#39; where the</span></div>
<div class="line"><span class="preprocessor">    # expression evaluates to the second argument if the first argument is</span></div>
<div class="line"><span class="preprocessor">    # true, and to the third argument otherwise. For a full overview of</span></div>
<div class="line"><span class="preprocessor">    # possible expressions accepted see the documentation of the muparser</span></div>
<div class="line"><span class="preprocessor">    # library at http:</span><span class="comment">//muparser.beltoforion.de/.</span></div>
<div class="line"><span class="preprocessor">    #</span></div>
<div class="line"><span class="preprocessor">    # If the function you are describing represents a vector-valued function</span></div>
<div class="line"><span class="preprocessor">    # with multiple components, then separate the expressions for individual</span></div>
<div class="line"><span class="preprocessor">    # components by a semicolon.</span></div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> <a class="code" href="classFunction.html">Function</a> expression = t &lt; .500001 ? 6.283185 : -6.283185 # <span class="keywordflow">default</span>: 0</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">    # The names of the variables as they will be used in the function,</span></div>
<div class="line"><span class="preprocessor">    # separated by commas. By default, the names of variables at which the</span></div>
<div class="line"><span class="preprocessor">    # function will be evaluated are `x&#39; (in 1d), `x,y&#39; (in 2d) or `x,y,z&#39; (in</span></div>
<div class="line"><span class="preprocessor">    # 3d) for spatial coordinates and `t&#39; for time. You can then use these</span></div>
<div class="line"><span class="preprocessor">    # variable names in your function expression and they will be replaced by</span></div>
<div class="line"><span class="preprocessor">    # the values of these variables at which the function is currently</span></div>
<div class="line"><span class="preprocessor">    # evaluated. However, you can also choose a different set of names for the</span></div>
<div class="line"><span class="preprocessor">    # independent variables at which to evaluate your function expression. For</span></div>
<div class="line"><span class="preprocessor">    # example, if you work in spherical coordinates, you may wish to set this</span></div>
<div class="line"><span class="preprocessor">    # input parameter to `r,phi,theta,t&#39; and then use these variable names in</span></div>
<div class="line"><span class="preprocessor">    # your function expression.</span></div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Variable names      = x,y,t</div>
<div class="line">  <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div>
<div class="line"> </div>
<div class="line">  subsection Grid generation</div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Fluid grid generator              = <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">hyper_cube</a></div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Fluid grid generator arguments    = -1: 1: <span class="keyword">false</span></div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Particle grid generator           = <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">hyper_ball</a></div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Particle grid generator arguments = 0.3, 0.3: 0.1: <span class="keyword">false</span></div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Solid grid generator              = <a class="code" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">hyper_rectangle</a></div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Solid grid generator arguments    = -.5, -.1: .5, .1: <span class="keyword">false</span></div>
<div class="line">  <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div>
<div class="line"> </div>
<div class="line">  subsection Refinement and remeshing</div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Maximum number of cells        = 20000</div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Refinement coarsening fraction = 0.3</div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Refinement fraction            = 0.3</div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Refinement maximal <a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>       = 8</div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Refinement minimal <a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>       = 5</div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Refinement step frequency      = 5</div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Refinement strategy            = fixed_fraction</div>
<div class="line">  <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div>
<div class="line"> </div>
<div class="line">  subsection Right hand side</div>
<div class="line"><span class="preprocessor">    # Sometimes it is convenient to use symbolic constants in the expression</span></div>
<div class="line"><span class="preprocessor">    # that describes the function, rather than having to use its numeric value</span></div>
<div class="line"><span class="preprocessor">    # everywhere the constant appears. These values can be defined using this</span></div>
<div class="line"><span class="preprocessor">    # parameter, in the form `var1=value1, var2=value2, ...&#39;.</span></div>
<div class="line"><span class="preprocessor">    #</span></div>
<div class="line"><span class="preprocessor">    # A typical example would be to set this runtime parameter to</span></div>
<div class="line"><span class="preprocessor">    # `pi=3.1415926536&#39; and then use `pi&#39; in the expression of the actual</span></div>
<div class="line"><span class="preprocessor">    # formula. (That said, for convenience this class actually defines both</span></div>
<div class="line"><span class="preprocessor">    # `pi&#39; and `Pi&#39; by default, but you get the idea.)</span></div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> <a class="code" href="classFunction.html">Function</a> constants  =</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">    # The formula that denotes the function you want to evaluate for</span></div>
<div class="line"><span class="preprocessor">    # particular values of the independent variables. This expression may</span></div>
<div class="line"><span class="preprocessor">    # contain any of the usual operations such as addition or multiplication,</span></div>
<div class="line"><span class="preprocessor">    # as well as all of the common functions such as `sin&#39; or `cos&#39;. In</span></div>
<div class="line"><span class="preprocessor">    # addition, it may contain expressions like `if(x&gt;0, 1, -1)&#39; where the</span></div>
<div class="line"><span class="preprocessor">    # expression evaluates to the second argument if the first argument is</span></div>
<div class="line"><span class="preprocessor">    # true, and to the third argument otherwise. For a full overview of</span></div>
<div class="line"><span class="preprocessor">    # possible expressions accepted see the documentation of the muparser</span></div>
<div class="line"><span class="preprocessor">    # library at http:</span><span class="comment">//muparser.beltoforion.de/.</span></div>
<div class="line"><span class="preprocessor">    #</span></div>
<div class="line"><span class="preprocessor">    # If the function you are describing represents a vector-valued function</span></div>
<div class="line"><span class="preprocessor">    # with multiple components, then separate the expressions for individual</span></div>
<div class="line"><span class="preprocessor">    # components by a semicolon.</span></div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> <a class="code" href="classFunction.html">Function</a> expression = 0; 0; 0</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">    # The names of the variables as they will be used in the function,</span></div>
<div class="line"><span class="preprocessor">    # separated by commas. By default, the names of variables at which the</span></div>
<div class="line"><span class="preprocessor">    # function will be evaluated are `x&#39; (in 1d), `x,y&#39; (in 2d) or `x,y,z&#39; (in</span></div>
<div class="line"><span class="preprocessor">    # 3d) for spatial coordinates and `t&#39; for time. You can then use these</span></div>
<div class="line"><span class="preprocessor">    # variable names in your function expression and they will be replaced by</span></div>
<div class="line"><span class="preprocessor">    # the values of these variables at which the function is currently</span></div>
<div class="line"><span class="preprocessor">    # evaluated. However, you can also choose a different set of names for the</span></div>
<div class="line"><span class="preprocessor">    # independent variables at which to evaluate your function expression. For</span></div>
<div class="line"><span class="preprocessor">    # example, if you work in spherical coordinates, you may wish to set this</span></div>
<div class="line"><span class="preprocessor">    # input parameter to `r,phi,theta,t&#39; and then use these variable names in</span></div>
<div class="line"><span class="preprocessor">    # your function expression.</span></div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Variable names      = x,y,t</div>
<div class="line">  <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div>
<div class="line"> </div>
<div class="line"><a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div>
<div class="ttc" id="agrid__out_8cc_html_a9082f945c1d289684d0bcd51ee08e11e"><div class="ttname"><a href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a></div><div class="ttdeci">unsigned int level</div><div class="ttdef"><b>Definition:</b> <a href="grid__out_8cc_source.html#l04590">grid_out.cc:4590</a></div></div>
<div class="ttc" id="agroup__CUDAWrappers_html_gabb7130e2cea54654455ca41ef304f939"><div class="ttname"><a href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">LinearAlgebra::CUDAWrappers::kernel::set</a></div><div class="ttdeci">__global__ void set(Number *val, const Number s, const size_type N)</div></div>
<div class="ttc" id="anamespaceGridGenerator_html_a533c4778cbc9bcbed365dcab42ca4418"><div class="ttname"><a href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a></div><div class="ttdeci">void hyper_ball(Triangulation&lt; dim &gt; &amp;tria, const Point&lt; dim &gt; &amp;center=Point&lt; dim &gt;(), const double radius=1., const bool attach_spherical_manifold_on_boundary_cells=false)</div></div>
<div class="ttc" id="anamespaceGridGenerator_html_a56019d263ae45708302d5d7599f0d458"><div class="ttname"><a href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">GridGenerator::hyper_rectangle</a></div><div class="ttdeci">void hyper_rectangle(Triangulation&lt; dim, spacedim &gt; &amp;tria, const Point&lt; dim &gt; &amp;p1, const Point&lt; dim &gt; &amp;p2, const bool colorize=false)</div></div>
<div class="ttc" id="anamespaceGridGenerator_html_acea0cbcd68e52ce8113d1134b87de403"><div class="ttname"><a href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a></div><div class="ttdeci">void hyper_cube(Triangulation&lt; dim, spacedim &gt; &amp;tria, const double left=0., const double right=1., const bool colorize=false)</div></div>
<div class="ttc" id="anamespaceTrilinosWrappers_1_1internal_html_aee42c8e3004e2e81eac3c3356d3ec46b"><div class="ttname"><a href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">TrilinosWrappers::internal::end</a></div><div class="ttdeci">VectorType::value_type * end(VectorType &amp;V)</div><div class="ttdef"><b>Definition:</b> <a href="trilinos__sparse__matrix_8cc_source.html#l00067">trilinos_sparse_matrix.cc:67</a></div></div>
</div><!-- fragment --><p>If you now run the program, you will get a file called <code>parameters_22.prm</code> in the directory specified by the parameter <code>Output directory</code> (which defaults to the current directory) containing a shorter version of the above parameters (without comments and documentation), documenting all parameters that were used to run your program:</p>
<div class="fragment"><div class="line">subsection Stokes Immersed Problem</div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Final time                            = 1</div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Fluid bounding boxes extraction <a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a> = 1</div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Homogeneous Dirichlet boundary ids    = 0</div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Initial fluid refinement              = 5</div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Initial solid refinement              = 5</div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Nitsche penalty term                  = 100</div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Number of time steps                  = 501</div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Output directory                      = .</div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Output frequency                      = 1</div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Particle insertion refinement         = 3</div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Velocity degree                       = 2</div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Viscosity                             = 1</div>
<div class="line">  subsection Angular velocity</div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> <a class="code" href="classFunction.html">Function</a> constants  =</div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> <a class="code" href="classFunction.html">Function</a> expression = t &lt; .500001 ? 6.283185 : -6.283185</div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Variable names      = x,y,t</div>
<div class="line">  <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div>
<div class="line">  subsection Grid generation</div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Fluid grid generator              = <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">hyper_cube</a></div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Fluid grid generator arguments    = -1: 1: <span class="keyword">false</span></div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Particle grid generator           = <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">hyper_ball</a></div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Particle grid generator arguments = 0.3, 0.3: 0.1: <span class="keyword">false</span></div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Solid grid generator              = <a class="code" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">hyper_rectangle</a></div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Solid grid generator arguments    = -.5, -.1: .5, .1: <span class="keyword">false</span></div>
<div class="line">  <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div>
<div class="line">  subsection Refinement and remeshing</div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Maximum number of cells        = 20000</div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Refinement coarsening fraction = 0.3</div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Refinement fraction            = 0.3</div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Refinement maximal <a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>       = 8</div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Refinement minimal <a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>       = 5</div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Refinement step frequency      = 5</div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Refinement strategy            = fixed_fraction</div>
<div class="line">  <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div>
<div class="line">  subsection Right hand side</div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> <a class="code" href="classFunction.html">Function</a> constants  =</div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> <a class="code" href="classFunction.html">Function</a> expression = 0; 0; 0</div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Variable names      = x,y,t</div>
<div class="line">  <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div>
<div class="line"><a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div>
</div><!-- fragment --><p>The rationale behind creating first <code>parameters.prm</code> file (the first time the program is run) and then a <code>output/parameters_22.prm</code> (every time you run the program with an existing input file), is because you may want to leave most parameters to their default values, and only modify a handful of them, while still beeing able to reproduce the results and inspect what parameters were used for a specific simulation. It is generally good scientific practice to store the parameter file you used for a simulation along with the simulation output so that you can repeat the exact same run at a later time if necessary.</p>
<p>Another reason is because the input file may only contain those parameters that differ from their defaults. For example, you could use the following (perfectly valid) parameter file with this tutorial program: </p><div class="fragment"><div class="line">subsection Stokes Immersed Problem</div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Final time                         = 1</div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Nitsche penalty term               = 10</div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Number of time steps               = 101</div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Velocity degree                    = 3</div>
<div class="line"><a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div>
</div><!-- fragment --><p> and you would run the program with Q3/Q2 Taylor-Hood finite elements, for 101 steps, using a Nitsche penalty of <code>10</code>, and leaving all the other parameters to their default value. The output directory then contains a record of not just these parameters, but indeed all parameters used in the simulation. You can inspect all the other parameters in the produced file <code>parameters_22.prm</code>.</p>
<p><a class="anchor" id="Twodimensionaltestcase"></a></p><h3>Two dimensional test case </h3>
<p>The default problem generates a co-dimension zero impeller, consisting of a rotating rectangular grid, where the rotation is for half a time unit in one direction, and half a time unit in the opposite direction, with constant angular velocity equal to \(\approx 2\pi \frac{\text{rad}}{\text{time unit}}\). Consequently, the impeller does half a rotation and returns to its original position. The following animation displays the velocity magnitude, the motion of the solid impeller and of the tracer particles.</p>
<p align="center"></p>
<div class="img" align="center"> <img src="https://www.dealii.org/images/steps/developer/step-70.2d_tracing.gif" alt="" width="500" class="inline"/> </div> <p>On one core, the output of the program will look like the following:</p>
<div class="fragment"><div class="line">bash@f$ mpirun -np 1 ./step-70 test.prm</div>
<div class="line">Running StokesImmersedProblem&lt;2&gt; <span class="keyword">using</span> Trilinos.</div>
<div class="line">Cycle 0:</div>
<div class="line">Time : 0, time step: 0.002</div>
<div class="line">   Number of degrees of freedom: 9539 (8450+1089 -- 0+0)</div>
<div class="line">Tracer particles: 337</div>
<div class="line">Solid particles: 9216</div>
<div class="line">   Solved in 158 iterations.</div>
<div class="line">   Number of degrees of freedom: 9845 (8722+1123 -- 9216+337)</div>
<div class="line">Cycle 1:</div>
<div class="line">Time : 0.002, time step: 0.002</div>
<div class="line">   Solved in 142 iterations.</div>
<div class="line">Cycle 2:</div>
<div class="line">Time : 0.004, time step: 0.002</div>
<div class="line">   Solved in 121 iterations.</div>
<div class="line">Cycle 3:</div>
<div class="line">Time : 0.006, time step: 0.002</div>
<div class="line">   Solved in 121 iterations.</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">Cycle 499:</div>
<div class="line">Time : 0.998, time step: 0.002</div>
<div class="line">   Solved in 199 iterations.</div>
<div class="line">Cycle 500:</div>
<div class="line">Time : 1, time step: 0.002</div>
<div class="line">   Solved in 196 iterations.</div>
<div class="line"> </div>
<div class="line">+---------------------------------------------+------------+------------+</div>
<div class="line">| Total wallclock time elapsed since start    |       302s |            |</div>
<div class="line">|                                             |            |            |</div>
<div class="line">| Section                         | no. calls |  wall time | % of total |</div>
<div class="line">+---------------------------------+-----------+------------+------------+</div>
<div class="line">| Assemble Nitsche terms          |       501 |      43.3s |        14% |</div>
<div class="line">| Assemble Stokes terms           |       501 |      21.5s |       7.1% |</div>
<div class="line">| Initial setup                   |         1 |  0.000792s |         0% |</div>
<div class="line">| Output fluid                    |       502 |      31.8s |        11% |</div>
<div class="line">| Output solid particles          |       502 |      32.2s |        11% |</div>
<div class="line">| Output tracer particles         |       502 |      0.61s |       0.2% |</div>
<div class="line">| Refine                          |       100 |      4.68s |       1.5% |</div>
<div class="line">| Set solid particle position     |       500 |      3.34s |       1.1% |</div>
<div class="line">| Set tracer particle motion      |       501 |     0.729s |      0.24% |</div>
<div class="line">| Setup dofs                      |       101 |       2.2s |      0.73% |</div>
<div class="line">| Solve                           |       501 |       164s |        54% |</div>
<div class="line">+---------------------------------+-----------+------------+------------+</div>
</div><!-- fragment --><p>You may notice that assembling the coupling system is more expensive than assembling the Stokes part. This depends highly on the number of Gauss points (solid particles) that are used to apply the Nitsche restriction. In the present case, a relatively low number of tracer particles are used. Consequently, tracking their motion is relatively cheap.</p>
<p>The following movie shows the evolution of the solution over time:</p>
<p> 
<p align="center">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/y4Gypj2jpXw"
   frameborder="0"
   allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
   allowfullscreen></iframe>
 </p>
</p>
<p>The movie shows the rotating obstacle in gray (actually a superposition of the solid particles plotted with large enough dots that they overlap), <a href="https://en.wikipedia.org/wiki/Streamlines,_streaklines,_and_pathlines">streamlines of the fluid flow</a> in light colors (including the corner vertices that form at specific times during the simulation), and the tracer particles in bluish tones.</p>
<p>The simulation shows that at the end time, the tracer particles have somewhat returned to their original position, although they have been distorted by the flow field. The following image compares the initial and the final position of the particles after one time unit of flow.</p>
<p align="center"></p>
<div class="img" align="center"> <img src="https://www.dealii.org/images/steps/developer/step-70.tracer_comparison.png" alt="" width="500" class="inline"/> </div> <p>In this case, we see that the tracer particles that were outside of the swept volume of the impeller have returned very close to their initial position, whereas those in the swept volume were slightly more deformed. This deformation is non-physical. It is caused by the numerical error induced by the explicit Euler scheme used to advect the particles, by the loss of accuracy due to the fictitious domain and, finally, by the discretization error on the Stokes equations. The first two errors are the leading cause of this deformation and they could be alleviated by the use of a finer mesh and a lower time step.</p>
<p><a class="anchor" id="Threedimensionaltestcase"></a></p><h3>Three dimensional test case </h3>
<p>To play around a little bit, we complicate the fictitious domain (taken from <a href="https://grabcad.com/library/lungstors-blower-1">https://grabcad.com/library/lungstors-blower-1</a>), and run a co-dimension one simulation in three space dimensions, using the following "`parameters_23.prm`" file :</p>
<div class="fragment"><div class="line">subsection Stokes Immersed Problem</div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Final time                            = 1</div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Homogeneous Dirichlet boundary ids    = 0</div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Fluid bounding boxes extraction <a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a> = 1</div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Initial fluid refinement              = 3</div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Initial solid refinement              = 0</div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Nitsche penalty term                  = 10</div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Number of time steps                  = 101</div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Output frequency                      = 1</div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Particle insertion refinement         = 3</div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Velocity degree                       = 2</div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Viscosity                             = 1</div>
<div class="line">  subsection Angular velocity</div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> <a class="code" href="classFunction.html">Function</a> constants  =</div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> <a class="code" href="classFunction.html">Function</a> expression = t &lt; .500001 ? 5 : -5</div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Variable names      = x,y,z,t</div>
<div class="line">  <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div>
<div class="line">  subsection Grid generation</div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Fluid grid generator              = <a class="code" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">hyper_rectangle</a></div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Fluid grid generator arguments    = -50,-50, -10: 50, 50, 40: <span class="keyword">false</span></div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Solid grid generator              = impeller.vtk</div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Solid grid generator arguments    = 1:impeller.step</div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Particle grid generator           = <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">hyper_ball</a></div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Particle grid generator arguments = 30, 30, 20: 10: <span class="keyword">false</span></div>
<div class="line">  <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div>
<div class="line">  subsection Refinement and remeshing</div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Maximum number of cells        = 100000</div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Refinement coarsening fraction = 0.3</div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Refinement fraction            = 0.3</div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Refinement maximal <a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>       = 6</div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Refinement step frequency      = 5</div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Refinement strategy            = fixed_fraction</div>
<div class="line">  <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div>
<div class="line">  subsection Right hand side</div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> <a class="code" href="classFunction.html">Function</a> constants  =</div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> <a class="code" href="classFunction.html">Function</a> expression = 0; 0; 0; 0</div>
<div class="line">    <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Variable names      = x,y,z,t</div>
<div class="line">  <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div>
<div class="line"><a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div>
</div><!-- fragment --><p>In this case, the timing outputs are a bit different:</p>
<div class="fragment"><div class="line">+---------------------------------------------+------------+------------+</div>
<div class="line">| Total wallclock time elapsed since start    |  5.54e+03s |            |</div>
<div class="line">|                                             |            |            |</div>
<div class="line">| Section                         | no. calls |  wall time | % of total |</div>
<div class="line">+---------------------------------+-----------+------------+------------+</div>
<div class="line">| Assemble Nitsche terms          |       101 |       111s |         2% |</div>
<div class="line">| Assemble Stokes terms           |       101 |       208s |       3.8% |</div>
<div class="line">| Initial setup                   |         1 |   0.00187s |         0% |</div>
<div class="line">| Output fluid                    |       102 |      15.5s |      0.28% |</div>
<div class="line">| Output solid particles          |       102 |      2.63s |         0% |</div>
<div class="line">| Output tracer particles         |       102 |      2.49s |         0% |</div>
<div class="line">| Refine                          |        20 |      18.4s |      0.33% |</div>
<div class="line">| Set solid particle position     |       100 |       6.1s |      0.11% |</div>
<div class="line">| Set tracer particle motion      |       101 |      10.8s |       0.2% |</div>
<div class="line">| Setup dofs                      |        21 |      13.9s |      0.25% |</div>
<div class="line">| Solve                           |       101 |  5.16e+03s |        93% |</div>
<div class="line">+---------------------------------+-----------+------------+------------+</div>
</div><!-- fragment --><p>Now, the solver is taking most of the solution time in three dimensions, and the particle motion and Nitsche assembly remain relatively unimportant as far as run time is concerned.</p>
<p> 
<p align="center">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/Srwq7zyR9mg"
   frameborder="0"
   allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
   allowfullscreen></iframe>
 </p>
</p>
<p><a class="anchor" id="extensions"></a> <a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>The current tutorial program shows a one-way coupling between the fluid and the solid, where the solid motion is imposed (and not solved for), and read in the solid domain by exploiting the location and the weights of the solid quadrature points.</p>
<p>The structure of the code already allows one to implement a two-way coupling, by exploiting the possibility to read values of the fluid velocity on the quadrature points of the solid grid. For this to be more efficient in terms of MPI communication patterns, one should maintain ownership of the quadrature points on the solid processor that owns the cells where they have been created. In the current code, it is sufficient to define the <a class="el" href="classIndexSet.html">IndexSet</a> of the vectors used to exchange information of the quadrature points by using the solid partition instead of the initial fluid partition.</p>
<p>This allows the combination of the technique used in this tutorial program with those presented in the tutorial <a class="el" href="step_60.html">step-60</a> to solve a fluid structure interaction problem with distributed Lagrange multipliers, on <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> objects.</p>
<p>The timings above show that the current preconditioning strategy does not work well for Nitsche penalization, and we should come up with a better preconditioner if we want to aim at larger problems. Moreover, a checkpoint restart strategy should be implemented to allow for longer simulations to be interrupted and restored, as it is done for example in the <a class="el" href="step_69.html">step-69</a> tutorial.</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Copyright (C) 2020 by the deal.II authors</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div>
<div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div>
<div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div>
<div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div>
<div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div>
<div class="line"><span class="comment"> * the top level directory of deal.II.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Authors: Luca Heltai, Bruno Blais, Rene Gassmoeller, 2020</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__linear__operator_8h.html">deal.II/lac/block_linear_operator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="generic__linear__algebra_8h.html">deal.II/lac/generic_linear_algebra.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator_8h.html">deal.II/lac/linear_operator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator__tools_8h.html">deal.II/lac/linear_operator_tools.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define FORCE_USE_OF_TRILINOS</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>LA</div>
<div class="line">{</div>
<div class="line"><span class="preprocessor">#if defined(DEAL_II_WITH_PETSC) &amp;&amp; !defined(DEAL_II_PETSC_WITH_COMPLEX) &amp;&amp; \</span></div>
<div class="line"><span class="preprocessor">  !(defined(DEAL_II_WITH_TRILINOS) &amp;&amp; defined(FORCE_USE_OF_TRILINOS))</span></div>
<div class="line">  <span class="keyword">using namespace </span>dealii::LinearAlgebraPETSc;</div>
<div class="line"><span class="preprocessor">#  define USE_PETSC_LA</span></div>
<div class="line"><span class="preprocessor">#elif defined(DEAL_II_WITH_TRILINOS)</span></div>
<div class="line">  <span class="keyword">using namespace </span>dealii::LinearAlgebraTrilinos;</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor">#  error DEAL_II_WITH_PETSC or DEAL_II_WITH_TRILINOS required</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">} <span class="comment">// namespace LA</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="conditional__ostream_8h.html">deal.II/base/conditional_ostream.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__acceptor_8h.html">deal.II/base/parameter_acceptor.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parsed__function_8h.html">deal.II/base/parsed_function.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2grid__refinement_8h.html">deal.II/distributed/grid_refinement.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2solution__transfer_8h.html">deal.II/distributed/solution_transfer.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2tria_8h.html">deal.II/distributed/tria.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__nothing_8h.html">deal.II/fe/fe_nothing.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__fe__field_8h.html">deal.II/fe/mapping_fe_field.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q_8h.html">deal.II/fe/mapping_q.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__in_8h.html">deal.II/grid/grid_in.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__precondition_8h.html">deal.II/lac/petsc_precondition.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__solver_8h.html">deal.II/lac/petsc_solver.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__sparse__matrix_8h.html">deal.II/lac/petsc_sparse_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__vector_8h.html">deal.II/lac/petsc_vector.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__gmres_8h.html">deal.II/lac/solver_gmres.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__minres_8h.html">deal.II/lac/solver_minres.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparsity__tools_8h.html">deal.II/lac/sparsity_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="particles_2data__out_8h.html">deal.II/particles/data_out.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="generators_8h.html">deal.II/particles/generators.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="particle__handler_8h.html">deal.II/particles/particle_handler.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2particles_2utilities_8h.html">deal.II/particles/utilities.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="opencascade_2manifold__lib_8h.html">deal.II/opencascade/manifold_lib.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2opencascade_2utilities_8h.html">deal.II/opencascade/utilities.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#ifdef DEAL_II_WITH_OPENCASCADE</span></div>
<div class="line"><span class="preprocessor">#  include &lt;TopoDS.hxx&gt;</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>Step70</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim = dim&gt;</div>
<div class="line">  <span class="keyword">class </span>StokesImmersedProblemParameters : <span class="keyword">public</span> <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a></div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    StokesImmersedProblemParameters();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> set_time(<span class="keyword">const</span> <span class="keywordtype">double</span> &amp;time)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      rhs.set_time(time);</div>
<div class="line">      angular_velocity.set_time(time);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::string output_directory = <span class="stringliteral">&quot;.&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> velocity_degree = 2;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> number_of_time_steps = 501;</div>
<div class="line">    <span class="keywordtype">double</span>       final_time           = 1.0;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> output_frequency = 1;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_fluid_refinement      = 5;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_solid_refinement      = 5;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> particle_insertion_refinement = 3;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fluid_rtree_extraction_level = 1;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> viscosity    = 1.0;</div>
<div class="line">    <span class="keywordtype">double</span> penalty_term = 100;</div>
<div class="line"> </div>
<div class="line">    std::list&lt;types::boundary_id&gt; homogeneous_dirichlet_ids{0};</div>
<div class="line"> </div>
<div class="line">    std::string name_of_fluid_grid       = <span class="stringliteral">&quot;hyper_cube&quot;</span>;</div>
<div class="line">    std::string arguments_for_fluid_grid = <span class="stringliteral">&quot;-1: 1: false&quot;</span>;</div>
<div class="line">    std::string name_of_solid_grid       = <span class="stringliteral">&quot;hyper_rectangle&quot;</span>;</div>
<div class="line">    std::string arguments_for_solid_grid = spacedim == 2 ?</div>
<div class="line">                                             <span class="stringliteral">&quot;-.5, -.1: .5, .1: false&quot;</span> :</div>
<div class="line">                                             <span class="stringliteral">&quot;-.5, -.1, -.1: .5, .1, .1: false&quot;</span>;</div>
<div class="line">    std::string name_of_particle_grid = <span class="stringliteral">&quot;hyper_ball&quot;</span>;</div>
<div class="line">    std::string arguments_for_particle_grid =</div>
<div class="line">      spacedim == 2 ? <span class="stringliteral">&quot;0.3, 0.3: 0.1: false&quot;</span> : <span class="stringliteral">&quot;0.3, 0.3, 0.3 : 0.1: false&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span>          max_level_refinement = 8;</div>
<div class="line">    <span class="keywordtype">int</span>          min_level_refinement = 5;</div>
<div class="line">    std::string  refinement_strategy  = <span class="stringliteral">&quot;fixed_fraction&quot;</span>;</div>
<div class="line">    <span class="keywordtype">double</span>       coarsening_fraction  = 0.3;</div>
<div class="line">    <span class="keywordtype">double</span>       refinement_fraction  = 0.3;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_cells            = 20000;</div>
<div class="line">    <span class="keywordtype">int</span>          refinement_frequency = 5;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">mutable</span> <a class="code" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy&lt;Functions::ParsedFunction&lt;spacedim&gt;</a>&gt; rhs;</div>
<div class="line">    <span class="keyword">mutable</span> <a class="code" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy&lt;Functions::ParsedFunction&lt;spacedim&gt;</a>&gt;</div>
<div class="line">      angular_velocity;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">  StokesImmersedProblemParameters&lt;dim,</div>
<div class="line">                                  spacedim&gt;::StokesImmersedProblemParameters()</div>
<div class="line">    : <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a>(<span class="stringliteral">&quot;Stokes Immersed Problem/&quot;</span>)</div>
<div class="line">    , rhs(<span class="stringliteral">&quot;Right hand side&quot;</span>, spacedim + 1)</div>
<div class="line">    , angular_velocity(<span class="stringliteral">&quot;Angular velocity&quot;</span>)</div>
<div class="line">  {</div>
<div class="line">    add_parameter(</div>
<div class="line">      <span class="stringliteral">&quot;Velocity degree&quot;</span>, velocity_degree, <span class="stringliteral">&quot;&quot;</span>, this-&gt;prm, <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1));</div>
<div class="line"> </div>
<div class="line">    add_parameter(<span class="stringliteral">&quot;Number of time steps&quot;</span>, number_of_time_steps);</div>
<div class="line">    add_parameter(<span class="stringliteral">&quot;Output frequency&quot;</span>, output_frequency);</div>
<div class="line"> </div>
<div class="line">    add_parameter(<span class="stringliteral">&quot;Output directory&quot;</span>, output_directory);</div>
<div class="line"> </div>
<div class="line">    add_parameter(<span class="stringliteral">&quot;Final time&quot;</span>, final_time);</div>
<div class="line"> </div>
<div class="line">    add_parameter(<span class="stringliteral">&quot;Viscosity&quot;</span>, viscosity);</div>
<div class="line"> </div>
<div class="line">    add_parameter(<span class="stringliteral">&quot;Nitsche penalty term&quot;</span>, penalty_term);</div>
<div class="line"> </div>
<div class="line">    add_parameter(<span class="stringliteral">&quot;Initial fluid refinement&quot;</span>,</div>
<div class="line">                  initial_fluid_refinement,</div>
<div class="line">                  <span class="stringliteral">&quot;Initial mesh refinement used for the fluid domain Omega&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    add_parameter(<span class="stringliteral">&quot;Initial solid refinement&quot;</span>,</div>
<div class="line">                  initial_solid_refinement,</div>
<div class="line">                  <span class="stringliteral">&quot;Initial mesh refinement used for the solid domain Gamma&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    add_parameter(<span class="stringliteral">&quot;Fluid bounding boxes extraction level&quot;</span>,</div>
<div class="line">                  fluid_rtree_extraction_level,</div>
<div class="line">                  <span class="stringliteral">&quot;Extraction level of the rtree used to construct global &quot;</span></div>
<div class="line">                  <span class="stringliteral">&quot;bounding boxes&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    add_parameter(</div>
<div class="line">      <span class="stringliteral">&quot;Particle insertion refinement&quot;</span>,</div>
<div class="line">      particle_insertion_refinement,</div>
<div class="line">      <span class="stringliteral">&quot;Refinement of the volumetric mesh used to insert the particles&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    add_parameter(</div>
<div class="line">      <span class="stringliteral">&quot;Homogeneous Dirichlet boundary ids&quot;</span>,</div>
<div class="line">      homogeneous_dirichlet_ids,</div>
<div class="line">      <span class="stringliteral">&quot;Boundary Ids over which homogeneous Dirichlet boundary conditions are applied&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    enter_subsection(<span class="stringliteral">&quot;Grid generation&quot;</span>);</div>
<div class="line">    {</div>
<div class="line">      add_parameter(<span class="stringliteral">&quot;Fluid grid generator&quot;</span>, name_of_fluid_grid);</div>
<div class="line">      add_parameter(<span class="stringliteral">&quot;Fluid grid generator arguments&quot;</span>, arguments_for_fluid_grid);</div>
<div class="line"> </div>
<div class="line">      add_parameter(<span class="stringliteral">&quot;Solid grid generator&quot;</span>, name_of_solid_grid);</div>
<div class="line">      add_parameter(<span class="stringliteral">&quot;Solid grid generator arguments&quot;</span>, arguments_for_solid_grid);</div>
<div class="line"> </div>
<div class="line">      add_parameter(<span class="stringliteral">&quot;Particle grid generator&quot;</span>, name_of_particle_grid);</div>
<div class="line">      add_parameter(<span class="stringliteral">&quot;Particle grid generator arguments&quot;</span>,</div>
<div class="line">                    arguments_for_particle_grid);</div>
<div class="line">    }</div>
<div class="line">    leave_subsection();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    enter_subsection(<span class="stringliteral">&quot;Refinement and remeshing&quot;</span>);</div>
<div class="line">    {</div>
<div class="line">      add_parameter(<span class="stringliteral">&quot;Refinement step frequency&quot;</span>, refinement_frequency);</div>
<div class="line">      add_parameter(<span class="stringliteral">&quot;Refinement maximal level&quot;</span>, max_level_refinement);</div>
<div class="line">      add_parameter(<span class="stringliteral">&quot;Refinement minimal level&quot;</span>, min_level_refinement);</div>
<div class="line">      add_parameter(<span class="stringliteral">&quot;Refinement strategy&quot;</span>,</div>
<div class="line">                    refinement_strategy,</div>
<div class="line">                    <span class="stringliteral">&quot;&quot;</span>,</div>
<div class="line">                    this-&gt;prm,</div>
<div class="line">                    <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;fixed_fraction|fixed_number&quot;</span>));</div>
<div class="line">      add_parameter(<span class="stringliteral">&quot;Refinement coarsening fraction&quot;</span>, coarsening_fraction);</div>
<div class="line">      add_parameter(<span class="stringliteral">&quot;Refinement fraction&quot;</span>, refinement_fraction);</div>
<div class="line">      add_parameter(<span class="stringliteral">&quot;Maximum number of cells&quot;</span>, max_cells);</div>
<div class="line">    }</div>
<div class="line">    leave_subsection();</div>
<div class="line"> </div>
<div class="line">    rhs.declare_parameters_call_back.connect([&amp;]() {</div>
<div class="line">      <a class="code" href="classFunctions_1_1ParsedFunction.html#a57fd4a680441ae940812431a421c9c40">Functions::ParsedFunction&lt;spacedim&gt;::declare_parameters</a>(this-&gt;prm,</div>
<div class="line">                                                              spacedim + 1);</div>
<div class="line">    });</div>
<div class="line">    angular_velocity.declare_parameters_call_back.connect([&amp;]() {</div>
<div class="line">      this-&gt;prm.set(<span class="stringliteral">&quot;Function expression&quot;</span>,</div>
<div class="line">                    <span class="stringliteral">&quot;t &lt; .500001 ? 6.283185 : -6.283185&quot;</span>);</div>
<div class="line">    });</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">  <span class="keyword">class </span>SolidVelocity : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;spacedim&gt;</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    static_assert(spacedim &gt; 1,</div>
<div class="line">                  <span class="stringliteral">&quot;Cannot instantiate SolidVelocity for spacedim == 1&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    SolidVelocity(<span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity)</div>
<div class="line">      : angular_velocity(angular_velocity)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;spacedim&gt;</a> &amp;p,</div>
<div class="line">                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>           component = 0)<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1, spacedim&gt;</a> velocity;</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> omega = angular_velocity.value(p);</div>
<div class="line">      velocity[0]        = -omega * p[1];</div>
<div class="line">      velocity[1]        = omega * p[0];</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">return</span> velocity[component];</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">  <span class="keyword">class </span>SolidPosition : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;spacedim&gt;</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    static_assert(spacedim &gt; 1,</div>
<div class="line">                  <span class="stringliteral">&quot;Cannot instantiate SolidPosition for spacedim == 1&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    SolidPosition(<span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity,</div>
<div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span>                               time_step)</div>
<div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;spacedim&gt;(spacedim)</div>
<div class="line">      , angular_velocity(angular_velocity)</div>
<div class="line">      , time_step(time_step)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;spacedim&gt;</a> &amp;p,</div>
<div class="line">                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>           component = 0)<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <a class="code" href="classPoint.html">Point&lt;spacedim&gt;</a> new_position = p;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">double</span> dtheta = angular_velocity.value(p) * time_step;</div>
<div class="line"> </div>
<div class="line">      new_position[0] = <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">std::cos</a>(dtheta) * p[0] - <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">std::sin</a>(dtheta) * p[1];</div>
<div class="line">      new_position[1] = <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">std::sin</a>(dtheta) * p[0] + <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">std::cos</a>(dtheta) * p[1];</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">return</span> new_position[component];</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> set_time_step(<span class="keyword">const</span> <span class="keywordtype">double</span> new_time_step)</div>
<div class="line">    {</div>
<div class="line">      time_step = new_time_step;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity;</div>
<div class="line">    <span class="keywordtype">double</span>                                     time_step;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim = dim&gt;</div>
<div class="line">  <span class="keyword">class </span>StokesImmersedProblem</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    StokesImmersedProblem(</div>
<div class="line">      <span class="keyword">const</span> StokesImmersedProblemParameters&lt;dim, spacedim&gt; &amp;par);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> make_grid();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> compute_time_step() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> setup_tracer_particles();</div>
<div class="line">    <span class="keywordtype">void</span> setup_solid_particles();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> initial_setup();</div>
<div class="line">    <span class="keywordtype">void</span> setup_dofs();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> assemble_stokes_system();</div>
<div class="line">    <span class="keywordtype">void</span> assemble_nitsche_restriction();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> solve();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> refine_and_transfer();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle, <span class="keyword">const</span> <span class="keywordtype">double</span> time) <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">void</span> output_particles(<span class="keyword">const</span> <a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> &amp;particles,</div>
<div class="line">                          std::string                                 fprefix,</div>
<div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                          iter,</div>
<div class="line">                          <span class="keyword">const</span> <span class="keywordtype">double</span> time) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> StokesImmersedProblemParameters&lt;dim, spacedim&gt; &amp;par;</div>
<div class="line"> </div>
<div class="line">    MPI_Comm mpi_communicator;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">mutable</span> <a class="code" href="classTimerOutput.html">TimerOutput</a> computing_timer;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;spacedim&gt;</a>      fluid_tria;</div>
<div class="line">    <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim, spacedim&gt;</a> solid_tria;</div>
<div class="line"> </div>
<div class="line">    std::unique_ptr&lt;FiniteElement&lt;spacedim&gt;&gt;      fluid_fe;</div>
<div class="line">    std::unique_ptr&lt;FiniteElement&lt;dim, spacedim&gt;&gt; solid_fe;</div>
<div class="line"> </div>
<div class="line">    std::unique_ptr&lt;Quadrature&lt;spacedim&gt;&gt; fluid_quadrature_formula;</div>
<div class="line">    std::unique_ptr&lt;Quadrature&lt;dim&gt;&gt;      solid_quadrature_formula;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;spacedim&gt;</a>      fluid_dh;</div>
<div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim, spacedim&gt;</a> solid_dh;</div>
<div class="line"> </div>
<div class="line">    std::unique_ptr&lt;MappingFEField&lt;dim, spacedim&gt;&gt; solid_mapping;</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;IndexSet&gt; fluid_owned_dofs;</div>
<div class="line">    std::vector&lt;IndexSet&gt; solid_owned_dofs;</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;IndexSet&gt; fluid_relevant_dofs;</div>
<div class="line">    std::vector&lt;IndexSet&gt; solid_relevant_dofs;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="namespaceLinearAlgebraDealII.html#a34f060e2c5e047fdc12c76d047c7c098">LA::MPI::BlockSparseMatrix</a> system_matrix;</div>
<div class="line">    <a class="code" href="namespaceLinearAlgebraDealII.html#a34f060e2c5e047fdc12c76d047c7c098">LA::MPI::BlockSparseMatrix</a> preconditioner_matrix;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="namespaceLinearAlgebraDealII.html#aa4543bb429e129431d48d18c1bfebae3">LA::MPI::BlockVector</a> solution;</div>
<div class="line">    <a class="code" href="namespaceLinearAlgebraDealII.html#aa4543bb429e129431d48d18c1bfebae3">LA::MPI::BlockVector</a> locally_relevant_solution;</div>
<div class="line">    <a class="code" href="namespaceLinearAlgebraDealII.html#aa4543bb429e129431d48d18c1bfebae3">LA::MPI::BlockVector</a> system_rhs;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> tracer_particle_handler;</div>
<div class="line">    <a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> solid_particle_handler;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> locally_owned_tracer_particle_coordinates;</div>
<div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_tracer_particle_coordinates;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="namespaceLinearAlgebraDealII.html#a9fe13d579422411556954ab3f28a59be">LA::MPI::Vector</a> tracer_particle_velocities;</div>
<div class="line">    <a class="code" href="namespaceLinearAlgebraDealII.html#a9fe13d579422411556954ab3f28a59be">LA::MPI::Vector</a> relevant_tracer_particle_displacements;</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;std::vector&lt;BoundingBox&lt;spacedim&gt;&gt;&gt; global_fluid_bounding_boxes;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">  StokesImmersedProblem&lt;dim, spacedim&gt;::StokesImmersedProblem(</div>
<div class="line">    <span class="keyword">const</span> StokesImmersedProblemParameters&lt;dim, spacedim&gt; &amp;par)</div>
<div class="line">    : par(par)</div>
<div class="line">    , mpi_communicator(MPI_COMM_WORLD)</div>
<div class="line">    , pcout(std::cout,</div>
<div class="line">            (<a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(mpi_communicator) == 0))</div>
<div class="line">    , computing_timer(mpi_communicator,</div>
<div class="line">                      pcout,</div>
<div class="line">                      <a class="code" href="classTimerOutput.html">TimerOutput</a>::summary,</div>
<div class="line">                      <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div>
<div class="line">    , fluid_tria(mpi_communicator,</div>
<div class="line">                 typename <a class="code" href="classTriangulation.html">Triangulation</a>&lt;spacedim&gt;::MeshSmoothing(</div>
<div class="line">                   <a class="code" href="classTriangulation.html">Triangulation</a>&lt;spacedim&gt;::smoothing_on_refinement |</div>
<div class="line">                   <a class="code" href="classTriangulation.html">Triangulation</a>&lt;spacedim&gt;::smoothing_on_coarsening))</div>
<div class="line">    , solid_tria(mpi_communicator,</div>
<div class="line">                 typename <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;::MeshSmoothing(</div>
<div class="line">                   <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;::smoothing_on_refinement |</div>
<div class="line">                   <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;::smoothing_on_coarsening))</div>
<div class="line">    , fluid_dh(fluid_tria)</div>
<div class="line">    , solid_dh(solid_tria)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> read_grid_and_cad_files(<span class="keyword">const</span> std::string &amp;grid_file_name,</div>
<div class="line">                               <span class="keyword">const</span> std::string &amp;ids_and_cad_file_names,</div>
<div class="line">                               <a class="code" href="classTriangulation.html">Triangulation&lt;dim, spacedim&gt;</a> &amp;tria)</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classGridIn.html">GridIn&lt;dim, spacedim&gt;</a> grid_in;</div>
<div class="line">    grid_in.<a class="code" href="classGridIn.html#a82ac1c03b0efe87204ad45d2f1d87f7e">attach_triangulation</a>(tria);</div>
<div class="line">    grid_in.<a class="code" href="classGridIn.html#ad30d9d6f2ff9920c4285e795c4495826">read</a>(grid_file_name);</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef DEAL_II_WITH_OPENCASCADE</span></div>
<div class="line">    <span class="keyword">using</span> map_type  = std::map&lt;types::manifold_id, std::string&gt;;</div>
<div class="line">    <span class="keyword">using</span> Converter = <a class="code" href="structPatterns_1_1Tools_1_1Convert.html">Patterns::Tools::Convert&lt;map_type&gt;</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;pair : <a class="code" href="group__Exceptions.html#ga59da8cbc1fc7db44bebb4fbc9dc4bbe9">Converter::to_value</a>(ids_and_cad_file_names))</div>
<div class="line">      {</div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">manifold_id</a>   = pair.first;</div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;cad_file_name = pair.second;</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> extension = boost::algorithm::to_lower_copy(</div>
<div class="line">          cad_file_name.substr(cad_file_name.find_last_of(<span class="charliteral">&#39;.&#39;</span>) + 1));</div>
<div class="line"> </div>
<div class="line">        TopoDS_Shape shape;</div>
<div class="line">        <span class="keywordflow">if</span> (extension == <span class="stringliteral">&quot;iges&quot;</span> || extension == <span class="stringliteral">&quot;igs&quot;</span>)</div>
<div class="line">          shape = <a class="code" href="namespaceOpenCASCADE.html#affe07b496f4edf844d5f4e8d7a540295">OpenCASCADE::read_IGES</a>(cad_file_name);</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (extension == <span class="stringliteral">&quot;step&quot;</span> || extension == <span class="stringliteral">&quot;stp&quot;</span>)</div>
<div class="line">          shape = <a class="code" href="namespaceOpenCASCADE.html#a614ec9f581086ad423513dd407e9e520">OpenCASCADE::read_STEP</a>(cad_file_name);</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">          <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>,</div>
<div class="line">                      <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>(<span class="stringliteral">&quot;We found an extension that we &quot;</span></div>
<div class="line">                                        <span class="stringliteral">&quot;do not recognize as a CAD file &quot;</span></div>
<div class="line">                                        <span class="stringliteral">&quot;extension. Bailing out.&quot;</span>));</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> n_elements = <a class="code" href="namespaceOpenCASCADE.html#a3e3e0df474c0e4f9abb627753c8754e9">OpenCASCADE::count_elements</a>(shape);</div>
<div class="line">        <span class="keywordflow">if</span> ((std::get&lt;0&gt;(n_elements) == 0))</div>
<div class="line">          tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(</div>
<div class="line">            <a class="code" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">manifold_id</a>,</div>
<div class="line">            <a class="code" href="classOpenCASCADE_1_1ArclengthProjectionLineManifold.html">OpenCASCADE::ArclengthProjectionLineManifold&lt;dim, spacedim&gt;</a>(shape));</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (spacedim == 3)</div>
<div class="line">          {</div>
<div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> t = <span class="keyword">reinterpret_cast&lt;</span><a class="code" href="classTriangulation.html">Triangulation&lt;dim, 3&gt;</a> *<span class="keyword">&gt;</span>(&amp;tria);</div>
<div class="line">            t-&gt;<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(<a class="code" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">manifold_id</a>,</div>
<div class="line">                            <a class="code" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">OpenCASCADE::NormalToMeshProjectionManifold&lt;dim, 3&gt;</a>(</div>
<div class="line">                              shape));</div>
<div class="line">          }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">          tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(<a class="code" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">manifold_id</a>,</div>
<div class="line">                            <a class="code" href="classOpenCASCADE_1_1NURBSPatchManifold.html">OpenCASCADE::NURBSPatchManifold&lt;dim, spacedim&gt;</a>(</div>
<div class="line">                              TopoDS::Face(shape)));</div>
<div class="line">      }</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">    (void)ids_and_cad_file_names;</div>
<div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>(<span class="stringliteral">&quot;Generation of the grid failed.&quot;</span>));</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::make_grid()</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">try</span></div>
<div class="line">      {</div>
<div class="line">        <a class="code" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments</a>(</div>
<div class="line">          fluid_tria, par.name_of_fluid_grid, par.arguments_for_fluid_grid);</div>
<div class="line">      }</div>
<div class="line">    <span class="keywordflow">catch</span> (...)</div>
<div class="line">      {</div>
<div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Generating from name and argument failed.&quot;</span> &lt;&lt; std::endl</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;Trying to read from file name.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        read_grid_and_cad_files(par.name_of_fluid_grid,</div>
<div class="line">                                par.arguments_for_fluid_grid,</div>
<div class="line">                                fluid_tria);</div>
<div class="line">      }</div>
<div class="line">    fluid_tria.refine_global(par.initial_fluid_refinement);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span></div>
<div class="line">      {</div>
<div class="line">        <a class="code" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments</a>(</div>
<div class="line">          solid_tria, par.name_of_solid_grid, par.arguments_for_solid_grid);</div>
<div class="line">      }</div>
<div class="line">    <span class="keywordflow">catch</span> (...)</div>
<div class="line">      {</div>
<div class="line">        read_grid_and_cad_files(par.name_of_solid_grid,</div>
<div class="line">                                par.arguments_for_solid_grid,</div>
<div class="line">                                solid_tria);</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">    solid_tria.refine_global(par.initial_solid_refinement);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::setup_tracer_particles()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;spacedim&gt;</a> particle_insert_tria(</div>
<div class="line">      mpi_communicator);</div>
<div class="line">    <a class="code" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments</a>(</div>
<div class="line">      particle_insert_tria,</div>
<div class="line">      par.name_of_particle_grid,</div>
<div class="line">      par.arguments_for_particle_grid);</div>
<div class="line">    particle_insert_tria.refine_global(par.particle_insertion_refinement);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;spacedim&gt;</a>       particles_fe(1);</div>
<div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;spacedim&gt;</a> particles_dof_handler(particle_insert_tria);</div>
<div class="line">    particles_dof_handler.distribute_dofs(particles_fe);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;BoundingBox&lt;spacedim&gt;&gt; all_boxes;</div>
<div class="line">    all_boxes.reserve(fluid_tria.n_locally_owned_active_cells());</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : fluid_tria.active_cell_iterators())</div>
<div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div>
<div class="line">        all_boxes.emplace_back(cell-&gt;bounding_box());</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> tree = <a class="code" href="rtree_8h.html#a66a9d76ea405b07e60e74aa6159ac7ad">pack_rtree</a>(all_boxes);</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> local_boxes =</div>
<div class="line">      <a class="code" href="rtree_8h.html#a3591e6e032b1a56920f897a2bc387d43">extract_rtree_level</a>(tree, par.fluid_rtree_extraction_level);</div>
<div class="line"> </div>
<div class="line">    global_fluid_bounding_boxes =</div>
<div class="line">      <a class="code" href="namespaceUtilities_1_1MPI.html#ac5a7433f594a19070add2afa0f769efb">Utilities::MPI::all_gather</a>(mpi_communicator, local_boxes);</div>
<div class="line"> </div>
<div class="line">    tracer_particle_handler.initialize(fluid_tria,</div>
<div class="line">                                       <a class="code" href="structStaticMappingQ1.html">StaticMappingQ1&lt;spacedim&gt;::mapping</a>);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="namespaceParticles_1_1Generators.html#a498c6b70c8c3169a3d1513418beb9e15">Particles::Generators::dof_support_points</a>(particles_dof_handler,</div>
<div class="line">                                              global_fluid_bounding_boxes,</div>
<div class="line">                                              tracer_particle_handler);</div>
<div class="line"> </div>
<div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Tracer particles: &quot;</span></div>
<div class="line">          &lt;&lt; tracer_particle_handler.n_global_particles() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    locally_owned_tracer_particle_coordinates =</div>
<div class="line">      tracer_particle_handler.locally_relevant_ids().tensor_product(</div>
<div class="line">        <a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(spacedim));</div>
<div class="line"> </div>
<div class="line">    locally_relevant_tracer_particle_coordinates =</div>
<div class="line">      locally_owned_tracer_particle_coordinates;</div>
<div class="line"> </div>
<div class="line">    fluid_tria.signals.pre_distributed_refinement.connect(</div>
<div class="line">      [&amp;]() { tracer_particle_handler.register_store_callback_function(); });</div>
<div class="line"> </div>
<div class="line">    fluid_tria.signals.post_distributed_refinement.connect([&amp;]() {</div>
<div class="line">      tracer_particle_handler.register_load_callback_function(<span class="keyword">false</span>);</div>
<div class="line">    });</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::setup_solid_particles()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature(fluid_fe-&gt;degree + 1);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_properties = 1;</div>
<div class="line">    solid_particle_handler.initialize(fluid_tria,</div>
<div class="line">                                      <a class="code" href="structStaticMappingQ1.html">StaticMappingQ1&lt;spacedim&gt;::mapping</a>,</div>
<div class="line">                                      n_properties);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;Point&lt;spacedim&gt;&gt; quadrature_points_vec;</div>
<div class="line">    quadrature_points_vec.reserve(quadrature.size() *</div>
<div class="line">                                  solid_tria.n_locally_owned_active_cells());</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;std::vector&lt;double&gt;&gt; properties;</div>
<div class="line">    properties.reserve(quadrature.size() *</div>
<div class="line">                       solid_tria.n_locally_owned_active_cells());</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim, spacedim&gt;</a> fe_v(*solid_fe,</div>
<div class="line">                                 quadrature,</div>
<div class="line">                                 <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : solid_dh.active_cell_iterators())</div>
<div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div>
<div class="line">        {</div>
<div class="line">          fe_v.reinit(cell);</div>
<div class="line">          <span class="keyword">const</span> <span class="keyword">auto</span> &amp;points = fe_v.get_quadrature_points();</div>
<div class="line">          <span class="keyword">const</span> <span class="keyword">auto</span> &amp;JxW    = fe_v.get_JxW_values();</div>
<div class="line"> </div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; points.size(); ++q)</div>
<div class="line">            {</div>
<div class="line">              quadrature_points_vec.emplace_back(points[q]);</div>
<div class="line">              properties.emplace_back(</div>
<div class="line">                std::vector&lt;double&gt;(n_properties, JxW[q]));</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(!global_fluid_bounding_boxes.empty(),</div>
<div class="line">           <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>(</div>
<div class="line">             <span class="stringliteral">&quot;I was expecting the &quot;</span></div>
<div class="line">             <span class="stringliteral">&quot;global_fluid_bounding_boxes to be filled at this stage. &quot;</span></div>
<div class="line">             <span class="stringliteral">&quot;Make sure you fill this vector before trying to use it &quot;</span></div>
<div class="line">             <span class="stringliteral">&quot;here. Bailing out.&quot;</span>));</div>
<div class="line"> </div>
<div class="line">    solid_particle_handler.insert_global_particles(quadrature_points_vec,</div>
<div class="line">                                                   global_fluid_bounding_boxes,</div>
<div class="line">                                                   properties);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    fluid_tria.signals.pre_distributed_refinement.connect(</div>
<div class="line">      [&amp;]() { solid_particle_handler.register_store_callback_function(); });</div>
<div class="line"> </div>
<div class="line">    fluid_tria.signals.post_distributed_refinement.connect(</div>
<div class="line">      [&amp;]() { solid_particle_handler.register_load_callback_function(<span class="keyword">false</span>); });</div>
<div class="line"> </div>
<div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Solid particles: &quot;</span> &lt;&lt; solid_particle_handler.n_global_particles()</div>
<div class="line">          &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::initial_setup()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Initial setup&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    fluid_fe =</div>
<div class="line">      std::make_unique&lt;FESystem&lt;spacedim&gt;&gt;(<a class="code" href="classFE__Q.html">FE_Q&lt;spacedim&gt;</a>(par.velocity_degree),</div>
<div class="line">                                           spacedim,</div>
<div class="line">                                           <a class="code" href="classFE__Q.html">FE_Q&lt;spacedim&gt;</a>(par.velocity_degree -</div>
<div class="line">                                                          1),</div>
<div class="line">                                           1);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    solid_fe = std::make_unique&lt;FE_Nothing&lt;dim, spacedim&gt;&gt;();</div>
<div class="line">    solid_dh.distribute_dofs(*solid_fe);</div>
<div class="line"> </div>
<div class="line">    fluid_quadrature_formula =</div>
<div class="line">      std::make_unique&lt;QGauss&lt;spacedim&gt;&gt;(par.velocity_degree + 1);</div>
<div class="line">    solid_quadrature_formula =</div>
<div class="line">      std::make_unique&lt;QGauss&lt;dim&gt;&gt;(par.velocity_degree + 1);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::setup_dofs()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup dofs&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    fluid_dh.distribute_dofs(*fluid_fe);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;unsigned int&gt; stokes_sub_blocks(spacedim + 1, 0);</div>
<div class="line">    stokes_sub_blocks[spacedim] = 1;</div>
<div class="line">    <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(fluid_dh, stokes_sub_blocks);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> dofs_per_block =</div>
<div class="line">      <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(fluid_dh, stokes_sub_blocks);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = dofs_per_block[0], n_p = dofs_per_block[1];</div>
<div class="line"> </div>
<div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; fluid_dh.n_dofs() &lt;&lt; <span class="stringliteral">&quot; (&quot;</span></div>
<div class="line">          &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="stringliteral">&quot; -- &quot;</span></div>
<div class="line">          &lt;&lt; solid_particle_handler.n_global_particles() &lt;&lt; <span class="charliteral">&#39;+&#39;</span></div>
<div class="line">          &lt;&lt; tracer_particle_handler.n_global_particles() &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    fluid_owned_dofs.resize(2);</div>
<div class="line">    fluid_owned_dofs[0] = fluid_dh.locally_owned_dofs().get_view(0, n_u);</div>
<div class="line">    fluid_owned_dofs[1] =</div>
<div class="line">      fluid_dh.locally_owned_dofs().get_view(n_u, n_u + n_p);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs;</div>
<div class="line">    <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(fluid_dh, locally_relevant_dofs);</div>
<div class="line">    fluid_relevant_dofs.resize(2);</div>
<div class="line">    fluid_relevant_dofs[0] = locally_relevant_dofs.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(0, n_u);</div>
<div class="line">    fluid_relevant_dofs[1] = locally_relevant_dofs.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(n_u, n_u + n_p);</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">      constraints.reinit(locally_relevant_dofs);</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div>
<div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(fluid_dh, constraints);</div>
<div class="line">      <a class="code" href="namespaceVectorTools.html#ab2562d41bb26f362043f9719a8cd9b87">VectorTools::interpolate_boundary_values</a>(</div>
<div class="line">        fluid_dh,</div>
<div class="line">        0,</div>
<div class="line">        <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;spacedim&gt;</a>(spacedim + 1),</div>
<div class="line">        constraints,</div>
<div class="line">        fluid_fe-&gt;component_mask(velocities));</div>
<div class="line">      constraints.close();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> locally_owned_dofs_per_processor =</div>
<div class="line">      <a class="code" href="namespaceUtilities_1_1MPI.html#ac5a7433f594a19070add2afa0f769efb">Utilities::MPI::all_gather</a>(mpi_communicator,</div>
<div class="line">                                 fluid_dh.locally_owned_dofs());</div>
<div class="line">    {</div>
<div class="line">      system_matrix.clear();</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(spacedim + 1, spacedim + 1);</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; spacedim + 1; ++c)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; spacedim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div>
<div class="line">          <span class="keywordflow">if</span> (c == spacedim &amp;&amp; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> == spacedim)</div>
<div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div>
<div class="line">          <span class="keywordflow">else</span> <span class="keywordflow">if</span> (c == spacedim || <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> == spacedim || c == <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div>
<div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div>
<div class="line">          <span class="keywordflow">else</span></div>
<div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(dofs_per_block, dofs_per_block);</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div>
<div class="line">        fluid_dh, coupling, dsp, constraints, <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="namespaceSparsityTools.html#afbc0c7a206ced91b154666215ea3c218">SparsityTools::distribute_sparsity_pattern</a>(</div>
<div class="line">        dsp,</div>
<div class="line">        locally_owned_dofs_per_processor,</div>
<div class="line">        mpi_communicator,</div>
<div class="line">        locally_relevant_dofs);</div>
<div class="line"> </div>
<div class="line">      system_matrix.reinit(fluid_owned_dofs, dsp, mpi_communicator);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">      preconditioner_matrix.clear();</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(spacedim + 1, spacedim + 1);</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; spacedim + 1; ++c)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; spacedim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div>
<div class="line">          <span class="keywordflow">if</span> (c == spacedim &amp;&amp; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> == spacedim)</div>
<div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div>
<div class="line">          <span class="keywordflow">else</span></div>
<div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(dofs_per_block, dofs_per_block);</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div>
<div class="line">        fluid_dh, coupling, dsp, constraints, <span class="keyword">false</span>);</div>
<div class="line">      <a class="code" href="namespaceSparsityTools.html#afbc0c7a206ced91b154666215ea3c218">SparsityTools::distribute_sparsity_pattern</a>(</div>
<div class="line">        dsp,</div>
<div class="line">        locally_owned_dofs_per_processor,</div>
<div class="line">        mpi_communicator,</div>
<div class="line">        locally_relevant_dofs);</div>
<div class="line">      preconditioner_matrix.reinit(fluid_owned_dofs, dsp, mpi_communicator);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    locally_relevant_solution.reinit(fluid_owned_dofs,</div>
<div class="line">                                     fluid_relevant_dofs,</div>
<div class="line">                                     mpi_communicator);</div>
<div class="line">    system_rhs.reinit(fluid_owned_dofs, mpi_communicator);</div>
<div class="line">    solution.reinit(fluid_owned_dofs, mpi_communicator);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::assemble_stokes_system()</div>
<div class="line">  {</div>
<div class="line">    system_matrix         = 0;</div>
<div class="line">    preconditioner_matrix = 0;</div>
<div class="line">    system_rhs            = 0;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Assemble Stokes terms&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;spacedim&gt;</a> fe_values(*fluid_fe,</div>
<div class="line">                                 *fluid_quadrature_formula,</div>
<div class="line">                                 <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div>
<div class="line">                                   <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div>
<div class="line">                                   <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fluid_fe-&gt;n_dofs_per_cell();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = fluid_quadrature_formula-&gt;size();</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div>
<div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix2(dofs_per_cell, dofs_per_cell);</div>
<div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     cell_rhs(dofs_per_cell);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; rhs_values(n_q_points,</div>
<div class="line">                                           <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(spacedim + 1));</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;Tensor&lt;2, spacedim&gt;&gt; grad_phi_u(dofs_per_cell);</div>
<div class="line">    std::vector&lt;double&gt;              div_phi_u(dofs_per_cell);</div>
<div class="line">    std::vector&lt;double&gt;              phi_p(dofs_per_cell);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a>     velocities(0);</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a>     pressure(spacedim);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : fluid_dh.active_cell_iterators())</div>
<div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div>
<div class="line">        {</div>
<div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>  = 0;</div>
<div class="line">          cell_matrix2 = 0;</div>
<div class="line">          cell_rhs     = 0;</div>
<div class="line"> </div>
<div class="line">          fe_values.reinit(cell);</div>
<div class="line">          par.rhs.vector_value_list(fe_values.get_quadrature_points(),</div>
<div class="line">                                    rhs_values);</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div>
<div class="line">            {</div>
<div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div>
<div class="line">                {</div>
<div class="line">                  grad_phi_u[k] = fe_values[velocities].gradient(k, q);</div>
<div class="line">                  div_phi_u[k]  = fe_values[velocities].divergence(k, q);</div>
<div class="line">                  phi_p[k]      = fe_values[pressure].value(k, q);</div>
<div class="line">                }</div>
<div class="line"> </div>
<div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div>
<div class="line">                {</div>
<div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div>
<div class="line">                    {</div>
<div class="line">                      <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div>
<div class="line">                        (par.viscosity *</div>
<div class="line">                           <a class="code" href="classSymmetricTensor.html#ab14ac27fc9ab74d4de531698b492d8de">scalar_product</a>(grad_phi_u[i], grad_phi_u[j]) -</div>
<div class="line">                         div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j]) *</div>
<div class="line">                        fe_values.JxW(q);</div>
<div class="line"> </div>
<div class="line">                      cell_matrix2(i, j) += 1.0 / par.viscosity * phi_p[i] *</div>
<div class="line">                                            phi_p[j] * fe_values.JxW(q);</div>
<div class="line">                    }</div>
<div class="line"> </div>
<div class="line">                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component_i =</div>
<div class="line">                    fluid_fe-&gt;system_to_component_index(i).first;</div>
<div class="line">                  cell_rhs(i) += fe_values.shape_value(i, q) *</div>
<div class="line">                                 rhs_values[q](component_i) * fe_values.JxW(q);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">          cell-&gt;get_dof_indices(local_dof_indices);</div>
<div class="line">          constraints.distribute_local_to_global(<a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>,</div>
<div class="line">                                                 cell_rhs,</div>
<div class="line">                                                 local_dof_indices,</div>
<div class="line">                                                 system_matrix,</div>
<div class="line">                                                 system_rhs);</div>
<div class="line"> </div>
<div class="line">          constraints.distribute_local_to_global(cell_matrix2,</div>
<div class="line">                                                 local_dof_indices,</div>
<div class="line">                                                 preconditioner_matrix);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">    system_matrix.compress(<a class="code" href="group__Vectors.html#gga40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div>
<div class="line">    preconditioner_matrix.compress(<a class="code" href="group__Vectors.html#gga40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div>
<div class="line">    system_rhs.compress(<a class="code" href="group__Vectors.html#gga40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::assemble_nitsche_restriction()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Assemble Nitsche terms&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(spacedim);</div>
<div class="line"> </div>
<div class="line">    SolidVelocity&lt;spacedim&gt; solid_velocity(par.angular_velocity);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;types::global_dof_index&gt; fluid_dof_indices(</div>
<div class="line">      fluid_fe-&gt;n_dofs_per_cell());</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>     local_matrix(fluid_fe-&gt;n_dofs_per_cell(),</div>
<div class="line">                                    fluid_fe-&gt;n_dofs_per_cell());</div>
<div class="line">    <a class="code" href="classVector.html">::Vector&lt;double&gt;</a> local_rhs(fluid_fe-&gt;n_dofs_per_cell());</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> penalty_parameter =</div>
<div class="line">      1.0 / <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(fluid_tria);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> particle = solid_particle_handler.begin();</div>
<div class="line">    <span class="keywordflow">while</span> (particle != solid_particle_handler.end())</div>
<div class="line">      {</div>
<div class="line">        local_matrix = 0;</div>
<div class="line">        local_rhs    = 0;</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell = particle-&gt;get_surrounding_cell(fluid_tria);</div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;dh_cell =</div>
<div class="line">          <span class="keyword">typename</span> <a class="code" href="group__Iterators.html#ga32b2a057d9abd2e1752bf8a3cb88e644">DoFHandler&lt;spacedim&gt;::cell_iterator</a>(*cell, &amp;fluid_dh);</div>
<div class="line">        dh_cell-&gt;get_dof_indices(fluid_dof_indices);</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> pic = solid_particle_handler.particles_in_cell(cell);</div>
<div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(pic.begin() == particle, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : pic)</div>
<div class="line">          {</div>
<div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> &amp;ref_q  = p.get_reference_location();</div>
<div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> &amp;real_q = p.get_location();</div>
<div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> &amp;JxW    = p.get_properties()[0];</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; fluid_fe-&gt;n_dofs_per_cell(); ++i)</div>
<div class="line">              {</div>
<div class="line">                <span class="keyword">const</span> <span class="keyword">auto</span> comp_i =</div>
<div class="line">                  fluid_fe-&gt;system_to_component_index(i).first;</div>
<div class="line">                <span class="keywordflow">if</span> (comp_i &lt; spacedim)</div>
<div class="line">                  {</div>
<div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; fluid_fe-&gt;n_dofs_per_cell();</div>
<div class="line">                         ++j)</div>
<div class="line">                      {</div>
<div class="line">                        <span class="keyword">const</span> <span class="keyword">auto</span> comp_j =</div>
<div class="line">                          fluid_fe-&gt;system_to_component_index(j).first;</div>
<div class="line">                        <span class="keywordflow">if</span> (comp_i == comp_j)</div>
<div class="line">                          local_matrix(i, j) +=</div>
<div class="line">                            penalty_parameter * par.penalty_term *</div>
<div class="line">                            fluid_fe-&gt;shape_value(i, ref_q) *</div>
<div class="line">                            fluid_fe-&gt;shape_value(j, ref_q) * JxW;</div>
<div class="line">                      }</div>
<div class="line">                    local_rhs(i) += penalty_parameter * par.penalty_term *</div>
<div class="line">                                    solid_velocity.value(real_q, comp_i) *</div>
<div class="line">                                    fluid_fe-&gt;shape_value(i, ref_q) * JxW;</div>
<div class="line">                  }</div>
<div class="line">              }</div>
<div class="line">          }</div>
<div class="line"> </div>
<div class="line">        constraints.distribute_local_to_global(local_matrix,</div>
<div class="line">                                               local_rhs,</div>
<div class="line">                                               fluid_dof_indices,</div>
<div class="line">                                               system_matrix,</div>
<div class="line">                                               system_rhs);</div>
<div class="line">        particle = pic.end();</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">    system_matrix.compress(<a class="code" href="group__Vectors.html#gga40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div>
<div class="line">    system_rhs.compress(<a class="code" href="group__Vectors.html#gga40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::solve()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Solve&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="namespaceLinearAlgebraPETSc_1_1MPI.html#a41f11f7a1992c6d6aa9367b12c68f791">LA::MPI::PreconditionAMG</a> prec_A;</div>
<div class="line">    {</div>
<div class="line">      LA::MPI::PreconditionAMG::AdditionalData data;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef USE_PETSC_LA</span></div>
<div class="line">      data.symmetric_operator = <span class="keyword">true</span>;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">      prec_A.<a class="code" href="classPETScWrappers_1_1PreconditionBoomerAMG.html#a3c82672eac786d7f369b296439859ff2">initialize</a>(system_matrix.block(0, 0), data);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="namespaceLinearAlgebraPETSc_1_1MPI.html#a41f11f7a1992c6d6aa9367b12c68f791">LA::MPI::PreconditionAMG</a> prec_S;</div>
<div class="line">    {</div>
<div class="line">      LA::MPI::PreconditionAMG::AdditionalData data;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef USE_PETSC_LA</span></div>
<div class="line">      data.symmetric_operator = <span class="keyword">true</span>;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">      prec_S.<a class="code" href="classPETScWrappers_1_1PreconditionBoomerAMG.html#a3c82672eac786d7f369b296439859ff2">initialize</a>(preconditioner_matrix.block(1, 1), data);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a> = linear_operator&lt;LA::MPI::Vector&gt;(system_matrix.block(0, 0));</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> amgA = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>, prec_A);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> S =</div>
<div class="line">      linear_operator&lt;LA::MPI::Vector&gt;(preconditioner_matrix.block(1, 1));</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> amgS = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(S, prec_S);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classReductionControl.html">ReductionControl</a>          inner_solver_control(100,</div>
<div class="line">                                          1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8 * system_rhs.l2_norm(),</div>
<div class="line">                                          1.e-2);</div>
<div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;LA::MPI::Vector&gt;</a> cg(inner_solver_control);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> invS = <a class="code" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a>(S, cg, amgS);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> P = block_diagonal_operator&lt;2, LA::MPI::BlockVector&gt;(</div>
<div class="line">      std::array&lt;</div>
<div class="line">        ::<a class="code" href="classLinearOperator.html">LinearOperator&lt;typename LA::MPI::BlockVector::BlockType&gt;</a>,</div>
<div class="line">        2&gt;{{amgA, amgS}});</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(system_matrix.m(),</div>
<div class="line">                                 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-10 * system_rhs.l2_norm());</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classSolverFGMRES.html">SolverFGMRES&lt;LA::MPI::BlockVector&gt;</a> solver(solver_control);</div>
<div class="line"> </div>
<div class="line">    constraints.set_zero(solution);</div>
<div class="line"> </div>
<div class="line">    solver.solve(system_matrix, solution, system_rhs, P);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Solved in &quot;</span> &lt;&lt; solver_control.last_step() &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span></div>
<div class="line">          &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    constraints.distribute(solution);</div>
<div class="line"> </div>
<div class="line">    locally_relevant_solution = solution;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> mean_pressure =</div>
<div class="line">      <a class="code" href="namespaceVectorTools.html#ad086eb08b8424fd7c853e389a3978a9a">VectorTools::compute_mean_value</a>(fluid_dh,</div>
<div class="line">                                      <a class="code" href="classQGauss.html">QGauss&lt;spacedim&gt;</a>(par.velocity_degree + 2),</div>
<div class="line">                                      locally_relevant_solution,</div>
<div class="line">                                      spacedim);</div>
<div class="line">    solution.block(1).add(-mean_pressure);</div>
<div class="line">    locally_relevant_solution.block(1) = solution.block(1);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::refine_and_transfer()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a>               t(computing_timer, <span class="stringliteral">&quot;Refine&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocity(0);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a> error_per_cell(fluid_tria.n_active_cells());</div>
<div class="line">    <a class="code" href="classKellyErrorEstimator.html#aa0917e696d4f8ddb983223a68c512357">KellyErrorEstimator&lt;spacedim&gt;::estimate</a>(fluid_dh,</div>
<div class="line">                                            <a class="code" href="classQGauss.html">QGauss&lt;spacedim - 1&gt;</a>(</div>
<div class="line">                                              par.velocity_degree + 1),</div>
<div class="line">                                            {},</div>
<div class="line">                                            locally_relevant_solution,</div>
<div class="line">                                            error_per_cell,</div>
<div class="line">                                            fluid_fe-&gt;component_mask(velocity));</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (par.refinement_strategy == <span class="stringliteral">&quot;fixed_fraction&quot;</span>)</div>
<div class="line">      {</div>
<div class="line">        <a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#ae5159e3207f6786f0749fc0b66ab8ca3">parallel::distributed::GridRefinement::</a></div>
<div class="line"><a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#ae5159e3207f6786f0749fc0b66ab8ca3">          refine_and_coarsen_fixed_fraction</a>(fluid_tria,</div>
<div class="line">                                            error_per_cell,</div>
<div class="line">                                            par.refinement_fraction,</div>
<div class="line">                                            par.coarsening_fraction);</div>
<div class="line">      }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (par.refinement_strategy == <span class="stringliteral">&quot;fixed_number&quot;</span>)</div>
<div class="line">      {</div>
<div class="line">        <a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#aa2ffb707a796ae6dedb75036606ef2e6">parallel::distributed::GridRefinement::refine_and_coarsen_fixed_number</a>(</div>
<div class="line">          fluid_tria,</div>
<div class="line">          error_per_cell,</div>
<div class="line">          par.refinement_fraction,</div>
<div class="line">          par.coarsening_fraction,</div>
<div class="line">          par.max_cells);</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : fluid_tria.active_cell_iterators())</div>
<div class="line">      {</div>
<div class="line">        <span class="keywordflow">if</span> (cell-&gt;refine_flag_set() &amp;&amp;</div>
<div class="line">            cell-&gt;level() == par.max_level_refinement)</div>
<div class="line">          cell-&gt;clear_refine_flag();</div>
<div class="line">        <span class="keywordflow">if</span> (cell-&gt;coarsen_flag_set() &amp;&amp;</div>
<div class="line">            cell-&gt;level() == par.min_level_refinement)</div>
<div class="line">          cell-&gt;clear_coarsen_flag();</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer&lt;spacedim, LA::MPI::BlockVector&gt;</a></div>
<div class="line">      transfer(fluid_dh);</div>
<div class="line">    fluid_tria.prepare_coarsening_and_refinement();</div>
<div class="line">    transfer.prepare_for_coarsening_and_refinement(locally_relevant_solution);</div>
<div class="line">    fluid_tria.execute_coarsening_and_refinement();</div>
<div class="line"> </div>
<div class="line">    setup_dofs();</div>
<div class="line"> </div>
<div class="line">    transfer.interpolate(solution);</div>
<div class="line">    constraints.distribute(solution);</div>
<div class="line">    locally_relevant_solution = solution;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">  <span class="keywordtype">void</span></div>
<div class="line">  StokesImmersedProblem&lt;dim, spacedim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle,</div>
<div class="line">                                                       <span class="keywordtype">double</span> time)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output fluid&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;std::string&gt; solution_names(spacedim, <span class="stringliteral">&quot;velocity&quot;</span>);</div>
<div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;pressure&quot;</span>);</div>
<div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div>
<div class="line">      data_component_interpretation(</div>
<div class="line">        spacedim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div>
<div class="line">    data_component_interpretation.push_back(</div>
<div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;spacedim&gt;</a> data_out;</div>
<div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a>(fluid_dh);</div>
<div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a>(locally_relevant_solution,</div>
<div class="line">                             solution_names,</div>
<div class="line">                             <a class="code" href="classDataOut.html">DataOut&lt;spacedim&gt;::type_dof_data</a>,</div>
<div class="line">                             data_component_interpretation);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a> subdomain(fluid_tria.n_active_cells());</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; subdomain.size(); ++i)</div>
<div class="line">      subdomain(i) = fluid_tria.locally_owned_subdomain();</div>
<div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a>(subdomain, <span class="stringliteral">&quot;subdomain&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> std::string filename =</div>
<div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div>
<div class="line">    data_out.<a class="code" href="group__Exceptions.html#ga5df488dad82b811ceb08cb1adf9eafcd">write_vtu_in_parallel</a>(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + filename,</div>
<div class="line">                                   mpi_communicator);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> std::vector&lt;std::pair&lt;double, std::string&gt;&gt; times_and_names;</div>
<div class="line">    times_and_names.push_back(std::make_pair(time, filename));</div>
<div class="line">    std::ofstream ofile(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + <span class="stringliteral">&quot;solution.pvd&quot;</span>);</div>
<div class="line">    <a class="code" href="namespaceDataOutBase.html#a6f1c052ba49fd44cd8e3f35ba871aebd">DataOutBase::write_pvd_record</a>(ofile, times_and_names);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::output_particles(</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> &amp;particles,</div>
<div class="line">    std::string                                 fprefix,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                          iter,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                                time)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <a class="code" href="classParticles_1_1DataOut.html">Particles::DataOut&lt;spacedim&gt;</a> particles_out;</div>
<div class="line">    particles_out.<a class="code" href="classParticles_1_1DataOut.html#adf095165dc286310226584b2b9972701">build_patches</a>(particles);</div>
<div class="line">    <span class="keyword">const</span> std::string filename =</div>
<div class="line">      (fprefix + <span class="stringliteral">&quot;-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(iter) + <span class="stringliteral">&quot;.vtu&quot;</span>);</div>
<div class="line">    particles_out.<a class="code" href="group__Exceptions.html#ga5df488dad82b811ceb08cb1adf9eafcd">write_vtu_in_parallel</a>(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + filename,</div>
<div class="line">                                        mpi_communicator);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> std::map&lt;std::string, std::vector&lt;std::pair&lt;double, std::string&gt;&gt;&gt;</div>
<div class="line">      times_and_names;</div>
<div class="line">    <span class="keywordflow">if</span> (times_and_names.find(fprefix) != times_and_names.end())</div>
<div class="line">      times_and_names[fprefix].push_back(std::make_pair(time, filename));</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">      times_and_names[fprefix] = {std::make_pair(time, filename)};</div>
<div class="line">    std::ofstream ofile(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + fprefix + <span class="stringliteral">&quot;.pvd&quot;</span>);</div>
<div class="line">    <a class="code" href="namespaceDataOutBase.html#a6f1c052ba49fd44cd8e3f35ba871aebd">DataOutBase::write_pvd_record</a>(ofile, times_and_names[fprefix]);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">StokesImmersedProblem&lt;dim, spacedim&gt;::run</a>()</div>
<div class="line">  {</div>
<div class="line"><span class="preprocessor">#ifdef USE_PETSC_LA</span></div>
<div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Running StokesImmersedProblem&lt;&quot;</span></div>
<div class="line">          &lt;&lt; <a class="code" href="namespaceUtilities.html#a21aa22d290ce783e37587b6c879b926c">Utilities::dim_string</a>(dim, spacedim) &lt;&lt; <span class="stringliteral">&quot;&gt; using PETSc.&quot;</span></div>
<div class="line">          &lt;&lt; std::endl;</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Running StokesImmersedProblem&lt;&quot;</span></div>
<div class="line">          &lt;&lt; <a class="code" href="namespaceUtilities.html#a21aa22d290ce783e37587b6c879b926c">Utilities::dim_string</a>(dim, spacedim) &lt;&lt; <span class="stringliteral">&quot;&gt; using Trilinos.&quot;</span></div>
<div class="line">          &lt;&lt; std::endl;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">    par.prm.print_parameters(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + <span class="stringliteral">&quot;used_parameters_&quot;</span> +</div>
<div class="line">                               <a class="code" href="group__Exceptions.html#ga72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(dim) + <a class="code" href="group__Exceptions.html#ga72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(spacedim) +</div>
<div class="line">                               <span class="stringliteral">&quot;.prm&quot;</span>,</div>
<div class="line">                             <a class="code" href="group__Exceptions.html#ga8364dda711b93753c6809eefe2a8e827a3c8ad66ea26104112458e2ce35b5028f">ParameterHandler::Short</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> time_step    = par.final_time / (par.number_of_time_steps - 1);</div>
<div class="line">    <span class="keywordtype">double</span>       time         = 0;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> output_cycle = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; par.number_of_time_steps;</div>
<div class="line">         ++cycle, time += time_step)</div>
<div class="line">      {</div>
<div class="line">        par.set_time(time);</div>
<div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;Time : &quot;</span> &lt;&lt; time &lt;&lt; <span class="stringliteral">&quot;, time step: &quot;</span> &lt;&lt; time_step &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div>
<div class="line">          {</div>
<div class="line">            make_grid();</div>
<div class="line">            initial_setup();</div>
<div class="line">            setup_dofs();</div>
<div class="line">            setup_tracer_particles();</div>
<div class="line">            setup_solid_particles();</div>
<div class="line">            tracer_particle_velocities.reinit(</div>
<div class="line">              locally_owned_tracer_particle_coordinates, mpi_communicator);</div>
<div class="line">            output_results(output_cycle, time);</div>
<div class="line">            {</div>
<div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output tracer particles&quot;</span>);</div>
<div class="line">              output_particles(tracer_particle_handler,</div>
<div class="line">                               <span class="stringliteral">&quot;tracer&quot;</span>,</div>
<div class="line">                               output_cycle,</div>
<div class="line">                               time);</div>
<div class="line">            }</div>
<div class="line">            {</div>
<div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output solid particles&quot;</span>);</div>
<div class="line">              output_particles(solid_particle_handler,</div>
<div class="line">                               <span class="stringliteral">&quot;solid&quot;</span>,</div>
<div class="line">                               output_cycle,</div>
<div class="line">                               time);</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">          {</div>
<div class="line">            <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer,</div>
<div class="line">                                 <span class="stringliteral">&quot;Set solid particle position&quot;</span>);</div>
<div class="line"> </div>
<div class="line">            SolidPosition&lt;spacedim&gt; solid_position(par.angular_velocity,</div>
<div class="line">                                                   time_step);</div>
<div class="line">            solid_particle_handler.set_particle_positions(solid_position,</div>
<div class="line">                                                          <span class="keyword">false</span>);</div>
<div class="line">          }</div>
<div class="line"> </div>
<div class="line">        {</div>
<div class="line">          <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Set tracer particle motion&quot;</span>);</div>
<div class="line">          <a class="code" href="namespaceParticles_1_1Utilities.html#a054f60295f7694c31a30b0019d94df73">Particles::Utilities::interpolate_field_on_particles</a>(</div>
<div class="line">            fluid_dh,</div>
<div class="line">            tracer_particle_handler,</div>
<div class="line">            locally_relevant_solution,</div>
<div class="line">            tracer_particle_velocities,</div>
<div class="line">            fluid_fe-&gt;component_mask(<a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a>(0)));</div>
<div class="line"> </div>
<div class="line">          tracer_particle_velocities *= time_step;</div>
<div class="line"> </div>
<div class="line">          locally_relevant_tracer_particle_coordinates =</div>
<div class="line">            tracer_particle_handler.locally_relevant_ids().tensor_product(</div>
<div class="line">              <a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(spacedim));</div>
<div class="line"> </div>
<div class="line">          relevant_tracer_particle_displacements.reinit(</div>
<div class="line">            locally_owned_tracer_particle_coordinates,</div>
<div class="line">            locally_relevant_tracer_particle_coordinates,</div>
<div class="line">            mpi_communicator);</div>
<div class="line"> </div>
<div class="line">          relevant_tracer_particle_displacements = tracer_particle_velocities;</div>
<div class="line"> </div>
<div class="line">          tracer_particle_handler.set_particle_positions(</div>
<div class="line">            relevant_tracer_particle_displacements);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        assemble_stokes_system();</div>
<div class="line">        assemble_nitsche_restriction();</div>
<div class="line">        solve();</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (cycle % par.output_frequency == 0)</div>
<div class="line">          {</div>
<div class="line">            output_results(output_cycle, time);</div>
<div class="line">            {</div>
<div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output tracer particles&quot;</span>);</div>
<div class="line">              output_particles(tracer_particle_handler,</div>
<div class="line">                               <span class="stringliteral">&quot;tracer&quot;</span>,</div>
<div class="line">                               output_cycle,</div>
<div class="line">                               time);</div>
<div class="line">            }</div>
<div class="line">            {</div>
<div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output solid particles&quot;</span>);</div>
<div class="line">              output_particles(solid_particle_handler,</div>
<div class="line">                               <span class="stringliteral">&quot;solid&quot;</span>,</div>
<div class="line">                               output_cycle,</div>
<div class="line">                               time);</div>
<div class="line">            }</div>
<div class="line">            ++output_cycle;</div>
<div class="line">          }</div>
<div class="line">        <span class="keywordflow">if</span> (cycle % par.refinement_frequency == 0 &amp;&amp;</div>
<div class="line">            cycle != par.number_of_time_steps - 1)</div>
<div class="line">          refine_and_transfer();</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace Step70</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span>Step70;</div>
<div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
<div class="line">  <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a>.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a>(1);</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv, 1);</div>
<div class="line"> </div>
<div class="line">      std::string prm_file;</div>
<div class="line">      <span class="keywordflow">if</span> (argc &gt; 1)</div>
<div class="line">        prm_file = argv[1];</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">        prm_file = <span class="stringliteral">&quot;parameters.prm&quot;</span>;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">if</span> (prm_file.find(<span class="stringliteral">&quot;23&quot;</span>) != std::string::npos)</div>
<div class="line">        {</div>
<div class="line">          StokesImmersedProblemParameters&lt;2, 3&gt; par;</div>
<div class="line">          <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(prm_file);</div>
<div class="line"> </div>
<div class="line">          StokesImmersedProblem&lt;2, 3&gt; problem(par);</div>
<div class="line">          problem.run();</div>
<div class="line">        }</div>
<div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (prm_file.find(<span class="stringliteral">&quot;3&quot;</span>) != std::string::npos)</div>
<div class="line">        {</div>
<div class="line">          StokesImmersedProblemParameters&lt;3&gt; par;</div>
<div class="line">          <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(prm_file);</div>
<div class="line"> </div>
<div class="line">          StokesImmersedProblem&lt;3&gt; problem(par);</div>
<div class="line">          problem.run();</div>
<div class="line">        }</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">          StokesImmersedProblemParameters&lt;2&gt; par;</div>
<div class="line">          <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(prm_file);</div>
<div class="line"> </div>
<div class="line">          StokesImmersedProblem&lt;2&gt; problem(par);</div>
<div class="line">          problem.run();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
