<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classScaLAPACKMatrix.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: ScaLAPACKMatrix&lt; NumberType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.3.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.3.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classScaLAPACKMatrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ScaLAPACKMatrix&lt; NumberType &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__Matrices.html">Matrix classes</a> &raquo; <a class="el" href="group__Matrix1.html">Basic matrices</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="scalapack_8h_source.html">deal.II/lac/scalapack.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ScaLAPACKMatrix&lt; NumberType &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classScaLAPACKMatrix__inherit__graph.svg" width="290" height="444"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a432e6f19e0ba55f12031a1a68fa7ab17"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a432e6f19e0ba55f12031a1a68fa7ab17">size_type</a> = unsigned int</td></tr>
<tr class="separator:a432e6f19e0ba55f12031a1a68fa7ab17"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a711503af730f169914268d2e307aa0ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a711503af730f169914268d2e307aa0ab">ScaLAPACKMatrix</a> (const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a> <a class="el" href="classScaLAPACKMatrix.html#a2bdb8189d7e88a60291430a2945e8bc3">n_rows</a>, const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a> <a class="el" href="classScaLAPACKMatrix.html#aa802e135eb0b2b5fb07636b3ad20e123">n_columns</a>, const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1ProcessGrid.html">Utilities::MPI::ProcessGrid</a> &gt; &amp;process_grid, const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a> <a class="el" href="classScaLAPACKMatrix.html#af10d04b6961bffb230a58f658ddb7d5d">row_block_size</a>=32, const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a> <a class="el" href="classScaLAPACKMatrix.html#a5286111f1e05e8019b36933eef6a55aa">column_block_size</a>=32, const <a class="el" href="namespaceLAPACKSupport.html#a45557450a3c1ae0e74d7ddf12c43bc98">LAPACKSupport::Property</a> <a class="el" href="classScaLAPACKMatrix.html#aae1c9ee4a7967975a161bc336d24a173">property</a>=LAPACKSupport::Property::general)</td></tr>
<tr class="separator:a711503af730f169914268d2e307aa0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18a3b69bbaf7bd48147f87218a8afd4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#ac18a3b69bbaf7bd48147f87218a8afd4">ScaLAPACKMatrix</a> (const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a> <a class="el" href="classTableBase.html#af2204c132154b5d6bfd571eb85d8a58f">size</a>, const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1ProcessGrid.html">Utilities::MPI::ProcessGrid</a> &gt; &amp;process_grid, const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a> block_size=32, const <a class="el" href="namespaceLAPACKSupport.html#a45557450a3c1ae0e74d7ddf12c43bc98">LAPACKSupport::Property</a> <a class="el" href="classScaLAPACKMatrix.html#aae1c9ee4a7967975a161bc336d24a173">property</a>=LAPACKSupport::Property::symmetric)</td></tr>
<tr class="separator:ac18a3b69bbaf7bd48147f87218a8afd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861b3d89915ca829cb3248f5da9d8e8b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a861b3d89915ca829cb3248f5da9d8e8b">ScaLAPACKMatrix</a> (const std::string &amp;filename, const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1ProcessGrid.html">Utilities::MPI::ProcessGrid</a> &gt; &amp;process_grid, const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a> <a class="el" href="classScaLAPACKMatrix.html#af10d04b6961bffb230a58f658ddb7d5d">row_block_size</a>=32, const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a> <a class="el" href="classScaLAPACKMatrix.html#a5286111f1e05e8019b36933eef6a55aa">column_block_size</a>=32)</td></tr>
<tr class="separator:a861b3d89915ca829cb3248f5da9d8e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e37a511442824aca1ffc090f1071d6a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a8e37a511442824aca1ffc090f1071d6a">~ScaLAPACKMatrix</a> () override=default</td></tr>
<tr class="separator:a8e37a511442824aca1ffc090f1071d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab755a374266785648ae364b6d78f6c94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#ab755a374266785648ae364b6d78f6c94">reinit</a> (const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a> <a class="el" href="classScaLAPACKMatrix.html#a2bdb8189d7e88a60291430a2945e8bc3">n_rows</a>, const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a> <a class="el" href="classScaLAPACKMatrix.html#aa802e135eb0b2b5fb07636b3ad20e123">n_columns</a>, const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1ProcessGrid.html">Utilities::MPI::ProcessGrid</a> &gt; &amp;process_grid, const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a> <a class="el" href="classScaLAPACKMatrix.html#af10d04b6961bffb230a58f658ddb7d5d">row_block_size</a>=32, const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a> <a class="el" href="classScaLAPACKMatrix.html#a5286111f1e05e8019b36933eef6a55aa">column_block_size</a>=32, const <a class="el" href="namespaceLAPACKSupport.html#a45557450a3c1ae0e74d7ddf12c43bc98">LAPACKSupport::Property</a> <a class="el" href="classScaLAPACKMatrix.html#aae1c9ee4a7967975a161bc336d24a173">property</a>=LAPACKSupport::Property::general)</td></tr>
<tr class="separator:ab755a374266785648ae364b6d78f6c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab9ec110b225e4aa3b88ce83ff7bbcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a7ab9ec110b225e4aa3b88ce83ff7bbcd">reinit</a> (const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a> <a class="el" href="classTableBase.html#af2204c132154b5d6bfd571eb85d8a58f">size</a>, const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1ProcessGrid.html">Utilities::MPI::ProcessGrid</a> &gt; &amp;process_grid, const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a> block_size=32, const <a class="el" href="namespaceLAPACKSupport.html#a45557450a3c1ae0e74d7ddf12c43bc98">LAPACKSupport::Property</a> <a class="el" href="classScaLAPACKMatrix.html#aae1c9ee4a7967975a161bc336d24a173">property</a>=LAPACKSupport::Property::symmetric)</td></tr>
<tr class="separator:a7ab9ec110b225e4aa3b88ce83ff7bbcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a0999bd5c5d5a519ae09bb1b1f6ddd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#ab1a0999bd5c5d5a519ae09bb1b1f6ddd">set_property</a> (const <a class="el" href="namespaceLAPACKSupport.html#a45557450a3c1ae0e74d7ddf12c43bc98">LAPACKSupport::Property</a> <a class="el" href="classScaLAPACKMatrix.html#aae1c9ee4a7967975a161bc336d24a173">property</a>)</td></tr>
<tr class="separator:ab1a0999bd5c5d5a519ae09bb1b1f6ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dcde64aa5131d2a997b7221132cbf5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceLAPACKSupport.html#a45557450a3c1ae0e74d7ddf12c43bc98">LAPACKSupport::Property</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a4dcde64aa5131d2a997b7221132cbf5d">get_property</a> () const</td></tr>
<tr class="separator:a4dcde64aa5131d2a997b7221132cbf5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f5b93c67c0f8851fd29ed89e4220cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638">LAPACKSupport::State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a49f5b93c67c0f8851fd29ed89e4220cd">get_state</a> () const</td></tr>
<tr class="separator:a49f5b93c67c0f8851fd29ed89e4220cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d424dbb47f6c4ce6d554677c53c1570"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a2d424dbb47f6c4ce6d554677c53c1570">operator=</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; NumberType &gt; &amp;)</td></tr>
<tr class="separator:a2d424dbb47f6c4ce6d554677c53c1570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb57a0f97778b451507ee32233571d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a1bb57a0f97778b451507ee32233571d4">copy_from</a> (const <a class="el" href="classLAPACKFullMatrix.html">LAPACKFullMatrix</a>&lt; NumberType &gt; &amp;matrix, const unsigned int rank)</td></tr>
<tr class="separator:a1bb57a0f97778b451507ee32233571d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae25c0bf99b3489c9b929a17be267d27f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#ae25c0bf99b3489c9b929a17be267d27f">copy_to</a> (<a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; NumberType &gt; &amp;matrix) const</td></tr>
<tr class="separator:ae25c0bf99b3489c9b929a17be267d27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb8d24a17a4b2538fdca4397f7f68b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a6fb8d24a17a4b2538fdca4397f7f68b8">copy_to</a> (<a class="el" href="classLAPACKFullMatrix.html">LAPACKFullMatrix</a>&lt; NumberType &gt; &amp;matrix, const unsigned int rank) const</td></tr>
<tr class="separator:a6fb8d24a17a4b2538fdca4397f7f68b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef7a687223ac1e36ba294a2f4b06115"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a1ef7a687223ac1e36ba294a2f4b06115">copy_to</a> (<a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;dest) const</td></tr>
<tr class="separator:a1ef7a687223ac1e36ba294a2f4b06115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ed2356018f07f75b3c951bb808bd49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a02ed2356018f07f75b3c951bb808bd49">copy_to</a> (<a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;B, const std::pair&lt; unsigned int, unsigned int &gt; &amp;offset_A, const std::pair&lt; unsigned int, unsigned int &gt; &amp;offset_B, const std::pair&lt; unsigned int, unsigned int &gt; &amp;submatrix_size) const</td></tr>
<tr class="separator:a02ed2356018f07f75b3c951bb808bd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9aa2d98bc501ca6c59b7bf72f3c0ceb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#ae9aa2d98bc501ca6c59b7bf72f3c0ceb">copy_transposed</a> (const <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;B)</td></tr>
<tr class="separator:ae9aa2d98bc501ca6c59b7bf72f3c0ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462e4473e763e00148572e554395c448"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a462e4473e763e00148572e554395c448">add</a> (const <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;B, const NumberType a=0., const NumberType b=1., const <a class="el" href="classbool.html">bool</a> transpose_B=false)</td></tr>
<tr class="separator:a462e4473e763e00148572e554395c448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e0a87f73838febd95208e6020fb87e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a65e0a87f73838febd95208e6020fb87e">add</a> (const NumberType b, const <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;B)</td></tr>
<tr class="separator:a65e0a87f73838febd95208e6020fb87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354f71241b0d44cba4f46e8410f26fcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a354f71241b0d44cba4f46e8410f26fcd">Tadd</a> (const NumberType b, const <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;B)</td></tr>
<tr class="separator:a354f71241b0d44cba4f46e8410f26fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada5bc79adf4d2b6f7a0a586dd154553"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#aada5bc79adf4d2b6f7a0a586dd154553">mult</a> (const NumberType b, const <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;B, const NumberType c, <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;C, const <a class="el" href="classbool.html">bool</a> transpose_A=false, const <a class="el" href="classbool.html">bool</a> transpose_B=false) const</td></tr>
<tr class="separator:aada5bc79adf4d2b6f7a0a586dd154553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8242435e8730f7cac460b1ac2310c7ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a8242435e8730f7cac460b1ac2310c7ed">mmult</a> (<a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;C, const <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;B, const <a class="el" href="classbool.html">bool</a> adding=false) const</td></tr>
<tr class="separator:a8242435e8730f7cac460b1ac2310c7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546401290947b77277a5f1811bc97ea2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a546401290947b77277a5f1811bc97ea2">Tmmult</a> (<a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;C, const <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;B, const <a class="el" href="classbool.html">bool</a> adding=false) const</td></tr>
<tr class="separator:a546401290947b77277a5f1811bc97ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36438ff9295f52ed4bb385663529f6cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a36438ff9295f52ed4bb385663529f6cb">mTmult</a> (<a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;C, const <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;B, const <a class="el" href="classbool.html">bool</a> adding=false) const</td></tr>
<tr class="separator:a36438ff9295f52ed4bb385663529f6cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcfc441f7e61468e505c20a2b937c46c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#adcfc441f7e61468e505c20a2b937c46c">TmTmult</a> (<a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;C, const <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;B, const <a class="el" href="classbool.html">bool</a> adding=false) const</td></tr>
<tr class="separator:adcfc441f7e61468e505c20a2b937c46c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988e7c86e7e560b2d8c815317a565371"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a988e7c86e7e560b2d8c815317a565371">save</a> (const std::string &amp;filename, const std::pair&lt; unsigned int, unsigned int &gt; &amp;chunk_size=std::make_pair(<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>, <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>)) const</td></tr>
<tr class="separator:a988e7c86e7e560b2d8c815317a565371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7578e1be3f70805316ec69f587ed7730"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a7578e1be3f70805316ec69f587ed7730">load</a> (const std::string &amp;filename)</td></tr>
<tr class="separator:a7578e1be3f70805316ec69f587ed7730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4fab96dc8bf972386fa37936fe8c132"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#ae4fab96dc8bf972386fa37936fe8c132">compute_cholesky_factorization</a> ()</td></tr>
<tr class="separator:ae4fab96dc8bf972386fa37936fe8c132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25b18f13ceb1f252c2526124396d180"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#aa25b18f13ceb1f252c2526124396d180">compute_lu_factorization</a> ()</td></tr>
<tr class="separator:aa25b18f13ceb1f252c2526124396d180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f723f324b1c7c22941f33034b652eec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a5f723f324b1c7c22941f33034b652eec">invert</a> ()</td></tr>
<tr class="separator:a5f723f324b1c7c22941f33034b652eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0278fa22a587e65fe73102baa4e3336"><td class="memItemLeft" align="right" valign="top">std::vector&lt; NumberType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#ae0278fa22a587e65fe73102baa4e3336">eigenpairs_symmetric_by_index</a> (const std::pair&lt; unsigned int, unsigned int &gt; &amp;index_limits, const <a class="el" href="classbool.html">bool</a> compute_eigenvectors)</td></tr>
<tr class="separator:ae0278fa22a587e65fe73102baa4e3336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05736f2044c74db48f53067f46ed4c75"><td class="memItemLeft" align="right" valign="top">std::vector&lt; NumberType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a05736f2044c74db48f53067f46ed4c75">eigenpairs_symmetric_by_value</a> (const std::pair&lt; NumberType, NumberType &gt; &amp;value_limits, const <a class="el" href="classbool.html">bool</a> compute_eigenvectors)</td></tr>
<tr class="separator:a05736f2044c74db48f53067f46ed4c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf56a3d220794a7c0e0839a1f44ff539"><td class="memItemLeft" align="right" valign="top">std::vector&lt; NumberType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#acf56a3d220794a7c0e0839a1f44ff539">eigenpairs_symmetric_by_index_MRRR</a> (const std::pair&lt; unsigned int, unsigned int &gt; &amp;index_limits, const <a class="el" href="classbool.html">bool</a> compute_eigenvectors)</td></tr>
<tr class="separator:acf56a3d220794a7c0e0839a1f44ff539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a53f1e6c1fce2ca93b718f34d215ae9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; NumberType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a0a53f1e6c1fce2ca93b718f34d215ae9">eigenpairs_symmetric_by_value_MRRR</a> (const std::pair&lt; NumberType, NumberType &gt; &amp;value_limits, const <a class="el" href="classbool.html">bool</a> compute_eigenvectors)</td></tr>
<tr class="separator:a0a53f1e6c1fce2ca93b718f34d215ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04feb5d5c22d71a40c6912ec8f0ee2f9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; NumberType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a04feb5d5c22d71a40c6912ec8f0ee2f9">compute_SVD</a> (<a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; *U=nullptr, <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; *VT=nullptr)</td></tr>
<tr class="separator:a04feb5d5c22d71a40c6912ec8f0ee2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f528e743bbb29f0608960eb420c102"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a23f528e743bbb29f0608960eb420c102">least_squares</a> (<a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;B, const <a class="el" href="classbool.html">bool</a> <a class="el" href="tensor_8h.html#a2991e0d54a5ae64c50fe9573570c5fcd">transpose</a>=false)</td></tr>
<tr class="separator:a23f528e743bbb29f0608960eb420c102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a17919a2ff3b9c8dc1f76beca7f57b4"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a0a17919a2ff3b9c8dc1f76beca7f57b4">pseudoinverse</a> (const NumberType ratio)</td></tr>
<tr class="separator:a0a17919a2ff3b9c8dc1f76beca7f57b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c472d23a551bbbdfbfcfee4f5bbe51"><td class="memItemLeft" align="right" valign="top">NumberType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#ad8c472d23a551bbbdfbfcfee4f5bbe51">reciprocal_condition_number</a> (const NumberType a_norm) const</td></tr>
<tr class="separator:ad8c472d23a551bbbdfbfcfee4f5bbe51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fae8f6bbe61900874e495b566059ed9"><td class="memItemLeft" align="right" valign="top">NumberType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a9fae8f6bbe61900874e495b566059ed9">l1_norm</a> () const</td></tr>
<tr class="separator:a9fae8f6bbe61900874e495b566059ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08bd68181f1690263ca241568a65e6e"><td class="memItemLeft" align="right" valign="top">NumberType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#af08bd68181f1690263ca241568a65e6e">linfty_norm</a> () const</td></tr>
<tr class="separator:af08bd68181f1690263ca241568a65e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c248dd3d7474ad88f01f361fb38763"><td class="memItemLeft" align="right" valign="top">NumberType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a08c248dd3d7474ad88f01f361fb38763">frobenius_norm</a> () const</td></tr>
<tr class="separator:a08c248dd3d7474ad88f01f361fb38763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec0701c49ab60d28960cdb34ce475ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#acec0701c49ab60d28960cdb34ce475ba">m</a> () const</td></tr>
<tr class="separator:acec0701c49ab60d28960cdb34ce475ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46bc94233591ea03adec9fb95dae9e16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a46bc94233591ea03adec9fb95dae9e16">n</a> () const</td></tr>
<tr class="separator:a46bc94233591ea03adec9fb95dae9e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3afe5deb2fe2726ee5451f9c76e0646"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#ae3afe5deb2fe2726ee5451f9c76e0646">local_m</a> () const</td></tr>
<tr class="separator:ae3afe5deb2fe2726ee5451f9c76e0646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0597c0f46ca4dd7477c1c83a98f38f11"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a0597c0f46ca4dd7477c1c83a98f38f11">local_n</a> () const</td></tr>
<tr class="separator:a0597c0f46ca4dd7477c1c83a98f38f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c72bf2945cab1cd8050371520629ed"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#ae2c72bf2945cab1cd8050371520629ed">global_row</a> (const unsigned int loc_row) const</td></tr>
<tr class="separator:ae2c72bf2945cab1cd8050371520629ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10eacb6dbdb705df9683564f03ee525"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#ae10eacb6dbdb705df9683564f03ee525">global_column</a> (const unsigned int loc_column) const</td></tr>
<tr class="separator:ae10eacb6dbdb705df9683564f03ee525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2420eec8cfc46561b26ed7d14916215b"><td class="memItemLeft" align="right" valign="top">NumberType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a2420eec8cfc46561b26ed7d14916215b">local_el</a> (const unsigned int loc_row, const unsigned int loc_column) const</td></tr>
<tr class="separator:a2420eec8cfc46561b26ed7d14916215b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0536e2cdf182c4cb3e4120960a1e805e"><td class="memItemLeft" align="right" valign="top">NumberType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a0536e2cdf182c4cb3e4120960a1e805e">local_el</a> (const unsigned int loc_row, const unsigned int loc_column)</td></tr>
<tr class="separator:a0536e2cdf182c4cb3e4120960a1e805e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6819321d6f65302155b6b7e2be70988"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:af6819321d6f65302155b6b7e2be70988"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#af6819321d6f65302155b6b7e2be70988">scale_columns</a> (const InputVector &amp;factors)</td></tr>
<tr class="separator:af6819321d6f65302155b6b7e2be70988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64013567ad63bbc2cee395c1b01fdb3b"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a64013567ad63bbc2cee395c1b01fdb3b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a64013567ad63bbc2cee395c1b01fdb3b">scale_rows</a> (const InputVector &amp;factors)</td></tr>
<tr class="separator:a64013567ad63bbc2cee395c1b01fdb3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:ac4b757c21de2da52da2dea3c98d61298"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransposeTable.html#ac4b757c21de2da52da2dea3c98d61298">value_type</a> = typename <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; NumberType &gt;::<a class="el" href="classTableBase.html#a91dbd84881f529bc6e026fb7dccd8a14">value_type</a></td></tr>
<tr class="separator:ac4b757c21de2da52da2dea3c98d61298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3cc546896667528a5514bcdb704ef4e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransposeTable.html#aa3cc546896667528a5514bcdb704ef4e">reference</a> = typename <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; NumberType &gt;::<a class="el" href="classTransposeTable.html#aa3cc546896667528a5514bcdb704ef4e">reference</a></td></tr>
<tr class="separator:aa3cc546896667528a5514bcdb704ef4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af443131e24234cb6ca5cb03b88c8d763"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransposeTable.html#af443131e24234cb6ca5cb03b88c8d763">const_reference</a> = typename <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; NumberType &gt;::<a class="el" href="classTransposeTable.html#af443131e24234cb6ca5cb03b88c8d763">const_reference</a></td></tr>
<tr class="separator:af443131e24234cb6ca5cb03b88c8d763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6123c6adf12bb6e59cd9fa440008fb1c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransposeTable.html#a6123c6adf12bb6e59cd9fa440008fb1c">const_iterator</a> = <a class="el" href="classMatrixTableIterators_1_1Iterator.html">MatrixTableIterators::Iterator</a>&lt; <a class="el" href="classTransposeTable.html">TransposeTable</a>&lt; NumberType &gt;, true, <a class="el" href="namespaceMatrixTableIterators.html#a071affcab0c2e4302df96f2d1540bd08a8c23f260f0ec1479d3bfaf3a1305a347">MatrixTableIterators::Storage::column_major</a> &gt;</td></tr>
<tr class="separator:a6123c6adf12bb6e59cd9fa440008fb1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38906966a208171e373d9568bdefed95"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransposeTable.html#a38906966a208171e373d9568bdefed95">iterator</a> = <a class="el" href="classMatrixTableIterators_1_1Iterator.html">MatrixTableIterators::Iterator</a>&lt; <a class="el" href="classTransposeTable.html">TransposeTable</a>&lt; NumberType &gt;, false, <a class="el" href="namespaceMatrixTableIterators.html#a071affcab0c2e4302df96f2d1540bd08a8c23f260f0ec1479d3bfaf3a1305a347">MatrixTableIterators::Storage::column_major</a> &gt;</td></tr>
<tr class="separator:a38906966a208171e373d9568bdefed95"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a1850f8cb99a54fe25506a8ff39418aaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransposeTable.html#a1850f8cb99a54fe25506a8ff39418aaf">reinit</a> (const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a> size1, const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a> size2, const <a class="el" href="classbool.html">bool</a> omit_default_initialization=false)</td></tr>
<tr class="separator:a1850f8cb99a54fe25506a8ff39418aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302ef67031a523602fd39911b968d6ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a302ef67031a523602fd39911b968d6ab">reinit</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;new_size, const <a class="el" href="classbool.html">bool</a> omit_default_initialization=false)</td></tr>
<tr class="separator:a302ef67031a523602fd39911b968d6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36b71ef45ac64e732975643771134a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTransposeTable.html#af443131e24234cb6ca5cb03b88c8d763">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransposeTable.html#ac36b71ef45ac64e732975643771134a2">operator()</a> (const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a> i, const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a> j) const</td></tr>
<tr class="separator:ac36b71ef45ac64e732975643771134a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeced6fe416efbe7f8c3ff50ad2cd7245"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTransposeTable.html#aa3cc546896667528a5514bcdb704ef4e">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransposeTable.html#aeced6fe416efbe7f8c3ff50ad2cd7245">operator()</a> (const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a> i, const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a> j)</td></tr>
<tr class="separator:aeced6fe416efbe7f8c3ff50ad2cd7245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b90cda631253866e0f2fa02d714e6b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::<a class="el" href="classTransposeTable.html#aa3cc546896667528a5514bcdb704ef4e">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a2b90cda631253866e0f2fa02d714e6b0">operator()</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;indices)</td></tr>
<tr class="separator:a2b90cda631253866e0f2fa02d714e6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2966017e02f461809ff90eb8f4c86ed3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::<a class="el" href="classTransposeTable.html#af443131e24234cb6ca5cb03b88c8d763">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a2966017e02f461809ff90eb8f4c86ed3">operator()</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;indices) const</td></tr>
<tr class="separator:a2966017e02f461809ff90eb8f4c86ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f8dcd60a406d43ba78269a96895fd90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransposeTable.html#a3f8dcd60a406d43ba78269a96895fd90">n_rows</a> () const</td></tr>
<tr class="separator:a3f8dcd60a406d43ba78269a96895fd90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a36ba83d9e425c774ea2362ac8996e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransposeTable.html#a4a36ba83d9e425c774ea2362ac8996e9">n_cols</a> () const</td></tr>
<tr class="separator:a4a36ba83d9e425c774ea2362ac8996e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14a7ea5713f7d7a721847f129e6649c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTransposeTable.html#a38906966a208171e373d9568bdefed95">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransposeTable.html#ac14a7ea5713f7d7a721847f129e6649c">begin</a> ()</td></tr>
<tr class="separator:ac14a7ea5713f7d7a721847f129e6649c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486413d5db2c89c75329251fc5ca497a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTransposeTable.html#a6123c6adf12bb6e59cd9fa440008fb1c">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransposeTable.html#a486413d5db2c89c75329251fc5ca497a">begin</a> () const</td></tr>
<tr class="separator:a486413d5db2c89c75329251fc5ca497a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30d26e173c56cc8bdda7e08760e7e2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTransposeTable.html#a38906966a208171e373d9568bdefed95">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransposeTable.html#aa30d26e173c56cc8bdda7e08760e7e2c">end</a> ()</td></tr>
<tr class="separator:aa30d26e173c56cc8bdda7e08760e7e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b32a0c0c89c83ad3dc59d5bd6fdf1fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTransposeTable.html#a6123c6adf12bb6e59cd9fa440008fb1c">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransposeTable.html#a8b32a0c0c89c83ad3dc59d5bd6fdf1fd">end</a> () const</td></tr>
<tr class="separator:a8b32a0c0c89c83ad3dc59d5bd6fdf1fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416b65cdf6d47a5f7b55f9cb34addf05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTransposeTable.html#aa3cc546896667528a5514bcdb704ef4e">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransposeTable.html#a416b65cdf6d47a5f7b55f9cb34addf05">el</a> (const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a> i, const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a> j)</td></tr>
<tr class="separator:a416b65cdf6d47a5f7b55f9cb34addf05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f84b2757aeb5618651eaec8864f2b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTransposeTable.html#af443131e24234cb6ca5cb03b88c8d763">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransposeTable.html#ad0f84b2757aeb5618651eaec8864f2b8">el</a> (const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a> i, const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a> j) const</td></tr>
<tr class="separator:ad0f84b2757aeb5618651eaec8864f2b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4474b545894de5a80f3fdacb9ead38c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::<a class="el" href="classTransposeTable.html#aa3cc546896667528a5514bcdb704ef4e">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#ad4474b545894de5a80f3fdacb9ead38c">el</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;indices)</td></tr>
<tr class="separator:ad4474b545894de5a80f3fdacb9ead38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a9979fda00a9293c3fa6a6df97639e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::<a class="el" href="classTransposeTable.html#af443131e24234cb6ca5cb03b88c8d763">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a40a9979fda00a9293c3fa6a6df97639e">el</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;indices) const</td></tr>
<tr class="separator:a40a9979fda00a9293c3fa6a6df97639e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa998401367252589f5a4bdd7d8087380"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#aa998401367252589f5a4bdd7d8087380">operator==</a> (const <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt; &amp;T2) const</td></tr>
<tr class="separator:aa998401367252589f5a4bdd7d8087380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e75a7ccd3359dccbddc0934bc1bf27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#af0e75a7ccd3359dccbddc0934bc1bf27">reset_values</a> ()</td></tr>
<tr class="separator:af0e75a7ccd3359dccbddc0934bc1bf27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2204c132154b5d6bfd571eb85d8a58f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#af2204c132154b5d6bfd571eb85d8a58f">size</a> (const unsigned int i) const</td></tr>
<tr class="separator:af2204c132154b5d6bfd571eb85d8a58f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba8a3da6e403297e8d2b231e9d6c35f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#aaba8a3da6e403297e8d2b231e9d6c35f">size</a> () const</td></tr>
<tr class="separator:aaba8a3da6e403297e8d2b231e9d6c35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67161f19c760e98588bdecc560285d2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a67161f19c760e98588bdecc560285d2d">n_elements</a> () const</td></tr>
<tr class="separator:a67161f19c760e98588bdecc560285d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb7b890ac4bbcba1b6524b45af1cbfd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#abb7b890ac4bbcba1b6524b45af1cbfd9">empty</a> () const</td></tr>
<tr class="separator:abb7b890ac4bbcba1b6524b45af1cbfd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad54a19dddbed32640b977b4d7948b434"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:ad54a19dddbed32640b977b4d7948b434"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTableBase.html#ad54a19dddbed32640b977b4d7948b434">fill</a> (InputIterator entries, const <a class="el" href="classbool.html">bool</a> C_style_indexing=true)</td></tr>
<tr class="separator:ad54a19dddbed32640b977b4d7948b434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a0d148a657080f22dc7c4f213c5a8ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a2a0d148a657080f22dc7c4f213c5a8ee">fill</a> (const T &amp;value)</td></tr>
<tr class="separator:a2a0d148a657080f22dc7c4f213c5a8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140815b9435c997be48f439634afc4f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a140815b9435c997be48f439634afc4f5">swap</a> (<a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt; &amp;v)</td></tr>
<tr class="separator:a140815b9435c997be48f439634afc4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c63db9ae49e0e3b099f0244801016f2"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a2c63db9ae49e0e3b099f0244801016f2">memory_consumption</a> () const</td></tr>
<tr class="separator:a2c63db9ae49e0e3b099f0244801016f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee01f8890040d7b480fc0c72e19f6711"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:aee01f8890040d7b480fc0c72e19f6711"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTableBase.html#aee01f8890040d7b480fc0c72e19f6711">serialize</a> (Archive &amp;ar, const unsigned int version)</td></tr>
<tr class="separator:aee01f8890040d7b480fc0c72e19f6711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8546237d4c76440bfaed5e1818cdd90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#ab8546237d4c76440bfaed5e1818cdd90">position</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;indices) const</td></tr>
<tr class="separator:ab8546237d4c76440bfaed5e1818cdd90"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a50beea2748a06b3abb8d65d5fe7aa8aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a50beea2748a06b3abb8d65d5fe7aa8aa">values</a></td></tr>
<tr class="separator:a50beea2748a06b3abb8d65d5fe7aa8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33df922c5081e1b69e73027cacdaa95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#af33df922c5081e1b69e73027cacdaa95">table_size</a></td></tr>
<tr class="separator:af33df922c5081e1b69e73027cacdaa95"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aa41a2ed7e7d97d1bab0742f8dd4f48b5"><td class="memItemLeft" align="right" valign="top">NumberType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#aa41a2ed7e7d97d1bab0742f8dd4f48b5">norm_symmetric</a> (const char type) const</td></tr>
<tr class="separator:aa41a2ed7e7d97d1bab0742f8dd4f48b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9e68ebdb81c95dc91a5cadc2d8d44e"><td class="memItemLeft" align="right" valign="top">NumberType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a8c9e68ebdb81c95dc91a5cadc2d8d44e">norm_general</a> (const char type) const</td></tr>
<tr class="separator:a8c9e68ebdb81c95dc91a5cadc2d8d44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84115bec54d73663a31d714e1a17c82c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; NumberType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a84115bec54d73663a31d714e1a17c82c">eigenpairs_symmetric</a> (const <a class="el" href="classbool.html">bool</a> compute_eigenvectors, const std::pair&lt; unsigned int, unsigned int &gt; &amp;index_limits=std::make_pair(<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>, <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>), const std::pair&lt; NumberType, NumberType &gt; &amp;value_limits=std::make_pair(std::numeric_limits&lt; NumberType &gt;::quiet_NaN(), std::numeric_limits&lt; NumberType &gt;::quiet_NaN()))</td></tr>
<tr class="separator:a84115bec54d73663a31d714e1a17c82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a20ea915118b8b2b149e3d4af10a5e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; NumberType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a56a20ea915118b8b2b149e3d4af10a5e">eigenpairs_symmetric_MRRR</a> (const <a class="el" href="classbool.html">bool</a> compute_eigenvectors, const std::pair&lt; unsigned int, unsigned int &gt; &amp;index_limits=std::make_pair(<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>, <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>), const std::pair&lt; NumberType, NumberType &gt; &amp;value_limits=std::make_pair(std::numeric_limits&lt; NumberType &gt;::quiet_NaN(), std::numeric_limits&lt; NumberType &gt;::quiet_NaN()))</td></tr>
<tr class="separator:a56a20ea915118b8b2b149e3d4af10a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86231732a54f89df92e15ec186d46e82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a86231732a54f89df92e15ec186d46e82">save_serial</a> (const std::string &amp;filename, const std::pair&lt; unsigned int, unsigned int &gt; &amp;chunk_size) const</td></tr>
<tr class="separator:a86231732a54f89df92e15ec186d46e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78850bc990c4f8de2270176a95b177a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#ac78850bc990c4f8de2270176a95b177a">load_serial</a> (const std::string &amp;filename)</td></tr>
<tr class="separator:ac78850bc990c4f8de2270176a95b177a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9a16cb5cdeb15f4ef1a18a3415dce2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a1c9a16cb5cdeb15f4ef1a18a3415dce2">save_parallel</a> (const std::string &amp;filename, const std::pair&lt; unsigned int, unsigned int &gt; &amp;chunk_size) const</td></tr>
<tr class="separator:a1c9a16cb5cdeb15f4ef1a18a3415dce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a12de09785d8b7be4f95e7a6f9fb06a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a9a12de09785d8b7be4f95e7a6f9fb06a">load_parallel</a> (const std::string &amp;filename)</td></tr>
<tr class="separator:a9a12de09785d8b7be4f95e7a6f9fb06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:adc8bcecff39fec4dda83ee72279081d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638">LAPACKSupport::State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#adc8bcecff39fec4dda83ee72279081d3">state</a></td></tr>
<tr class="separator:adc8bcecff39fec4dda83ee72279081d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae1c9ee4a7967975a161bc336d24a173"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceLAPACKSupport.html#a45557450a3c1ae0e74d7ddf12c43bc98">LAPACKSupport::Property</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#aae1c9ee4a7967975a161bc336d24a173">property</a></td></tr>
<tr class="separator:aae1c9ee4a7967975a161bc336d24a173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8799d4b9b8cad88f6af9dbafbb6bb2"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1ProcessGrid.html">Utilities::MPI::ProcessGrid</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a6d8799d4b9b8cad88f6af9dbafbb6bb2">grid</a></td></tr>
<tr class="separator:a6d8799d4b9b8cad88f6af9dbafbb6bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bdb8189d7e88a60291430a2945e8bc3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a2bdb8189d7e88a60291430a2945e8bc3">n_rows</a></td></tr>
<tr class="separator:a2bdb8189d7e88a60291430a2945e8bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa802e135eb0b2b5fb07636b3ad20e123"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#aa802e135eb0b2b5fb07636b3ad20e123">n_columns</a></td></tr>
<tr class="separator:aa802e135eb0b2b5fb07636b3ad20e123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10d04b6961bffb230a58f658ddb7d5d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#af10d04b6961bffb230a58f658ddb7d5d">row_block_size</a></td></tr>
<tr class="separator:af10d04b6961bffb230a58f658ddb7d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5286111f1e05e8019b36933eef6a55aa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a5286111f1e05e8019b36933eef6a55aa">column_block_size</a></td></tr>
<tr class="separator:a5286111f1e05e8019b36933eef6a55aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aeb43089505bb7b32477271cc76312e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a2aeb43089505bb7b32477271cc76312e">n_local_rows</a></td></tr>
<tr class="separator:a2aeb43089505bb7b32477271cc76312e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b34cedd3940060edbe3ce4aeec09903"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a4b34cedd3940060edbe3ce4aeec09903">n_local_columns</a></td></tr>
<tr class="separator:a4b34cedd3940060edbe3ce4aeec09903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0337ee06e1bf8c56ea28d92c290b9b65"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a0337ee06e1bf8c56ea28d92c290b9b65">descriptor</a> [9]</td></tr>
<tr class="separator:a0337ee06e1bf8c56ea28d92c290b9b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9713119f9eb1f2bac9d66cfc8bad2265"><td class="memItemLeft" align="right" valign="top">std::vector&lt; NumberType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a9713119f9eb1f2bac9d66cfc8bad2265">work</a></td></tr>
<tr class="separator:a9713119f9eb1f2bac9d66cfc8bad2265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e4719dedb862973b5a7e5b94241b32"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a40e4719dedb862973b5a7e5b94241b32">iwork</a></td></tr>
<tr class="separator:a40e4719dedb862973b5a7e5b94241b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ba99b7ee9d41099239aab8c912007e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#ad6ba99b7ee9d41099239aab8c912007e">ipiv</a></td></tr>
<tr class="separator:ad6ba99b7ee9d41099239aab8c912007e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54c16e73ab356c8577d13afeec841c3"><td class="memItemLeft" align="right" valign="top">const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#aa54c16e73ab356c8577d13afeec841c3">uplo</a></td></tr>
<tr class="separator:aa54c16e73ab356c8577d13afeec841c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b66eb11a9e96f925692a930bf98f8d6"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a6b66eb11a9e96f925692a930bf98f8d6">first_process_row</a></td></tr>
<tr class="separator:a6b66eb11a9e96f925692a930bf98f8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e893b58c1079c78ee094f8107f7ce4"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a15e893b58c1079c78ee094f8107f7ce4">first_process_column</a></td></tr>
<tr class="separator:a15e893b58c1079c78ee094f8107f7ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801e8b7f84711c97d732019ca9ddce50"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a801e8b7f84711c97d732019ca9ddce50">submatrix_row</a></td></tr>
<tr class="separator:a801e8b7f84711c97d732019ca9ddce50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784802959d4846fc5f2fd329ea8c66d5"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#a784802959d4846fc5f2fd329ea8c66d5">submatrix_column</a></td></tr>
<tr class="separator:a784802959d4846fc5f2fd329ea8c66d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee5b765105669677bd7e5a5944c6b27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classThreads_1_1Mutex.html">Threads::Mutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScaLAPACKMatrix.html#adee5b765105669677bd7e5a5944c6b27">mutex</a></td></tr>
<tr class="separator:adee5b765105669677bd7e5a5944c6b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Subscriptor functionality</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp8d6bc922eebec0b76272099aee4a220d"></a>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</td></tr>
<tr class="memitem:ga20658b60d6ef2d530fafa076efa9f503"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga20658b60d6ef2d530fafa076efa9f503">counter</a></td></tr>
<tr class="separator:ga20658b60d6ef2d530fafa076efa9f503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73f9f8936b61e6e17ab2a82e9516e95b"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga73f9f8936b61e6e17ab2a82e9516e95b">counter_map</a></td></tr>
<tr class="separator:ga73f9f8936b61e6e17ab2a82e9516e95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga094d5932c6c004c2a2b1b966950fb2f7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga094d5932c6c004c2a2b1b966950fb2f7">validity_pointers</a></td></tr>
<tr class="separator:ga094d5932c6c004c2a2b1b966950fb2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44e13f7984b31af8d7c54921175a75ff"><td class="memItemLeft" align="right" valign="top">const std::type_info *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga44e13f7984b31af8d7c54921175a75ff">object_info</a></td></tr>
<tr class="separator:ga44e13f7984b31af8d7c54921175a75ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga300c593ea0f9422dcbce1445903e6c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga300c593ea0f9422dcbce1445903e6c12">check_no_subscribers</a> () const noexcept</td></tr>
<tr class="separator:ga300c593ea0f9422dcbce1445903e6c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaeb9ac67567aa7d837f25debd33cd4ce5">map_value_type</a> = decltype(<a class="el" href="group__Exceptions.html#ga73f9f8936b61e6e17ab2a82e9516e95b">counter_map</a>)::<a class="el" href="classTableBase.html#a91dbd84881f529bc6e026fb7dccd8a14">value_type</a></td></tr>
<tr class="separator:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacebdc2d11f8522e4d9e8b7d73ac3f491">map_iterator</a> = decltype(<a class="el" href="group__Exceptions.html#ga73f9f8936b61e6e17ab2a82e9516e95b">counter_map</a>)::<a class="el" href="classTransposeTable.html#a38906966a208171e373d9568bdefed95">iterator</a></td></tr>
<tr class="separator:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (int arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename NumberType&gt;<br />
class ScaLAPACKMatrix&lt; NumberType &gt;</h3>

<p>A wrapper class around ScaLAPACK parallel dense linear algebra.</p>
<p>ScaLAPACK assumes that matrices are distributed according to the block-cyclic decomposition scheme. An \(M\) by \(N\) matrix is first decomposed into \(\lceil M / MB \rceil\) by \(\lceil N / NB \rceil\) blocks which are then uniformly distributed across the 2D process grid with \(p q \le Np\) processes, where \(p,q\) are grid dimensions and \(Np\) is the total number of processes. The parameters MB and NB are referred to as row and column block size and determine the granularity of the block-cyclic distribution.</p>
<p>In the following the block-cyclic distribution of a \(10 \times 9\) matrix onto a \(3\times 3\) Cartesian process grid with block sizes \(\text{MB}=\text{NB}=2\) is displayed.</p>
<p> <style>div.image
img[src="scalapack_block_cycling.png"]{width:35%;}</style>
 </p><div class="image">
<img src="scalapack_block_cycling.png" alt=""/>
<div class="caption">
Block-Cyclic Distribution</div></div>
<p>Note that the odd number of columns of the local matrices owned by the processes P2, P5 and P8 accounts for \(N=9\) not being an integral multiple of \(\text{NB}=2\).</p>
<p>The choice of the block sizes is a compromise between a sufficiently large size for efficient local/serial BLAS, but one that is also small enough to achieve good parallel load balance.</p>
<p>Below we show a strong scaling example of <a class="el" href="classScaLAPACKMatrix.html#a5f723f324b1c7c22941f33034b652eec">ScaLAPACKMatrix::invert()</a> on up to 5 nodes each composed of two Intel Xeon 2660v2 IvyBridge sockets 2.20GHz, 10 cores/socket. Calculations are performed on square processor grids 1x1, 2x2, 3x3, 4x4, 5x5, 6x6, 7x7, 8x8, 9x9, 10x10.</p>
<div class="image">
<img src="scalapack_invert.png" alt=""/>
</div>
 
<p class="definition">Definition at line <a class="el" href="scalapack_8h_source.html#l00076">76</a> of file <a class="el" href="scalapack_8h_source.html">scalapack.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a432e6f19e0ba55f12031a1a68fa7ab17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a432e6f19e0ba55f12031a1a68fa7ab17">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::<a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a> =  unsigned int</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare the type for container size. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8h_source.html#l00082">82</a> of file <a class="el" href="scalapack_8h_source.html">scalapack.h</a>.</p>

</div>
</div>
<a id="ac4b757c21de2da52da2dea3c98d61298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4b757c21de2da52da2dea3c98d61298">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTransposeTable.html">TransposeTable</a>&lt; NumberType  &gt;::<a class="el" href="classTableBase.html#a91dbd84881f529bc6e026fb7dccd8a14">value_type</a> =  typename <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;NumberType &gt;::<a class="el" href="classTableBase.html#a91dbd84881f529bc6e026fb7dccd8a14">value_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Typedef for the values in the table. </p>

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l01884">1884</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<a id="aa3cc546896667528a5514bcdb704ef4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3cc546896667528a5514bcdb704ef4e">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTransposeTable.html">TransposeTable</a>&lt; NumberType  &gt;::<a class="el" href="classTransposeTable.html#aa3cc546896667528a5514bcdb704ef4e">reference</a> =  typename <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;NumberType &gt;::<a class="el" href="classTransposeTable.html#aa3cc546896667528a5514bcdb704ef4e">reference</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Typedef for the references in the table. </p>

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l01889">1889</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<a id="af443131e24234cb6ca5cb03b88c8d763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af443131e24234cb6ca5cb03b88c8d763">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTransposeTable.html">TransposeTable</a>&lt; NumberType  &gt;::<a class="el" href="classTransposeTable.html#af443131e24234cb6ca5cb03b88c8d763">const_reference</a> =  typename <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;NumberType &gt;::<a class="el" href="classTransposeTable.html#af443131e24234cb6ca5cb03b88c8d763">const_reference</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Typedef for the constant references in the table. </p>

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l01894">1894</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<a id="a6123c6adf12bb6e59cd9fa440008fb1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6123c6adf12bb6e59cd9fa440008fb1c">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTransposeTable.html">TransposeTable</a>&lt; NumberType  &gt;::<a class="el" href="classTransposeTable.html#a6123c6adf12bb6e59cd9fa440008fb1c">const_iterator</a> =  <a class="el" href="classMatrixTableIterators_1_1Iterator.html">MatrixTableIterators::Iterator</a>&lt;<a class="el" href="classTransposeTable.html">TransposeTable</a>&lt;NumberType &gt;, true, <a class="el" href="namespaceMatrixTableIterators.html#a071affcab0c2e4302df96f2d1540bd08a8c23f260f0ec1479d3bfaf3a1305a347">MatrixTableIterators::Storage::column_major</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Typedef for a constant iterator that traverses the table in column-major order. </p>

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l01900">1900</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<a id="a38906966a208171e373d9568bdefed95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38906966a208171e373d9568bdefed95">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTransposeTable.html">TransposeTable</a>&lt; NumberType  &gt;::<a class="el" href="classTransposeTable.html#a38906966a208171e373d9568bdefed95">iterator</a> =  <a class="el" href="classMatrixTableIterators_1_1Iterator.html">MatrixTableIterators::Iterator</a>&lt;<a class="el" href="classTransposeTable.html">TransposeTable</a>&lt;NumberType &gt;, false, <a class="el" href="namespaceMatrixTableIterators.html#a071affcab0c2e4302df96f2d1540bd08a8c23f260f0ec1479d3bfaf3a1305a347">MatrixTableIterators::Storage::column_major</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Typedef for an iterator that traverses the table in column-major order. </p>

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l01908">1908</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a711503af730f169914268d2e307aa0ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a711503af730f169914268d2e307aa0ab">&#9670;&nbsp;</a></span>ScaLAPACKMatrix() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::<a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a>&#160;</td>
          <td class="paramname"><em>n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a>&#160;</td>
          <td class="paramname"><em>n_columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1ProcessGrid.html">Utilities::MPI::ProcessGrid</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>process_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a>&#160;</td>
          <td class="paramname"><em>row_block_size</em> = <code>32</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a>&#160;</td>
          <td class="paramname"><em>column_block_size</em> = <code>32</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceLAPACKSupport.html#a45557450a3c1ae0e74d7ddf12c43bc98">LAPACKSupport::Property</a>&#160;</td>
          <td class="paramname"><em>property</em> = <code>LAPACKSupport::Property::general</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for a rectangular matrix with <code>n_rows</code> and <code>n_cols</code> and distributed using the grid <code>process_grid</code>.</p>
<p>The parameters <code>row_block_size</code> and <code>column_block_size</code> are the block sizes used for the block-cyclic distribution of the matrix. In general, it is recommended to use powers of \(2\), e.g. \(16,32,64, \dots\). </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l00080">80</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="ac18a3b69bbaf7bd48147f87218a8afd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac18a3b69bbaf7bd48147f87218a8afd4">&#9670;&nbsp;</a></span>ScaLAPACKMatrix() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::<a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1ProcessGrid.html">Utilities::MPI::ProcessGrid</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>process_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a>&#160;</td>
          <td class="paramname"><em>block_size</em> = <code>32</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceLAPACKSupport.html#a45557450a3c1ae0e74d7ddf12c43bc98">LAPACKSupport::Property</a>&#160;</td>
          <td class="paramname"><em>property</em> = <code>LAPACKSupport::Property::symmetric</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for a square matrix of size <code>size</code>, and distributed using the process grid in <code>process_grid</code>.</p>
<p>The parameter <code>block_size</code> is used for the block-cyclic distribution of the matrix. An identical block size is used for the rows and columns of the matrix. In general, it is recommended to use powers of \(2\), e.g. \(16,32,64, \dots\). </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l00105">105</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="a861b3d89915ca829cb3248f5da9d8e8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861b3d89915ca829cb3248f5da9d8e8b">&#9670;&nbsp;</a></span>ScaLAPACKMatrix() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::<a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1ProcessGrid.html">Utilities::MPI::ProcessGrid</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>process_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a>&#160;</td>
          <td class="paramname"><em>row_block_size</em> = <code>32</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a>&#160;</td>
          <td class="paramname"><em>column_block_size</em> = <code>32</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for a general rectangular matrix that is read from the file <code>filename</code> and distributed using the grid <code>process_grid</code>.</p>
<p>Loads the matrix from file <code>filename</code> using <a class="el" href="namespaceHDF5.html">HDF5</a>. In case that deal.II was built without <a class="el" href="namespaceHDF5.html">HDF5</a> a call to this function will cause an exception to be thrown.</p>
<p>The parameters <code>row_block_size</code> and <code>column_block_size</code> are the block sizes used for the block-cyclic distribution of the matrix. In general, it is recommended to use powers of \(2\), e.g. \(16,32,64, \dots\). </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l00121">121</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="a8e37a511442824aca1ffc090f1071d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e37a511442824aca1ffc090f1071d6a">&#9670;&nbsp;</a></span>~ScaLAPACKMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::~<a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab755a374266785648ae364b6d78f6c94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab755a374266785648ae364b6d78f6c94">&#9670;&nbsp;</a></span>reinit() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a>&#160;</td>
          <td class="paramname"><em>n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a>&#160;</td>
          <td class="paramname"><em>n_columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1ProcessGrid.html">Utilities::MPI::ProcessGrid</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>process_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a>&#160;</td>
          <td class="paramname"><em>row_block_size</em> = <code>32</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a>&#160;</td>
          <td class="paramname"><em>column_block_size</em> = <code>32</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceLAPACKSupport.html#a45557450a3c1ae0e74d7ddf12c43bc98">LAPACKSupport::Property</a>&#160;</td>
          <td class="paramname"><em>property</em> = <code>LAPACKSupport::Property::general</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the rectangular matrix with <code>n_rows</code> and <code>n_cols</code> and distributed using the grid <code>process_grid</code>.</p>
<p>The parameters <code>row_block_size</code> and <code>column_block_size</code> are the block sizes used for the block-cyclic distribution of the matrix. In general, it is recommended to use powers of \(2\), e.g. \(16,32,64, \dots\). </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l00216">216</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="a7ab9ec110b225e4aa3b88ce83ff7bbcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ab9ec110b225e4aa3b88ce83ff7bbcd">&#9670;&nbsp;</a></span>reinit() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1ProcessGrid.html">Utilities::MPI::ProcessGrid</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>process_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a>&#160;</td>
          <td class="paramname"><em>block_size</em> = <code>32</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceLAPACKSupport.html#a45557450a3c1ae0e74d7ddf12c43bc98">LAPACKSupport::Property</a>&#160;</td>
          <td class="paramname"><em>property</em> = <code>LAPACKSupport::Property::symmetric</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the square matrix of size <code>size</code> and distributed using the grid <code>process_grid</code>.</p>
<p>The parameter <code>block_size</code> is used for the block-cyclic distribution of the matrix. An identical block size is used for the rows and columns of the matrix. In general, it is recommended to use powers of \(2\), e.g. \(16,32,64, \dots\). </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l00290">290</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="ab1a0999bd5c5d5a519ae09bb1b1f6ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1a0999bd5c5d5a519ae09bb1b1f6ddd">&#9670;&nbsp;</a></span>set_property()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::set_property </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceLAPACKSupport.html#a45557450a3c1ae0e74d7ddf12c43bc98">LAPACKSupport::Property</a>&#160;</td>
          <td class="paramname"><em>property</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assign <code>property</code> to this matrix. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l00303">303</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="a4dcde64aa5131d2a997b7221132cbf5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dcde64aa5131d2a997b7221132cbf5d">&#9670;&nbsp;</a></span>get_property()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceLAPACKSupport.html#a45557450a3c1ae0e74d7ddf12c43bc98">LAPACKSupport::Property</a> <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::get_property</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return current <code>property</code> of this matrix </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l00313">313</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="a49f5b93c67c0f8851fd29ed89e4220cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f5b93c67c0f8851fd29ed89e4220cd">&#9670;&nbsp;</a></span>get_state()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638">LAPACKSupport::State</a> <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::get_state</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return current <code>state</code> of this matrix </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l00322">322</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="a2d424dbb47f6c4ce6d554677c53c1570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d424dbb47f6c4ce6d554677c53c1570">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp; <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; NumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment operator from a regular <a class="el" href="classFullMatrix.html">FullMatrix</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function should only be used for relatively small matrix dimensions. It is primarily intended for debugging purposes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l00331">331</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="a1bb57a0f97778b451507ee32233571d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb57a0f97778b451507ee32233571d4">&#9670;&nbsp;</a></span>copy_from()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrix.html">LAPACKFullMatrix</a>&lt; NumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the content of the locally owned <code>matrix</code> to the distributed matrix. The distributed matrix and <code>matrix</code> on process <code>rank</code> must have matching dimensions.</p>
<p>For all processes except the process with rank <code>rank</code> the serial <code>matrix</code> is not referenced. The user has to ensure that all processes call this with identical <code>rank</code>. The <code>rank</code> refers to a process of the MPI communicator used to create the process grid of the distributed matrix. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l00362">362</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="ae25c0bf99b3489c9b929a17be267d27f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae25c0bf99b3489c9b929a17be267d27f">&#9670;&nbsp;</a></span>copy_to() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::copy_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; NumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the contents of the distributed matrix into <code>matrix</code>.</p>
<dl class="section note"><dt>Note</dt><dd>This function should only be used for relatively small matrix dimensions. It is primarily intended for debugging purposes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l00664">664</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="a6fb8d24a17a4b2538fdca4397f7f68b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fb8d24a17a4b2538fdca4397f7f68b8">&#9670;&nbsp;</a></span>copy_to() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::copy_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLAPACKFullMatrix.html">LAPACKFullMatrix</a>&lt; NumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the content of the distributed matrix into the locally replicated <code>matrix</code> on the process with rank <code>rank</code>. For all processes except <code>rank</code> <code>matrix</code> is not referenced. The distributed matrix and <code>matrix</code> on the process <code>rank</code> must have matching dimensions.</p>
<p>The user has to ensure that all processes call this with identical <code>rank</code>. The <code>rank</code> refers to a process of the MPI communicator used to create the process grid of the distributed matrix. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l00531">531</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="a1ef7a687223ac1e36ba294a2f4b06115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ef7a687223ac1e36ba294a2f4b06115">&#9670;&nbsp;</a></span>copy_to() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::copy_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the contents of the distributed matrix into a differently distributed matrix <code>dest</code>. The function also works for matrices with different process grids or block-cyclic distributions. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l00850">850</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="a02ed2356018f07f75b3c951bb808bd49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02ed2356018f07f75b3c951bb808bd49">&#9670;&nbsp;</a></span>copy_to() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::copy_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; unsigned int, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; unsigned int, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; unsigned int, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>submatrix_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy a submatrix (subset) of the distributed matrix A to a submatrix of the distributed matrix <code>B</code>.</p>
<ul>
<li>The global row and column index of the first element of the submatrix A is provided by <code>offset_A</code> with row index=<code>offset_A.first</code> and column index=<code>offset_A.second</code>.</li>
<li>The global row and column index of the first element of the submatrix B is provided by <code>offset_B</code> with row index=<code>offset_B.first</code> and column index=<code>offset_B.second</code>.</li>
<li>The dimension of the submatrix to be copied is given by <code>submatrix_size</code> with number of rows=<code>submatrix_size.first</code> and number of columns=<code>submatrix_size.second</code>.</li>
</ul>
<p>If it is necessary to copy complete matrices with an identical block-cyclic distribution, use ScaLAPACKMatrix&lt;NumberType&gt;::copy_to(ScaLAPACKMatrix&lt;NumberType&gt; &amp;dest) with only one argument to avoid communication.</p>
<p>The underlying process grids of the matrices <code>A</code> and <code>B</code> must have been built with the same MPI communicator. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l00721">721</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="ae9aa2d98bc501ca6c59b7bf72f3c0ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9aa2d98bc501ca6c59b7bf72f3c0ceb">&#9670;&nbsp;</a></span>copy_transposed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::copy_transposed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transposing assignment: \(\mathbf{A} = \mathbf{B}^T\)</p>
<p>The matrices \(\mathbf{A}\) and \(\mathbf{B}\) must have the same process grid.</p>
<p>The following alignment conditions have to be fulfilled: \(MB_A=NB_B\) and \(NB_A=MB_B\). </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l00981">981</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="a462e4473e763e00148572e554395c448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a462e4473e763e00148572e554395c448">&#9670;&nbsp;</a></span>add() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NumberType&#160;</td>
          <td class="paramname"><em>a</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NumberType&#160;</td>
          <td class="paramname"><em>b</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>transpose_B</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The operations based on the input parameter <code>transpose_B</code> and the alignment conditions are summarized in the following table:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">transpose_B   </th><th class="markdownTableHeadCenter">Block Sizes   </th><th class="markdownTableHeadCenter">Operation    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">false   </td><td class="markdownTableBodyCenter">\(MB_A=MB_B\) <br  />
 \(NB_A=NB_B\)   </td><td class="markdownTableBodyCenter">\(\mathbf{A} = a \mathbf{A} + b \mathbf{B}\)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">true   </td><td class="markdownTableBodyCenter">\(MB_A=NB_B\) <br  />
 \(NB_A=MB_B\)   </td><td class="markdownTableBodyCenter">\(\mathbf{A} = a \mathbf{A} + b \mathbf{B}^T\)   </td></tr>
</table>
<p>The matrices \(\mathbf{A}\) and \(\mathbf{B}\) must have the same process grid. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l00991">991</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="a65e0a87f73838febd95208e6020fb87e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65e0a87f73838febd95208e6020fb87e">&#9670;&nbsp;</a></span>add() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const NumberType&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix-addition: \(\mathbf{A} = \mathbf{A} + b\, \mathbf{B}\)</p>
<p>The matrices \(\mathbf{A}\) and \(\mathbf{B}\) must have the same process grid.</p>
<p>The following alignment conditions have to be fulfilled: \(MB_A=MB_B\) and \(NB_A=NB_B\). </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l01047">1047</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="a354f71241b0d44cba4f46e8410f26fcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a354f71241b0d44cba4f46e8410f26fcd">&#9670;&nbsp;</a></span>Tadd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::Tadd </td>
          <td>(</td>
          <td class="paramtype">const NumberType&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix-addition: \(\mathbf{A} = \mathbf{A} + b\, \mathbf{B}^T\)</p>
<p>The matrices \(\mathbf{A}\) and \(\mathbf{B}\) must have the same process grid.</p>
<p>The following alignment conditions have to be fulfilled: \(MB_A=NB_B\) and \(NB_A=MB_B\). </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l01057">1057</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="aada5bc79adf4d2b6f7a0a586dd154553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada5bc79adf4d2b6f7a0a586dd154553">&#9670;&nbsp;</a></span>mult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::mult </td>
          <td>(</td>
          <td class="paramtype">const NumberType&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NumberType&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>transpose_A</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>transpose_B</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix-matrix-multiplication:</p>
<p>The operations based on the input parameters and the alignment conditions are summarized in the following table:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">transpose_A   </th><th class="markdownTableHeadCenter">transpose_B   </th><th class="markdownTableHeadCenter">Block Sizes   </th><th class="markdownTableHeadCenter">Operation    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">false   </td><td class="markdownTableBodyCenter">false   </td><td class="markdownTableBodyCenter">\(MB_A=MB_C\) <br  />
 \(NB_A=MB_B\) <br  />
 \(NB_B=NB_C\)   </td><td class="markdownTableBodyCenter">\(\mathbf{C} = b \mathbf{A} \cdot \mathbf{B} + c \mathbf{C}\)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">false   </td><td class="markdownTableBodyCenter">true   </td><td class="markdownTableBodyCenter">\(MB_A=MB_C\) <br  />
 \(NB_A=NB_B\) <br  />
 \(MB_B=NB_C\)   </td><td class="markdownTableBodyCenter">\(\mathbf{C} = b \mathbf{A} \cdot \mathbf{B}^T + c \mathbf{C}\)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">true   </td><td class="markdownTableBodyCenter">false   </td><td class="markdownTableBodyCenter">\(MB_A=MB_B\) <br  />
 \(NB_A=MB_C\) <br  />
 \(NB_B=NB_C\)   </td><td class="markdownTableBodyCenter">\(\mathbf{C} = b \mathbf{A}^T \cdot \mathbf{B} + c \mathbf{C}\)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">true   </td><td class="markdownTableBodyCenter">true   </td><td class="markdownTableBodyCenter">\(MB_A=NB_B\) <br  />
 \(NB_A=MB_C\) <br  />
 \(MB_B=NB_C\)   </td><td class="markdownTableBodyCenter">\(\mathbf{C} = b \mathbf{A}^T \cdot \mathbf{B}^T + c \mathbf{C}\)   </td></tr>
</table>
<p>It is assumed that \(\mathbf{A}\) and \(\mathbf{B}\) have compatible sizes and that \(\mathbf{C}\) already has the right size.</p>
<p>The matrices \(\mathbf{A}\), \(\mathbf{B}\) and \(\mathbf{C}\) must have the same process grid. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l01067">1067</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="a8242435e8730f7cac460b1ac2310c7ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8242435e8730f7cac460b1ac2310c7ed">&#9670;&nbsp;</a></span>mmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::mmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>adding</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix-matrix-multiplication.</p>
<p>The optional parameter <code>adding</code> determines whether the result is stored in \(\mathbf{C}\) or added to \(\mathbf{C}\).</p>
<p>if (<code>adding</code>) \(\mathbf{C} = \mathbf{C} + \mathbf{A} \cdot \mathbf{B}\)</p>
<p>else \(\mathbf{C} = \mathbf{A} \cdot \mathbf{B}\)</p>
<p>It is assumed that \(\mathbf{A}\) and \(\mathbf{B}\) have compatible sizes and that \(\mathbf{C}\) already has the right size.</p>
<p>The following alignment conditions have to be fulfilled: \(MB_A=MB_C\), \(NB_A=MB_B\) and \(NB_B=NB_C\). </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l01184">1184</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="a546401290947b77277a5f1811bc97ea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a546401290947b77277a5f1811bc97ea2">&#9670;&nbsp;</a></span>Tmmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::Tmmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>adding</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix-matrix-multiplication using transpose of \(\mathbf{A}\).</p>
<p>The optional parameter <code>adding</code> determines whether the result is stored in \(\mathbf{C}\) or added to \(\mathbf{C}\).</p>
<p>if (<code>adding</code>) \(\mathbf{C} = \mathbf{C} + \mathbf{A}^T \cdot \mathbf{B}\)</p>
<p>else \(\mathbf{C} = \mathbf{A}^T \cdot \mathbf{B}\)</p>
<p>It is assumed that \(\mathbf{A}\) and \(\mathbf{B}\) have compatible sizes and that \(\mathbf{C}\) already has the right size.</p>
<p>The following alignment conditions have to be fulfilled: \(MB_A=MB_B\), \(NB_A=MB_C\) and \(NB_B=NB_C\). </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l01198">1198</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="a36438ff9295f52ed4bb385663529f6cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36438ff9295f52ed4bb385663529f6cb">&#9670;&nbsp;</a></span>mTmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::mTmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>adding</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix-matrix-multiplication using the transpose of \(\mathbf{B}\).</p>
<p>The optional parameter <code>adding</code> determines whether the result is stored in \(\mathbf{C}\) or added to \(\mathbf{C}\).</p>
<p>if (<code>adding</code>) \(\mathbf{C} = \mathbf{C} + \mathbf{A} \cdot \mathbf{B}^T\)</p>
<p>else \(\mathbf{C} = \mathbf{A} \cdot \mathbf{B}^T\)</p>
<p>It is assumed that \(\mathbf{A}\) and \(\mathbf{B}\) have compatible sizes and that \(\mathbf{C}\) already has the right size.</p>
<p>The following alignment conditions have to be fulfilled: \(MB_A=MB_C\), \(NB_A=NB_B\) and \(MB_B=NB_C\). </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l01212">1212</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="adcfc441f7e61468e505c20a2b937c46c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcfc441f7e61468e505c20a2b937c46c">&#9670;&nbsp;</a></span>TmTmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::TmTmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>adding</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix-matrix-multiplication using transpose of \(\mathbf{A}\) and \(\mathbf{B}\).</p>
<p>The optional parameter <code>adding</code> determines whether the result is stored in \(\mathbf{C}\) or added to \(\mathbf{C}\).</p>
<p>if (<code>adding</code>) \(\mathbf{C} = \mathbf{C} + \mathbf{A}^T \cdot \mathbf{B}^T\)</p>
<p>else \(\mathbf{C} = \mathbf{A}^T \cdot \mathbf{B}^T\)</p>
<p>It is assumed that \(\mathbf{A}\) and \(\mathbf{B}\) have compatible sizes and that \(\mathbf{C}\) already has the right size.</p>
<p>The following alignment conditions have to be fulfilled: \(MB_A=NB_B\), \(NB_A=MB_C\) and \(MB_B=NB_C\). </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l01226">1226</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="a988e7c86e7e560b2d8c815317a565371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a988e7c86e7e560b2d8c815317a565371">&#9670;&nbsp;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::save </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; unsigned int, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>chunk_size</em> = <code>std::make_pair(<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>,&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores the distributed matrix in <code>filename</code> using <a class="el" href="namespaceHDF5.html">HDF5</a>.</p>
<p>In case that deal.II was built without <a class="el" href="namespaceHDF5.html">HDF5</a> a call to this function will cause an exception to be thrown.</p>
<p>If <a class="el" href="namespaceHDF5.html">HDF5</a> was built with MPI, parallel I/O is used to save the matrix. Otherwise, just one process will do the output. This means that internally the distributed matrix is copied to one process, which does the output. Therefore, the matrix has to fit into the memory of one process.</p>
<p>To tweak the I/O performance, especially for parallel I/O, the user may define the optional parameter <code>chunk_size</code>. All MPI processes need to call the function with the same value. The matrix is written in chunks to the file, therefore the properties of the system define the optimal chunk size. Internally, <a class="el" href="namespaceHDF5.html">HDF5</a> splits the matrix into <code>chunk_size.first</code> x <code>chunk_size.second</code> sized blocks, with <code>chunk_size.first</code> being the number of rows of a chunk and <code>chunk_size.second</code> the number of columns. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l02608">2608</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="a7578e1be3f70805316ec69f587ed7730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7578e1be3f70805316ec69f587ed7730">&#9670;&nbsp;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loads the distributed matrix from file <code>filename</code> using <a class="el" href="namespaceHDF5.html">HDF5</a>. In case that deal.II was built without <a class="el" href="namespaceHDF5.html">HDF5</a> a call to this function will cause an exception to be thrown.</p>
<p>The matrix must have the same dimensions as the matrix stored in the file.</p>
<p>If <a class="el" href="namespaceHDF5.html">HDF5</a> was build with MPI, parallel I/O is used to load the matrix. Otherwise, just one process will load the matrix from storage and distribute the content to the other processes subsequently. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l03043">3043</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="ae4fab96dc8bf972386fa37936fe8c132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4fab96dc8bf972386fa37936fe8c132">&#9670;&nbsp;</a></span>compute_cholesky_factorization()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::compute_cholesky_factorization</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the Cholesky factorization of the matrix using ScaLAPACK function <code>pXpotrf</code>. The result of the factorization is stored in this object. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l01240">1240</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="aa25b18f13ceb1f252c2526124396d180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25b18f13ceb1f252c2526124396d180">&#9670;&nbsp;</a></span>compute_lu_factorization()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::compute_lu_factorization</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the LU factorization of the matrix using ScaLAPACK function <code>pXgetrf</code> and partial pivoting with row interchanges. The result of the factorization is stored in this object. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l01273">1273</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="a5f723f324b1c7c22941f33034b652eec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f723f324b1c7c22941f33034b652eec">&#9670;&nbsp;</a></span>invert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::invert</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invert the matrix by first computing a Cholesky for symmetric matrices or a LU factorization for general matrices and then building the actual inverse using <code>pXpotri</code> or <code>pXgetri</code>. If the matrix is triangular, the LU factorization step is skipped, and <code>pXtrtri</code> is used directly.</p>
<p>If a Cholesky or LU factorization has been applied previously, <code>pXpotri</code> or <code>pXgetri</code> are called directly.</p>
<p>The inverse is stored in this object. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l01314">1314</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="ae0278fa22a587e65fe73102baa4e3336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0278fa22a587e65fe73102baa4e3336">&#9670;&nbsp;</a></span>eigenpairs_symmetric_by_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; NumberType &gt; <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::eigenpairs_symmetric_by_index </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; unsigned int, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_limits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>compute_eigenvectors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computing selected eigenvalues and, optionally, the eigenvectors of the real symmetric matrix \(\mathbf{A} \in \mathbb{R}^{M \times M}\).</p>
<p>The eigenvalues/eigenvectors are selected by prescribing a range of indices <code>index_limits</code>.</p>
<p>If successful, the computed eigenvalues are arranged in ascending order. The eigenvectors are stored in the columns of the matrix, thereby overwriting the original content of the matrix.</p>
<p>If all eigenvalues/eigenvectors have to be computed, pass the closed interval \( \left[ 0, M-1 \right] \) in <code>index_limits</code>.</p>
<p>Pass the closed interval \( \left[ M-r, M-1 \right] \) if the \(r\) largest eigenvalues/eigenvectors are desired. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l01430">1430</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="a05736f2044c74db48f53067f46ed4c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05736f2044c74db48f53067f46ed4c75">&#9670;&nbsp;</a></span>eigenpairs_symmetric_by_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; NumberType &gt; <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::eigenpairs_symmetric_by_value </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; NumberType, NumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>value_limits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>compute_eigenvectors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computing selected eigenvalues and, optionally, the eigenvectors. The eigenvalues/eigenvectors are selected by prescribing a range of values <code>value_limits</code> for the eigenvalues.</p>
<p>If successful, the computed eigenvalues are arranged in ascending order. The eigenvectors are stored in the columns of the matrix, thereby overwriting the original content of the matrix. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l01453">1453</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="acf56a3d220794a7c0e0839a1f44ff539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf56a3d220794a7c0e0839a1f44ff539">&#9670;&nbsp;</a></span>eigenpairs_symmetric_by_index_MRRR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; NumberType &gt; <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::eigenpairs_symmetric_by_index_MRRR </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; unsigned int, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_limits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>compute_eigenvectors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computing selected eigenvalues and, optionally, the eigenvectors of the real symmetric matrix \(\mathbf{A} \in \mathbb{R}^{M \times M}\) using the MRRR algorithm.</p>
<p>The eigenvalues/eigenvectors are selected by prescribing a range of indices <code>index_limits</code>.</p>
<p>If successful, the computed eigenvalues are arranged in ascending order. The eigenvectors are stored in the columns of the matrix, thereby overwriting the original content of the matrix.</p>
<p>If all eigenvalues/eigenvectors have to be computed, pass the closed interval \( \left[ 0, M-1 \right] \) in <code>index_limits</code>.</p>
<p>Pass the closed interval \( \left[ M-r, M-1 \right] \) if the \(r\) largest eigenvalues/eigenvectors are desired. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l01763">1763</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="a0a53f1e6c1fce2ca93b718f34d215ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a53f1e6c1fce2ca93b718f34d215ae9">&#9670;&nbsp;</a></span>eigenpairs_symmetric_by_value_MRRR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; NumberType &gt; <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::eigenpairs_symmetric_by_value_MRRR </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; NumberType, NumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>value_limits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>compute_eigenvectors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computing selected eigenvalues and, optionally, the eigenvectors of the real symmetric matrix \(\mathbf{A} \in \mathbb{R}^{M \times M}\) using the MRRR algorithm. The eigenvalues/eigenvectors are selected by prescribing a range of values <code>value_limits</code> for the eigenvalues.</p>
<p>If successful, the computed eigenvalues are arranged in ascending order. The eigenvectors are stored in the columns of the matrix, thereby overwriting the original content of the matrix. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l01786">1786</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="a04feb5d5c22d71a40c6912ec8f0ee2f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04feb5d5c22d71a40c6912ec8f0ee2f9">&#9670;&nbsp;</a></span>compute_SVD()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; NumberType &gt; <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::compute_SVD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; *&#160;</td>
          <td class="paramname"><em>U</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; *&#160;</td>
          <td class="paramname"><em>VT</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computing the singular value decomposition (SVD) of a matrix \(\mathbf{A} \in \mathbb{R}^{M \times N}\), optionally computing the left and/or right singular vectors. The SVD is written as \(\mathbf{A} = \mathbf{U} \cdot \mathbf{\Sigma} \cdot \mathbf{V}^T\) with \(\mathbf{\Sigma} \in \mathbb{R}^{M \times N}\) as a diagonal matrix, \(\mathbf{U} \in \mathbb{R}^{M \times M}\) and \(\mathbf{V} \in \mathbb{R}^{M \times M}\) as orthogonal matrices. The diagonal elements of \(\mathbf{\Sigma}\) are the singular values of \(A\) and the columns of \(\mathbf{U}\) and \(\mathbf{V}\) are the corresponding left and right singular vectors, respectively. The singular values are returned in decreasing order and only the first \(\min(M,N)\) columns of \(\mathbf{U}\) and rows of \(\mathbf{V}^T\) are computed.</p>
<p>Upon return the content of the matrix is unusable. The matrix \(\mathbf{A}\) must have identical block cyclic distribution for the rows and column.</p>
<p>If left singular vectors are required matrices \(\mathbf{A}\) and \(\mathbf{U}\) have to be constructed with the same process grid and block cyclic distribution. If right singular vectors are required matrices \(\mathbf{A}\) and \(\mathbf{V}^T\) have to be constructed with the same process grid and block cyclic distribution.</p>
<p>To avoid computing the left and/or right singular vectors the function accepts <code>nullptr</code> for <code>U</code> and/or <code>VT</code>. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l02014">2014</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="a23f528e743bbb29f0608960eb420c102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23f528e743bbb29f0608960eb420c102">&#9670;&nbsp;</a></span>least_squares()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::least_squares </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>transpose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solving overdetermined or underdetermined real linear systems involving matrix \(\mathbf{A} \in \mathbb{R}^{M \times N}\), or its transpose \(\mathbf{A}^T\), using a <a class="el" href="classQR.html">QR</a> or LQ factorization of \(\mathbf{A}\) for \(N_{\rm RHS}\) RHS vectors in the columns of matrix \(\mathbf{B}\)</p>
<p>It is assumed that \(\mathbf{A}\) has full rank: \(\rm{rank}(\mathbf{A}) = \min(M,N)\).</p>
<p>The following options are supported:</p><ol type="1">
<li>If(!transpose) and \(M \geq N\): least squares solution of overdetermined system \(\min \Vert \mathbf{B} - \mathbf{A}\cdot \mathbf{X}\Vert\).<br  />
 Upon exit the rows \(0\) to \(N-1\) of \(\mathbf{B}\) contain the least square solution vectors. The residual sum of squares for each column is given by the sum of squares of elements \(N\) to \(M-1\) in that column.</li>
<li>If(!transpose) and \(M &lt; N\): find minimum norm solutions of underdetermined systems \(\mathbf{A} \cdot \mathbf{X} = \mathbf{B}\).<br  />
 Upon exit the columns of \(\mathbf{B}\) contain the minimum norm solution vectors.</li>
<li>If(transpose) and \(M \geq N\): find minimum norm solutions of underdetermined system \( \mathbf{A}^\top \cdot \mathbf{X} = \mathbf{B}\).<br  />
 Upon exit the columns of \(\mathbf{B}\) contain the minimum norm solution vectors.</li>
<li>If(transpose) and \(M &lt; N\): least squares solution of overdetermined system \(\min \Vert \mathbf{B} - \mathbf{A}^\top \cdot \mathbf{X}\Vert\).<br  />
 Upon exit the rows \(0\) to \(M-1\) contain the least square solution vectors. The residual sum of squares for each column is given by the sum of squares of elements \(M\) to \(N-1\) in that column.</li>
</ol>
<p>If(!tranpose) then \(\mathbf{B} \in \mathbb{R}^{M \times N_{\rm RHS}}\), otherwise \(\mathbf{B} \in \mathbb{R}^{N \times N_{\rm RHS}}\). The matrices \(\mathbf{A}\) and \(\mathbf{B}\) must have an identical block cyclic distribution for rows and columns. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l02134">2134</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="a0a17919a2ff3b9c8dc1f76beca7f57b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a17919a2ff3b9c8dc1f76beca7f57b4">&#9670;&nbsp;</a></span>pseudoinverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::pseudoinverse </td>
          <td>(</td>
          <td class="paramtype">const NumberType&#160;</td>
          <td class="paramname"><em>ratio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the pseudoinverse \(\mathbf{A}^+ \in \mathbb{R}^{N \times M}\) (Moore-Penrose inverse) of a real matrix \(\mathbf{A} \in \mathbb{R}^{M \times N}\) using the singular value decomposition \(\mathbf{A} = \mathbf{U} \cdot \mathbf{\Sigma} \cdot \mathbf{V}^T\).</p>
<p>Unlike the inverse, the pseudoinverse \(\mathbf{A}^+ = \mathbf{V} \cdot \mathbf{\Sigma}^+ \cdot \mathbf{U}^T\) exists for both rectangular as well as singular matrices \(\mathbf{A}\).</p>
<p>For a rectangular \(\mathbf{\Sigma}\) the pseudoinverse is computed by taking the reciprocal of each non-zero element on the diagonal, leaving the zeros in place, and then transposing \(\mathbf{\Sigma}\). For the numerical computation only the singular values \(\sigma_i &gt; \sigma_{\text{max}} \, \text{ratio}\) are taken into account. Upon successful exit, the function returns the number of singular values fulfilling that condition. That value can be interpreted as the rank of \(\mathbf{A}\).</p>
<p>Upon return this object contains the pseudoinverse \(\mathbf{A}^+ \in \mathbb{R}^{N \times M}\).</p>
<p>The following alignment conditions have to be fulfilled: \(MB_A = NB_A\). </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l02226">2226</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="ad8c472d23a551bbbdfbfcfee4f5bbe51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8c472d23a551bbbdfbfcfee4f5bbe51">&#9670;&nbsp;</a></span>reciprocal_condition_number()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">NumberType <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::reciprocal_condition_number </td>
          <td>(</td>
          <td class="paramtype">const NumberType&#160;</td>
          <td class="paramname"><em>a_norm</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Estimate the condition number of a SPD matrix in the \(l_1\)-norm. The matrix has to be in the Cholesky state (see <a class="el" href="classScaLAPACKMatrix.html#ae4fab96dc8bf972386fa37936fe8c132">compute_cholesky_factorization()</a>). The reciprocal of the condition number is returned in order to avoid the possibility of overflow when the condition number is very large.</p>
<p><code>a_norm</code> must contain the \(l_1\)-norm of the matrix prior to calling Cholesky factorization (see <a class="el" href="classScaLAPACKMatrix.html#a9fae8f6bbe61900874e495b566059ed9">l1_norm()</a>).</p>
<dl class="section note"><dt>Note</dt><dd>An alternative is to compute the inverse of the matrix explicitly and manually construct \(k_1 = ||\mathbf{A}||_1 \, ||\mathbf{A}^{-1}||_1\). </dd></dl>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l02313">2313</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="a9fae8f6bbe61900874e495b566059ed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fae8f6bbe61900874e495b566059ed9">&#9670;&nbsp;</a></span>l1_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">NumberType <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::l1_norm</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the \(l_1\)-norm of the matrix. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l02375">2375</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="af08bd68181f1690263ca241568a65e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af08bd68181f1690263ca241568a65e6e">&#9670;&nbsp;</a></span>linfty_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">NumberType <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::linfty_norm</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the \(l_{\infty}\) norm of the matrix. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l02389">2389</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="a08c248dd3d7474ad88f01f361fb38763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08c248dd3d7474ad88f01f361fb38763">&#9670;&nbsp;</a></span>frobenius_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">NumberType <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::frobenius_norm</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the Frobenius norm of the matrix. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l02403">2403</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="acec0701c49ab60d28960cdb34ce475ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acec0701c49ab60d28960cdb34ce475ba">&#9670;&nbsp;</a></span>m()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a> <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::m </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of rows of the \(M \times N\) matrix. </p>

</div>
</div>
<a id="a46bc94233591ea03adec9fb95dae9e16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46bc94233591ea03adec9fb95dae9e16">&#9670;&nbsp;</a></span>n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a> <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::n </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of columns of the \(M \times N\) matrix. </p>

</div>
</div>
<a id="ae3afe5deb2fe2726ee5451f9c76e0646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3afe5deb2fe2726ee5451f9c76e0646">&#9670;&nbsp;</a></span>local_m()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::local_m </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of local rows on this MPI processes. </p>

</div>
</div>
<a id="a0597c0f46ca4dd7477c1c83a98f38f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0597c0f46ca4dd7477c1c83a98f38f11">&#9670;&nbsp;</a></span>local_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::local_n </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of local columns on this MPI process. </p>

</div>
</div>
<a id="ae2c72bf2945cab1cd8050371520629ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2c72bf2945cab1cd8050371520629ed">&#9670;&nbsp;</a></span>global_row()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::global_row </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>loc_row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the global row number for the given local row <code>loc_row</code> . </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l00496">496</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="ae10eacb6dbdb705df9683564f03ee525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae10eacb6dbdb705df9683564f03ee525">&#9670;&nbsp;</a></span>global_column()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::global_column </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>loc_column</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the global column number for the given local column <code>loc_column</code>. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l00513">513</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="a2420eec8cfc46561b26ed7d14916215b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2420eec8cfc46561b26ed7d14916215b">&#9670;&nbsp;</a></span>local_el() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">NumberType <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::local_el </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>loc_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>loc_column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read access to local element. </p>

</div>
</div>
<a id="a0536e2cdf182c4cb3e4120960a1e805e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0536e2cdf182c4cb3e4120960a1e805e">&#9670;&nbsp;</a></span>local_el() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">NumberType&amp; <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::local_el </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>loc_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>loc_column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write access to local element. </p>

</div>
</div>
<a id="af6819321d6f65302155b6b7e2be70988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6819321d6f65302155b6b7e2be70988">&#9670;&nbsp;</a></span>scale_columns()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::scale_columns </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>factors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale the columns of the distributed matrix by the scalars provided in the array <code>factors</code>.</p>
<p>The array <code>factors</code> must have as many entries as the matrix columns.</p>
<p>Copies of <code>factors</code> have to be available on all processes of the underlying MPI communicator.</p>
<dl class="section note"><dt>Note</dt><dd>The fundamental prerequisite for the <code>InputVector</code> is that it must be possible to create an <a class="el" href="classArrayView.html">ArrayView</a> from it; this is satisfied by the <code>std::vector</code> and <a class="el" href="classVector.html">Vector</a> classes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l03496">3496</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="a64013567ad63bbc2cee395c1b01fdb3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64013567ad63bbc2cee395c1b01fdb3b">&#9670;&nbsp;</a></span>scale_rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::scale_rows </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>factors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale the rows of the distributed matrix by the scalars provided in the array <code>factors</code>.</p>
<p>The array <code>factors</code> must have as many entries as the matrix rows.</p>
<p>Copies of <code>factors</code> have to be available on all processes of the underlying MPI communicator.</p>
<dl class="section note"><dt>Note</dt><dd>The fundamental prerequisite for the <code>InputVector</code> is that it must be possible to create an <a class="el" href="classArrayView.html">ArrayView</a> from it; this is satisfied by the <code>std::vector</code> and <a class="el" href="classVector.html">Vector</a> classes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l03507">3507</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="aa41a2ed7e7d97d1bab0742f8dd4f48b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa41a2ed7e7d97d1bab0742f8dd4f48b5">&#9670;&nbsp;</a></span>norm_symmetric()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NumberType <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::norm_symmetric </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculate the norm of a distributed symmetric dense matrix using ScaLAPACK's internal function. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l02476">2476</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="a8c9e68ebdb81c95dc91a5cadc2d8d44e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9e68ebdb81c95dc91a5cadc2d8d44e">&#9670;&nbsp;</a></span>norm_general()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NumberType <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::norm_general </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculate the norm of a distributed dense matrix using ScaLAPACK's internal function. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l02417">2417</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="a84115bec54d73663a31d714e1a17c82c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84115bec54d73663a31d714e1a17c82c">&#9670;&nbsp;</a></span>eigenpairs_symmetric()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; NumberType &gt; <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::eigenpairs_symmetric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>compute_eigenvectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; unsigned int, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_limits</em> = <code>std::make_pair(<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>,&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; NumberType, NumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>value_limits</em> = <code>std::make_pair(std::numeric_limits&lt;NumberType&gt;::quiet_NaN(),&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::numeric_limits&lt;NumberType&gt;::quiet_NaN())</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computing selected eigenvalues and, optionally, the eigenvectors. The eigenvalues/eigenvectors are selected by either prescribing a range of indices <code>index_limits</code> or a range of values <code>value_limits</code> for the eigenvalues. The function will throw an exception if both ranges are prescribed (meaning that both ranges differ from the default value) as this ambiguity is prohibited. If successful, the computed eigenvalues are arranged in ascending order. The eigenvectors are stored in the columns of the matrix, thereby overwriting the original content of the matrix. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l01473">1473</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="a56a20ea915118b8b2b149e3d4af10a5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56a20ea915118b8b2b149e3d4af10a5e">&#9670;&nbsp;</a></span>eigenpairs_symmetric_MRRR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; NumberType &gt; <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::eigenpairs_symmetric_MRRR </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>compute_eigenvectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; unsigned int, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_limits</em> = <code>std::make_pair(<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>,&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; NumberType, NumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>value_limits</em> = <code>std::make_pair(std::numeric_limits&lt;NumberType&gt;::quiet_NaN(),&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::numeric_limits&lt;NumberType&gt;::quiet_NaN())</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computing selected eigenvalues and, optionally, the eigenvectors of the real symmetric matrix \(\mathbf{A} \in \mathbb{R}^{M \times M}\) using the MRRR algorithm. The eigenvalues/eigenvectors are selected by either prescribing a range of indices <code>index_limits</code> or a range of values <code>value_limits</code> for the eigenvalues. The function will throw an exception if both ranges are prescribed (meaning that both ranges differ from the default value) as this ambiguity is prohibited.</p>
<p>By calling this function the original content of the matrix will be overwritten. If requested, the eigenvectors are stored in the columns of the matrix. Also in the case that just the eigenvalues are required, the content of the matrix will be overwritten.</p>
<p>If successful, the computed eigenvalues are arranged in ascending order.</p>
<dl class="section note"><dt>Note</dt><dd>Due to a bug in Netlib-ScaLAPACK, either all or no eigenvectors can be computed. Therefore, the input <code>index_limits</code> has to be set accordingly. Using Intel-MKL this restriction is not required. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l01804">1804</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="a86231732a54f89df92e15ec186d46e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86231732a54f89df92e15ec186d46e82">&#9670;&nbsp;</a></span>save_serial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::save_serial </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; unsigned int, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>chunk_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l02650">2650</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="ac78850bc990c4f8de2270176a95b177a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac78850bc990c4f8de2270176a95b177a">&#9670;&nbsp;</a></span>load_serial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::load_serial </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l03064">3064</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="a1c9a16cb5cdeb15f4ef1a18a3415dce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c9a16cb5cdeb15f4ef1a18a3415dce2">&#9670;&nbsp;</a></span>save_parallel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::save_parallel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; unsigned int, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>chunk_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l02807">2807</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="a9a12de09785d8b7be4f95e7a6f9fb06a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a12de09785d8b7be4f95e7a6f9fb06a">&#9670;&nbsp;</a></span>load_parallel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::load_parallel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="scalapack_8cc_source.html#l03242">3242</a> of file <a class="el" href="scalapack_8cc_source.html">scalapack.cc</a>.</p>

</div>
</div>
<a id="a1850f8cb99a54fe25506a8ff39418aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1850f8cb99a54fe25506a8ff39418aaf">&#9670;&nbsp;</a></span>reinit() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTransposeTable.html">TransposeTable</a>&lt; NumberType  &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a>&#160;</td>
          <td class="paramname"><em>size1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a>&#160;</td>
          <td class="paramname"><em>size2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_default_initialization</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reinitialize the object. This function is mostly here for compatibility with the earlier <code>vector2d</code> class. Passes down to the base class by converting the arguments to the data type requested by the base class. </p>

</div>
</div>
<a id="a302ef67031a523602fd39911b968d6ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a302ef67031a523602fd39911b968d6ab">&#9670;&nbsp;</a></span>reinit() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_default_initialization</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the dimensions of this object to the sizes given in the first argument, and allocate the required memory for table entries to accommodate these sizes. If <code>omit_default_initialization</code> is set to <code>false</code>, all elements of the table are set to a default constructed object for the element type. Otherwise the memory is left in an uninitialized or otherwise undefined state. </p>

</div>
</div>
<a id="ac36b71ef45ac64e732975643771134a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac36b71ef45ac64e732975643771134a2">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTransposeTable.html#af443131e24234cb6ca5cb03b88c8d763">const_reference</a> <a class="el" href="classTransposeTable.html">TransposeTable</a>&lt; NumberType  &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Direct access to one element of the table by specifying all indices at the same time. Range checks are performed.</p>
<p>This version of the function only allows read access. </p>

</div>
</div>
<a id="aeced6fe416efbe7f8c3ff50ad2cd7245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeced6fe416efbe7f8c3ff50ad2cd7245">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTransposeTable.html#aa3cc546896667528a5514bcdb704ef4e">reference</a> <a class="el" href="classTransposeTable.html">TransposeTable</a>&lt; NumberType  &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Direct access to one element of the table by specifying all indices at the same time. Range checks are performed.</p>
<p>This version of the function allows read-write access. </p>

</div>
</div>
<a id="a2b90cda631253866e0f2fa02d714e6b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b90cda631253866e0f2fa02d714e6b0">&#9670;&nbsp;</a></span>operator()() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;T&gt;::<a class="el" href="classTransposeTable.html#aa3cc546896667528a5514bcdb704ef4e">reference</a> <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a read-write reference to the indicated element. </p>

</div>
</div>
<a id="a2966017e02f461809ff90eb8f4c86ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2966017e02f461809ff90eb8f4c86ed3">&#9670;&nbsp;</a></span>operator()() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;T&gt;::<a class="el" href="classTransposeTable.html#af443131e24234cb6ca5cb03b88c8d763">const_reference</a> <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the indicated element as a read-only reference.</p>
<p>We return the requested value as a constant reference rather than by value since this object may hold data types that may be large, and we don't know here whether copying is expensive or not. </p>

</div>
</div>
<a id="a3f8dcd60a406d43ba78269a96895fd90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f8dcd60a406d43ba78269a96895fd90">&#9670;&nbsp;</a></span>n_rows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a> <a class="el" href="classTransposeTable.html">TransposeTable</a>&lt; NumberType  &gt;::n_rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of rows. This function really makes only sense since we have a two-dimensional object here. </p>

</div>
</div>
<a id="a4a36ba83d9e425c774ea2362ac8996e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a36ba83d9e425c774ea2362ac8996e9">&#9670;&nbsp;</a></span>n_cols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a> <a class="el" href="classTransposeTable.html">TransposeTable</a>&lt; NumberType  &gt;::n_cols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of columns. This function really makes only sense since we have a two-dimensional object here. </p>

</div>
</div>
<a id="ac14a7ea5713f7d7a721847f129e6649c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac14a7ea5713f7d7a721847f129e6649c">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTransposeTable.html#a38906966a208171e373d9568bdefed95">iterator</a> <a class="el" href="classTransposeTable.html">TransposeTable</a>&lt; NumberType  &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator pointing to the first entry. </p>

</div>
</div>
<a id="a486413d5db2c89c75329251fc5ca497a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486413d5db2c89c75329251fc5ca497a">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTransposeTable.html#a6123c6adf12bb6e59cd9fa440008fb1c">const_iterator</a> <a class="el" href="classTransposeTable.html">TransposeTable</a>&lt; NumberType  &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a constant iterator pointing to the first entry. </p>

</div>
</div>
<a id="aa30d26e173c56cc8bdda7e08760e7e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa30d26e173c56cc8bdda7e08760e7e2c">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTransposeTable.html#a38906966a208171e373d9568bdefed95">iterator</a> <a class="el" href="classTransposeTable.html">TransposeTable</a>&lt; NumberType  &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator pointing to one past the last entry. </p>

</div>
</div>
<a id="a8b32a0c0c89c83ad3dc59d5bd6fdf1fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b32a0c0c89c83ad3dc59d5bd6fdf1fd">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTransposeTable.html#a6123c6adf12bb6e59cd9fa440008fb1c">const_iterator</a> <a class="el" href="classTransposeTable.html">TransposeTable</a>&lt; NumberType  &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a constant iterator pointing to one past the last entry. </p>

</div>
</div>
<a id="a416b65cdf6d47a5f7b55f9cb34addf05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a416b65cdf6d47a5f7b55f9cb34addf05">&#9670;&nbsp;</a></span>el() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTransposeTable.html#aa3cc546896667528a5514bcdb704ef4e">reference</a> <a class="el" href="classTransposeTable.html">TransposeTable</a>&lt; NumberType  &gt;::el </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a read-write reference to the element <code>(i,j)</code>.</p>
<p>This function does no bounds checking and is only to be used internally and in functions already checked.</p>
<p>These functions are mainly here for compatibility with a former implementation of these table classes for 2d arrays, then called <code>vector2d</code>. </p>

</div>
</div>
<a id="ad0f84b2757aeb5618651eaec8864f2b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0f84b2757aeb5618651eaec8864f2b8">&#9670;&nbsp;</a></span>el() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTransposeTable.html#af443131e24234cb6ca5cb03b88c8d763">const_reference</a> <a class="el" href="classTransposeTable.html">TransposeTable</a>&lt; NumberType  &gt;::el </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the element <code>(i,j)</code> as a read-only reference.</p>
<p>This function does no bounds checking and is only to be used internally and in functions already checked.</p>
<p>We return the requested value as a constant reference rather than by value since this object may hold data types that may be large, and we don't know here whether copying is expensive or not.</p>
<p>These functions are mainly here for compatibility with a former implementation of these table classes for 2d arrays, then called <code>vector2d</code>. </p>

</div>
</div>
<a id="ad4474b545894de5a80f3fdacb9ead38c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4474b545894de5a80f3fdacb9ead38c">&#9670;&nbsp;</a></span>el() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;T&gt;::<a class="el" href="classTransposeTable.html#aa3cc546896667528a5514bcdb704ef4e">reference</a> <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::el </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a read-write reference to the indicated element.</p>
<p>This function does no bounds checking and is only to be used internally and in functions already checked. </p>

</div>
</div>
<a id="a40a9979fda00a9293c3fa6a6df97639e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a9979fda00a9293c3fa6a6df97639e">&#9670;&nbsp;</a></span>el() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;T&gt;::<a class="el" href="classTransposeTable.html#af443131e24234cb6ca5cb03b88c8d763">const_reference</a> <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::el </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the indicated element as a read-only reference.</p>
<p>This function does no bounds checking and is only to be used internally and in functions already checked.</p>
<p>We return the requested value as a constant reference rather than by value since this object may hold data types that may be large, and we don't know here whether copying is expensive or not. </p>

</div>
</div>
<a id="aa998401367252589f5a4bdd7d8087380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa998401367252589f5a4bdd7d8087380">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>T2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test for equality of two tables. </p>

</div>
</div>
<a id="af0e75a7ccd3359dccbddc0934bc1bf27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e75a7ccd3359dccbddc0934bc1bf27">&#9670;&nbsp;</a></span>reset_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::reset_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set all entries to their default value (i.e. copy them over with default constructed objects). Do not change the size of the table, though. </p>

</div>
</div>
<a id="af2204c132154b5d6bfd571eb85d8a58f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2204c132154b5d6bfd571eb85d8a58f">&#9670;&nbsp;</a></span>size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a> <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::size </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Size of the table in direction <code>i</code>. </p>

</div>
</div>
<a id="aaba8a3da6e403297e8d2b231e9d6c35f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba8a3da6e403297e8d2b231e9d6c35f">&#9670;&nbsp;</a></span>size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt;N&gt;&amp; <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the sizes of this object in each direction. </p>

</div>
</div>
<a id="a67161f19c760e98588bdecc560285d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67161f19c760e98588bdecc560285d2d">&#9670;&nbsp;</a></span>n_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a> <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::n_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of elements stored in this object, which is the product of the extensions in each dimension. </p>

</div>
</div>
<a id="abb7b890ac4bbcba1b6524b45af1cbfd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb7b890ac4bbcba1b6524b45af1cbfd9">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether the object is empty, i.e. one of the directions is zero. This is equivalent to <code><a class="el" href="classTableBase.html#a67161f19c760e98588bdecc560285d2d">n_elements()</a>==0</code>. </p>

</div>
</div>
<a id="ad54a19dddbed32640b977b4d7948b434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad54a19dddbed32640b977b4d7948b434">&#9670;&nbsp;</a></span>fill() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T &gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>C_style_indexing</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fill this table (which is assumed to already have the correct size) from a source given by dereferencing the given forward iterator (which could, for example, be a pointer to the first element of an array, or an inserting std::istream_iterator). The second argument denotes whether the elements pointed to are arranged in a way that corresponds to the last index running fastest or slowest. The default is to use C-style indexing where the last index runs fastest (as opposed to Fortran-style where the first index runs fastest when traversing multidimensional arrays. For example, if you try to fill an object of type <a class="el" href="classTable_3_012_00_01T_01_4.html">Table&lt;2,T&gt;</a>, then calling this function with the default value for the second argument will result in the equivalent of doing </p><div class="fragment"><div class="line"><a class="code" href="classTable_3_012_00_01T_01_4.html">Table&lt;2,T&gt;</a> t;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;t.<a class="code" href="classTableBase.html#af2204c132154b5d6bfd571eb85d8a58f">size</a>(0); ++i)</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;t.<a class="code" href="classTableBase.html#af2204c132154b5d6bfd571eb85d8a58f">size</a>(1); ++j)</div>
<div class="line">    t[i][j] = *entries++;</div>
<div class="ttc" id="aclassTableBase_html_af2204c132154b5d6bfd571eb85d8a58f"><div class="ttname"><a href="classTableBase.html#af2204c132154b5d6bfd571eb85d8a58f">TableBase::size</a></div><div class="ttdeci">size_type size(const unsigned int i) const</div></div>
<div class="ttc" id="aclassTable_3_012_00_01T_01_4_html"><div class="ttname"><a href="classTable_3_012_00_01T_01_4.html">Table&lt; 2, T &gt;</a></div><div class="ttdef"><b>Definition:</b> <a href="table_8h_source.html#l01106">table.h:1107</a></div></div>
</div><!-- fragment --><p> On the other hand, if the second argument to this function is false, then this would result in code of the following form: </p><div class="fragment"><div class="line"><a class="code" href="classTable_3_012_00_01T_01_4.html">Table&lt;2,T&gt;</a> t;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;t.<a class="code" href="classTableBase.html#af2204c132154b5d6bfd571eb85d8a58f">size</a>(1); ++j)</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;t.<a class="code" href="classTableBase.html#af2204c132154b5d6bfd571eb85d8a58f">size</a>(0); ++i)</div>
<div class="line">    t[i][j] = *entries++;</div>
</div><!-- fragment --><p> Note the switched order in which we fill the table elements by traversing the given set of iterators.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entries</td><td>An iterator to a set of elements from which to initialize this table. It is assumed that iterator can be incremented and dereferenced a sufficient number of times to fill this table. </td></tr>
    <tr><td class="paramname">C_style_indexing</td><td>If true, run over elements of the table with the last index changing fastest as we dereference subsequent elements of the input range. If false, change the first index fastest. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a0d148a657080f22dc7c4f213c5a8ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a0d148a657080f22dc7c4f213c5a8ee">&#9670;&nbsp;</a></span>fill() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fill all table entries with the same value. </p>

</div>
</div>
<a id="a140815b9435c997be48f439634afc4f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a140815b9435c997be48f439634afc4f5">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swap the contents of this table and the other table <code>v</code>. One could do this operation with a temporary variable and copying over the data elements, but this function is significantly more efficient since it only swaps the pointers to the data of the two vectors and therefore does not need to allocate temporary storage and move data around.</p>
<p>This function is analogous to the <code>swap</code> function of all C++ standard containers. Also, there is a global function <code>swap(u,v)</code> that simply calls <code>u.swap(v)</code>, again in analogy to standard functions. </p>

</div>
</div>
<a id="a2c63db9ae49e0e3b099f0244801016f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c63db9ae49e0e3b099f0244801016f2">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. </p>

</div>
</div>
<a id="aee01f8890040d7b480fc0c72e19f6711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee01f8890040d7b480fc0c72e19f6711">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T &gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write or read the data of this object to or from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. </p>

</div>
</div>
<a id="ab8546237d4c76440bfaed5e1818cdd90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8546237d4c76440bfaed5e1818cdd90">&#9670;&nbsp;</a></span>position()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a> <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::position </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the position of the indicated element within the array of elements stored one after the other. This function does no index checking. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="adc8bcecff39fec4dda83ee72279081d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc8bcecff39fec4dda83ee72279081d3">&#9670;&nbsp;</a></span>state</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638">LAPACKSupport::State</a> <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::state</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Since ScaLAPACK operations notoriously change the meaning of the matrix entries, we record the current state after the last operation here. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8h_source.html#l00887">887</a> of file <a class="el" href="scalapack_8h_source.html">scalapack.h</a>.</p>

</div>
</div>
<a id="aae1c9ee4a7967975a161bc336d24a173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae1c9ee4a7967975a161bc336d24a173">&#9670;&nbsp;</a></span>property</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceLAPACKSupport.html#a45557450a3c1ae0e74d7ddf12c43bc98">LAPACKSupport::Property</a> <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::property</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Additional property of the matrix which may help to select more efficient ScaLAPACK functions. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8h_source.html#l00893">893</a> of file <a class="el" href="scalapack_8h_source.html">scalapack.h</a>.</p>

</div>
</div>
<a id="a6d8799d4b9b8cad88f6af9dbafbb6bb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d8799d4b9b8cad88f6af9dbafbb6bb2">&#9670;&nbsp;</a></span>grid</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classUtilities_1_1MPI_1_1ProcessGrid.html">Utilities::MPI::ProcessGrid</a>&gt; <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::grid</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A shared pointer to a <a class="el" href="classUtilities_1_1MPI_1_1ProcessGrid.html">Utilities::MPI::ProcessGrid</a> object which contains a BLACS context and a MPI communicator, as well as other necessary data structures. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8h_source.html#l00900">900</a> of file <a class="el" href="scalapack_8h_source.html">scalapack.h</a>.</p>

</div>
</div>
<a id="a2bdb8189d7e88a60291430a2945e8bc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bdb8189d7e88a60291430a2945e8bc3">&#9670;&nbsp;</a></span>n_rows</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::n_rows</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of rows in the matrix. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8h_source.html#l00905">905</a> of file <a class="el" href="scalapack_8h_source.html">scalapack.h</a>.</p>

</div>
</div>
<a id="aa802e135eb0b2b5fb07636b3ad20e123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa802e135eb0b2b5fb07636b3ad20e123">&#9670;&nbsp;</a></span>n_columns</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::n_columns</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of columns in the matrix. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8h_source.html#l00910">910</a> of file <a class="el" href="scalapack_8h_source.html">scalapack.h</a>.</p>

</div>
</div>
<a id="af10d04b6961bffb230a58f658ddb7d5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af10d04b6961bffb230a58f658ddb7d5d">&#9670;&nbsp;</a></span>row_block_size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::row_block_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Row block size. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8h_source.html#l00915">915</a> of file <a class="el" href="scalapack_8h_source.html">scalapack.h</a>.</p>

</div>
</div>
<a id="a5286111f1e05e8019b36933eef6a55aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5286111f1e05e8019b36933eef6a55aa">&#9670;&nbsp;</a></span>column_block_size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::column_block_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Column block size. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8h_source.html#l00920">920</a> of file <a class="el" href="scalapack_8h_source.html">scalapack.h</a>.</p>

</div>
</div>
<a id="a2aeb43089505bb7b32477271cc76312e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aeb43089505bb7b32477271cc76312e">&#9670;&nbsp;</a></span>n_local_rows</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::n_local_rows</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of rows in the matrix owned by the current process. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8h_source.html#l00925">925</a> of file <a class="el" href="scalapack_8h_source.html">scalapack.h</a>.</p>

</div>
</div>
<a id="a4b34cedd3940060edbe3ce4aeec09903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b34cedd3940060edbe3ce4aeec09903">&#9670;&nbsp;</a></span>n_local_columns</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::n_local_columns</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of columns in the matrix owned by the current process. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8h_source.html#l00930">930</a> of file <a class="el" href="scalapack_8h_source.html">scalapack.h</a>.</p>

</div>
</div>
<a id="a0337ee06e1bf8c56ea28d92c290b9b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0337ee06e1bf8c56ea28d92c290b9b65">&#9670;&nbsp;</a></span>descriptor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::descriptor[9]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>ScaLAPACK description vector. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8h_source.html#l00935">935</a> of file <a class="el" href="scalapack_8h_source.html">scalapack.h</a>.</p>

</div>
</div>
<a id="a9713119f9eb1f2bac9d66cfc8bad2265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9713119f9eb1f2bac9d66cfc8bad2265">&#9670;&nbsp;</a></span>work</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;NumberType&gt; <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::work</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Workspace array. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8h_source.html#l00940">940</a> of file <a class="el" href="scalapack_8h_source.html">scalapack.h</a>.</p>

</div>
</div>
<a id="a40e4719dedb862973b5a7e5b94241b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40e4719dedb862973b5a7e5b94241b32">&#9670;&nbsp;</a></span>iwork</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::iwork</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Integer workspace array. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8h_source.html#l00945">945</a> of file <a class="el" href="scalapack_8h_source.html">scalapack.h</a>.</p>

</div>
</div>
<a id="ad6ba99b7ee9d41099239aab8c912007e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6ba99b7ee9d41099239aab8c912007e">&#9670;&nbsp;</a></span>ipiv</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::ipiv</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Integer array holding pivoting information required by ScaLAPACK's matrix factorization routines. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8h_source.html#l00951">951</a> of file <a class="el" href="scalapack_8h_source.html">scalapack.h</a>.</p>

</div>
</div>
<a id="aa54c16e73ab356c8577d13afeec841c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa54c16e73ab356c8577d13afeec841c3">&#9670;&nbsp;</a></span>uplo</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::uplo</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A character to define where elements are stored in case ScaLAPACK operations support this. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8h_source.html#l00957">957</a> of file <a class="el" href="scalapack_8h_source.html">scalapack.h</a>.</p>

</div>
</div>
<a id="a6b66eb11a9e96f925692a930bf98f8d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b66eb11a9e96f925692a930bf98f8d6">&#9670;&nbsp;</a></span>first_process_row</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::first_process_row</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The process row of the process grid over which the first row of the global matrix is distributed. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8h_source.html#l00963">963</a> of file <a class="el" href="scalapack_8h_source.html">scalapack.h</a>.</p>

</div>
</div>
<a id="a15e893b58c1079c78ee094f8107f7ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15e893b58c1079c78ee094f8107f7ce4">&#9670;&nbsp;</a></span>first_process_column</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::first_process_column</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The process column of the process grid over which the first column of the global matrix is distributed. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8h_source.html#l00969">969</a> of file <a class="el" href="scalapack_8h_source.html">scalapack.h</a>.</p>

</div>
</div>
<a id="a801e8b7f84711c97d732019ca9ddce50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a801e8b7f84711c97d732019ca9ddce50">&#9670;&nbsp;</a></span>submatrix_row</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::submatrix_row</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Global row index that determines where to start a submatrix. Currently this equals unity, as we don't use submatrices. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8h_source.html#l00975">975</a> of file <a class="el" href="scalapack_8h_source.html">scalapack.h</a>.</p>

</div>
</div>
<a id="a784802959d4846fc5f2fd329ea8c66d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a784802959d4846fc5f2fd329ea8c66d5">&#9670;&nbsp;</a></span>submatrix_column</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::submatrix_column</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Global column index that determines where to start a submatrix. Currently this equals unity, as we don't use submatrices. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8h_source.html#l00981">981</a> of file <a class="el" href="scalapack_8h_source.html">scalapack.h</a>.</p>

</div>
</div>
<a id="adee5b765105669677bd7e5a5944c6b27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adee5b765105669677bd7e5a5944c6b27">&#9670;&nbsp;</a></span>mutex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classThreads_1_1Mutex.html">Threads::Mutex</a> <a class="el" href="classScaLAPACKMatrix.html">ScaLAPACKMatrix</a>&lt; NumberType &gt;::mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Thread mutex. </p>

<p class="definition">Definition at line <a class="el" href="scalapack_8h_source.html#l00986">986</a> of file <a class="el" href="scalapack_8h_source.html">scalapack.h</a>.</p>

</div>
</div>
<a id="a50beea2748a06b3abb8d65d5fe7aa8aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50beea2748a06b3abb8d65d5fe7aa8aa">&#9670;&nbsp;</a></span>values</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;T&gt; <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::values</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Component-array. </p>

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00640">640</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<a id="af33df922c5081e1b69e73027cacdaa95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af33df922c5081e1b69e73027cacdaa95">&#9670;&nbsp;</a></span>table_size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTableIndices.html">TableIndices</a>&lt;N&gt; <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::table_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Size in each direction of the table. </p>

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00645">645</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/lac/<a class="el" href="scalapack_8h_source.html">scalapack.h</a></li>
<li>source/lac/<a class="el" href="scalapack_8cc_source.html">scalapack.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
