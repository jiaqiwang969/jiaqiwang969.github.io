<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_22.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-22 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.3.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.3.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">The step-22 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_6.html">step-6</a>, <a class="el" href="step_21.html">step-21</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Weakform">Weak form</a>
        <li><a href="#Boundaryconditions">Boundary conditions</a>
        <li><a href="#Discretization">Discretization</a>
        <li><a href="#Linearsolverandpreconditioningissues">Linear solver and preconditioning issues</a>
      <ul>
        <li><a href="#IsthishowoneshouldsolvetheStokesequations"> Is this how one should solve the Stokes equations? </a>
        <li><a href="#Anoteonthestructureofthelinearsystem"> A note on the structure of the linear system </a>
      </ul>
        <li><a href="#Thetestcase">The testcase</a>
        <li><a href="#Implementation">Implementation</a>
      <ul>
        <li><a href="#UsingimhomogeneousconstraintsforimplementingDirichletboundaryconditions">Using imhomogeneous constraints for implementing Dirichlet boundary conditions</a>
        <li><a href="#UsingAffineConstraintsforincreasingperformance">Using AffineConstraints for increasing performance</a>
        <li><a href="#Performanceoptimizations">Performance optimizations</a>
    </ul>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#Definingtheinnerpreconditionertype">Defining the inner preconditioner type</a>
        <li><a href="#ThecodeStokesProblemcodeclasstemplate">The <code>StokesProblem</code> class template</a>
        <li><a href="#Boundaryvaluesandrighthandside">Boundary values and right hand side</a>
        <li><a href="#Linearsolversandpreconditioners">Linear solvers and preconditioners</a>
      <ul>
        <li><a href="#ThecodeInverseMatrixcodeclasstemplate">The <code>InverseMatrix</code> class template</a>
        <li><a href="#ThecodeSchurComplementcodeclasstemplate">The <code>SchurComplement</code> class template</a>
      </ul>
        <li><a href="#StokesProblemclassimplementation">StokesProblem class implementation</a>
      <ul>
        <li><a href="#StokesProblemStokesProblem">StokesProblem::StokesProblem</a>
        <li><a href="#StokesProblemsetup_dofs">StokesProblem::setup_dofs</a>
        <li><a href="#StokesProblemassemble_system">StokesProblem::assemble_system</a>
        <li><a href="#StokesProblemsolve">StokesProblem::solve</a>
        <li><a href="#StokesProblemoutput_results">StokesProblem::output_results</a>
        <li><a href="#StokesProblemrefine_mesh">StokesProblem::refine_mesh</a>
        <li><a href="#StokesProblemrun">StokesProblem::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Outputoftheprogramandgraphicalvisualization">Output of the program and graphical visualization</a>
      <ul>
        <li><a href="#2Dcalculations">2D calculations</a>
        <li><a href="#3Dcalculations">3D calculations</a>
      </ul>
        <li><a href="#Sparsitypattern">Sparsity pattern</a>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
      <ul>
        <li><a href="#Improvedlinearsolverin3D">Improved linear solver in 3D</a>
      <ul>
        <li><a href="#BetterILUdecompositionbysmartreordering">Better ILU decomposition by smart reordering</a>
        <li><a href="#BetterpreconditionerfortheinnerCGsolver">Better preconditioner for the inner CG solver</a>
        <li><a href="#BlockSchurcomplementpreconditioner">Block Schur complement preconditioner</a>
        <li><a href="#Combiningtheblockpreconditionerandmultigrid">Combining the block preconditioner and multigrid</a>
        <li><a href="#Noblockmatricesandvectors">No block matrices and vectors</a>
      </ul>
        <li><a href="#Moreinterestingtestcases">More interesting testcases</a>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br  />
</p>
<p><em>This program was contributed by Martin Kronbichler and Wolfgang Bangerth. <br  />
 This material is based upon work partly supported by the National Science Foundation under Award No. EAR-0426271 and The California Institute of Technology. Any opinions, findings, and conclusions or recommendations expressed in this publication are those of the author and do not necessarily reflect the views of the National Science Foundation or of The California Institute of Technology. </em></p>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>This program deals with the Stokes system of equations which reads as follows in non-dimensionalized form: </p><p class="formulaDsp">
\begin{eqnarray*} -2\; \textrm{div}\; \varepsilon(\textbf{u}) + \nabla p &amp;=&amp; \textbf{f}, \\ -\textrm{div}\; \textbf{u} &amp;=&amp; 0, \end{eqnarray*}
</p>
<p> where \(\textbf u\) denotes the velocity of a fluid, \(p\) is its pressure, \(\textbf f\) are external forces, and \(\varepsilon(\textbf{u})= \nabla^s{\textbf{u}}= \frac 12 \left[ (\nabla \textbf{u}) + (\nabla \textbf{u})^T\right]\) is the rank-2 tensor of symmetrized gradients; a component-wise definition of it is \(\varepsilon(\textbf{u})_{ij}=\frac 12\left(\frac{\partial u_i}{\partial x_j} + \frac{\partial u_j}{\partial x_i}\right)\).</p>
<p>The Stokes equations describe the steady-state motion of a slow-moving, viscous fluid such as honey, rocks in the earth mantle, or other cases where inertia does not play a significant role. If a fluid is moving fast enough that inertia forces are significant compared to viscous friction, the Stokes equations are no longer valid; taking into account inertia effects then leads to the nonlinear Navier-Stokes equations. However, in this tutorial program, we will focus on the simpler Stokes system.</p>
<p>Note that when deriving the more general compressible Navier-Stokes equations, the diffusion is modeled as the divergence of the stress tensor </p><p class="formulaDsp">
\begin{eqnarray*} \tau = - \mu (2\varepsilon(\textbf{u}) - \frac{2}{3}\nabla \cdot \textbf{u} I), \end{eqnarray*}
</p>
<p> where \(\mu\) is the viscosity of the fluid. With the assumption of \(\mu=1\) (assume constant viscosity and non-dimensionalize the equation by dividing out \(\mu\)) and assuming incompressibility ( \(\textrm{div}\; \textbf{u}=0\)), we arrive at the formulation from above: </p><p class="formulaDsp">
\begin{eqnarray*} \textrm{div}\; \tau = -2\textrm{div}\;\varepsilon(\textbf{u}). \end{eqnarray*}
</p>
<p> A different formulation uses the Laplace operator ( \(-\triangle \textbf{u}\)) instead of the symmetrized gradient. A big difference here is that the different components of the velocity do not couple. If you assume additional regularity of the solution \(\textbf{u}\) (second partial derivatives exist and are continuous), the formulations are equivalent: </p><p class="formulaDsp">
\begin{eqnarray*} \textrm{div}\; \tau = -2\textrm{div}\;\varepsilon(\textbf{u}) = -\triangle \textbf{u} + \nabla \cdot (\nabla\textbf{u})^T = -\triangle \textbf{u}. \end{eqnarray*}
</p>
<p> This is because the \(i\)th entry of \(\nabla \cdot (\nabla\textbf{u})^T\) is given by: </p><p class="formulaDsp">
\begin{eqnarray*} [\nabla \cdot (\nabla\textbf{u})^T]_i = \sum_j \frac{\partial}{\partial x_j} [(\nabla\textbf{u})^T]_{i,j} = \sum_j \frac{\partial}{\partial x_j} [(\nabla\textbf{u})]_{j,i} = \sum_j \frac{\partial}{\partial x_j} \frac{\partial}{\partial x_i} \textbf{u}_j = \sum_j \frac{\partial}{\partial x_i} \frac{\partial}{\partial x_j} \textbf{u}_j = \frac{\partial}{\partial x_i} \textrm{div}\; \textbf{u} = 0. \end{eqnarray*}
</p>
<p> If you can not assume the above mentioned regularity, or if your viscosity is not a constant, the equivalence no longer holds. Therefore, we decided to stick with the more physically accurate symmetric tensor formulation in this tutorial.</p>
<p>To be well-posed, we will have to add boundary conditions to the equations. What boundary conditions are readily possible here will become clear once we discuss the weak form of the equations.</p>
<p>The equations covered here fall into the class of vector-valued problems. A toplevel overview of this topic can be found in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module.</p>
<p><a class="anchor" id="Weakform"></a></p><h3>Weak form</h3>
<p>The weak form of the equations is obtained by writing it in vector form as </p><p class="formulaDsp">
\begin{eqnarray*} \begin{pmatrix} {-2\; \textrm{div}\; \varepsilon(\textbf{u}) + \nabla p} \\ {-\textrm{div}\; \textbf{u}} \end{pmatrix} = \begin{pmatrix} {\textbf{f}} \\ 0 \end{pmatrix}, \end{eqnarray*}
</p>
<p> forming the dot product from the left with a vector-valued test function \(\phi = \begin{pmatrix}\textbf{v} \\ q\end{pmatrix}\) and integrating over the domain \(\Omega\), yielding the following set of equations: </p><p class="formulaDsp">
\begin{eqnarray*} (\mathrm v, -2\; \textrm{div}\; \varepsilon(\textbf{u}) + \nabla p)_{\Omega} - (q,\textrm{div}\; \textbf{u})_{\Omega} = (\textbf{v}, \textbf{f})_\Omega, \end{eqnarray*}
</p>
<p> which has to hold for all test functions \(\phi = \begin{pmatrix}\textbf{v} \\ q\end{pmatrix}\).</p>
<p>A generally good rule of thumb is that if one <em>can</em> reduce how many derivatives are taken on any variable in the formulation, then one <em>should</em> in fact do that using integration by parts. (This is motivated by the theory of <a href="https://en.wikipedia.org/wiki/Partial_differential_equation">partial differential equations</a>, and in particular the difference between strong and <a href="https://en.wikipedia.org/wiki/Weak_solution">weak solutions</a>.) We have already done that for the Laplace equation, where we have integrated the second derivative by parts to obtain the weak formulation that has only one derivative on both test and trial function.</p>
<p>In the current context, we integrate by parts the second term: </p><p class="formulaDsp">
\begin{eqnarray*} (\textbf{v}, -2\; \textrm{div}\; \varepsilon(\textbf{u}))_{\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} + (\textbf{n}\cdot\textbf{v}, p)_{\partial\Omega} - (q,\textrm{div}\; \textbf{u})_{\Omega} = (\textbf{v}, \textbf{f})_\Omega. \end{eqnarray*}
</p>
<p> Likewise, we integrate by parts the first term to obtain </p><p class="formulaDsp">
\begin{eqnarray*} (\nabla \textbf{v}, 2\; \varepsilon(\textbf{u}))_{\Omega} - (\textbf{n} \otimes \textbf{v}, 2\; \varepsilon(\textbf{u}))_{\partial\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} + (\textbf{n}\cdot\textbf{v}, p)_{\partial\Omega} - (q,\textrm{div}\; \textbf{u})_{\Omega} = (\textbf{v}, \textbf{f})_\Omega, \end{eqnarray*}
</p>
<p> where the scalar product between two tensor-valued quantities is here defined as </p><p class="formulaDsp">
\begin{eqnarray*} (\nabla \textbf{v}, 2\; \varepsilon(\textbf{u}))_{\Omega} = 2 \int_\Omega \sum_{i,j=1}^d \frac{\partial v_j}{\partial x_i} \varepsilon(\textbf{u})_{ij} \ dx. \end{eqnarray*}
</p>
<p> Using this, we have now reduced the requirements on our variables to first derivatives for \(\mathbf u,\mathbf v\) and no derivatives at all for \(p,q\).</p>
<p>Because the scalar product between a general tensor like \(\nabla\textbf{v}\) and a symmetric tensor like \(\varepsilon(\textbf{u})\) equals the scalar product between the symmetrized forms of the two, we can also write the bilinear form above as follows: </p><p class="formulaDsp">
\begin{eqnarray*} (\varepsilon(\textbf{v}), 2\; \varepsilon(\textbf{u}))_{\Omega} - (\textbf{n} \otimes \textbf{v}, 2\; \varepsilon(\textbf{u}))_{\partial\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} + (\textbf{n}\cdot\textbf{v}, p)_{\partial\Omega} - (q,\textrm{div}\; \textbf{u})_{\Omega} = (\textbf{v}, \textbf{f})_\Omega, \end{eqnarray*}
</p>
<p> We will deal with the boundary terms in the next section, but it is already clear from the domain terms </p><p class="formulaDsp">
\begin{eqnarray*} (\varepsilon(\textbf{v}), 2\; \varepsilon(\textbf{u}))_{\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q,\textrm{div}\; \textbf{u})_{\Omega} \end{eqnarray*}
</p>
<p> of the bilinear form that the Stokes equations yield a symmetric bilinear form, and consequently a symmetric (if indefinite) system matrix.</p>
<p><a class="anchor" id="Boundaryconditions"></a></p><h3>Boundary conditions</h3>
<dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.21.5.html">video lecture 21.5</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.) (See also <a href="http://www.math.colostate.edu/~bangerth/videos.676.21.55.html">video lecture 21.55</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.21.6.html">video lecture 21.6</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.21.65.html">video lecture 21.65</a>.)</dd></dl>
<p>The weak form just derived immediately presents us with different possibilities for imposing boundary conditions: </p><ol>
<li>
<p class="startli">Dirichlet velocity boundary conditions: On a part \(\Gamma_D\subset\partial\Omega\) we may impose Dirichlet conditions on the velocity \(\textbf u\):</p>
<p class="formulaDsp">
\begin{eqnarray*} \textbf u = \textbf g_D \qquad\qquad \textrm{on}\ \Gamma_D. \end{eqnarray*}
</p>
<p> Because test functions \(\textbf{v}\) come from the tangent space of the solution variable, we have that \(\textbf{v}=0\) on \(\Gamma_D\) and consequently that </p><p class="formulaDsp">
\begin{eqnarray*} -(\textbf{n} \otimes \mathrm v, 2\; \varepsilon(\textbf{u}))_{\Gamma_D} + (\textbf{n}\cdot\textbf{v}, p)_{\Gamma_D} = 0. \end{eqnarray*}
</p>
<p> In other words, as usual, strongly imposed boundary values do not appear in the weak form.</p>
<p class="interli">It is noteworthy that if we impose Dirichlet boundary values on the entire boundary, then the pressure is only determined up to a constant. An algorithmic realization of that would use similar tools as have been seen in <a class="el" href="step_11.html">step-11</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Neumann-type or natural boundary conditions: On the rest of the boundary \(\Gamma_N=\partial\Omega\backslash\Gamma_D\), let us re-write the boundary terms as follows: </p><p class="formulaDsp">
\begin{eqnarray*} -(\textbf{n} \otimes \mathrm v, 2\; \varepsilon(\textbf{u}))_{\Gamma_N} + (\textbf{n}\cdot\textbf{v}, p)_{\Gamma_N} &amp;=&amp; \sum_{i,j=1}^d -(n_i v_j, 2\; \varepsilon(\textbf{u})_{ij})_{\Gamma_N} + \sum_{i=1}^d (n_i v_i, p)_{\Gamma_N} \\ &amp;=&amp; \sum_{i,j=1}^d -(n_i v_j, 2\; \varepsilon(\textbf{u})_{ij})_{\Gamma_N} + \sum_{i,j=1}^d (n_i v_j, p \delta_{ij})_{\Gamma_N} \\ &amp;=&amp; \sum_{i,j=1}^d (n_i v_j,p \delta_{ij} - 2\; \varepsilon(\textbf{u})_{ij})_{\Gamma_N} \\ &amp;=&amp; (\textbf{n} \otimes \textbf{v}, p \textbf{I} - 2\; \varepsilon(\textbf{u}))_{\Gamma_N}. \\ &amp;=&amp; (\textbf{v}, \textbf{n}\cdot [p \textbf{I} - 2\; \varepsilon(\textbf{u})])_{\Gamma_N}. \end{eqnarray*}
</p>
<p> In other words, on the Neumann part of the boundary we can prescribe values for the total stress: </p><p class="formulaDsp">
\begin{eqnarray*} \textbf{n}\cdot [p \textbf{I} - 2\; \varepsilon(\textbf{u})] = \textbf g_N \qquad\qquad \textrm{on}\ \Gamma_N. \end{eqnarray*}
</p>
<p> If the boundary is subdivided into Dirichlet and Neumann parts \(\Gamma_D,\Gamma_N\), this then leads to the following weak form: </p><p class="formulaDsp">
\begin{eqnarray*} (\varepsilon(\textbf{v}), 2\; \varepsilon(\textbf{u}))_{\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q,\textrm{div}\; \textbf{u})_{\Omega} = (\textbf{v}, \textbf{f})_\Omega - (\textbf{v}, \textbf g_N)_{\Gamma_N}. \end{eqnarray*}
</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Robin-type boundary conditions: Robin boundary conditions are a mixture of Dirichlet and Neumann boundary conditions. They would read </p><p class="formulaDsp">
\begin{eqnarray*} \textbf{n}\cdot [p \textbf{I} - 2\; \varepsilon(\textbf{u})] = \textbf S \textbf u \qquad\qquad \textrm{on}\ \Gamma_R, \end{eqnarray*}
</p>
<p> with a rank-2 tensor (matrix) \(\textbf S\). The associated weak form is </p><p class="formulaDsp">
\begin{eqnarray*} (\varepsilon(\textbf{v}), 2\; \varepsilon(\textbf{u}))_{\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q,\textrm{div}\; \textbf{u})_{\Omega} + (\textbf S \textbf u, \textbf{v})_{\Gamma_R} = (\textbf{v}, \textbf{f})_\Omega. \end{eqnarray*}
</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Partial boundary conditions: It is possible to combine Dirichlet and Neumann boundary conditions by only enforcing each of them for certain components of the velocity. For example, one way to impose artificial boundary conditions is to require that the flow is perpendicular to the boundary, i.e. the tangential component \(\textbf u_{\textbf t}=(\textbf 1-\textbf n\otimes\textbf n)\textbf u\) be zero, thereby constraining <code>dim</code>-1 components of the velocity. The remaining component can be constrained by requiring that the normal component of the normal stress be zero, yielding the following set of boundary conditions: </p><p class="formulaDsp">
\begin{eqnarray*} \textbf u_{\textbf t} &amp;=&amp; 0, \\ \textbf n \cdot \left(\textbf{n}\cdot [p \textbf{I} - 2\; \varepsilon(\textbf{u})] \right) &amp;=&amp; 0. \end{eqnarray*}
</p>
<p class="endli">An alternative to this is when one wants the flow to be <em>parallel</em> rather than perpendicular to the boundary (in deal.II, the <a class="el" href="group__constraints.html#ga0d16c332aaa652e8905a6f48208e4500">VectorTools::compute_no_normal_flux_constraints</a> function can do this for you). This is frequently the case for problems with a free boundary (e.g. at the surface of a river or lake if vertical forces of the flow are not large enough to actually deform the surface), or if no significant friction is exerted by the boundary on the fluid (e.g. at the interface between earth mantle and earth core where two fluids meet that are stratified by different densities but that both have small enough viscosities to not introduce much tangential stress on each other). In formulas, this means that </p><p class="formulaDsp">
\begin{eqnarray*} \textbf{n}\cdot\textbf u &amp;=&amp; 0, \\ (\textbf 1-\textbf n\otimes\textbf n) \left(\textbf{n}\cdot [p \textbf{I} - 2\; \varepsilon(\textbf{u})] \right) &amp;=&amp; 0, \end{eqnarray*}
</p>
<p> the first condition (which needs to be imposed strongly) fixing a single component of the velocity, with the second (which would be enforced in the weak form) fixing the remaining two components. </p>
</li>
</ol>
<p>Despite this wealth of possibilities, we will only use Dirichlet and (homogeneous) Neumann boundary conditions in this tutorial program.</p>
<p><a class="anchor" id="Discretization"></a></p><h3>Discretization</h3>
<p>As developed above, the weak form of the equations with Dirichlet and Neumann boundary conditions on \(\Gamma_D\) and \(\Gamma_N\) reads like this: find \(\textbf u\in \textbf V_g = \{\varphi \in H^1(\Omega)^d: \varphi_{\Gamma_D}=\textbf g_D\}, p\in Q=L^2(\Omega)\) so that </p><p class="formulaDsp">
\begin{eqnarray*} (\varepsilon(\textbf{v}), 2\; \varepsilon(\textbf{u}))_{\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q,\textrm{div}\; \textbf{u})_{\Omega} = (\textbf{v}, \textbf{f})_\Omega - (\textbf{v}, \textbf g_N)_{\Gamma_N} \end{eqnarray*}
</p>
<p> for all test functions \(\textbf{v}\in \textbf V_0 = \{\varphi \in H^1(\Omega)^d: \varphi_{\Gamma_D}=0\},q\in Q\).</p>
<p>These equations represent a symmetric <a href="https://en.wikipedia.org/wiki/Ladyzhenskaya%E2%80%93Babu%C5%A1ka%E2%80%93Brezzi_condition">saddle point problem</a>. It is well known that then a solution only exists if the function spaces in which we search for a solution have to satisfy certain conditions, typically referred to as the Babuska-Brezzi or Ladyzhenskaya-Babuska-Brezzi (LBB) conditions. The continuous function spaces above satisfy these. However, when we discretize the equations by replacing the continuous variables and test functions by finite element functions in finite dimensional spaces \(\textbf V_{g,h}\subset \textbf V_g, Q_h\subset Q\), we have to make sure that \(\textbf V_h,Q_h\) also satisfy the LBB conditions. This is similar to what we had to do in <a class="el" href="step_20.html">step-20</a>.</p>
<p>For the Stokes equations, there are a number of possible choices to ensure that the finite element spaces are compatible with the LBB condition. A simple and accurate choice that we will use here is \(\textbf u_h\in Q_{p+1}^d, p_h\in Q_p\), i.e. use elements one order higher for the velocities than for the pressures.</p>
<p>This then leads to the following discrete problem: find \(\textbf u_h,p_h\) so that </p><p class="formulaDsp">
\begin{eqnarray*} (\varepsilon(\textbf{v}_h), 2\; \varepsilon(\textbf u_h))_{\Omega} - (\textrm{div}\; \textbf{v}_h, p_h)_{\Omega} - (q_h,\textrm{div}\; \textbf{u}_h)_{\Omega} = (\textbf{v}_h, \textbf{f})_\Omega - (\textbf{v}_h, \textbf g_N)_{\Gamma_N} \end{eqnarray*}
</p>
<p> for all test functions \(\textbf{v}_h, q_h\). Assembling the linear system associated with this problem follows the same lines used in <a class="el" href="step_20.html">step-20</a>, <a class="el" href="step_21.html">step-21</a>, and explained in detail in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module.</p>
<p><a class="anchor" id="Linearsolverandpreconditioningissues"></a></p><h3>Linear solver and preconditioning issues</h3>
<p>The weak form of the discrete equations naturally leads to the following linear system for the nodal values of the velocity and pressure fields: </p><p class="formulaDsp">
\begin{eqnarray*} \left(\begin{array}{cc} A &amp; B^T \\ B &amp; 0 \end{array}\right) \left(\begin{array}{c} U \\ P \end{array}\right) = \left(\begin{array}{c} F \\ G \end{array}\right), \end{eqnarray*}
</p>
<p> Like in <a class="el" href="step_20.html">step-20</a> and <a class="el" href="step_21.html">step-21</a>, we will solve this system of equations by forming the Schur complement, i.e. we will first find the solution \(P\) of </p><p class="formulaDsp">
\begin{eqnarray*} BA^{-1}B^T P &amp;=&amp; BA^{-1} F - G, \\ \end{eqnarray*}
</p>
<p> and then </p><p class="formulaDsp">
\begin{eqnarray*} AU &amp;=&amp; F - B^TP. \end{eqnarray*}
</p>
<p> The way we do this is pretty much exactly like we did in these previous tutorial programs, i.e. we use the same classes <code>SchurComplement</code> and <code>InverseMatrix</code> again. There are two significant differences, however:</p>
<ol>
<li>
<p class="startli">First, in the mixed Laplace equation we had to deal with the question of how to precondition the Schur complement \(B^TM^{-1}B\), which was spectrally equivalent to the Laplace operator on the pressure space (because \(B\) represents the gradient operator, \(B^T\) its adjoint \(-\textrm{div}\), and \(M\) the identity (up to the material parameter \(K^{-1}\)), so \(B^TM^{-1}B\) is something like \(-\textrm{div} \mathbf 1 \nabla = -\Delta\)). Consequently, the matrix is badly conditioned for small mesh sizes and we had to come up with an elaborate preconditioning scheme for the Schur complement.</p>
<p class="endli"></p>
</li>
<li>
Second, every time we multiplied with \(B^TM^{-1}B\) we had to solve with the mass matrix \(M\). This wasn't particularly difficult, however, since the mass matrix is always well conditioned and so simple to invert using CG and a little bit of preconditioning. </li>
</ol>
<p>In other words, preconditioning the inner solver for \(M\) was simple whereas preconditioning the outer solver for \(B^TM^{-1}B\) was complicated.</p>
<p>Here, the situation is pretty much exactly the opposite. The difference stems from the fact that the matrix at the heart of the Schur complement does not stem from the identity operator but from a variant of the Laplace operator, \(-\textrm{div} \nabla^s\) (where \(\nabla^s\) is the symmetric gradient) acting on a vector field. In the investigation of this issue we largely follow the paper D. Silvester and A. Wathen: "Fast iterative solution of stabilised Stokes systems part II. Using
general block preconditioners." (SIAM J. Numer. Anal., 31 (1994), pp. 1352-1367), which is available online <a href="http://siamdl.aip.org/getabs/servlet/GetabsServlet?prog=normal&amp;id=SJNAAM000031000005001352000001&amp;idtype=cvips&amp;gifs=Yes" target="_top">here</a>. Principally, the difference in the matrix at the heart of the Schur complement has two consequences:</p>
<ol>
<li>
<p class="startli">First, it makes the outer preconditioner simple: the Schur complement corresponds to the operator \(-\textrm{div} (-\textrm{div} \nabla^s)^{-1} \nabla\) on the pressure space; forgetting about the fact that we deal with symmetric gradients instead of the regular one, the Schur complement is something like \(-\textrm{div} (-\textrm{div} \nabla)^{-1} \nabla = -\textrm{div} (-\Delta)^{-1} \nabla\), which, even if not mathematically entirely concise, is spectrally equivalent to the identity operator (a heuristic argument would be to commute the operators into \(-\textrm{div}(-\Delta)^{-1} \nabla = -\textrm{div}\nabla(-\Delta)^{-1} = -\Delta(-\Delta)^{-1} = \mathbf 1\)). It turns out that it isn't easy to solve this Schur complement in a straightforward way with the CG method: using no preconditioner, the condition number of the Schur complement matrix depends on the size ratios of the largest to the smallest cells, and one still needs on the order of 50-100 CG iterations. However, there is a simple cure: precondition with the mass matrix on the pressure space and we get down to a number between 5-15 CG iterations, pretty much independently of the structure of the mesh (take a look at the <a href="#Results">results section</a> of this program to see that indeed the number of CG iterations does not change as we refine the mesh).</p>
<p class="interli">So all we need in addition to what we already have is the mass matrix on the pressure variables and we will store it in a separate object.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">While the outer preconditioner has become simpler compared to the mixed Laplace case discussed in <a class="el" href="step_20.html">step-20</a>, the issue of the inner solver has become more complicated. In the mixed Laplace discretization, the Schur complement has the form \(B^TM^{-1}B\). Thus, every time we multiplied with the Schur complement, we had to solve a linear system \(M_uz=y\); this isn't too complicated there, however, since the mass matrix \(M_u\) on the pressure space is well-conditioned.</p>
<p class="interli">On the other hand, for the Stokes equation we consider here, the Schur complement is \(BA^{-1}B^T\) where the matrix \(A\) is related to the Laplace operator (it is, in fact, the matrix corresponding to the bilinear form \((\nabla^s \varphi_i, \nabla^s\varphi_j)\)). Thus, solving with \(A\) is a lot more complicated: the matrix is badly conditioned and we know that we need many iterations unless we have a very good preconditioner. What is worse, we have to solve with \(A\) every time we multiply with the Schur complement, which is 5-15 times using the preconditioner described above.</p>
<p class="interli">Because we have to solve with \(A\) several times, it pays off to spend a bit more time once to create a good preconditioner for this matrix. So here's what we're going to do: if in 2d, we use the ultimate preconditioner, namely a direct sparse LU decomposition of the matrix. This is implemented using the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class that uses the UMFPACK direct solver to compute the decomposition. To use it, you will have to build deal.II with UMFPACK support (which is the default); see the <a href="../../readme.html#optional-software">ReadMe file</a> for instructions. With this, the inner solver converges in one iteration.</p>
<p class="interli">In 2d, we can do this sort of thing because even reasonably large problems rarely have more than a few 100,000 unknowns with relatively few nonzero entries per row. Furthermore, the bandwidth of matrices in 2d is \({\cal O}(\sqrt{N})\) and therefore moderate. For such matrices, sparse factors can be computed in a matter of a few seconds. (As a point of reference, computing the sparse factors of a matrix of size \(N\) and bandwidth \(B\) takes \({\cal O}(NB^2)\) operations. In 2d, this is \({\cal O}(N^2)\); though this is a higher complexity than, for example, assembling the linear system which takes \({\cal O}(N)\), the constant for computing the decomposition is so small that it doesn't become the dominating factor in the entire program until we get to very large numbers of unknowns in the high 100,000s or more.)</p>
<p class="interli">The situation changes in 3d, because there we quickly have many more unknowns and the bandwidth of matrices (which determines the number of nonzero entries in sparse LU factors) is \({\cal O}(N^{2/3})\), and there are many more entries per row as well. This makes using a sparse direct solver such as UMFPACK inefficient: only for problem sizes of a few 10,000 to maybe 100,000 unknowns can a sparse decomposition be computed using reasonable time and memory resources.</p>
<p class="endli">What we do in that case is to use an incomplete LU decomposition (ILU) as a preconditioner, rather than actually computing complete LU factors. As it so happens, deal.II has a class that does this: <a class="el" href="classSparseILU.html">SparseILU</a>. Computing the ILU takes a time that only depends on the number of nonzero entries in the sparse matrix (or that we are willing to fill in the LU factors, if these should be more than the ones in the matrix), but is independent of the bandwidth of the matrix. It is therefore an operation that can efficiently also be computed in 3d. On the other hand, an incomplete LU decomposition, by definition, does not represent an exact inverse of the matrix \(A\). Consequently, preconditioning with the ILU will still require more than one iteration, unlike preconditioning with the sparse direct solver. The inner solver will therefore take more time when multiplying with the Schur complement: an unavoidable trade-off. </p>
</li>
</ol>
<p>In the program below, we will make use of the fact that the <a class="el" href="classSparseILU.html">SparseILU</a> and <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> classes have a very similar interface and can be used interchangeably. All that we need is a switch class that, depending on the dimension, provides a type that is either of the two classes mentioned above. This is how we do that: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">struct </span>InnerPreconditioner;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">struct </span>InnerPreconditioner&lt;2&gt;</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using</span> type = <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">struct </span>InnerPreconditioner&lt;3&gt;</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using</span> type = <a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a>;</div>
<div class="line">};</div>
<div class="ttc" id="aclassSparseDirectUMFPACK_html"><div class="ttname"><a href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a></div><div class="ttdef"><b>Definition:</b> <a href="sparse__direct_8h_source.html#l00087">sparse_direct.h:88</a></div></div>
<div class="ttc" id="aclassSparseILU_html"><div class="ttname"><a href="classSparseILU.html">SparseILU</a></div><div class="ttdef"><b>Definition:</b> <a href="sparse__ilu_8h_source.html#l00059">sparse_ilu.h:60</a></div></div>
</div><!-- fragment --><p>From here on, we can refer to the type <code>typename InnerPreconditioner&lt;dim&gt;::type</code> and automatically get the correct preconditioner class. Because of the similarity of the interfaces of the two classes, we will be able to use them interchangeably using the same syntax in all places.</p>
<p><a class="anchor" id="IsthishowoneshouldsolvetheStokesequations"></a></p><h4>Is this how one should solve the Stokes equations? </h4>
<p>The discussions above showed <em>one</em> way in which the linear system that results from the Stokes equations can be solved, and because the tutorial programs are teaching tools that makes sense. But is this the way this system of equations <em>should</em> be solved?</p>
<p>The answer to this is no. The primary bottleneck with the approach, already identified above, is that we have to repeatedly solve linear systems with \(A\) inside the Schur complement, and because we don't have a good preconditioner for the Schur complement, these solves just have to happen too often. A better approach is to use a block decomposition, which is based on an observation of Silvester and Wathen <b>[SW94]</b> and explained in much greater detail in <b>[elman2005]</b> . An implementation of this alternative approach is discussed below, in the section on a <a href="#block-schur">block Schur complementation preconditioner</a> in the results section of this program.</p>
<p><a class="anchor" id="Anoteonthestructureofthelinearsystem"></a></p><h4>A note on the structure of the linear system </h4>
<p>Above, we have claimed that the linear system has the form </p><p class="formulaDsp">
\begin{eqnarray*} \left(\begin{array}{cc} A &amp; B^T \\ B &amp; 0 \end{array}\right) \left(\begin{array}{cc} U \\ P \end{array}\right) = \left(\begin{array}{cc} F \\ G \end{array}\right), \end{eqnarray*}
</p>
<p> i.e., in particular that there is a zero block at the bottom right of the matrix. This then allowed us to write the Schur complement as \(S=B A^{-1} B^T\). But this is not quite correct.</p>
<p>Think of what would happen if there are constraints on some pressure variables (see the <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> documentation module), for example because we use adaptively refined meshes and continuous pressure finite elements so that there are hanging nodes. Another cause for such constraints are Dirichlet boundary conditions on the pressure. Then the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> class, upon copying the local contributions to the matrix into the global linear system will zero out rows and columns corresponding to constrained degrees of freedom and put a positive entry on the diagonal. (You can think of this entry as being one for simplicity, though in reality it is a value of the same order of magnitude as the other matrix entries.) In other words, the bottom right block is really not empty at all: It has a few entries on the diagonal, one for each constrained pressure degree of freedom, and a correct description of the linear system we have to solve is that it has the form </p><p class="formulaDsp">
\begin{eqnarray*} \left(\begin{array}{cc} A &amp; B^T \\ B &amp; D_c \end{array}\right) \left(\begin{array}{cc} U \\ P \end{array}\right) = \left(\begin{array}{cc} F \\ G \end{array}\right), \end{eqnarray*}
</p>
<p> where \(D_c\) is the zero matrix with the exception of the positive diagonal entries for the constrained degrees of freedom. The correct Schur complement would then in fact be the matrix \(S = B A^{-1} B^T - D_c \) instead of the one stated above.</p>
<p>Thinking about this makes us, first, realize that the resulting Schur complement is now indefinite because \(B A^{-1} B^T\) is symmetric and positive definite whereas \(D_c\) is a positive semidefinite, and subtracting the latter from the former may no longer be positive definite. This is annoying because we could no longer employ the Conjugate Gradient method on this true Schur complement. That said, we could fix the issue in <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a> by simply putting <em>negative</em> values onto the diagonal for the constrained pressure variables &ndash; because we really only put something nonzero to ensure that the resulting matrix is not singular; we really didn't care whether that entry is positive or negative. So if the entries on the diagonal of \(D_c\) were negative, then \(S\) would again be a symmetric and positive definite matrix.</p>
<p>But, secondly, the code below doesn't actually do any of that: It happily solves the linear system with the wrong Schur complement \(S = B A^{-1} B^T\) that just ignores the issue altogether. Why does this even work? To understand why this is so, recall that when writing local contributions into the global matrix, <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a> zeros out the rows and columns that correspond to constrained degrees of freedom. This means that \(B\) has some zero rows, and \(B^T\) zero columns. As a consequence, if one were to multiply out what the entries of \(S\) are, one would realize that it has zero rows and columns for all constrained pressure degrees of freedom, including a zero on the diagonal. The nonzero entries of \(D_c\) would fit into exactly those zero diagonal locations, and ensure that \(S\) is invertible. Not doing so, strictly speaking, means that \(S\) remains singular: It is symmetric and positive definite on the subset of non-constrained pressure degrees of freedom, and simply the zero matrix on the constrained pressures. Why does the Conjugate Gradient method work for this matrix? Because <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a> also makes sure that the right hand side entries that correspond to these zero rows of the matrix are <em>also</em> zero, i.e., the right hand side is compatible.</p>
<p>What this means is that whatever the values of the solution vector for these constrained pressure degrees of freedom, these rows will always have a zero residual and, if one were to consider what the CG algorithm does internally, just never produce any updates to the solution vector. In other words, the CG algorithm just <em>ignores</em> these rows, despite the fact that the matrix is singular. This only works because these degrees of freedom are entirely decoupled from the rest of the linear system (because the entire row and corresponding column are zero). At the end of the solution process, the constrained pressure values in the solution vector therefore remain exactly as they were when we started the call to the solver; they are finally overwritten with their correct values when we call <a class="el" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">AffineConstraints::distribute()</a> after the CG solver is done.</p>
<p>The upshot of this discussion is that the assumption that the bottom right block of the big matrix is zero is a bit simplified, but that just going with it does not actually lead to any practical problems worth addressing.</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The testcase</h3>
<p>The domain, right hand side and boundary conditions we implement below relate to a problem in geophysics: there, one wants to compute the flow field of magma in the earth's interior under a mid-ocean rift. Rifts are places where two continental plates are very slowly drifting apart (a few centimeters per year at most), leaving a crack in the earth crust that is filled with magma from below. Without trying to be entirely realistic, we model this situation by solving the following set of equations and boundary conditions on the domain \(\Omega=[-2,2]\times[0,1]\times[-1,0]\): </p><p class="formulaDsp">
\begin{eqnarray*} -2\; \textrm{div}\; \varepsilon(\textbf{u}) + \nabla p &amp;=&amp; 0, \\ -\textrm{div}\; \textbf{u} &amp;=&amp; 0, \\ \mathbf u &amp;=&amp; \left(\begin{array}{c} -1 \\ 0 \\0 \end{array}\right) \qquad\qquad \textrm{at}\ z=0, x&lt;0, \\ \mathbf u &amp;=&amp; \left(\begin{array}{c} +1 \\ 0 \\0 \end{array}\right) \qquad\qquad \textrm{at}\ z=0, x&gt;0, \\ \mathbf u &amp;=&amp; \left(\begin{array}{c} 0 \\ 0 \\0 \end{array}\right) \qquad\qquad \textrm{at}\ z=0, x=0, \end{eqnarray*}
</p>
<p> and using natural boundary conditions \(\textbf{n}\cdot [p \textbf{I} - 2 \varepsilon(\textbf{u})] = 0\) everywhere else. In other words, at the left part of the top surface we prescribe that the fluid moves with the continental plate to the left at speed \(-1\), that it moves to the right on the right part of the top surface, and impose natural flow conditions everywhere else. If we are in 2d, the description is essentially the same, with the exception that we omit the second component of all vectors stated above.</p>
<p>As will become apparent in the <a href="#Results">results section</a>, the flow field will pull material from below and move it to the left and right ends of the domain, as expected. The discontinuity of velocity boundary conditions will produce a singularity in the pressure at the center of the top surface that sucks material all the way to the top surface to fill the gap left by the outward motion of material at this location.</p>
<p><a class="anchor" id="Implementation"></a></p><h3>Implementation</h3>
<p><a class="anchor" id="UsingimhomogeneousconstraintsforimplementingDirichletboundaryconditions"></a></p><h4>Using imhomogeneous constraints for implementing Dirichlet boundary conditions</h4>
<p>In all the previous tutorial programs, we used the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object merely for handling hanging node constraints (with exception of <a class="el" href="step_11.html">step-11</a>). However, the class can also be used to implement Dirichlet boundary conditions, as we will show in this program, by fixing some node values \(x_i = b_i\). Note that these are inhomogeneous constraints, and we have to pay some special attention to that. The way we are going to implement this is to first read in the boundary values into the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object by using the call</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceVectorTools.html#ab2562d41bb26f362043f9719a8cd9b87">VectorTools::interpolate_boundary_values</a> (dof_handler,</div>
<div class="line">                                          1,</div>
<div class="line">                                          BoundaryValues&lt;dim&gt;(),</div>
<div class="line">                                          constraints);</div>
<div class="ttc" id="anamespaceVectorTools_html_ab2562d41bb26f362043f9719a8cd9b87"><div class="ttname"><a href="namespaceVectorTools.html#ab2562d41bb26f362043f9719a8cd9b87">VectorTools::interpolate_boundary_values</a></div><div class="ttdeci">void interpolate_boundary_values(const Mapping&lt; dim, spacedim &gt; &amp;mapping, const DoFHandler&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; types::boundary_id, const Function&lt; spacedim, number &gt; * &gt; &amp;function_map, std::map&lt; types::global_dof_index, number &gt; &amp;boundary_values, const ComponentMask &amp;component_mask=ComponentMask())</div></div>
</div><!-- fragment --><p>very similar to how we were making the list of boundary nodes before (note that we set Dirichlet conditions only on boundaries with boundary flag 1). The actual application of the boundary values is then handled by the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object directly, without any additional interference.</p>
<p>We could then proceed as before, namely by filling the matrix, and then calling a condense function on the constraints object of the form </p><div class="fragment"><div class="line">constraints.condense (system_matrix, system_rhs);</div>
</div><!-- fragment --><p>Note that we call this on the system matrix and system right hand side simultaneously, since resolving inhomogeneous constraints requires knowledge about both the matrix entries and the right hand side. For efficiency reasons, though, we choose another strategy: all the constraints collected in the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object can be resolved on the fly while writing local data into the global matrix, by using the call </p><div class="fragment"><div class="line">constraints.distribute_local_to_global (local_matrix, local_rhs,</div>
<div class="line">                                        local_dof_indices,</div>
<div class="line">                                        system_matrix, system_rhs);</div>
</div><!-- fragment --><p>This technique is further discussed in the <a class="el" href="step_27.html">step-27</a> tutorial program. All we need to know here is that this functions does three things at once: it writes the local data into the global matrix and right hand side, it distributes the hanging node constraints and additionally implements (inhomogeneous) Dirichlet boundary conditions. That's nice, isn't it?</p>
<p>We can conclude that the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> class provides an alternative to using <a class="el" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a> for implementing Dirichlet boundary conditions.</p>
<p><a class="anchor" id="constraint-matrix"></a> <a class="anchor" id="UsingAffineConstraintsforincreasingperformance"></a></p><h4>Using <a class="el" href="classAffineConstraints.html">AffineConstraints</a> for increasing performance</h4>
<p>Frequently, a sparse matrix contains a substantial amount of elements that actually are zero when we are about to start a linear solve. Such elements are introduced when we eliminate constraints or implement Dirichlet conditions, where we usually delete all entries in constrained rows and columns, i.e., we set them to zero. The fraction of elements that are present in the sparsity pattern, but do not really contain any information, can be up to one fourth of the total number of elements in the matrix for the 3D application considered in this tutorial program. Remember that matrix-vector products or preconditioners operate on all the elements of a sparse matrix (even those that are zero), which is an inefficiency we will avoid here.</p>
<p>An advantage of directly resolving constrained degrees of freedom is that we can avoid having most of the entries that are going to be zero in our sparse matrix &mdash; we do not need constrained entries during matrix construction (as opposed to the traditional algorithms, which first fill the matrix, and only resolve constraints afterwards). This will save both memory and time when forming matrix-vector products. The way we are going to do that is to pass the information about constraints to the function that generates the sparsity pattern, and then set a <code>false</code> argument specifying that we do not intend to use constrained entries: </p><div class="fragment"><div class="line"><a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a> (dof_handler, sparsity_pattern,</div>
<div class="line">                                 constraints, <span class="keyword">false</span>);</div>
<div class="ttc" id="agroup__constraints_html_gaf78e864edbfba7e0a7477457bfb96b26"><div class="ttname"><a href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a></div><div class="ttdeci">void make_sparsity_pattern(const DoFHandler&lt; dim, spacedim &gt; &amp;dof_handler, SparsityPatternType &amp;sparsity_pattern, const AffineConstraints&lt; number &gt; &amp;constraints=AffineConstraints&lt; number &gt;(), const bool keep_constrained_dofs=true, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id)</div><div class="ttdef"><b>Definition:</b> <a href="dof__tools__sparsity_8cc_source.html#l00064">dof_tools_sparsity.cc:64</a></div></div>
</div><!-- fragment --><p> This functions obviates, by the way, also the call to the <code>condense()</code> function on the sparsity pattern.</p>
<p><a class="anchor" id="Performanceoptimizations"></a></p><h4>Performance optimizations</h4>
<p>The program developed below has seen a lot of TLC. We have run it over and over under profiling tools (mainly <a href="http://www.valgrind.org/">valgrind</a>'s cachegrind and callgrind tools, as well as the KDE <a href="http://kcachegrind.sourceforge.net/">KCachegrind</a> program for visualization) to see where the bottlenecks are. This has paid off: through this effort, the program has become about four times as fast when considering the runtime of the refinement cycles zero through three, reducing the overall number of CPU instructions executed from 869,574,060,348 to 199,853,005,625. For higher refinement levels, the gain is probably even larger since some algorithms that are not \({\cal O}(N)\) have been eliminated.</p>
<p>Essentially, there are currently two algorithms in the program that do not scale linearly with the number of degrees of freedom: renumbering of degrees of freedom (which is \({\cal O}(N \log N)\), and the linear solver (which is \({\cal O}(N^{4/3})\)). As for the first, while reordering degrees of freedom may not scale linearly, it is an indispensable part of the overall algorithm as it greatly improves the quality of the sparse ILU, easily making up for the time spent on computing the renumbering; graphs and timings to demonstrate this are shown in the documentation of the <a class="el" href="namespaceDoFRenumbering.html">DoFRenumbering</a> namespace, also underlining the choice of the Cuthill-McKee reordering algorithm chosen below.</p>
<p>As for the linear solver: as mentioned above, our implementation here uses a Schur complement formulation. This is not necessarily the very best choice but demonstrates various important techniques available in deal.II. The question of which solver is best is again discussed in the <a href="#improved-solver">section on improved solvers in the results part</a> of this program, along with code showing alternative solvers and a comparison of their results.</p>
<p>Apart from this, many other algorithms have been tested and improved during the creation of this program. For example, in building the sparsity pattern, we originally used a (now no longer existing) BlockCompressedSparsityPattern object that added one element at a time; however, its data structures were poorly adapted for the large numbers of nonzero entries per row created by our discretization in 3d, leading to a quadratic behavior. Replacing the internal algorithms in deal.II to set many elements at a time, and using a BlockCompressedSimpleSparsityPattern (which has, as of early 2015, been in turn replaced by <a class="el" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a>) as a better adapted data structure, removed this bottleneck at the price of a slightly higher memory consumption. Likewise, the implementation of the decomposition step in the <a class="el" href="classSparseILU.html">SparseILU</a> class was very inefficient and has been replaced by one that is about 10 times faster. Even the vmult function of the <a class="el" href="classSparseILU.html">SparseILU</a> has been improved to save about twenty percent of time. Small improvements were applied here and there. Moreover, the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object has been used to eliminate a lot of entries in the sparse matrix that are eventually going to be zero, see <a href="#constraint-matrix">the section on using advanced features of the AffineConstraints class</a>.</p>
<p>A profile of how many CPU instructions are spent at the various different places in the program during refinement cycles zero through three in 3d is shown here:</p>
<p><img src="https://www.dealii.org/images/steps/developer/step-22.profile-3.png" alt="" class="inline"/></p>
<p>As can be seen, at this refinement level approximately three quarters of the instruction count is spent on the actual solver (the <a class="el" href="group__Preconditioners.html#gaa16a8a95ca9429c04a4af95d57078f74">SparseILU::vmult</a> calls on the left, the <a class="el" href="classSparseMatrix.html#a7706b5f721efc5ea1966f5a5cdaad0e6">SparseMatrix::vmult</a> call in the middle for the Schur complement solve, and another box representing the multiplications with <a class="el" href="classSparseILU.html">SparseILU</a> and <a class="el" href="classSparseMatrix.html">SparseMatrix</a> in the solve for <em>U</em>). About one fifth of the instruction count is spent on matrix assembly and sparse ILU computation (box in the lower right corner) and the rest on other things. Since floating point operations such as in the <a class="el" href="group__Preconditioners.html#gaa16a8a95ca9429c04a4af95d57078f74">SparseILU::vmult</a> calls typically take much longer than many of the logical operations and table lookups in matrix assembly, the fraction of the run time taken up by matrix assembly is actually significantly less than the fraction of instructions, as will become apparent in the comparison we make in the results section.</p>
<p>For higher refinement levels, the boxes representing the solver as well as the blue box at the top right stemming from reordering algorithm are going to grow at the expense of the other parts of the program, since they don't scale linearly. The fact that at this moderate refinement level (3168 cells and 93176 degrees of freedom) the linear solver already makes up about three quarters of the instructions is a good sign that most of the algorithms used in this program are well-tuned and that major improvements in speeding up the program are most likely not to come from hand-optimizing individual aspects but by changing solver algorithms. We will address this point in the discussion of results below as well.</p>
<p>As a final point, and as a point of reference, the following picture also shows how the profile looked at an early stage of optimizing this program:</p>
<p><img src="https://www.dealii.org/images/steps/developer/step-22.profile-3.original.png" alt="" class="inline"/></p>
<p>As mentioned above, the runtime of this version was about four times as long as for the first profile, with the <a class="el" href="classSparseILU.html">SparseILU</a> decomposition taking up about 30% of the instruction count, and operations an early, inefficient version of <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> about 10%. Both these bottlenecks have since been completely removed.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>As usual, we start by including some well-known files:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__vector_8h.html">deal.II/lac/block_vector.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparse__matrix_8h.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div>
<div class="ttc" id="aaffine__constraints_8h_html"><div class="ttname"><a href="affine__constraints_8h.html">affine_constraints.h</a></div></div>
<div class="ttc" id="ablock__sparse__matrix_8h_html"><div class="ttname"><a href="block__sparse__matrix_8h.html">block_sparse_matrix.h</a></div></div>
<div class="ttc" id="ablock__vector_8h_html"><div class="ttname"><a href="block__vector_8h.html">block_vector.h</a></div></div>
<div class="ttc" id="adof__renumbering_8h_html"><div class="ttname"><a href="dof__renumbering_8h.html">dof_renumbering.h</a></div></div>
<div class="ttc" id="adof__tools_8h_html"><div class="ttname"><a href="dof__tools_8h.html">dof_tools.h</a></div></div>
<div class="ttc" id="adofs_2dof__handler_8h_html"><div class="ttname"><a href="dofs_2dof__handler_8h.html">dof_handler.h</a></div></div>
<div class="ttc" id="aerror__estimator_8h_html"><div class="ttname"><a href="error__estimator_8h.html">error_estimator.h</a></div></div>
<div class="ttc" id="afe_2fe__values_8h_html"><div class="ttname"><a href="fe_2fe__values_8h.html">fe_values.h</a></div></div>
<div class="ttc" id="afe__q_8h_html"><div class="ttname"><a href="fe__q_8h.html">fe_q.h</a></div></div>
<div class="ttc" id="afe__system_8h_html"><div class="ttname"><a href="fe__system_8h.html">fe_system.h</a></div></div>
<div class="ttc" id="afull__matrix_8h_html"><div class="ttname"><a href="full__matrix_8h.html">full_matrix.h</a></div></div>
<div class="ttc" id="afunction_8h_html"><div class="ttname"><a href="function_8h.html">function.h</a></div></div>
<div class="ttc" id="agrid_2grid__refinement_8h_html"><div class="ttname"><a href="grid_2grid__refinement_8h.html">grid_refinement.h</a></div></div>
<div class="ttc" id="agrid_2tria_8h_html"><div class="ttname"><a href="grid_2tria_8h.html">tria.h</a></div></div>
<div class="ttc" id="agrid__generator_8h_html"><div class="ttname"><a href="grid__generator_8h.html">grid_generator.h</a></div></div>
<div class="ttc" id="agrid__tools_8h_html"><div class="ttname"><a href="grid__tools_8h.html">grid_tools.h</a></div></div>
<div class="ttc" id="ainclude_2deal_8II_2base_2utilities_8h_html"><div class="ttname"><a href="include_2deal_8II_2base_2utilities_8h.html">utilities.h</a></div></div>
<div class="ttc" id="alogstream_8h_html"><div class="ttname"><a href="logstream_8h.html">logstream.h</a></div></div>
<div class="ttc" id="amatrix__tools_8h_html"><div class="ttname"><a href="matrix__tools_8h.html">matrix_tools.h</a></div></div>
<div class="ttc" id="anumerics_2data__out_8h_html"><div class="ttname"><a href="numerics_2data__out_8h.html">data_out.h</a></div></div>
<div class="ttc" id="aprecondition_8h_html"><div class="ttname"><a href="precondition_8h.html">precondition.h</a></div></div>
<div class="ttc" id="aquadrature__lib_8h_html"><div class="ttname"><a href="quadrature__lib_8h.html">quadrature_lib.h</a></div></div>
<div class="ttc" id="asolver__cg_8h_html"><div class="ttname"><a href="solver__cg_8h.html">solver_cg.h</a></div></div>
<div class="ttc" id="avector__tools_8h_html"><div class="ttname"><a href="vector__tools_8h.html">vector_tools.h</a></div></div>
</div><!-- fragment --><p>Then we need to include the header file for the sparse direct solver UMFPACK:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div>
<div class="ttc" id="asparse__direct_8h_html"><div class="ttname"><a href="sparse__direct_8h.html">sparse_direct.h</a></div></div>
</div><!-- fragment --><p>This includes the library for the incomplete LU factorization that will be used as a preconditioner in 3D:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__ilu_8h.html">deal.II/lac/sparse_ilu.h</a>&gt;</span></div>
<div class="ttc" id="asparse__ilu_8h_html"><div class="ttname"><a href="sparse__ilu_8h.html">sparse_ilu.h</a></div></div>
</div><!-- fragment --><p>This is C++:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
</div><!-- fragment --><p>As in all programs, the namespace dealii is included:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step22</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
<div class="ttc" id="anamespacedealii_html"><div class="ttname"><a href="namespacedealii.html">dealii</a></div><div class="ttdef"><b>Definition:</b> <a href="namespace__dealii_8h_source.html#l00025">namespace_dealii.h:26</a></div></div>
</div><!-- fragment --><p><a class="anchor" id="Definingtheinnerpreconditionertype"></a> </p><h3>Defining the inner preconditioner type</h3>
<p>As explained in the introduction, we are going to use different preconditioners for two and three space dimensions, respectively. We distinguish between them by the use of the spatial dimension as a template parameter. See <a class="el" href="step_4.html">step-4</a> for details on templates. We are not going to create any preconditioner object here, all we do is to create class that holds a local alias determining the preconditioner class so we can write our program in a dimension-independent way.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">struct </span>InnerPreconditioner;</div>
</div><!-- fragment --><p>In 2D, we are going to use a sparse direct solver as preconditioner:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">struct </span>InnerPreconditioner&lt;2&gt;</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using</span> type = <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a>;</div>
<div class="line">};</div>
</div><!-- fragment --><p>And the ILU preconditioning in 3D, called by <a class="el" href="classSparseILU.html">SparseILU</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">struct </span>InnerPreconditioner&lt;3&gt;</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using</span> type = <a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a>;</div>
<div class="line">};</div>
</div><!-- fragment --><p><a class="anchor" id="ThecodeStokesProblemcodeclasstemplate"></a> </p><h3>The <code>StokesProblem</code> class template</h3>
<p>This is an adaptation of <a class="el" href="step_20.html">step-20</a>, so the main class and the data types are nearly the same as used there. The only difference is that we have an additional member <code>preconditioner_matrix</code>, that is used for preconditioning the Schur complement, and a corresponding sparsity pattern <code>preconditioner_sparsity_pattern</code>. In addition, instead of relying on <a class="el" href="classLinearOperator.html">LinearOperator</a>, we implement our own InverseMatrix class.</p>
<p>In this example we also use adaptive grid refinement, which is handled in analogy to <a class="el" href="step_6.html">step-6</a>. According to the discussion in the introduction, we are also going to use the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object for implementing Dirichlet boundary conditions. Hence, we change the name <code>hanging_node_constraints</code> into <code>constraints</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>StokesProblem</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  StokesProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">void</span> setup_dofs();</div>
<div class="line">  <span class="keywordtype">void</span> assemble_system();</div>
<div class="line">  <span class="keywordtype">void</span> solve();</div>
<div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle) <span class="keyword">const</span>;</div>
<div class="line">  <span class="keywordtype">void</span> refine_mesh();</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div>
<div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>      fe;</div>
<div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>      sparsity_pattern;</div>
<div class="line">  <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> system_matrix;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>      preconditioner_sparsity_pattern;</div>
<div class="line">  <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> preconditioner_matrix;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> solution;</div>
<div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> system_rhs;</div>
<div class="ttc" id="aclassAffineConstraints_html"><div class="ttname"><a href="classAffineConstraints.html">AffineConstraints&lt; double &gt;</a></div></div>
<div class="ttc" id="aclassBlockSparseMatrix_html"><div class="ttname"><a href="classBlockSparseMatrix.html">BlockSparseMatrix</a></div><div class="ttdef"><b>Definition:</b> <a href="block__sparse__matrix_8h_source.html#l00049">block_sparse_matrix.h:50</a></div></div>
<div class="ttc" id="aclassBlockSparsityPattern_html"><div class="ttname"><a href="classBlockSparsityPattern.html">BlockSparsityPattern</a></div><div class="ttdef"><b>Definition:</b> <a href="block__sparsity__pattern_8h_source.html#l00406">block_sparsity_pattern.h:407</a></div></div>
<div class="ttc" id="aclassBlockVector_html"><div class="ttname"><a href="classBlockVector.html">BlockVector</a></div><div class="ttdef"><b>Definition:</b> <a href="block__vector_8h_source.html#l00070">block_vector.h:71</a></div></div>
<div class="ttc" id="aclassDoFHandler_html"><div class="ttname"><a href="classDoFHandler.html">DoFHandler</a></div><div class="ttdef"><b>Definition:</b> <a href="dofs_2dof__handler_8h_source.html#l00314">dof_handler.h:315</a></div></div>
<div class="ttc" id="aclassFESystem_html"><div class="ttname"><a href="classFESystem.html">FESystem</a></div><div class="ttdef"><b>Definition:</b> <a href="fe__system_8h_source.html#l00215">fe_system.h:216</a></div></div>
<div class="ttc" id="aclassTriangulation_html"><div class="ttname"><a href="classTriangulation.html">Triangulation</a></div><div class="ttdef"><b>Definition:</b> <a href="grid_2tria_8h_source.html#l01127">tria.h:1128</a></div></div>
<div class="ttc" id="anamespaceWorkStream_1_1internal_1_1tbb__no__coloring_html_a8673698a405bf47aa24002aeb6d76d70"><div class="ttname"><a href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">WorkStream::internal::tbb_no_coloring::run</a></div><div class="ttdeci">void run(const Iterator &amp;begin, const typename identity&lt; Iterator &gt;::type &amp;end, Worker worker, Copier copier, const ScratchData &amp;sample_scratch_data, const CopyData &amp;sample_copy_data, const unsigned int queue_length, const unsigned int chunk_size)</div><div class="ttdef"><b>Definition:</b> <a href="work__stream_8h_source.html#l00691">work_stream.h:691</a></div></div>
<div class="ttc" id="ap4est__wrappers_8cc_html_ace00f2f80d9780ef9aa1007e1c22c6a4"><div class="ttname"><a href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a></div><div class="ttdeci">const ::parallel::distributed::Triangulation&lt; dim, spacedim &gt; * triangulation</div><div class="ttdef"><b>Definition:</b> <a href="p4est__wrappers_8cc_source.html#l00069">p4est_wrappers.cc:69</a></div></div>
</div><!-- fragment --><p>This one is new: We shall use a so-called shared pointer structure to access the preconditioner. Shared pointers are essentially just a convenient form of pointers. Several shared pointers can point to the same object (just like regular pointers), but when the last shared pointer object to point to a preconditioner object is deleted (for example if a shared pointer object goes out of scope, if the class of which it is a member is destroyed, or if the pointer is assigned a different preconditioner object) then the preconditioner object pointed to is also destroyed. This ensures that we don't have to manually track in how many places a preconditioner object is still referenced, it can never create a memory leak, and can never produce a dangling pointer to an already destroyed object:</p>
<div class="fragment"><div class="line">  std::shared_ptr&lt;typename InnerPreconditioner&lt;dim&gt;::type&gt; A_preconditioner;</div>
<div class="line">};</div>
</div><!-- fragment --><p><a class="anchor" id="Boundaryvaluesandrighthandside"></a> </p><h3>Boundary values and right hand side</h3>
<p>As in <a class="el" href="step_20.html">step-20</a> and most other example programs, the next task is to define the data for the PDE: For the Stokes problem, we are going to use natural boundary values on parts of the boundary (i.e. homogeneous Neumann-type) for which we won't have to do anything special (the homogeneity implies that the corresponding terms in the weak form are simply zero), and boundary conditions on the velocity (Dirichlet-type) on the rest of the boundary, as described in the introduction.</p>
<p>In order to enforce the Dirichlet boundary values on the velocity, we will use the <a class="el" href="namespaceVectorTools.html#ab2562d41bb26f362043f9719a8cd9b87">VectorTools::interpolate_boundary_values</a> function as usual which requires us to write a function object with as many components as the finite element has. In other words, we have to define the function on the \((u,p)\)-space, but we are going to filter out the pressure component when interpolating the boundary values.</p>
<p>The following function object is a representation of the boundary values described in the introduction:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  BoundaryValues()</div>
<div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim + 1)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div>
<div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">vector_value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div>
<div class="line">                            <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  value) <span class="keyword">const override</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div>
<div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component &lt; this-&gt;n_components,</div>
<div class="line">         <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, this-&gt;n_components));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (component == 0)</div>
<div class="line">    <span class="keywordflow">return</span> (p[0] &lt; 0 ? -1 : (p[0] &gt; 0 ? 1 : 0));</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> BoundaryValues&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div>
<div class="line">                                       <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div>
<div class="line">    <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = BoundaryValues&lt;dim&gt;::value(p, c);</div>
<div class="line">}</div>
<div class="ttc" id="aclassFunction_html"><div class="ttname"><a href="classFunction.html">Function</a></div><div class="ttdef"><b>Definition:</b> <a href="function_8h_source.html#l00150">function.h:153</a></div></div>
<div class="ttc" id="aclassFunction_html_acbfcab66b2fc63bfea59268f40772bb4"><div class="ttname"><a href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">Function::value</a></div><div class="ttdeci">virtual RangeNumberType value(const Point&lt; dim &gt; &amp;p, const unsigned int component=0) const</div></div>
<div class="ttc" id="aclassFunction_html_ae316ebc05d21989d573024f8a23c49cb"><div class="ttname"><a href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">Function::vector_value</a></div><div class="ttdeci">virtual void vector_value(const Point&lt; dim &gt; &amp;p, Vector&lt; RangeNumberType &gt; &amp;values) const</div></div>
<div class="ttc" id="aclassPoint_html"><div class="ttname"><a href="classPoint.html">Point</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2point_8h_source.html#l00110">point.h:111</a></div></div>
<div class="ttc" id="aclassVector_html"><div class="ttname"><a href="classVector.html">Vector&lt; double &gt;</a></div></div>
<div class="ttc" id="agroup__Exceptions_html_ga0d685aad996180f9851183ae3e29019a"><div class="ttname"><a href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">StandardExceptions::ExcIndexRange</a></div><div class="ttdeci">static ::ExceptionBase &amp; ExcIndexRange(int arg1, int arg2, int arg3)</div></div>
<div class="ttc" id="agroup__Exceptions_html_ga70a0bb353656e704acf927945277bbc6"><div class="ttname"><a href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a></div><div class="ttdeci">#define Assert(cond, exc)</div><div class="ttdef"><b>Definition:</b> <a href="include_2deal_8II_2base_2exceptions_8h_source.html#l01473">exceptions.h:1473</a></div></div>
<div class="ttc" id="anamespaceEvaluationFlags_html_a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58"><div class="ttname"><a href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a></div><div class="ttdeci">@ values</div><div class="ttdef"><b>Definition:</b> <a href="evaluation__flags_8h_source.html#l00051">evaluation_flags.h:51</a></div></div>
</div><!-- fragment --><p>We implement similar functions for the right hand side which for the current example is simply zero:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  RightHandSide()</div>
<div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim + 1)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div>
<div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">vector_value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div>
<div class="line">                            <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  value) <span class="keyword">const override</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div>
<div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> RightHandSide&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div>
<div class="line">                                      <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div>
<div class="line">    <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = RightHandSide&lt;dim&gt;::value(p, c);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="Linearsolversandpreconditioners"></a> </p><h3>Linear solvers and preconditioners</h3>
<p>The linear solvers and preconditioners are discussed extensively in the introduction. Here, we create the respective objects that will be used.</p>
<p><a class="anchor" id="ThecodeInverseMatrixcodeclasstemplate"></a> </p><h4>The <code>InverseMatrix</code> class template</h4>
<p>The <code>InverseMatrix</code> class represents the data structure for an inverse matrix. Unlike <a class="el" href="step_20.html">step-20</a>, we implement this with a class instead of the helper function inverse_linear_operator() we will apply this class to different kinds of matrices that will require different preconditioners (in <a class="el" href="step_20.html">step-20</a> we only used a non-identity preconditioner for the mass matrix). The types of matrix and preconditioner are passed to this class via template parameters, and matrix and preconditioner objects of these types will then be passed to the constructor when an <code>InverseMatrix</code> object is created. The member function <code>vmult</code> is obtained by solving a linear system:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div>
<div class="line"><span class="keyword">class </span>InverseMatrix : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  InverseMatrix(<span class="keyword">const</span> MatrixType &amp;        m,</div>
<div class="line">                <span class="keyword">const</span> PreconditionerType &amp;preconditioner);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> vmult(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;dst, <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const MatrixType&gt;</a>         <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>;</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const PreconditionerType&gt;</a> preconditioner;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div>
<div class="line">InverseMatrix&lt;MatrixType, PreconditionerType&gt;::InverseMatrix(</div>
<div class="line">  <span class="keyword">const</span> MatrixType &amp;        m,</div>
<div class="line">  <span class="keyword">const</span> PreconditionerType &amp;preconditioner)</div>
<div class="line">  : <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>(&amp;m)</div>
<div class="line">  , preconditioner(&amp;preconditioner)</div>
<div class="line">{}</div>
<div class="ttc" id="aclassSmartPointer_html"><div class="ttname"><a href="classSmartPointer.html">SmartPointer</a></div><div class="ttdef"><b>Definition:</b> <a href="smartpointer_8h_source.html#l00067">smartpointer.h:68</a></div></div>
<div class="ttc" id="aclassSubscriptor_html"><div class="ttname"><a href="classSubscriptor.html">Subscriptor</a></div><div class="ttdef"><b>Definition:</b> <a href="subscriptor_8h_source.html#l00061">subscriptor.h:62</a></div></div>
<div class="ttc" id="anamespaceLAPACKSupport_html_a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003"><div class="ttname"><a href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">LAPACKSupport::matrix</a></div><div class="ttdeci">@ matrix</div><div class="ttdoc">Contents is actually a matrix.</div><div class="ttdef"><b>Definition:</b> <a href="lapack__support_8h_source.html#l00058">lapack_support.h:58</a></div></div>
</div><!-- fragment --><p>This is the implementation of the <code>vmult</code> function.</p>
<p>In this class we use a rather large tolerance for the solver control. The reason for this is that the function is used very frequently, and hence, any additional effort to make the residual in the CG solve smaller makes the solution more expensive. Note that we do not only use this class as a preconditioner for the Schur complement, but also when forming the inverse of the Laplace matrix &ndash; which is hence directly responsible for the accuracy of the solution itself, so we can't choose a too large tolerance, either.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div>
<div class="line"><span class="keywordtype">void</span> InverseMatrix&lt;MatrixType, PreconditionerType&gt;::vmult(</div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;      dst,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(src.<a class="code" href="group__Vectors.html#ga81dcfa5c77bdd426603386c0844149ae">size</a>(), 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-6 * src.<a class="code" href="group__Vectors.html#ga8ee1b8309a7a9ecf109c8a7116733ef8">l2_norm</a>());</div>
<div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div>
<div class="line"> </div>
<div class="line">  dst = 0;</div>
<div class="line"> </div>
<div class="line">  cg.solve(*<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, dst, src, *preconditioner);</div>
<div class="line">}</div>
<div class="ttc" id="aclassSolverCG_html"><div class="ttname"><a href="classSolverCG.html">SolverCG</a></div><div class="ttdef"><b>Definition:</b> <a href="solver__cg_8h_source.html#l00095">solver_cg.h:96</a></div></div>
<div class="ttc" id="aclassSolverControl_html"><div class="ttname"><a href="classSolverControl.html">SolverControl</a></div><div class="ttdef"><b>Definition:</b> <a href="solver__control_8h_source.html#l00065">solver_control.h:66</a></div></div>
<div class="ttc" id="agroup__Vectors_html_ga81dcfa5c77bdd426603386c0844149ae"><div class="ttname"><a href="group__Vectors.html#ga81dcfa5c77bdd426603386c0844149ae">Vector::size</a></div><div class="ttdeci">size_type size() const</div></div>
<div class="ttc" id="agroup__Vectors_html_ga8ee1b8309a7a9ecf109c8a7116733ef8"><div class="ttname"><a href="group__Vectors.html#ga8ee1b8309a7a9ecf109c8a7116733ef8">Vector::l2_norm</a></div><div class="ttdeci">real_type l2_norm() const</div></div>
<div class="ttc" id="anamespacePhysics_1_1Elasticity_1_1Kinematics_html_a9587d5229555daa5b1fa1ba2f8a40adb"><div class="ttname"><a href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">Physics::Elasticity::Kinematics::e</a></div><div class="ttdeci">SymmetricTensor&lt; 2, dim, Number &gt; e(const Tensor&lt; 2, dim, Number &gt; &amp;F)</div></div>
</div><!-- fragment --><p><a class="anchor" id="ThecodeSchurComplementcodeclasstemplate"></a> </p><h4>The <code>SchurComplement</code> class template</h4>
<p>This class implements the Schur complement discussed in the introduction. It is in analogy to <a class="el" href="step_20.html">step-20</a>. Though, we now call it with a template parameter <code>PreconditionerType</code> in order to access that when specifying the respective type of the inverse matrix class. As a consequence of the definition above, the declaration <code>InverseMatrix</code> now contains the second template parameter for a preconditioner class as above, which affects the <code><a class="el" href="classSmartPointer.html">SmartPointer</a></code> object <code>m_inverse</code> as well.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerType&gt;</div>
<div class="line"><span class="keyword">class </span>SchurComplement : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  SchurComplement(</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;system_matrix,</div>
<div class="line">    <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>, PreconditionerType&gt; &amp;A_inverse);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> vmult(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;dst, <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const BlockSparseMatrix&lt;double&gt;</a>&gt; system_matrix;</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer</a>&lt;</div>
<div class="line">    <span class="keyword">const</span> InverseMatrix&lt;SparseMatrix&lt;double&gt;, PreconditionerType&gt;&gt;</div>
<div class="line">    A_inverse;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">mutable</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp1, tmp2;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerType&gt;</div>
<div class="line">SchurComplement&lt;PreconditionerType&gt;::SchurComplement(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;system_matrix,</div>
<div class="line">  <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>, PreconditionerType&gt; &amp;A_inverse)</div>
<div class="line">  : system_matrix(&amp;system_matrix)</div>
<div class="line">  , A_inverse(&amp;A_inverse)</div>
<div class="line">  , tmp1(system_matrix.block(0, 0).m())</div>
<div class="line">  , tmp2(system_matrix.block(0, 0).m())</div>
<div class="line">{}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerType&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">SchurComplement&lt;PreconditionerType&gt;::vmult(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;      dst,</div>
<div class="line">                                           <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  system_matrix-&gt;<a class="code" href="group__Matrix1.html#ga1e54eb8c095bf2191a29c36a7784a5b6">block</a>(0, 1).<a class="code" href="classSparseMatrix.html#a7706b5f721efc5ea1966f5a5cdaad0e6">vmult</a>(tmp1, src);</div>
<div class="line">  A_inverse-&gt;vmult(tmp2, tmp1);</div>
<div class="line">  system_matrix-&gt;block(1, 0).vmult(dst, tmp2);</div>
<div class="line">}</div>
<div class="ttc" id="aclassSparseMatrix_html"><div class="ttname"><a href="classSparseMatrix.html">SparseMatrix&lt; double &gt;</a></div></div>
<div class="ttc" id="aclassSparseMatrix_html_a7706b5f721efc5ea1966f5a5cdaad0e6"><div class="ttname"><a href="classSparseMatrix.html#a7706b5f721efc5ea1966f5a5cdaad0e6">SparseMatrix::vmult</a></div><div class="ttdeci">void vmult(OutVector &amp;dst, const InVector &amp;src) const</div></div>
<div class="ttc" id="agroup__Matrix1_html_ga1e54eb8c095bf2191a29c36a7784a5b6"><div class="ttname"><a href="group__Matrix1.html#ga1e54eb8c095bf2191a29c36a7784a5b6">BlockMatrixBase::block</a></div><div class="ttdeci">BlockType &amp; block(const unsigned int row, const unsigned int column)</div></div>
</div><!-- fragment --><p><a class="anchor" id="StokesProblemclassimplementation"></a> </p><h3>StokesProblem class implementation</h3>
<p><a class="anchor" id="StokesProblemStokesProblem"></a> </p><h4>StokesProblem::StokesProblem</h4>
<p>The constructor of this class looks very similar to the one of <a class="el" href="step_20.html">step-20</a>. The constructor initializes the variables for the polynomial degree, triangulation, finite element system and the dof handler. The underlying polynomial functions are of order <code>degree+1</code> for the vector-valued velocity components and of order <code>degree</code> for the pressure. This gives the LBB-stable element pair \(Q_{degree+1}^d\times Q_{degree}\), often referred to as the Taylor-Hood element.</p>
<p>Note that we initialize the triangulation with a MeshSmoothing argument, which ensures that the refinement of cells is done in a way that the approximation of the PDE solution remains well-behaved (problems arise if grids are too unstructured), see the documentation of <code><a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">Triangulation::MeshSmoothing</a></code> for details.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">StokesProblem&lt;dim&gt;::StokesProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div>
<div class="line">  : degree(degree)</div>
<div class="line">  , <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::maximum_smoothing)</div>
<div class="line">  , fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(degree + 1), dim, <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(degree), 1)</div>
<div class="line">  , dof_handler(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>)</div>
<div class="line">{}</div>
<div class="ttc" id="aclassFE__Q_html"><div class="ttname"><a href="classFE__Q.html">FE_Q</a></div><div class="ttdef"><b>Definition:</b> <a href="fe__q_8h_source.html#l00548">fe_q.h:549</a></div></div>
</div><!-- fragment --><p><a class="anchor" id="StokesProblemsetup_dofs"></a> </p><h4>StokesProblem::setup_dofs</h4>
<p>Given a mesh, this function associates the degrees of freedom with it and creates the corresponding matrices and vectors. At the beginning it also releases the pointer to the preconditioner object (if the shared pointer pointed at anything at all at this point) since it will definitely not be needed any more after this point and will have to be re-computed after assembling the matrix, and unties the sparse matrices from their sparsity pattern objects.</p>
<p>We then proceed with distributing degrees of freedom and renumbering them: In order to make the ILU preconditioner (in 3D) work efficiently, it is important to enumerate the degrees of freedom in such a way that it reduces the bandwidth of the matrix, or maybe more importantly: in such a way that the ILU is as close as possible to a real LU decomposition. On the other hand, we need to preserve the block structure of velocity and pressure already seen in <a class="el" href="step_20.html">step-20</a> and <a class="el" href="step_21.html">step-21</a>. This is done in two steps: First, all dofs are renumbered to improve the ILU and then we renumber once again by components. Since <code><a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a></code> does not touch the renumbering within the individual blocks, the basic renumbering from the first step remains. As for how the renumber degrees of freedom to improve the ILU: deal.II has a number of algorithms that attempt to find orderings to improve ILUs, or reduce the bandwidth of matrices, or optimize some other aspect. The <a class="el" href="namespaceDoFRenumbering.html">DoFRenumbering</a> namespace shows a comparison of the results we obtain with several of these algorithms based on the testcase discussed here in this tutorial program. Here, we will use the traditional Cuthill-McKee algorithm already used in some of the previous tutorial programs. In the <a href="#improved-ilu">section on improved ILU</a> we're going to discuss this issue in more detail.</p>
<p>There is one more change compared to previous tutorial programs: There is no reason in sorting the <code>dim</code> velocity components individually. In fact, rather than first enumerating all \(x\)-velocities, then all \(y\)-velocities, etc, we would like to keep all velocities at the same location together and only separate between velocities (all components) and pressures. By default, this is not what the <a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a> function does: it treats each vector component separately; what we have to do is group several components into "blocks" and pass this block structure to that function. Consequently, we allocate a vector <code>block_component</code> with as many elements as there are components and describe all velocity components to correspond to block 0, while the pressure component will form block 1:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::setup_dofs()</div>
<div class="line">{</div>
<div class="line">  A_preconditioner.reset();</div>
<div class="line">  system_matrix.clear();</div>
<div class="line">  preconditioner_matrix.clear();</div>
<div class="line"> </div>
<div class="line">  dof_handler.distribute_dofs(fe);</div>
<div class="line">  <a class="code" href="namespaceDoFRenumbering.html#a68651164485490b86d901d9ae1fbfc3b">DoFRenumbering::Cuthill_McKee</a>(dof_handler);</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;unsigned int&gt; block_component(dim + 1, 0);</div>
<div class="line">  block_component[dim] = 1;</div>
<div class="line">  <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(dof_handler, block_component);</div>
<div class="ttc" id="anamespaceDoFRenumbering_html_a52c1941406d1ce2937e29a46edf111f4"><div class="ttname"><a href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a></div><div class="ttdeci">void component_wise(DoFHandler&lt; dim, spacedim &gt; &amp;dof_handler, const std::vector&lt; unsigned int &gt; &amp;target_component=std::vector&lt; unsigned int &gt;())</div><div class="ttdef"><b>Definition:</b> <a href="dof__renumbering_8cc_source.html#l00681">dof_renumbering.cc:681</a></div></div>
<div class="ttc" id="anamespaceDoFRenumbering_html_a68651164485490b86d901d9ae1fbfc3b"><div class="ttname"><a href="namespaceDoFRenumbering.html#a68651164485490b86d901d9ae1fbfc3b">DoFRenumbering::Cuthill_McKee</a></div><div class="ttdeci">void Cuthill_McKee(DoFHandler&lt; dim, spacedim &gt; &amp;dof_handler, const bool reversed_numbering=false, const bool use_constraints=false, const std::vector&lt; types::global_dof_index &gt; &amp;starting_indices=std::vector&lt; types::global_dof_index &gt;())</div><div class="ttdef"><b>Definition:</b> <a href="dof__renumbering_8cc_source.html#l00366">dof_renumbering.cc:366</a></div></div>
</div><!-- fragment --><p>Now comes the implementation of Dirichlet boundary conditions, which should be evident after the discussion in the introduction. All that changed is that the function already appears in the setup functions, whereas we were used to see it in some assembly routine. Further down below where we set up the mesh, we will associate the top boundary where we impose Dirichlet boundary conditions with boundary indicator</p><ol type="1">
<li>We will have to pass this boundary indicator as second argument to the function below interpolating boundary values. There is one more thing, though. The function describing the Dirichlet conditions was defined for all components, both velocity and pressure. However, the Dirichlet conditions are to be set for the velocity only. To this end, we use a <a class="el" href="classComponentMask.html">ComponentMask</a> that only selects the velocity components. The component mask is obtained from the finite element by specifying the particular components we want. Since we use adaptively refined grids, the affine constraints object needs to be first filled with hanging node constraints generated from the DoF handler. Note the order of the two functions &mdash; we first compute the hanging node constraints, and then insert the boundary values into the constraints object. This makes sure that we respect H<sup>1</sup> conformity on boundaries with hanging nodes (in three space dimensions), where the hanging node needs to dominate the Dirichlet boundary values.</li>
</ol>
<div class="fragment"><div class="line">{</div>
<div class="line">  constraints.clear();</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div>
<div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div>
<div class="line">  <a class="code" href="namespaceVectorTools.html#ab2562d41bb26f362043f9719a8cd9b87">VectorTools::interpolate_boundary_values</a>(dof_handler,</div>
<div class="line">                                           1,</div>
<div class="line">                                           BoundaryValues&lt;dim&gt;(),</div>
<div class="line">                                           constraints,</div>
<div class="line">                                           fe.component_mask(velocities));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">constraints.close();</div>
<div class="ttc" id="agroup__constraints_html_ga3b4ea7dfd313e388d868c4e4aa685799"><div class="ttname"><a href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a></div><div class="ttdeci">void make_hanging_node_constraints(const DoFHandler&lt; dim, spacedim &gt; &amp;dof_handler, AffineConstraints&lt; number &gt; &amp;constraints)</div><div class="ttdef"><b>Definition:</b> <a href="dof__tools__constraints_8cc_source.html#l01787">dof_tools_constraints.cc:1787</a></div></div>
<div class="ttc" id="astructFEValuesExtractors_1_1Vector_html"><div class="ttname"><a href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a></div><div class="ttdef"><b>Definition:</b> <a href="fe__values__extractors_8h_source.html#l00150">fe_values_extractors.h:151</a></div></div>
</div><!-- fragment --><p>In analogy to <a class="el" href="step_20.html">step-20</a>, we count the dofs in the individual components. We could do this in the same way as there, but we want to operate on the block structure we used already for the renumbering: The function <code><a class="el" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a></code> does the same as <code><a class="el" href="namespaceDoFTools.html#a956ac5c6aab03ec1c04f1ad955301db9">DoFTools::count_dofs_per_fe_component</a></code>, but now grouped as velocity and pressure block via <code>block_component</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; dofs_per_block =</div>
<div class="line">  <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(dof_handler, block_component);</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = dofs_per_block[0];</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_p = dofs_per_block[1];</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells: &quot;</span> &lt;&lt; <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.n_active_cells()</div>
<div class="line">          &lt;&lt; std::endl</div>
<div class="line">          &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div>
<div class="line">          &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl;</div>
<div class="ttc" id="anamespaceDoFTools_html_a796721b56b3a90e4e3973c7caae4c3d8"><div class="ttname"><a href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a></div><div class="ttdeci">std::vector&lt; types::global_dof_index &gt; count_dofs_per_fe_block(const DoFHandler&lt; dim, spacedim &gt; &amp;dof, const std::vector&lt; unsigned int &gt; &amp;target_block=std::vector&lt; unsigned int &gt;())</div><div class="ttdef"><b>Definition:</b> <a href="dof__tools_8cc_source.html#l02047">dof_tools.cc:2047</a></div></div>
</div><!-- fragment --><p>The next task is to allocate a sparsity pattern for the system matrix we will create and one for the preconditioner matrix. We could do this in the same way as in <a class="el" href="step_20.html">step-20</a>, i.e. directly build an object of type <a class="el" href="classSparsityPattern.html">SparsityPattern</a> through <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>. However, there is a major reason not to do so: In 3D, the function DoFTools::max_couplings_between_dofs yields a conservative but rather large number for the coupling between the individual dofs, so that the memory initially provided for the creation of the sparsity pattern of the matrix is far too much &ndash; so much actually that the initial sparsity pattern won't even fit into the physical memory of most systems already for moderately-sized 3D problems, see also the discussion in <a class="el" href="step_18.html">step-18</a>. Instead, we first build temporary objects that use a different data structure that doesn't require allocating more memory than necessary but isn't suitable for use as a basis of <a class="el" href="classSparseMatrix.html">SparseMatrix</a> or <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a> objects; in a second step we then copy these objects into objects of type <a class="el" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>. This is entirely analogous to what we already did in <a class="el" href="step_11.html">step-11</a> and <a class="el" href="step_18.html">step-18</a>. In particular, we make use of the fact that we will never write into the \((1,1)\) block of the system matrix and that this is the only block to be filled for the preconditioner matrix.</p>
<p>All this is done inside new scopes, which means that the memory of <code>dsp</code> will be released once the information has been copied to <code>sparsity_pattern</code>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(2, 2);</div>
<div class="line"> </div>
<div class="line">  dsp.block(0, 0).reinit(n_u, n_u);</div>
<div class="line">  dsp.block(1, 0).reinit(n_p, n_u);</div>
<div class="line">  dsp.block(0, 1).reinit(n_u, n_p);</div>
<div class="line">  dsp.block(1, 1).reinit(n_p, n_p);</div>
<div class="line"> </div>
<div class="line">  dsp.collect_sizes();</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div>
<div class="line">      <span class="keywordflow">if</span> (!((c == dim) &amp;&amp; (<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> == dim)))</div>
<div class="line">        coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">        coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div>
<div class="line">    dof_handler, coupling, dsp, constraints, <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">  sparsity_pattern.copy_from(dsp);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> preconditioner_dsp(2, 2);</div>
<div class="line"> </div>
<div class="line">  preconditioner_dsp.block(0, 0).reinit(n_u, n_u);</div>
<div class="line">  preconditioner_dsp.block(1, 0).reinit(n_p, n_u);</div>
<div class="line">  preconditioner_dsp.block(0, 1).reinit(n_u, n_p);</div>
<div class="line">  preconditioner_dsp.block(1, 1).reinit(n_p, n_p);</div>
<div class="line"> </div>
<div class="line">  preconditioner_dsp.collect_sizes();</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> preconditioner_coupling(dim + 1, dim + 1);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div>
<div class="line">      <span class="keywordflow">if</span> (((c == dim) &amp;&amp; (<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> == dim)))</div>
<div class="line">        preconditioner_coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">        preconditioner_coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler,</div>
<div class="line">                                  preconditioner_coupling,</div>
<div class="line">                                  preconditioner_dsp,</div>
<div class="line">                                  constraints,</div>
<div class="line">                                  <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">  preconditioner_sparsity_pattern.copy_from(preconditioner_dsp);</div>
<div class="line">}</div>
<div class="ttc" id="aclassBlockDynamicSparsityPattern_html"><div class="ttname"><a href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a></div><div class="ttdef"><b>Definition:</b> <a href="block__sparsity__pattern_8h_source.html#l00524">block_sparsity_pattern.h:526</a></div></div>
<div class="ttc" id="aclassTable_html"><div class="ttname"><a href="classTable.html">Table</a></div><div class="ttdef"><b>Definition:</b> <a href="table_8h_source.html#l00666">table.h:667</a></div></div>
<div class="ttc" id="anamespaceDoFTools_html_ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba"><div class="ttname"><a href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a></div><div class="ttdeci">@ none</div><div class="ttdef"><b>Definition:</b> <a href="dof__tools_8h_source.html#l00231">dof_tools.h:231</a></div></div>
<div class="ttc" id="anamespaceDoFTools_html_ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec"><div class="ttname"><a href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a></div><div class="ttdeci">@ always</div><div class="ttdef"><b>Definition:</b> <a href="dof__tools_8h_source.html#l00235">dof_tools.h:235</a></div></div>
<div class="ttc" id="anamespacePhysics_1_1Elasticity_1_1Kinematics_html_a15728437b942dab0b0042eb06a407d2c"><div class="ttname"><a href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">Physics::Elasticity::Kinematics::d</a></div><div class="ttdeci">SymmetricTensor&lt; 2, dim, Number &gt; d(const Tensor&lt; 2, dim, Number &gt; &amp;F, const Tensor&lt; 2, dim, Number &gt; &amp;dF_dt)</div></div>
</div><!-- fragment --><p>Finally, the system matrix, the preconsitioner matrix, the solution and the right hand side vector are created from the block structure similar to the approach in <a class="el" href="step_20.html">step-20</a>:</p>
<div class="fragment"><div class="line">  system_matrix.reinit(sparsity_pattern);</div>
<div class="line">  preconditioner_matrix.reinit(preconditioner_sparsity_pattern);</div>
<div class="line"> </div>
<div class="line">  solution.reinit(2);</div>
<div class="line">  solution.block(0).reinit(n_u);</div>
<div class="line">  solution.block(1).reinit(n_p);</div>
<div class="line">  solution.collect_sizes();</div>
<div class="line"> </div>
<div class="line">  system_rhs.reinit(2);</div>
<div class="line">  system_rhs.block(0).reinit(n_u);</div>
<div class="line">  system_rhs.block(1).reinit(n_p);</div>
<div class="line">  system_rhs.collect_sizes();</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="StokesProblemassemble_system"></a> </p><h4>StokesProblem::assemble_system</h4>
<p>The assembly process follows the discussion in <a class="el" href="step_20.html">step-20</a> and in the introduction. We use the well-known abbreviations for the data structures that hold the local matrices, right hand side, and global numbering of the degrees of freedom for the present cell.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::assemble_system()</div>
<div class="line">{</div>
<div class="line">  system_matrix         = 0;</div>
<div class="line">  system_rhs            = 0;</div>
<div class="line">  preconditioner_matrix = 0;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(degree + 2);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div>
<div class="line">                          quadrature_formula,</div>
<div class="line">                          <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div>
<div class="line">                            <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.size();</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div>
<div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_preconditioner_matrix(dofs_per_cell,</div>
<div class="line">                                                 dofs_per_cell);</div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     local_rhs(dofs_per_cell);</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> RightHandSide&lt;dim&gt;    right_hand_side;</div>
<div class="line">  std::vector&lt;Vector&lt;double&gt;&gt; rhs_values(n_q_points, <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim + 1));</div>
<div class="ttc" id="aclassFEValues_html"><div class="ttname"><a href="classFEValues.html">FEValues</a></div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__values_8h_source.html#l03905">fe_values.h:3906</a></div></div>
<div class="ttc" id="aclassFullMatrix_html"><div class="ttname"><a href="classFullMatrix.html">FullMatrix&lt; double &gt;</a></div></div>
<div class="ttc" id="aclassQGauss_html"><div class="ttname"><a href="classQGauss.html">QGauss</a></div><div class="ttdef"><b>Definition:</b> <a href="quadrature__lib_8h_source.html#l00038">quadrature_lib.h:39</a></div></div>
<div class="ttc" id="afe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea"><div class="ttname"><a href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a></div><div class="ttdeci">@ update_values</div><div class="ttdoc">Shape function values.</div><div class="ttdef"><b>Definition:</b> <a href="fe__update__flags_8h_source.html#l00078">fe_update_flags.h:78</a></div></div>
<div class="ttc" id="afe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85"><div class="ttname"><a href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a></div><div class="ttdeci">@ update_JxW_values</div><div class="ttdoc">Transformed quadrature weights.</div><div class="ttdef"><b>Definition:</b> <a href="fe__update__flags_8h_source.html#l00129">fe_update_flags.h:129</a></div></div>
<div class="ttc" id="afe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20"><div class="ttname"><a href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a></div><div class="ttdeci">@ update_gradients</div><div class="ttdoc">Shape function gradients.</div><div class="ttdef"><b>Definition:</b> <a href="fe__update__flags_8h_source.html#l00084">fe_update_flags.h:84</a></div></div>
<div class="ttc" id="afe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a"><div class="ttname"><a href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a></div><div class="ttdeci">@ update_quadrature_points</div><div class="ttdoc">Transformed quadrature points.</div><div class="ttdef"><b>Definition:</b> <a href="fe__update__flags_8h_source.html#l00122">fe_update_flags.h:122</a></div></div>
</div><!-- fragment --><p>Next, we need two objects that work as extractors for the <a class="el" href="classFEValues.html">FEValues</a> object. Their use is explained in detail in the report on <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> :</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div>
<div class="ttc" id="astructFEValuesExtractors_1_1Scalar_html"><div class="ttname"><a href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="ttdef"><b>Definition:</b> <a href="fe__values__extractors_8h_source.html#l00095">fe_values_extractors.h:96</a></div></div>
</div><!-- fragment --><p>As an extension over <a class="el" href="step_20.html">step-20</a> and <a class="el" href="step_21.html">step-21</a>, we include a few optimizations that make assembly much faster for this particular problem. The improvements are based on the observation that we do a few calculations too many times when we do as in <a class="el" href="step_20.html">step-20</a>: The symmetric gradient actually has <code>dofs_per_cell</code> different values per quadrature point, but we extract it <code>dofs_per_cell*dofs_per_cell</code> times from the <a class="el" href="classFEValues.html">FEValues</a> object - for both the loop over <code>i</code> and the inner loop over <code>j</code>. In 3d, that means evaluating it \(89^2=7921\) instead of \(89\) times, a not insignificant difference.</p>
<p>So what we're going to do here is to avoid such repeated calculations by getting a vector of rank-2 tensors (and similarly for the divergence and the basis function value on pressure) at the quadrature point prior to starting the loop over the dofs on the cell. First, we create the respective objects that will hold these values. Then, we start the loop over all cells and the loop over the quadrature points, where we first extract these values. There is one more optimization we implement here: the local matrix (as well as the global one) is going to be symmetric, since all the operations involved are symmetric with respect to \(i\) and \(j\). This is implemented by simply running the inner loop not to <code>dofs_per_cell</code>, but only up to <code>i</code>, the index of the outer loop.</p>
<div class="fragment"><div class="line">std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; symgrad_phi_u(dofs_per_cell);</div>
<div class="line">std::vector&lt;double&gt;                  div_phi_u(dofs_per_cell);</div>
<div class="line">std::vector&lt;double&gt;                  phi_p(dofs_per_cell);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.active_cell_iterators())</div>
<div class="line">  {</div>
<div class="line">    fe_values.reinit(cell);</div>
<div class="line">    local_matrix                = 0;</div>
<div class="line">    local_preconditioner_matrix = 0;</div>
<div class="line">    local_rhs                   = 0;</div>
<div class="line"> </div>
<div class="line">    right_hand_side.vector_value_list(fe_values.get_quadrature_points(),</div>
<div class="line">                                      rhs_values);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div>
<div class="line">      {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div>
<div class="line">          {</div>
<div class="line">            symgrad_phi_u[k] =</div>
<div class="line">              fe_values[velocities].symmetric_gradient(k, q);</div>
<div class="line">            div_phi_u[k] = fe_values[velocities].divergence(k, q);</div>
<div class="line">            phi_p[k]     = fe_values[pressure].value(k, q);</div>
<div class="line">          }</div>
</div><!-- fragment --><p>Now finally for the bilinear forms of both the system matrix and the matrix we use for the preconditioner. Recall that the formulas for these two are </p><p class="formulaDsp">
\begin{align*} A_{ij} &amp;= a(\varphi_i,\varphi_j) \\ &amp;= \underbrace{2(\varepsilon(\varphi_{i,\textbf{u}}), \varepsilon(\varphi_{j,\textbf{u}}))_{\Omega}} _{(1)} \; \underbrace{- (\textrm{div}\; \varphi_{i,\textbf{u}}, \varphi_{j,p})_{\Omega}} _{(2)} \; \underbrace{- (\varphi_{i,p}, \textrm{div}\; \varphi_{j,\textbf{u}})_{\Omega}} _{(3)} \end{align*}
</p>
<p> and </p><p class="formulaDsp">
\begin{align*} M_{ij} &amp;= \underbrace{(\varphi_{i,p}, \varphi_{j,p})_{\Omega}} _{(4)}, \end{align*}
</p>
<p> respectively, where \(\varphi_{i,\textbf{u}}\) and \(\varphi_{i,p}\) are the velocity and pressure components of the \(i\)th shape function. The various terms above are then easily recognized in the following implementation:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt;= i; ++j)</div>
<div class="line">      {</div>
<div class="line">        local_matrix(i, j) +=</div>
<div class="line">          (2 * (symgrad_phi_u[i] * symgrad_phi_u[j]) <span class="comment">// (1)</span></div>
<div class="line">           - div_phi_u[i] * phi_p[j]                 <span class="comment">// (2)</span></div>
<div class="line">           - phi_p[i] * div_phi_u[j])                <span class="comment">// (3)</span></div>
<div class="line">          * fe_values.JxW(q);                        <span class="comment">// * dx</span></div>
<div class="line"> </div>
<div class="line">        local_preconditioner_matrix(i, j) +=</div>
<div class="line">          (phi_p[i] * phi_p[j]) <span class="comment">// (4)</span></div>
<div class="line">          * fe_values.JxW(q);   <span class="comment">// * dx</span></div>
<div class="line">      }</div>
</div><!-- fragment --><p>Note that in the implementation of (1) above, <code>operator*</code> is overloaded for symmetric tensors, yielding the scalar product between the two tensors.</p>
<p>For the right-hand side we use the fact that the shape functions are only non-zero in one component (because our elements are primitive). Instead of multiplying the tensor representing the dim+1 values of shape function i with the whole right-hand side vector, we only look at the only non-zero component. The function <a class="el" href="classFiniteElement.html#a23200d54e40cd719a183d47b6cfb719f">FiniteElement::system_to_component_index</a> will return which component this shape function lives in (0=x velocity, 1=y velocity, 2=pressure in 2d), which we use to pick out the correct component of the right-hand side vector to multiply with.</p>
<div class="fragment"><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component_i =</div>
<div class="line">        fe.system_to_component_index(i).first;</div>
<div class="line">      local_rhs(i) += (fe_values.shape_value(i, q)   <span class="comment">// (phi_u_i(x_q)</span></div>
<div class="line">                       * rhs_values[q](component_i)) <span class="comment">// * f(x_q))</span></div>
<div class="line">                      * fe_values.JxW(q);            <span class="comment">// * dx</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Before we can write the local data into the global matrix (and simultaneously use the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object to apply Dirichlet boundary conditions and eliminate hanging node constraints, as we discussed in the introduction), we have to be careful about one thing, though. We have only built half of the local matrices because of symmetry, but we're going to save the full matrices in order to use the standard functions for solving. This is done by flipping the indices in case we are pointing into the empty part of the local matrices.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = i + 1; j &lt; dofs_per_cell; ++j)</div>
<div class="line">      {</div>
<div class="line">        local_matrix(i, j) = local_matrix(j, i);</div>
<div class="line">        local_preconditioner_matrix(i, j) =</div>
<div class="line">          local_preconditioner_matrix(j, i);</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">  cell-&gt;get_dof_indices(local_dof_indices);</div>
<div class="line">  constraints.distribute_local_to_global(local_matrix,</div>
<div class="line">                                         local_rhs,</div>
<div class="line">                                         local_dof_indices,</div>
<div class="line">                                         system_matrix,</div>
<div class="line">                                         system_rhs);</div>
<div class="line">  constraints.distribute_local_to_global(local_preconditioner_matrix,</div>
<div class="line">                                         local_dof_indices,</div>
<div class="line">                                         preconditioner_matrix);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Before we're going to solve this linear system, we generate a preconditioner for the velocity-velocity matrix, i.e., <code>block(0,0)</code> in the system matrix. As mentioned above, this depends on the spatial dimension. Since the two classes described by the <code>InnerPreconditioner::type</code> alias have the same interface, we do not have to do anything different whether we want to use a sparse direct solver or an ILU:</p>
<div class="fragment"><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Computing preconditioner...&quot;</span> &lt;&lt; std::endl &lt;&lt; std::flush;</div>
<div class="line"> </div>
<div class="line">  A_preconditioner =</div>
<div class="line">    std::make_shared&lt;typename InnerPreconditioner&lt;dim&gt;::type&gt;();</div>
<div class="line">  A_preconditioner-&gt;initialize(</div>
<div class="line">    system_matrix.block(0, 0),</div>
<div class="line">    <span class="keyword">typename</span> InnerPreconditioner&lt;dim&gt;::type::AdditionalData());</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="StokesProblemsolve"></a> </p><h4>StokesProblem::solve</h4>
<p>After the discussion in the introduction and the definition of the respective classes above, the implementation of the <code>solve</code> function is rather straight-forward and done in a similar way as in <a class="el" href="step_20.html">step-20</a>. To start with, we need an object of the <code>InverseMatrix</code> class that represents the inverse of the matrix A. As described in the introduction, the inverse is generated with the help of an inner preconditioner of type <code>InnerPreconditioner::type</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::solve()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> InverseMatrix&lt;SparseMatrix&lt;double&gt;,</div>
<div class="line">                      <span class="keyword">typename</span> InnerPreconditioner&lt;dim&gt;::type&gt;</div>
<div class="line">                 A_inverse(system_matrix.block(0, 0), *A_preconditioner);</div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp(solution.block(0).size());</div>
</div><!-- fragment --><p>This is as in <a class="el" href="step_20.html">step-20</a>. We generate the right hand side \(B A^{-1} F - G\) for the Schur complement and an object that represents the respective linear operation \(B A^{-1} B^T\), now with a template parameter indicating the preconditioner - in accordance with the definition of the class.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> schur_rhs(solution.block(1).size());</div>
<div class="line">  A_inverse.vmult(tmp, system_rhs.block(0));</div>
<div class="line">  system_matrix.block(1, 0).vmult(schur_rhs, tmp);</div>
<div class="line">  schur_rhs -= system_rhs.block(1);</div>
<div class="line"> </div>
<div class="line">  SchurComplement&lt;typename InnerPreconditioner&lt;dim&gt;::type&gt; <a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>(</div>
<div class="line">    system_matrix, A_inverse);</div>
<div class="ttc" id="agroup__LAOperators_html_ga76acca911f21089cd3bb385d20ccc995"><div class="ttname"><a href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">LinearOperator::schur_complement</a></div><div class="ttdeci">LinearOperator&lt; Range_2, Domain_2, Payload &gt; schur_complement(const LinearOperator&lt; Domain_1, Range_1, Payload &gt; &amp;A_inv, const LinearOperator&lt; Range_1, Domain_2, Payload &gt; &amp;B, const LinearOperator&lt; Range_2, Domain_1, Payload &gt; &amp;C, const LinearOperator&lt; Range_2, Domain_2, Payload &gt; &amp;D)</div><div class="ttdef"><b>Definition:</b> <a href="schur__complement_8h_source.html#l00248">schur_complement.h:248</a></div></div>
</div><!-- fragment --><p>The usual control structures for the solver call are created...</p>
<div class="fragment"><div class="line"><a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(solution.block(1).size(),</div>
<div class="line">                             1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-6 * schur_rhs.l2_norm());</div>
<div class="line"><a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div>
</div><!-- fragment --><p>Now to the preconditioner to the Schur complement. As explained in the introduction, the preconditioning is done by a mass matrix in the pressure variable.</p>
<p>Actually, the solver needs to have the preconditioner in the form \(P^{-1}\), so we need to create an inverse operation. Once again, we use an object of the class <code>InverseMatrix</code>, which implements the <code>vmult</code> operation that is needed by the solver. In this case, we have to invert the pressure mass matrix. As it already turned out in earlier tutorial programs, the inversion of a mass matrix is a rather cheap and straight-forward operation (compared to, e.g., a Laplace matrix). The CG method with ILU preconditioning converges in 5-10 steps, independently on the mesh size. This is precisely what we do here: We choose another ILU preconditioner and take it along to the InverseMatrix object via the corresponding template parameter. A CG solver is then called within the vmult operation of the inverse matrix.</p>
<p>An alternative that is cheaper to build, but needs more iterations afterwards, would be to choose a SSOR preconditioner with factor 1.2. It needs about twice the number of iterations, but the costs for its generation are almost negligible.</p>
<div class="fragment"><div class="line"><a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a> preconditioner;</div>
<div class="line">preconditioner.<a class="code" href="group__Preconditioners.html#gae4b56dfaab3fd8820faa1b21160b1acb">initialize</a>(preconditioner_matrix.block(1, 1),</div>
<div class="line">                          <a class="code" href="group__Preconditioners.html#gae21347f3202a1186060eac36dcb45817">SparseILU&lt;double&gt;::AdditionalData</a>());</div>
<div class="line"> </div>
<div class="line">InverseMatrix&lt;SparseMatrix&lt;double&gt;, <a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a>&gt; m_inverse(</div>
<div class="line">  preconditioner_matrix.block(1, 1), preconditioner);</div>
<div class="ttc" id="agroup__Preconditioners_html_gae21347f3202a1186060eac36dcb45817"><div class="ttname"><a href="group__Preconditioners.html#gae21347f3202a1186060eac36dcb45817">SparseILU::AdditionalData</a></div><div class="ttdeci">typename SparseLUDecomposition&lt; number &gt;::AdditionalData AdditionalData</div><div class="ttdef"><b>Definition:</b> <a href="sparse__ilu_8h_source.html#l00079">sparse_ilu.h:79</a></div></div>
<div class="ttc" id="agroup__Preconditioners_html_gae4b56dfaab3fd8820faa1b21160b1acb"><div class="ttname"><a href="group__Preconditioners.html#gae4b56dfaab3fd8820faa1b21160b1acb">SparseILU::initialize</a></div><div class="ttdeci">void initialize(const SparseMatrix&lt; somenumber &gt; &amp;matrix, const AdditionalData &amp;parameters=AdditionalData())</div></div>
</div><!-- fragment --><p>With the Schur complement and an efficient preconditioner at hand, we can solve the respective equation for the pressure (i.e. block 0 in the solution vector) in the usual way:</p>
<div class="fragment"><div class="line">cg.solve(<a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>, solution.block(1), schur_rhs, m_inverse);</div>
</div><!-- fragment --><p>After this first solution step, the hanging node constraints have to be distributed to the solution in order to achieve a consistent pressure field.</p>
<div class="fragment"><div class="line">  constraints.distribute(solution);</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; solver_control.last_step()</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot; outer CG Schur complement iterations for pressure&quot;</span></div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p>As in <a class="el" href="step_20.html">step-20</a>, we finally need to solve for the velocity equation where we plug in the solution to the pressure equation. This involves only objects we already know - so we simply multiply \(p\) by \(B^T\), subtract the right hand side and multiply by the inverse of \(A\). At the end, we need to distribute the constraints from hanging nodes in order to obtain a consistent flow field:</p>
<div class="fragment"><div class="line">  {</div>
<div class="line">    system_matrix.block(0, 1).vmult(tmp, solution.block(1));</div>
<div class="line">    tmp *= -1;</div>
<div class="line">    tmp += system_rhs.block(0);</div>
<div class="line"> </div>
<div class="line">    A_inverse.vmult(solution.block(0), tmp);</div>
<div class="line"> </div>
<div class="line">    constraints.distribute(solution);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="StokesProblemoutput_results"></a> </p><h4>StokesProblem::output_results</h4>
<p>The next function generates graphical output. In this example, we are going to use the VTK file format. We attach names to the individual variables in the problem: <code>velocity</code> to the <code>dim</code> components of velocity and <code>pressure</code> to the pressure.</p>
<p>Not all visualization programs have the ability to group individual vector components into a vector to provide vector plots; in particular, this holds for some VTK-based visualization programs. In this case, the logical grouping of components into vectors should already be described in the file containing the data. In other words, what we need to do is provide our output writers with a way to know which of the components of the finite element logically form a vector (with \(d\) components in \(d\) space dimensions) rather than letting them assume that we simply have a bunch of scalar fields. This is achieved using the members of the <code><a class="el" href="namespaceDataComponentInterpretation.html">DataComponentInterpretation</a></code> namespace: as with the filename, we create a vector in which the first <code>dim</code> components refer to the velocities and are given the tag <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>; we finally push one tag <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a> to describe the grouping of the pressure variable.</p>
<p>The rest of the function is then the same as in <a class="el" href="step_20.html">step-20</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">StokesProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  std::vector&lt;std::string&gt; solution_names(dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div>
<div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;pressure&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div>
<div class="line">    data_component_interpretation(</div>
<div class="line">      dim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div>
<div class="line">  data_component_interpretation.push_back(</div>
<div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div>
<div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a>(dof_handler);</div>
<div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a>(solution,</div>
<div class="line">                           solution_names,</div>
<div class="line">                           <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div>
<div class="line">                           data_component_interpretation);</div>
<div class="line">  data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a>();</div>
<div class="line"> </div>
<div class="line">  std::ofstream output(</div>
<div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(refinement_cycle, 2) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div>
<div class="line">  data_out.<a class="code" href="group__Exceptions.html#gacad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div>
<div class="line">}</div>
<div class="ttc" id="aclassDataOut__DoFData_html_ac1eb26168177faa30ffbcf9cbb9c3cd5"><div class="ttname"><a href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">DataOut_DoFData::attach_dof_handler</a></div><div class="ttdeci">void attach_dof_handler(const DoFHandlerType &amp;)</div></div>
<div class="ttc" id="aclassDataOut__DoFData_html_ace4b76e565ba0701c4d32c26075ed3b9"><div class="ttname"><a href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">DataOut_DoFData::add_data_vector</a></div><div class="ttdeci">void add_data_vector(const VectorType &amp;data, const std::vector&lt; std::string &gt; &amp;names, const DataVectorType type=type_automatic, const std::vector&lt; DataComponentInterpretation::DataComponentInterpretation &gt; &amp;data_component_interpretation=std::vector&lt; DataComponentInterpretation::DataComponentInterpretation &gt;())</div><div class="ttdef"><b>Definition:</b> <a href="data__out__dof__data_8h_source.html#l01087">data_out_dof_data.h:1087</a></div></div>
<div class="ttc" id="aclassDataOut_html"><div class="ttname"><a href="classDataOut.html">DataOut</a></div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__out_8h_source.html#l00147">data_out.h:150</a></div></div>
<div class="ttc" id="aclassDataOut_html_a5eb51872b8736849bb7e8d2007fae086"><div class="ttname"><a href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">DataOut::build_patches</a></div><div class="ttdeci">virtual void build_patches(const unsigned int n_subdivisions=0)</div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__out_8cc_source.html#l01085">data_out.cc:1085</a></div></div>
<div class="ttc" id="agroup__Exceptions_html_gacad99726038e4fca7f605fdffb3317e4"><div class="ttname"><a href="group__Exceptions.html#gacad99726038e4fca7f605fdffb3317e4">DataOutInterface::write_vtk</a></div><div class="ttdeci">void write_vtk(std::ostream &amp;out) const</div><div class="ttdef"><b>Definition:</b> <a href="data__out__base_8cc_source.html#l07177">data_out_base.cc:7177</a></div></div>
<div class="ttc" id="anamespaceDataComponentInterpretation_html_a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51"><div class="ttname"><a href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a></div><div class="ttdeci">@ component_is_scalar</div><div class="ttdef"><b>Definition:</b> <a href="data__component__interpretation_8h_source.html#l00053">data_component_interpretation.h:53</a></div></div>
<div class="ttc" id="anamespaceDataComponentInterpretation_html_a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0"><div class="ttname"><a href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a></div><div class="ttdeci">@ component_is_part_of_vector</div><div class="ttdef"><b>Definition:</b> <a href="data__component__interpretation_8h_source.html#l00059">data_component_interpretation.h:59</a></div></div>
<div class="ttc" id="anamespaceUtilities_html_a6195c5f009ea8c7c536c6ffdf108c32f"><div class="ttname"><a href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a></div><div class="ttdeci">std::string int_to_string(const unsigned int value, const unsigned int digits=numbers::invalid_unsigned_int)</div><div class="ttdef"><b>Definition:</b> <a href="base_2utilities_8cc_source.html#l00473">utilities.cc:473</a></div></div>
</div><!-- fragment --><p><a class="anchor" id="StokesProblemrefine_mesh"></a> </p><h4>StokesProblem::refine_mesh</h4>
<p>This is the last interesting function of the <code>StokesProblem</code> class. As indicated by its name, it takes the solution to the problem and refines the mesh where this is needed. The procedure is the same as in the respective step in <a class="el" href="step_6.html">step-6</a>, with the exception that we base the refinement only on the change in pressure, i.e., we call the Kelly error estimator with a mask object of type <a class="el" href="classComponentMask.html">ComponentMask</a> that selects the single scalar component for the pressure that we are interested in (we get such a mask from the finite element class by specifying the component we want). Additionally, we do not coarsen the grid again:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::refine_mesh()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.n_active_cells());</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div>
<div class="line">  <a class="code" href="classKellyErrorEstimator.html#aa0917e696d4f8ddb983223a68c512357">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div>
<div class="line">    dof_handler,</div>
<div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(degree + 1),</div>
<div class="line">    std::map&lt;<a class="code" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div>
<div class="line">    solution,</div>
<div class="line">    estimated_error_per_cell,</div>
<div class="line">    fe.component_mask(pressure));</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>,</div>
<div class="line">                                                  estimated_error_per_cell,</div>
<div class="line">                                                  0.3,</div>
<div class="line">                                                  0.0);</div>
<div class="line">  <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.execute_coarsening_and_refinement();</div>
<div class="line">}</div>
<div class="ttc" id="aclassKellyErrorEstimator_html_aa0917e696d4f8ddb983223a68c512357"><div class="ttname"><a href="classKellyErrorEstimator.html#aa0917e696d4f8ddb983223a68c512357">KellyErrorEstimator::estimate</a></div><div class="ttdeci">static void estimate(const Mapping&lt; dim, spacedim &gt; &amp;mapping, const DoFHandler&lt; dim, spacedim &gt; &amp;dof, const Quadrature&lt; dim - 1 &gt; &amp;quadrature, const std::map&lt; types::boundary_id, const Function&lt; spacedim, typename InputVector::value_type &gt; * &gt; &amp;neumann_bc, const InputVector &amp;solution, Vector&lt; float &gt; &amp;error, const ComponentMask &amp;component_mask=ComponentMask(), const Function&lt; spacedim &gt; *coefficients=nullptr, const unsigned int n_threads=numbers::invalid_unsigned_int, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id, const types::material_id material_id=numbers::invalid_material_id, const Strategy strategy=cell_diameter_over_24)</div></div>
<div class="ttc" id="anamespaceGridRefinement_html_a48e5395381ed87155942a61a1edd134d"><div class="ttname"><a href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a></div><div class="ttdeci">void refine_and_coarsen_fixed_number(Triangulation&lt; dim, spacedim &gt; &amp;triangulation, const Vector&lt; Number &gt; &amp;criteria, const double top_fraction_of_cells, const double bottom_fraction_of_cells, const unsigned int max_n_cells=std::numeric_limits&lt; unsigned int &gt;::max())</div><div class="ttdef"><b>Definition:</b> <a href="grid_2grid__refinement_8cc_source.html#l00322">grid_refinement.cc:322</a></div></div>
<div class="ttc" id="anamespacetypes_html_aed8813fee8c8a2edcc6005e6a48c321a"><div class="ttname"><a href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a></div><div class="ttdeci">unsigned int boundary_id</div><div class="ttdef"><b>Definition:</b> <a href="types_8h_source.html#l00129">types.h:129</a></div></div>
</div><!-- fragment --><p><a class="anchor" id="StokesProblemrun"></a> </p><h4>StokesProblem::run</h4>
<p>The last step in the Stokes class is, as usual, the function that generates the initial grid and calls the other functions in the respective order.</p>
<p>We start off with a rectangle of size \(4 \times 1\) (in 2d) or \(4 \times 1 \times 1\) (in 3d), placed in \(R^2/R^3\) as \((-2,2)\times(-1,0)\) or \((-2,2)\times(0,1)\times(-1,0)\), respectively. It is natural to start with equal mesh size in each direction, so we subdivide the initial rectangle four times in the first coordinate direction. To limit the scope of the variables involved in the creation of the mesh to the range where we actually need them, we put the entire block between a pair of braces:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">StokesProblem&lt;dim&gt;::run</a>()</div>
<div class="line">{</div>
<div class="line">  {</div>
<div class="line">    std::vector&lt;unsigned int&gt; subdivisions(dim, 1);</div>
<div class="line">    subdivisions[0] = 4;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> bottom_left = (dim == 2 ?                </div>
<div class="line">                                      <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(-2, -1) :    <span class="comment">// 2d case</span></div>
<div class="line">                                      <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(-2, 0, -1)); <span class="comment">// 3d case</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> top_right = (dim == 2 ?              </div>
<div class="line">                                    <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(2, 0) :    <span class="comment">// 2d case</span></div>
<div class="line">                                    <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(2, 1, 0)); <span class="comment">// 3d case</span></div>
<div class="line"> </div>
<div class="line">    <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>,</div>
<div class="line">                                              subdivisions,</div>
<div class="line">                                              bottom_left,</div>
<div class="line">                                              top_right);</div>
<div class="line">  }</div>
<div class="ttc" id="anamespaceGridGenerator_html_ac76417d7404b75cf53c732f456e6e971"><div class="ttname"><a href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a></div><div class="ttdeci">void subdivided_hyper_rectangle(Triangulation&lt; dim, spacedim &gt; &amp;tria, const std::vector&lt; unsigned int &gt; &amp;repetitions, const Point&lt; dim &gt; &amp;p1, const Point&lt; dim &gt; &amp;p2, const bool colorize=false)</div></div>
</div><!-- fragment --><p>A boundary indicator of 1 is set to all boundaries that are subject to Dirichlet boundary conditions, i.e. to faces that are located at 0 in the last coordinate direction. See the example description above for details.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.active_cell_iterators())</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div>
<div class="line">    <span class="keywordflow">if</span> (face-&gt;center()[dim - 1] == 0)</div>
<div class="line">      face-&gt;set_all_boundary_ids(1);</div>
</div><!-- fragment --><p>We then apply an initial refinement before solving for the first time. In 3D, there are going to be more degrees of freedom, so we refine less there:</p>
<div class="fragment"><div class="line"><a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.refine_global(4 - dim);</div>
</div><!-- fragment --><p>As first seen in <a class="el" href="step_6.html">step-6</a>, we cycle over the different refinement levels and refine (except for the first cycle), setup the degrees of freedom and matrices, assemble, solve and create output:</p>
<div class="fragment"><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle = 0; refinement_cycle &lt; 6;</div>
<div class="line">         ++refinement_cycle)</div>
<div class="line">      {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Refinement cycle &quot;</span> &lt;&lt; refinement_cycle &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (refinement_cycle &gt; 0)</div>
<div class="line">          refine_mesh();</div>
<div class="line"> </div>
<div class="line">        setup_dofs();</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Assembling...&quot;</span> &lt;&lt; std::endl &lt;&lt; std::flush;</div>
<div class="line">        assemble_system();</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving...&quot;</span> &lt;&lt; std::flush;</div>
<div class="line">        solve();</div>
<div class="line"> </div>
<div class="line">        output_results(refinement_cycle);</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; std::endl;</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line">} <span class="comment">// namespace Step22</span></div>
</div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>The main function is the same as in <a class="el" href="step_20.html">step-20</a>. We pass the element degree as a parameter and choose the space dimension at the well-known template slot.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">using namespace </span>Step22;</div>
<div class="line"> </div>
<div class="line">      StokesProblem&lt;2&gt; flow_problem(1);</div>
<div class="line">      flow_problem.run();</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> <a class="anchor" id="Results"></a> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p><a class="anchor" id="Outputoftheprogramandgraphicalvisualization"></a></p><h3>Output of the program and graphical visualization</h3>
<p><a class="anchor" id="2Dcalculations"></a></p><h4>2D calculations</h4>
<p>Running the program with the space dimension set to 2 in the <code>main</code> function yields the following output (in "release mode", See also <a href="http://www.math.colostate.edu/~bangerth/videos.676.18.html">video lecture 18</a>.): </p><div class="fragment"><div class="line">examples/step-22&gt; make <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div>
<div class="line">Refinement cycle 0</div>
<div class="line">   Number of active cells: 64</div>
<div class="line">   Number of degrees of freedom: 679 (594+85)</div>
<div class="line">   Assembling...</div>
<div class="line">   Computing preconditioner...</div>
<div class="line">   Solving...  11 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure</div>
<div class="line"> </div>
<div class="line">Refinement cycle 1</div>
<div class="line">   Number of active cells: 160</div>
<div class="line">   Number of degrees of freedom: 1683 (1482+201)</div>
<div class="line">   Assembling...</div>
<div class="line">   Computing preconditioner...</div>
<div class="line">   Solving...  11 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure</div>
<div class="line"> </div>
<div class="line">Refinement cycle 2</div>
<div class="line">   Number of active cells: 376</div>
<div class="line">   Number of degrees of freedom: 3813 (3370+443)</div>
<div class="line">   Assembling...</div>
<div class="line">   Computing preconditioner...</div>
<div class="line">   Solving...  11 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure</div>
<div class="line"> </div>
<div class="line">Refinement cycle 3</div>
<div class="line">   Number of active cells: 880</div>
<div class="line">   Number of degrees of freedom: 8723 (7722+1001)</div>
<div class="line">   Assembling...</div>
<div class="line">   Computing preconditioner...</div>
<div class="line">   Solving...  11 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure</div>
<div class="line"> </div>
<div class="line">Refinement cycle 4</div>
<div class="line">   Number of active cells: 2008</div>
<div class="line">   Number of degrees of freedom: 19383 (17186+2197)</div>
<div class="line">   Assembling...</div>
<div class="line">   Computing preconditioner...</div>
<div class="line">   Solving...  11 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure</div>
<div class="line"> </div>
<div class="line">Refinement cycle 5</div>
<div class="line">   Number of active cells: 4288</div>
<div class="line">   Number of degrees of freedom: 40855 (36250+4605)</div>
<div class="line">   Assembling...</div>
<div class="line">   Computing preconditioner...</div>
<div class="line">   Solving...  11 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure</div>
</div><!-- fragment --><p>The entire computation above takes about 2 seconds on a reasonably quick (for 2015 standards) machine.</p>
<p>What we see immediately from this is that the number of (outer) iterations does not increase as we refine the mesh. This confirms the statement in the introduction that preconditioning the Schur complement with the mass matrix indeed yields a matrix spectrally equivalent to the identity matrix (i.e. with eigenvalues bounded above and below independently of the mesh size or the relative sizes of cells). In other words, the mass matrix and the Schur complement are spectrally equivalent.</p>
<p>In the images below, we show the grids for the first six refinement steps in the program. Observe how the grid is refined in regions where the solution rapidly changes: On the upper boundary, we have Dirichlet boundary conditions that are -1 in the left half of the line and 1 in the right one, so there is an abrupt change at \(x=0\). Likewise, there are changes from Dirichlet to Neumann data in the two upper corners, so there is need for refinement there as well:</p>
<table width="60%" align="center">
<tr>
<td align="center"><img src="https://www.dealii.org/images/steps/developer/step-22.2d.mesh-0.png" alt="" class="inline"/>  </td><td align="center"><img src="https://www.dealii.org/images/steps/developer/step-22.2d.mesh-1.png" alt="" class="inline"/>   </td></tr>
<tr>
<td align="center"><img src="https://www.dealii.org/images/steps/developer/step-22.2d.mesh-2.png" alt="" class="inline"/>  </td><td align="center"><img src="https://www.dealii.org/images/steps/developer/step-22.2d.mesh-3.png" alt="" class="inline"/>   </td></tr>
<tr>
<td align="center"><img src="https://www.dealii.org/images/steps/developer/step-22.2d.mesh-4.png" alt="" class="inline"/>  </td><td align="center"><img src="https://www.dealii.org/images/steps/developer/step-22.2d.mesh-5.png" alt="" class="inline"/>   </td></tr>
</table>
<p>Finally, following is a plot of the flow field. It shows fluid transported along with the moving upper boundary and being replaced by material coming from below:</p>
<p><img src="https://www.dealii.org/images/steps/developer/step-22.2d.solution.png" alt="" class="inline"/></p>
<p>This plot uses the capability of VTK-based visualization programs (in this case of VisIt) to show vector data; this is the result of us declaring the velocity components of the finite element in use to be a set of vector components, rather than independent scalar components in the <code>StokesProblem&lt;dim&gt;::output_results</code> function of this tutorial program.</p>
<p><a class="anchor" id="3Dcalculations"></a></p><h4>3D calculations</h4>
<p>In 3d, the screen output of the program looks like this:</p>
<div class="fragment"><div class="line">Refinement cycle 0</div>
<div class="line">   Number of active cells: 32</div>
<div class="line">   Number of degrees of freedom: 1356 (1275+81)</div>
<div class="line">   Assembling...</div>
<div class="line">   Computing preconditioner...</div>
<div class="line">   Solving...  13 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure.</div>
<div class="line"> </div>
<div class="line">Refinement cycle 1</div>
<div class="line">   Number of active cells: 144</div>
<div class="line">   Number of degrees of freedom: 5088 (4827+261)</div>
<div class="line">   Assembling...</div>
<div class="line">   Computing preconditioner...</div>
<div class="line">   Solving...  14 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure.</div>
<div class="line"> </div>
<div class="line">Refinement cycle 2</div>
<div class="line">   Number of active cells: 704</div>
<div class="line">   Number of degrees of freedom: 22406 (21351+1055)</div>
<div class="line">   Assembling...</div>
<div class="line">   Computing preconditioner...</div>
<div class="line">   Solving...  14 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure.</div>
<div class="line"> </div>
<div class="line">Refinement cycle 3</div>
<div class="line">   Number of active cells: 3168</div>
<div class="line">   Number of degrees of freedom: 93176 (89043+4133)</div>
<div class="line">   Assembling...</div>
<div class="line">   Computing preconditioner...</div>
<div class="line">   Solving...  15 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure.</div>
<div class="line"> </div>
<div class="line">Refinement cycle 4</div>
<div class="line">   Number of active cells: 11456</div>
<div class="line">   Number of degrees of freedom: 327808 (313659+14149)</div>
<div class="line">   Assembling...</div>
<div class="line">   Computing preconditioner...</div>
<div class="line">   Solving...  15 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure.</div>
<div class="line"> </div>
<div class="line">Refinement cycle 5</div>
<div class="line">   Number of active cells: 45056</div>
<div class="line">   Number of degrees of freedom: 1254464 (1201371+53093)</div>
<div class="line">   Assembling...</div>
<div class="line">   Computing preconditioner...</div>
<div class="line">   Solving...  14 outer CG Schur complement iterations <span class="keywordflow">for</span> pressure.</div>
</div><!-- fragment --><p>Again, we see that the number of outer iterations does not increase as we refine the mesh. Nevertheless, the compute time increases significantly: for each of the iterations above separately, it takes about 0.14 seconds, 0.63 seconds, 4.8 seconds, 35 seconds, 2 minutes and 33 seconds, and 13 minutes and 12 seconds. This overall superlinear (in the number of unknowns) increase in runtime is due to the fact that our inner solver is not \({\cal O}(N)\): a simple experiment shows that as we keep refining the mesh, the average number of ILU-preconditioned CG iterations to invert the velocity-velocity block \(A\) increases.</p>
<p>We will address the question of how possibly to improve our solver <a href="#improved-solver">below</a>.</p>
<p>As for the graphical output, the grids generated during the solution look as follow:</p>
<table width="60%" align="center">
<tr>
<td align="center"><img src="https://www.dealii.org/images/steps/developer/step-22.3d.mesh-0.png" alt="" class="inline"/>  </td><td align="center"><img src="https://www.dealii.org/images/steps/developer/step-22.3d.mesh-1.png" alt="" class="inline"/>   </td></tr>
<tr>
<td align="center"><img src="https://www.dealii.org/images/steps/developer/step-22.3d.mesh-2.png" alt="" class="inline"/>  </td><td align="center"><img src="https://www.dealii.org/images/steps/developer/step-22.3d.mesh-3.png" alt="" class="inline"/>   </td></tr>
<tr>
<td align="center"><img src="https://www.dealii.org/images/steps/developer/step-22.3d.mesh-4.png" alt="" class="inline"/>  </td><td align="center"><img src="https://www.dealii.org/images/steps/developer/step-22.3d.mesh-5.png" alt="" class="inline"/>   </td></tr>
</table>
<p>Again, they show essentially the location of singularities introduced by boundary conditions. The vector field computed makes for an interesting graph:</p>
<p><img src="https://www.dealii.org/images/steps/developer/step-22.3d.solution.png" alt="" class="inline"/></p>
<p>The isocontours shown here as well are those of the pressure variable, showing the singularity at the point of discontinuous velocity boundary conditions.</p>
<p><a class="anchor" id="Sparsitypattern"></a></p><h3>Sparsity pattern</h3>
<p>As explained during the generation of the sparsity pattern, it is important to have the numbering of degrees of freedom in mind when using preconditioners like incomplete LU decompositions. This is most conveniently visualized using the distribution of nonzero elements in the stiffness matrix.</p>
<p>If we don't do anything special to renumber degrees of freedom (i.e., without using <a class="el" href="namespaceDoFRenumbering.html#a68651164485490b86d901d9ae1fbfc3b">DoFRenumbering::Cuthill_McKee</a>, but with using <a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a> to ensure that degrees of freedom are appropriately sorted into their corresponding blocks of the matrix and vector), then we get the following image after the first adaptive refinement in two dimensions:</p>
<p><img src="https://www.dealii.org/images/steps/developer/step-22.2d.sparsity-nor.png" alt="" class="inline"/></p>
<p>In order to generate such a graph, you have to insert a piece of code like the following to the end of the setup step. </p><div class="fragment"><div class="line">{</div>
<div class="line">  std::ofstream out (<span class="stringliteral">&quot;sparsity_pattern.gpl&quot;</span>);</div>
<div class="line">  sparsity_pattern.print_gnuplot(out);</div>
<div class="line">}</div>
</div><!-- fragment --><p>It is clearly visible that the nonzero entries are spread over almost the whole matrix. This makes preconditioning by ILU inefficient: ILU generates a Gaussian elimination (LU decomposition) without fill-in elements, which means that more tentative fill-ins left out will result in a worse approximation of the complete decomposition.</p>
<p>In this program, we have thus chosen a more advanced renumbering of components. The renumbering with <a class="el" href="namespaceDoFRenumbering.html#a68651164485490b86d901d9ae1fbfc3b">DoFRenumbering::Cuthill_McKee</a> and grouping the components into velocity and pressure yields the following output:</p>
<p><img src="https://www.dealii.org/images/steps/developer/step-22.2d.sparsity-ren.png" alt="" class="inline"/></p>
<p>It is apparent that the situation has improved a lot. Most of the elements are now concentrated around the diagonal in the (0,0) block in the matrix. Similar effects are also visible for the other blocks. In this case, the ILU decomposition will be much closer to the full LU decomposition, which improves the quality of the preconditioner. (It may be interesting to note that the sparse direct solver UMFPACK does some internal renumbering of the equations before actually generating a sparse LU decomposition; that procedure leads to a very similar pattern to the one we got from the Cuthill-McKee algorithm.)</p>
<p>Finally, we want to have a closer look at a sparsity pattern in 3D. We show only the (0,0) block of the matrix, again after one adaptive refinement. Apart from the fact that the matrix size has increased, it is also visible that there are many more entries in the matrix. Moreover, even for the optimized renumbering, there will be a considerable amount of tentative fill-in elements. This illustrates why UMFPACK is not a good choice in 3D - a full decomposition needs many new entries that eventually won't fit into the physical memory (RAM):</p>
<p><img src="https://www.dealii.org/images/steps/developer/step-22.3d.sparsity_uu-ren.png" alt="" class="inline"/></p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p><a class="anchor" id="improved-solver"></a> <a class="anchor" id="Improvedlinearsolverin3D"></a></p><h4>Improved linear solver in 3D</h4>
<p>We have seen in the section of computational results that the number of outer iterations does not depend on the mesh size, which is optimal in a sense of scalability. This does, however, not apply to the solver as a whole, as mentioned above: We did not look at the number of inner iterations when generating the inverse of the matrix \(A\) and the mass matrix \(M_p\). Of course, this is unproblematic in the 2D case where we precondition \(A\) with a direct solver and the <code>vmult</code> operation of the inverse matrix structure will converge in one single CG step, but this changes in 3D where we only use an ILU preconditioner. There, the number of required preconditioned CG steps to invert \(A\) increases as the mesh is refined, and each <code>vmult</code> operation involves on average approximately 14, 23, 36, 59, 75 and 101 inner CG iterations in the refinement steps shown above. (On the other hand, the number of iterations for applying the inverse pressure mass matrix is always around five, both in two and three dimensions.) To summarize, most work is spent on solving linear systems with the same matrix \(A\) over and over again. What makes this look even worse is the fact that we actually invert a matrix that is about 95 percent the size of the total system matrix and stands for 85 percent of the non-zero entries in the sparsity pattern. Hence, the natural question is whether it is reasonable to solve a linear system with matrix \(A\) for about 15 times when calculating the solution to the block system.</p>
<p>The answer is, of course, that we can do that in a few other (most of the time better) ways. Nevertheless, it has to be remarked that an indefinite system as the one at hand puts indeed much higher demands on the linear algebra than standard elliptic problems as we have seen in the early tutorial programs. The improvements are still rather unsatisfactory, if one compares with an elliptic problem of similar size. Either way, we will introduce below a number of improvements to the linear solver, a discussion that we will re-consider again with additional options in the <a class="el" href="step_31.html">step-31</a> program.</p>
<p><a class="anchor" id="improved-ilu"></a> <a class="anchor" id="BetterILUdecompositionbysmartreordering"></a></p><h5>Better ILU decomposition by smart reordering</h5>
<p>A first attempt to improve the speed of the linear solution process is to choose a dof reordering that makes the ILU being closer to a full LU decomposition, as already mentioned in the in-code comments. The <a class="el" href="namespaceDoFRenumbering.html">DoFRenumbering</a> namespace compares several choices for the renumbering of dofs for the Stokes equations. The best result regarding the computing time was found for the King ordering, which is accessed through the call <a class="el" href="namespaceDoFRenumbering_1_1boost.html#a76fd1dc3212aeeca4294c358248e46d5">DoFRenumbering::boost::king_ordering</a>. With that program, the inner solver needs considerably less operations, e.g. about 62 inner CG iterations for the inversion of \(A\) at cycle 4 compared to about 75 iterations with the standard Cuthill-McKee-algorithm. Also, the computing time at cycle 4 decreased from about 17 to 11 minutes for the <code>solve()</code> call. However, the King ordering (and the orderings provided by the <a class="el" href="namespaceDoFRenumbering_1_1boost.html">DoFRenumbering::boost</a> namespace in general) has a serious drawback - it uses much more memory than the in-build deal versions, since it acts on abstract graphs rather than the geometry provided by the triangulation. In the present case, the renumbering takes about 5 times as much memory, which yields an infeasible algorithm for the last cycle in 3D with 1.2 million unknowns.</p>
<p><a class="anchor" id="BetterpreconditionerfortheinnerCGsolver"></a></p><h5>Better preconditioner for the inner CG solver</h5>
<p>Another idea to improve the situation even more would be to choose a preconditioner that makes CG for the (0,0) matrix \(A\) converge in a mesh-independent number of iterations, say 10 to 30. We have seen such a candidate in <a class="el" href="step_16.html">step-16</a>: multigrid.</p>
<p><a class="anchor" id="BlockSchurcomplementpreconditioner"></a></p><h5>Block Schur complement preconditioner</h5>
<p><a class="anchor" id="block-schur"></a> Even with a good preconditioner for \(A\), we still need to solve of the same linear system repeatedly (with different right hand sides, though) in order to make the Schur complement solve converge. The approach we are going to discuss here is how inner iteration and outer iteration can be combined. If we persist in calculating the Schur complement, there is no other possibility.</p>
<p>The alternative is to attack the block system at once and use an approximate Schur complement as efficient preconditioner. The idea is as follows: If we find a block preconditioner \(P\) such that the matrix </p><p class="formulaDsp">
\begin{eqnarray*} P^{-1}\left(\begin{array}{cc} A &amp; B^T \\ B &amp; 0 \end{array}\right) \end{eqnarray*}
</p>
<p> is simple, then an iterative solver with that preconditioner will converge in a few iterations. Using the Schur complement \(S = B A^{-1} B^T\), one finds that </p><p class="formulaDsp">
\begin{eqnarray*} P^{-1} = \left(\begin{array}{cc} A^{-1} &amp; 0 \\ S^{-1} B A^{-1} &amp; -S^{-1} \end{array}\right) \end{eqnarray*}
</p>
<p> would appear to be a good choice since </p><p class="formulaDsp">
\begin{eqnarray*} P^{-1}\left(\begin{array}{cc} A &amp; B^T \\ B &amp; 0 \end{array}\right) = \left(\begin{array}{cc} A^{-1} &amp; 0 \\ S^{-1} B A^{-1} &amp; -S^{-1} \end{array}\right)\cdot \left(\begin{array}{cc} A &amp; B^T \\ B &amp; 0 \end{array}\right) = \left(\begin{array}{cc} I &amp; A^{-1} B^T \\ 0 &amp; I \end{array}\right). \end{eqnarray*}
</p>
<p> This is the approach taken by the paper by Silvester and Wathen referenced to in the introduction (with the exception that Silvester and Wathen use right preconditioning). In this case, a Krylov-based iterative method would converge in one step only if exact inverses of \(A\) and \(S\) were applied, since all the eigenvalues are one (and the number of iterations in such a method is bounded by the number of distinct eigenvalues). Below, we will discuss the choice of an adequate solver for this problem. First, we are going to have a closer look at the implementation of the preconditioner.</p>
<p>Since \(P\) is aimed to be a preconditioner only, we shall use approximations to the inverse of the Schur complement \(S\) and the matrix \(A\). Hence, the Schur complement will be approximated by the pressure mass matrix \(M_p\), and we use a preconditioner to \(A\) (without an InverseMatrix class around it) for approximating \(A^{-1}\).</p>
<p>Here comes the class that implements the block Schur complement preconditioner. The <code>vmult</code> operation for block vectors according to the derivation above can be specified by three successive operations: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerA, <span class="keyword">class</span> PreconditionerMp&gt;</div>
<div class="line"><span class="keyword">class </span>BlockSchurPreconditioner : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    BlockSchurPreconditioner (<span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a>         &amp;S,</div>
<div class="line">          <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>,PreconditionerMp&gt;  &amp;Mpinv,</div>
<div class="line">          <span class="keyword">const</span> PreconditionerA &amp;Apreconditioner);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> vmult (<a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>       &amp;dst,</div>
<div class="line">              <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const BlockSparseMatrix&lt;double&gt;</a> &gt; system_matrix;</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const InverseMatrix&lt;SparseMatrix&lt;double&gt;</a>,</div>
<div class="line">                       PreconditionerMp &gt; &gt; m_inverse;</div>
<div class="line">    <span class="keyword">const</span> PreconditionerA &amp;a_preconditioner;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">mutable</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp;</div>
<div class="line"> </div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerA, <span class="keyword">class</span> PreconditionerMp&gt;</div>
<div class="line">BlockSchurPreconditioner&lt;PreconditionerA, PreconditionerMp&gt;::BlockSchurPreconditioner(</div>
<div class="line">          <span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a>                            &amp;S,</div>
<div class="line">          <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>,PreconditionerMp&gt; &amp;Mpinv,</div>
<div class="line">          <span class="keyword">const</span> PreconditionerA &amp;Apreconditioner</div>
<div class="line">          )</div>
<div class="line">                :</div>
<div class="line">                system_matrix           (&amp;S),</div>
<div class="line">                m_inverse               (&amp;Mpinv),</div>
<div class="line">                a_preconditioner        (Apreconditioner),</div>
<div class="line">                tmp                     (S.block(1,1).m())</div>
<div class="line">{}</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Now the interesting function, the multiplication of</span></div>
<div class="line">        <span class="comment">// the preconditioner with a BlockVector.</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerA, <span class="keyword">class</span> PreconditionerMp&gt;</div>
<div class="line"><span class="keywordtype">void</span> BlockSchurPreconditioner&lt;PreconditionerA, PreconditionerMp&gt;::vmult (</div>
<div class="line">                                     <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>       &amp;dst,</div>
<div class="line">                                     <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">        <span class="comment">// Form u_new = A^{-1} u</span></div>
<div class="line">  a_preconditioner.vmult (dst.<a class="code" href="group__Exceptions.html#gae05a0e26814f032473ed2ef66da018bd">block</a>(0), src.<a class="code" href="group__Exceptions.html#gae05a0e26814f032473ed2ef66da018bd">block</a>(0));</div>
<div class="line">        <span class="comment">// Form tmp = - B u_new + p</span></div>
<div class="line">        <span class="comment">// (&lt;code&gt;SparseMatrix::residual&lt;/code&gt;</span></div>
<div class="line">        <span class="comment">// does precisely this)</span></div>
<div class="line">  system_matrix-&gt;block(1,0).residual(tmp, dst.<a class="code" href="group__Exceptions.html#gae05a0e26814f032473ed2ef66da018bd">block</a>(0), src.<a class="code" href="group__Exceptions.html#gae05a0e26814f032473ed2ef66da018bd">block</a>(1));</div>
<div class="line">        <span class="comment">// Change sign in tmp</span></div>
<div class="line">  tmp *= -1;</div>
<div class="line">        <span class="comment">// Multiply by approximate Schur complement</span></div>
<div class="line">        <span class="comment">// (i.e. a pressure mass matrix)</span></div>
<div class="line">  m_inverse-&gt;vmult (dst.<a class="code" href="group__Exceptions.html#gae05a0e26814f032473ed2ef66da018bd">block</a>(1), tmp);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__Exceptions_html_gae05a0e26814f032473ed2ef66da018bd"><div class="ttname"><a href="group__Exceptions.html#gae05a0e26814f032473ed2ef66da018bd">BlockVectorBase::block</a></div><div class="ttdeci">BlockType &amp; block(const unsigned int i)</div></div>
</div><!-- fragment --><p>Since we act on the whole block system now, we have to live with one disadvantage: we need to perform the solver iterations on the full block system instead of the smaller pressure space.</p>
<p>Now we turn to the question which solver we should use for the block system. The first observation is that the resulting preconditioned matrix cannot be solved with CG since it is neither positive definite nor symmetric.</p>
<p>The deal.II libraries implement several solvers that are appropriate for the problem at hand. One choice is the solver <a class="el" href="classSolverBicgstab.html">BiCGStab</a>, which was used for the solution of the unsymmetric advection problem in <a class="el" href="step_9.html">step-9</a>. The second option, the one we are going to choose, is <a class="el" href="classSolverGMRES.html">GMRES</a> (generalized minimum residual). Both methods have their pros and cons - there are problems where one of the two candidates clearly outperforms the other, and vice versa. <a href="http://en.wikipedia.org/wiki/GMRES#Comparison_with_other_solvers">Wikipedia</a>'s article on the GMRES method gives a comparative presentation. A more comprehensive and well-founded comparison can be read e.g. in the book by J.W. Demmel (Applied Numerical Linear Algebra, SIAM, 1997, section 6.6.6).</p>
<p>For our specific problem with the ILU preconditioner for \(A\), we certainly need to perform hundreds of iterations on the block system for large problem sizes (we won't beat CG!). Actually, this disfavors GMRES: During the GMRES iterations, a basis of Krylov vectors is successively built up and some operations are performed on these vectors. The more vectors are in this basis, the more operations and memory will be needed. The number of operations scales as \({\cal O}(n + k^2)\) and memory as \({\cal O}(kn)\), where \(k\) is the number of vectors in the Krylov basis and \(n\) the size of the (block) matrix. To not let these demands grow excessively, deal.II limits the size \(k\) of the basis to 30 vectors by default. Then, the basis is rebuilt. This implementation of the GMRES method is called GMRES(k), with default \(k=30\). What we have gained by this restriction, namely a bound on operations and memory requirements, will be compensated by the fact that we use an incomplete basis - this will increase the number of required iterations.</p>
<p>BiCGStab, on the other hand, won't get slower when many iterations are needed (one iteration uses only results from one preceding step and not all the steps as GMRES). Besides the fact the BiCGStab is more expensive per step since two matrix-vector products are needed (compared to one for CG or GMRES), there is one main reason which makes BiCGStab not appropriate for this problem: The preconditioner applies the inverse of the pressure mass matrix by using the InverseMatrix class. Since the application of the inverse matrix to a vector is done only in approximative way (an exact inverse is too expensive), this will also affect the solver. In the case of BiCGStab, the Krylov vectors will not be orthogonal due to that perturbation. While this is uncritical for a small number of steps (up to about 50), it ruins the performance of the solver when these perturbations have grown to a significant magnitude in the coarse of iterations.</p>
<p>We did some experiments with BiCGStab and found it to be faster than GMRES up to refinement cycle 3 (in 3D), but it became very slow for cycles 4 and 5 (even slower than the original Schur complement), so the solver is useless in this situation. Choosing a sharper tolerance for the inverse matrix class (<code>1e-10*src.<a class="el" href="namespaceAdaptationStrategies_1_1Refinement.html#a629b528b2c9777d26eb9048d50d6c13a">l2_norm()</a></code> instead of <code>1e-6*src.<a class="el" href="namespaceAdaptationStrategies_1_1Refinement.html#a629b528b2c9777d26eb9048d50d6c13a">l2_norm()</a></code>) made BiCGStab perform well also for cycle 4, but did not change the failure on the very large problems.</p>
<p>GMRES is of course also effected by the approximate inverses, but it is not as sensitive to orthogonality and retains a relatively good performance also for large sizes, see the results below.</p>
<p>With this said, we turn to the realization of the solver call with GMRES with \(k=100\) temporary vectors:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> &amp;pressure_mass_matrix</div>
<div class="line">  = preconditioner_matrix.block(1,1);</div>
<div class="line"><a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a> pmass_preconditioner;</div>
<div class="line">pmass_preconditioner.<a class="code" href="group__Preconditioners.html#gae4b56dfaab3fd8820faa1b21160b1acb">initialize</a> (pressure_mass_matrix,</div>
<div class="line">  <a class="code" href="group__Preconditioners.html#gae21347f3202a1186060eac36dcb45817">SparseILU&lt;double&gt;::AdditionalData</a>());</div>
<div class="line"> </div>
<div class="line">InverseMatrix&lt;SparseMatrix&lt;double&gt;,<a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a> &gt;</div>
<div class="line">  m_inverse (pressure_mass_matrix, pmass_preconditioner);</div>
<div class="line"> </div>
<div class="line">BlockSchurPreconditioner&lt;typename InnerPreconditioner&lt;dim&gt;::type,</div>
<div class="line">                         <a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a> &gt;</div>
<div class="line">  preconditioner (system_matrix, m_inverse, *A_preconditioner);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classSolverControl.html">SolverControl</a> solver_control (system_matrix.m(),</div>
<div class="line">                              1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-6*system_rhs.l2_norm());</div>
<div class="line"><a class="code" href="classGrowingVectorMemory.html">GrowingVectorMemory&lt;BlockVector&lt;double&gt;</a> &gt; vector_memory;</div>
<div class="line"><a class="code" href="classSolverGMRES.html">SolverGMRES&lt;BlockVector&lt;double&gt;</a> &gt;::AdditionalData gmres_data;</div>
<div class="line">gmres_data.max_n_tmp_vectors = 100;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classSolverGMRES.html">SolverGMRES&lt;BlockVector&lt;double&gt;</a> &gt; gmres(solver_control, vector_memory,</div>
<div class="line">                                        gmres_data);</div>
<div class="line"> </div>
<div class="line">gmres.solve(system_matrix, solution, system_rhs,</div>
<div class="line">            preconditioner);</div>
<div class="line"> </div>
<div class="line">constraints.distribute (solution);</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div>
<div class="line">          &lt;&lt; solver_control.last_step()</div>
<div class="line">          &lt;&lt; <span class="stringliteral">&quot; block GMRES iterations&quot;</span>;</div>
<div class="ttc" id="aclassGrowingVectorMemory_html"><div class="ttname"><a href="classGrowingVectorMemory.html">GrowingVectorMemory</a></div><div class="ttdef"><b>Definition:</b> <a href="include_2deal_8II_2lac_2vector__memory_8h_source.html#l00313">vector_memory.h:314</a></div></div>
<div class="ttc" id="aclassSolverGMRES_html"><div class="ttname"><a href="classSolverGMRES.html">SolverGMRES</a></div><div class="ttdef"><b>Definition:</b> <a href="solver__gmres_8h_source.html#l00175">solver_gmres.h:176</a></div></div>
</div><!-- fragment --><p>Obviously, one needs to add the include file <a class="el" href="classSolverGMRES.html">&lt;lac/solver_gmres.h&gt;</a> in order to make this run. We call the solver with a <a class="el" href="classBlockVector.html">BlockVector</a> template in order to enable GMRES to operate on block vectors and matrices. Note also that we need to set the (1,1) block in the system matrix to zero (we saved the pressure mass matrix there which is not part of the problem) after we copied the information to another matrix.</p>
<p>Using the <a class="el" href="classTimer.html">Timer</a> class, we collect some statistics that compare the runtime of the block solver with the one from the problem implementation above. Besides the solution with the two options we also check if the solutions of the two variants are close to each other (i.e. this solver gives indeed the same solution as we had before) and calculate the infinity norm of the vector difference.</p>
<p>Let's first see the results in 2D: </p><div class="fragment"><div class="line">Refinement cycle 0</div>
<div class="line">   Number of active cells: 64</div>
<div class="line">   Number of degrees of freedom: 679 (594+85) [0.00162792 s]</div>
<div class="line">   Assembling...  [0.00108981 s]</div>
<div class="line">   Computing preconditioner... [0.0025959 s]</div>
<div class="line">   Solving...</div>
<div class="line">      Schur complement: 11 outer CG iterations <span class="keywordflow">for</span> p  [0.00479603s ]</div>
<div class="line">      Block Schur preconditioner: 12 GMRES iterations [0.00441718 s]</div>
<div class="line">   l_infinity difference between solution vectors: 5.38258e-07</div>
<div class="line"> </div>
<div class="line">Refinement cycle 1</div>
<div class="line">   Number of active cells: 160</div>
<div class="line">   Number of degrees of freedom: 1683 (1482+201) [0.00345707 s]</div>
<div class="line">   Assembling...  [0.00237417 s]</div>
<div class="line">   Computing preconditioner... [0.00605702 s]</div>
<div class="line">   Solving...</div>
<div class="line">      Schur complement: 11 outer CG iterations <span class="keywordflow">for</span> p  [0.0123992s ]</div>
<div class="line">      Block Schur preconditioner: 12 GMRES iterations [0.011909 s]</div>
<div class="line">   l_infinity difference between solution vectors: 1.74658e-05</div>
<div class="line"> </div>
<div class="line">Refinement cycle 2</div>
<div class="line">   Number of active cells: 376</div>
<div class="line">   Number of degrees of freedom: 3813 (3370+443) [0.00729299 s]</div>
<div class="line">   Assembling...  [0.00529909 s]</div>
<div class="line">   Computing preconditioner... [0.0167508 s]</div>
<div class="line">   Solving...</div>
<div class="line">      Schur complement: 11 outer CG iterations <span class="keywordflow">for</span> p  [0.031672s ]</div>
<div class="line">      Block Schur preconditioner: 12 GMRES iterations [0.029232 s]</div>
<div class="line">   l_infinity difference between solution vectors: 7.81569e-06</div>
<div class="line"> </div>
<div class="line">Refinement cycle 3</div>
<div class="line">   Number of active cells: 880</div>
<div class="line">   Number of degrees of freedom: 8723 (7722+1001) [0.017709 s]</div>
<div class="line">   Assembling...  [0.0126002 s]</div>
<div class="line">   Computing preconditioner... [0.0435679 s]</div>
<div class="line">   Solving...</div>
<div class="line">      Schur complement: 11 outer CG iterations <span class="keywordflow">for</span> p  [0.0971651s ]</div>
<div class="line">      Block Schur preconditioner: 12 GMRES iterations [0.0992041 s]</div>
<div class="line">   l_infinity difference between solution vectors: 1.87249e-05</div>
<div class="line"> </div>
<div class="line">Refinement cycle 4</div>
<div class="line">   Number of active cells: 2008</div>
<div class="line">   Number of degrees of freedom: 19383 (17186+2197) [0.039988 s]</div>
<div class="line">   Assembling...  [0.028281 s]</div>
<div class="line">   Computing preconditioner... [0.118314 s]</div>
<div class="line">   Solving...</div>
<div class="line">      Schur complement: 11 outer CG iterations <span class="keywordflow">for</span> p  [0.252133s ]</div>
<div class="line">      Block Schur preconditioner: 13 GMRES iterations [0.269125 s]</div>
<div class="line">   l_infinity difference between solution vectors: 6.38657e-05</div>
<div class="line"> </div>
<div class="line">Refinement cycle 5</div>
<div class="line">   Number of active cells: 4288</div>
<div class="line">   Number of degrees of freedom: 40855 (36250+4605) [0.0880702 s]</div>
<div class="line">   Assembling...  [0.0603511 s]</div>
<div class="line">   Computing preconditioner... [0.278339 s]</div>
<div class="line">   Solving...</div>
<div class="line">      Schur complement: 11 outer CG iterations <span class="keywordflow">for</span> p  [0.53846s ]</div>
<div class="line">      Block Schur preconditioner: 13 GMRES iterations [0.578667 s]</div>
<div class="line">   l_infinity difference between solution vectors: 0.000173363</div>
</div><!-- fragment --><p>We see that there is no huge difference in the solution time between the block Schur complement preconditioner solver and the Schur complement itself. The reason is simple: we used a direct solve as preconditioner for \(A\) - so we cannot expect any gain by avoiding the inner iterations. We see that the number of iterations has slightly increased for GMRES, but all in all the two choices are fairly similar.</p>
<p>The picture of course changes in 3D:</p>
<div class="fragment"><div class="line">Refinement cycle 0</div>
<div class="line">   Number of active cells: 32</div>
<div class="line">   Number of degrees of freedom: 1356 (1275+81) [0.00845218 s]</div>
<div class="line">   Assembling...  [0.019372 s]</div>
<div class="line">   Computing preconditioner... [0.00712395 s]</div>
<div class="line">   Solving...</div>
<div class="line">      Schur complement: 13 outer CG iterations <span class="keywordflow">for</span> p  [0.0320101s ]</div>
<div class="line">      Block Schur preconditioner: 22 GMRES iterations [0.0048759 s]</div>
<div class="line">   l_infinity difference between solution vectors: 2.15942e-05</div>
<div class="line"> </div>
<div class="line">Refinement cycle 1</div>
<div class="line">   Number of active cells: 144</div>
<div class="line">   Number of degrees of freedom: 5088 (4827+261) [0.0346942 s]</div>
<div class="line">   Assembling...  [0.0857739 s]</div>
<div class="line">   Computing preconditioner... [0.0465031 s]</div>
<div class="line">   Solving...</div>
<div class="line">      Schur complement: 14 outer CG iterations <span class="keywordflow">for</span> p  [0.349258s ]</div>
<div class="line">      Block Schur preconditioner: 35 GMRES iterations [0.048759 s]</div>
<div class="line">   l_infinity difference between solution vectors: 1.77657e-05</div>
<div class="line"> </div>
<div class="line">Refinement cycle 2</div>
<div class="line">   Number of active cells: 704</div>
<div class="line">   Number of degrees of freedom: 22406 (21351+1055) [0.175669 s]</div>
<div class="line">   Assembling...  [0.437447 s]</div>
<div class="line">   Computing preconditioner... [0.286435 s]</div>
<div class="line">   Solving...</div>
<div class="line">      Schur complement: 14 outer CG iterations <span class="keywordflow">for</span> p  [3.65519s ]</div>
<div class="line">      Block Schur preconditioner: 63 GMRES iterations [0.497787 s]</div>
<div class="line">   l_infinity difference between solution vectors: 5.08078e-05</div>
<div class="line"> </div>
<div class="line">Refinement cycle 3</div>
<div class="line">   Number of active cells: 3168</div>
<div class="line">   Number of degrees of freedom: 93176 (89043+4133) [0.790985 s]</div>
<div class="line">   Assembling...  [1.97598 s]</div>
<div class="line">   Computing preconditioner... [1.4325 s]</div>
<div class="line">   Solving...</div>
<div class="line">      Schur complement: 15 outer CG iterations <span class="keywordflow">for</span> p  [29.9666s ]</div>
<div class="line">      Block Schur preconditioner: 128 GMRES iterations [5.02645 s]</div>
<div class="line">   l_infinity difference between solution vectors: 0.000119671</div>
<div class="line"> </div>
<div class="line">Refinement cycle 4</div>
<div class="line">   Number of active cells: 11456</div>
<div class="line">   Number of degrees of freedom: 327808 (313659+14149) [3.44995 s]</div>
<div class="line">   Assembling...  [7.54772 s]</div>
<div class="line">   Computing preconditioner... [5.46306 s]</div>
<div class="line">   Solving...</div>
<div class="line">      Schur complement: 15 outer CG iterations <span class="keywordflow">for</span> p  [139.987s ]</div>
<div class="line">      Block Schur preconditioner: 255 GMRES iterations [38.0946 s]</div>
<div class="line">   l_infinity difference between solution vectors: 0.00020793</div>
<div class="line"> </div>
<div class="line">Refinement cycle 5</div>
<div class="line">   Number of active cells: 45056</div>
<div class="line">   Number of degrees of freedom: 1254464 (1201371+53093) [19.6795 s]</div>
<div class="line">   Assembling...  [28.6586 s]</div>
<div class="line">   Computing preconditioner... [22.401 s]</div>
<div class="line">   Solving...</div>
<div class="line">      Schur complement: 14 outer CG iterations <span class="keywordflow">for</span> p  [796.767s ]</div>
<div class="line">      Block Schur preconditioner: 524 GMRES iterations [355.597 s]</div>
<div class="line">   l_infinity difference between solution vectors: 0.000501219</div>
</div><!-- fragment --><p>Here, the block preconditioned solver is clearly superior to the Schur complement, but the advantage gets less for more mesh points. This is because GMRES(k) scales worse with the problem size than CG, as we discussed above. Nonetheless, the improvement by a factor of 3-6 for moderate problem sizes is quite impressive.</p>
<p><a class="anchor" id="Combiningtheblockpreconditionerandmultigrid"></a></p><h5>Combining the block preconditioner and multigrid</h5>
<p>An ultimate linear solver for this problem could be imagined as a combination of an optimal preconditioner for \(A\) (e.g. multigrid) and the block preconditioner described above, which is the approach taken in the <a class="el" href="step_31.html">step-31</a> and <a class="el" href="step_32.html">step-32</a> tutorial programs (where we use an algebraic multigrid method) and <a class="el" href="step_56.html">step-56</a> (where we use a geometric multigrid method).</p>
<p><a class="anchor" id="Noblockmatricesandvectors"></a></p><h5>No block matrices and vectors</h5>
<p>Another possibility that can be taken into account is to not set up a block system, but rather solve the system of velocity and pressure all at once. The options are direct solve with UMFPACK (2D) or GMRES with ILU preconditioning (3D). It should be straightforward to try that.</p>
<p><a class="anchor" id="Moreinterestingtestcases"></a></p><h4>More interesting testcases</h4>
<p>The program can of course also serve as a basis to compute the flow in more interesting cases. The original motivation to write this program was for it to be a starting point for some geophysical flow problems, such as the movement of magma under places where continental plates drift apart (for example mid-ocean ridges). Of course, in such places, the geometry is more complicated than the examples shown above, but it is not hard to accommodate for that.</p>
<p>For example, by using the following modification of the boundary values function </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">double</span></div>
<div class="line">BoundaryValues&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>  &amp;p,</div>
<div class="line">                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (component &lt; this-&gt;n_components,</div>
<div class="line">          <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a> (component, 0, this-&gt;n_components));</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> x_offset = <a class="code" href="namespaceDifferentiation_1_1SD.html#a803fcea270d7a523a91e3b7c173059f9">std::atan</a>(p[1]*4)/3;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (component == 0)</div>
<div class="line">    <span class="keywordflow">return</span> (p[0] &lt; x_offset ? -1 : (p[0] &gt; x_offset ? 1 : 0));</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceDifferentiation_1_1SD_html_a803fcea270d7a523a91e3b7c173059f9"><div class="ttname"><a href="namespaceDifferentiation_1_1SD.html#a803fcea270d7a523a91e3b7c173059f9">Differentiation::SD::atan</a></div><div class="ttdeci">Expression atan(const Expression &amp;x)</div><div class="ttdef"><b>Definition:</b> <a href="symengine__math_8cc_source.html#l00147">symengine_math.cc:147</a></div></div>
</div><!-- fragment --><p> and the following way to generate the mesh as the domain \([-2,2]\times[-2,2]\times[-1,0]\) </p><div class="fragment"><div class="line">std::vector&lt;unsigned int&gt; subdivisions (dim, 1);</div>
<div class="line">subdivisions[0] = 4;</div>
<div class="line"><span class="keywordflow">if</span> (dim&gt;2)</div>
<div class="line">  subdivisions[1] = 4;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> bottom_left = (dim == 2 ?</div>
<div class="line">                                <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(-2,-1) :</div>
<div class="line">                                <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(-2,-2,-1));</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> top_right   = (dim == 2 ?</div>
<div class="line">                                <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(2,0) :</div>
<div class="line">                                <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(2,2,0));</div>
<div class="line"> </div>
<div class="line"><a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a> (<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>,</div>
<div class="line">                                           subdivisions,</div>
<div class="line">                                           bottom_left,</div>
<div class="line">                                           top_right);</div>
</div><!-- fragment --><p> then we get images where the fault line is curved: </p><table width="60%" align="center">
<tr>
<td align="center"><img src="https://www.dealii.org/images/steps/developer/step-22.3d-extension.png" alt="" class="inline"/>  </td><td align="center"><img src="https://www.dealii.org/images/steps/developer/step-22.3d-grid-extension.png" alt="" class="inline"/>   </td></tr>
</table>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Copyright (C) 2008 - 2020 by the deal.II authors</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div>
<div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div>
<div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div>
<div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div>
<div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div>
<div class="line"><span class="comment"> * the top level directory of deal.II.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Author: Wolfgang Bangerth, Texas A&amp;M University, 2008</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__vector_8h.html">deal.II/lac/block_vector.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparse__matrix_8h.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__ilu_8h.html">deal.II/lac/sparse_ilu.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>Step22</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keyword">struct </span>InnerPreconditioner;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;&gt;</div>
<div class="line">  <span class="keyword">struct </span>InnerPreconditioner&lt;2&gt;</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">using</span> type = <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a>;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;&gt;</div>
<div class="line">  <span class="keyword">struct </span>InnerPreconditioner&lt;3&gt;</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">using</span> type = <a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a>;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keyword">class </span>StokesProblem</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    StokesProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> setup_dofs();</div>
<div class="line">    <span class="keywordtype">void</span> assemble_system();</div>
<div class="line">    <span class="keywordtype">void</span> solve();</div>
<div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle) <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">void</span> refine_mesh();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div>
<div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>      fe;</div>
<div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>      sparsity_pattern;</div>
<div class="line">    <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> system_matrix;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>      preconditioner_sparsity_pattern;</div>
<div class="line">    <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> preconditioner_matrix;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> solution;</div>
<div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> system_rhs;</div>
<div class="line"> </div>
<div class="line">    std::shared_ptr&lt;typename InnerPreconditioner&lt;dim&gt;::type&gt; A_preconditioner;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    BoundaryValues()</div>
<div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim + 1)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="namespaceinternal.html#aa5bef221c94bc6b9c5441c306a72cdbaa2063c1608d6e0baf80249c42e2be5804">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div>
<div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div>
<div class="line">                              <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  value) <span class="keyword">const override</span>;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div>
<div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component &lt; this-&gt;n_components,</div>
<div class="line">           <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, this-&gt;n_components));</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (component == 0)</div>
<div class="line">      <span class="keywordflow">return</span> (p[0] &lt; 0 ? -1 : (p[0] &gt; 0 ? 1 : 0));</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> BoundaryValues&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div>
<div class="line">                                         <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div>
<div class="line">      <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = BoundaryValues&lt;dim&gt;::value(p, c);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    RightHandSide()</div>
<div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim + 1)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="namespaceinternal.html#aa5bef221c94bc6b9c5441c306a72cdbaa2063c1608d6e0baf80249c42e2be5804">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div>
<div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div>
<div class="line">                              <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  value) <span class="keyword">const override</span>;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div>
<div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> RightHandSide&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div>
<div class="line">                                        <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div>
<div class="line">      <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = RightHandSide&lt;dim&gt;::value(p, c);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div>
<div class="line">  <span class="keyword">class </span>InverseMatrix : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    InverseMatrix(<span class="keyword">const</span> MatrixType &amp;        m,</div>
<div class="line">                  <span class="keyword">const</span> PreconditionerType &amp;preconditioner);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> vmult(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;dst, <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const MatrixType&gt;</a>         <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>;</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const PreconditionerType&gt;</a> preconditioner;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div>
<div class="line">  InverseMatrix&lt;MatrixType, PreconditionerType&gt;::InverseMatrix(</div>
<div class="line">    <span class="keyword">const</span> MatrixType &amp;        m,</div>
<div class="line">    <span class="keyword">const</span> PreconditionerType &amp;preconditioner)</div>
<div class="line">    : <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>(&amp;m)</div>
<div class="line">    , preconditioner(&amp;preconditioner)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div>
<div class="line">  <span class="keywordtype">void</span> InverseMatrix&lt;MatrixType, PreconditionerType&gt;::vmult(</div>
<div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;      dst,</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(src.<a class="code" href="group__Vectors.html#ga81dcfa5c77bdd426603386c0844149ae">size</a>(), 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-6 * src.<a class="code" href="group__Vectors.html#ga8ee1b8309a7a9ecf109c8a7116733ef8">l2_norm</a>());</div>
<div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div>
<div class="line"> </div>
<div class="line">    dst = 0;</div>
<div class="line"> </div>
<div class="line">    cg.solve(*<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, dst, src, *preconditioner);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerType&gt;</div>
<div class="line">  <span class="keyword">class </span>SchurComplement : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    SchurComplement(</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;system_matrix,</div>
<div class="line">      <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>, PreconditionerType&gt; &amp;A_inverse);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> vmult(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;dst, <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const BlockSparseMatrix&lt;double&gt;</a>&gt; system_matrix;</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer</a>&lt;</div>
<div class="line">      <span class="keyword">const</span> InverseMatrix&lt;SparseMatrix&lt;double&gt;, PreconditionerType&gt;&gt;</div>
<div class="line">      A_inverse;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">mutable</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp1, tmp2;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerType&gt;</div>
<div class="line">  SchurComplement&lt;PreconditionerType&gt;::SchurComplement(</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;system_matrix,</div>
<div class="line">    <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>, PreconditionerType&gt; &amp;A_inverse)</div>
<div class="line">    : system_matrix(&amp;system_matrix)</div>
<div class="line">    , A_inverse(&amp;A_inverse)</div>
<div class="line">    , tmp1(system_matrix.block(0, 0).m())</div>
<div class="line">    , tmp2(system_matrix.block(0, 0).m())</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerType&gt;</div>
<div class="line">  <span class="keywordtype">void</span></div>
<div class="line">  SchurComplement&lt;PreconditionerType&gt;::vmult(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;      dst,</div>
<div class="line">                                             <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    system_matrix-&gt;<a class="code" href="group__Matrix1.html#ga1e54eb8c095bf2191a29c36a7784a5b6">block</a>(0, 1).<a class="code" href="classSparseMatrix.html#a7706b5f721efc5ea1966f5a5cdaad0e6">vmult</a>(tmp1, src);</div>
<div class="line">    A_inverse-&gt;vmult(tmp2, tmp1);</div>
<div class="line">    system_matrix-&gt;block(1, 0).vmult(dst, tmp2);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  StokesProblem&lt;dim&gt;::StokesProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div>
<div class="line">    : degree(degree)</div>
<div class="line">    , <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::maximum_smoothing)</div>
<div class="line">    , fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(degree + 1), dim, <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(degree), 1)</div>
<div class="line">    , dof_handler(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::setup_dofs()</div>
<div class="line">  {</div>
<div class="line">    A_preconditioner.reset();</div>
<div class="line">    system_matrix.clear();</div>
<div class="line">    preconditioner_matrix.clear();</div>
<div class="line"> </div>
<div class="line">    dof_handler.distribute_dofs(fe);</div>
<div class="line">    <a class="code" href="namespaceDoFRenumbering.html#a68651164485490b86d901d9ae1fbfc3b">DoFRenumbering::Cuthill_McKee</a>(dof_handler);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;unsigned int&gt; block_component(dim + 1, 0);</div>
<div class="line">    block_component[dim] = 1;</div>
<div class="line">    <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(dof_handler, block_component);</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">      constraints.clear();</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div>
<div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div>
<div class="line">      <a class="code" href="namespaceVectorTools.html#ab2562d41bb26f362043f9719a8cd9b87">VectorTools::interpolate_boundary_values</a>(dof_handler,</div>
<div class="line">                                               1,</div>
<div class="line">                                               BoundaryValues&lt;dim&gt;(),</div>
<div class="line">                                               constraints,</div>
<div class="line">                                               fe.component_mask(velocities));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    constraints.close();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; dofs_per_block =</div>
<div class="line">      <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(dof_handler, block_component);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = dofs_per_block[0];</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_p = dofs_per_block[1];</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells: &quot;</span> &lt;&lt; <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.n_active_cells()</div>
<div class="line">              &lt;&lt; std::endl</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(2, 2);</div>
<div class="line"> </div>
<div class="line">      dsp.block(0, 0).reinit(n_u, n_u);</div>
<div class="line">      dsp.block(1, 0).reinit(n_p, n_u);</div>
<div class="line">      dsp.block(0, 1).reinit(n_u, n_p);</div>
<div class="line">      dsp.block(1, 1).reinit(n_p, n_p);</div>
<div class="line"> </div>
<div class="line">      dsp.collect_sizes();</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div>
<div class="line">          <span class="keywordflow">if</span> (!((c == dim) &amp;&amp; (<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> == dim)))</div>
<div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div>
<div class="line">          <span class="keywordflow">else</span></div>
<div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div>
<div class="line">        dof_handler, coupling, dsp, constraints, <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">      sparsity_pattern.copy_from(dsp);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> preconditioner_dsp(2, 2);</div>
<div class="line"> </div>
<div class="line">      preconditioner_dsp.block(0, 0).reinit(n_u, n_u);</div>
<div class="line">      preconditioner_dsp.block(1, 0).reinit(n_p, n_u);</div>
<div class="line">      preconditioner_dsp.block(0, 1).reinit(n_u, n_p);</div>
<div class="line">      preconditioner_dsp.block(1, 1).reinit(n_p, n_p);</div>
<div class="line"> </div>
<div class="line">      preconditioner_dsp.collect_sizes();</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> preconditioner_coupling(dim + 1, dim + 1);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div>
<div class="line">          <span class="keywordflow">if</span> (((c == dim) &amp;&amp; (<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> == dim)))</div>
<div class="line">            preconditioner_coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div>
<div class="line">          <span class="keywordflow">else</span></div>
<div class="line">            preconditioner_coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler,</div>
<div class="line">                                      preconditioner_coupling,</div>
<div class="line">                                      preconditioner_dsp,</div>
<div class="line">                                      constraints,</div>
<div class="line">                                      <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">      preconditioner_sparsity_pattern.copy_from(preconditioner_dsp);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    system_matrix.reinit(sparsity_pattern);</div>
<div class="line">    preconditioner_matrix.reinit(preconditioner_sparsity_pattern);</div>
<div class="line"> </div>
<div class="line">    solution.reinit(2);</div>
<div class="line">    solution.block(0).reinit(n_u);</div>
<div class="line">    solution.block(1).reinit(n_p);</div>
<div class="line">    solution.collect_sizes();</div>
<div class="line"> </div>
<div class="line">    system_rhs.reinit(2);</div>
<div class="line">    system_rhs.block(0).reinit(n_u);</div>
<div class="line">    system_rhs.block(1).reinit(n_p);</div>
<div class="line">    system_rhs.collect_sizes();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::assemble_system()</div>
<div class="line">  {</div>
<div class="line">    system_matrix         = 0;</div>
<div class="line">    system_rhs            = 0;</div>
<div class="line">    preconditioner_matrix = 0;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(degree + 2);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div>
<div class="line">                            quadrature_formula,</div>
<div class="line">                            <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div>
<div class="line">                              <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.size();</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div>
<div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_preconditioner_matrix(dofs_per_cell,</div>
<div class="line">                                                   dofs_per_cell);</div>
<div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     local_rhs(dofs_per_cell);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> RightHandSide&lt;dim&gt;    right_hand_side;</div>
<div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; rhs_values(n_q_points, <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim + 1));</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; symgrad_phi_u(dofs_per_cell);</div>
<div class="line">    std::vector&lt;double&gt;                  div_phi_u(dofs_per_cell);</div>
<div class="line">    std::vector&lt;double&gt;                  phi_p(dofs_per_cell);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.active_cell_iterators())</div>
<div class="line">      {</div>
<div class="line">        fe_values.reinit(cell);</div>
<div class="line">        local_matrix                = 0;</div>
<div class="line">        local_preconditioner_matrix = 0;</div>
<div class="line">        local_rhs                   = 0;</div>
<div class="line"> </div>
<div class="line">        right_hand_side.vector_value_list(fe_values.get_quadrature_points(),</div>
<div class="line">                                          rhs_values);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div>
<div class="line">          {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div>
<div class="line">              {</div>
<div class="line">                symgrad_phi_u[k] =</div>
<div class="line">                  fe_values[velocities].symmetric_gradient(k, q);</div>
<div class="line">                div_phi_u[k] = fe_values[velocities].divergence(k, q);</div>
<div class="line">                phi_p[k]     = fe_values[pressure].value(k, q);</div>
<div class="line">              }</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div>
<div class="line">              {</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt;= i; ++j)</div>
<div class="line">                  {</div>
<div class="line">                    local_matrix(i, j) +=</div>
<div class="line">                      (2 * (symgrad_phi_u[i] * symgrad_phi_u[j]) <span class="comment">// (1)</span></div>
<div class="line">                       - div_phi_u[i] * phi_p[j]                 <span class="comment">// (2)</span></div>
<div class="line">                       - phi_p[i] * div_phi_u[j])                <span class="comment">// (3)</span></div>
<div class="line">                      * fe_values.JxW(q);                        <span class="comment">// * dx</span></div>
<div class="line"> </div>
<div class="line">                    local_preconditioner_matrix(i, j) +=</div>
<div class="line">                      (phi_p[i] * phi_p[j]) <span class="comment">// (4)</span></div>
<div class="line">                      * fe_values.JxW(q);   <span class="comment">// * dx</span></div>
<div class="line">                  }</div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component_i =</div>
<div class="line">                  fe.system_to_component_index(i).first;</div>
<div class="line">                local_rhs(i) += (fe_values.shape_value(i, q)   <span class="comment">// (phi_u_i(x_q)</span></div>
<div class="line">                                 * rhs_values[q](component_i)) <span class="comment">// * f(x_q))</span></div>
<div class="line">                                * fe_values.JxW(q);            <span class="comment">// * dx</span></div>
<div class="line">              }</div>
<div class="line">          }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = i + 1; j &lt; dofs_per_cell; ++j)</div>
<div class="line">            {</div>
<div class="line">              local_matrix(i, j) = local_matrix(j, i);</div>
<div class="line">              local_preconditioner_matrix(i, j) =</div>
<div class="line">                local_preconditioner_matrix(j, i);</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div>
<div class="line">        constraints.distribute_local_to_global(local_matrix,</div>
<div class="line">                                               local_rhs,</div>
<div class="line">                                               local_dof_indices,</div>
<div class="line">                                               system_matrix,</div>
<div class="line">                                               system_rhs);</div>
<div class="line">        constraints.distribute_local_to_global(local_preconditioner_matrix,</div>
<div class="line">                                               local_dof_indices,</div>
<div class="line">                                               preconditioner_matrix);</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Computing preconditioner...&quot;</span> &lt;&lt; std::endl &lt;&lt; std::flush;</div>
<div class="line"> </div>
<div class="line">    A_preconditioner =</div>
<div class="line">      std::make_shared&lt;typename InnerPreconditioner&lt;dim&gt;::type&gt;();</div>
<div class="line">    A_preconditioner-&gt;initialize(</div>
<div class="line">      system_matrix.block(0, 0),</div>
<div class="line">      <span class="keyword">typename</span> InnerPreconditioner&lt;dim&gt;::type::AdditionalData());</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::solve()</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">const</span> InverseMatrix&lt;SparseMatrix&lt;double&gt;,</div>
<div class="line">                        <span class="keyword">typename</span> InnerPreconditioner&lt;dim&gt;::type&gt;</div>
<div class="line">                   A_inverse(system_matrix.block(0, 0), *A_preconditioner);</div>
<div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp(solution.block(0).size());</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="classVector.html">Vector&lt;double&gt;</a> schur_rhs(solution.block(1).size());</div>
<div class="line">      A_inverse.vmult(tmp, system_rhs.block(0));</div>
<div class="line">      system_matrix.block(1, 0).vmult(schur_rhs, tmp);</div>
<div class="line">      schur_rhs -= system_rhs.block(1);</div>
<div class="line"> </div>
<div class="line">      SchurComplement&lt;typename InnerPreconditioner&lt;dim&gt;::type&gt; <a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>(</div>
<div class="line">        system_matrix, A_inverse);</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(solution.block(1).size(),</div>
<div class="line">                                   1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-6 * schur_rhs.l2_norm());</div>
<div class="line">      <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a> preconditioner;</div>
<div class="line">      preconditioner.<a class="code" href="group__Preconditioners.html#gae4b56dfaab3fd8820faa1b21160b1acb">initialize</a>(preconditioner_matrix.block(1, 1),</div>
<div class="line">                                <a class="code" href="group__Preconditioners.html#gae21347f3202a1186060eac36dcb45817">SparseILU&lt;double&gt;::AdditionalData</a>());</div>
<div class="line"> </div>
<div class="line">      InverseMatrix&lt;SparseMatrix&lt;double&gt;, <a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a>&gt; m_inverse(</div>
<div class="line">        preconditioner_matrix.block(1, 1), preconditioner);</div>
<div class="line"> </div>
<div class="line">      cg.solve(<a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>, solution.block(1), schur_rhs, m_inverse);</div>
<div class="line"> </div>
<div class="line">      constraints.distribute(solution);</div>
<div class="line"> </div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; solver_control.last_step()</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot; outer CG Schur complement iterations for pressure&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">      system_matrix.block(0, 1).vmult(tmp, solution.block(1));</div>
<div class="line">      tmp *= -1;</div>
<div class="line">      tmp += system_rhs.block(0);</div>
<div class="line"> </div>
<div class="line">      A_inverse.vmult(solution.block(0), tmp);</div>
<div class="line"> </div>
<div class="line">      constraints.distribute(solution);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span></div>
<div class="line">  StokesProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    std::vector&lt;std::string&gt; solution_names(dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div>
<div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;pressure&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div>
<div class="line">      data_component_interpretation(</div>
<div class="line">        dim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div>
<div class="line">    data_component_interpretation.push_back(</div>
<div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div>
<div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a>(dof_handler);</div>
<div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a>(solution,</div>
<div class="line">                             solution_names,</div>
<div class="line">                             <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div>
<div class="line">                             data_component_interpretation);</div>
<div class="line">    data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a>();</div>
<div class="line"> </div>
<div class="line">    std::ofstream output(</div>
<div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(refinement_cycle, 2) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div>
<div class="line">    data_out.<a class="code" href="group__Exceptions.html#gacad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::refine_mesh()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.n_active_cells());</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div>
<div class="line">    <a class="code" href="classKellyErrorEstimator.html#aa0917e696d4f8ddb983223a68c512357">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div>
<div class="line">      dof_handler,</div>
<div class="line">      <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(degree + 1),</div>
<div class="line">      std::map&lt;<a class="code" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div>
<div class="line">      solution,</div>
<div class="line">      estimated_error_per_cell,</div>
<div class="line">      fe.component_mask(pressure));</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>,</div>
<div class="line">                                                    estimated_error_per_cell,</div>
<div class="line">                                                    0.3,</div>
<div class="line">                                                    0.0);</div>
<div class="line">    <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.execute_coarsening_and_refinement();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">StokesProblem&lt;dim&gt;::run</a>()</div>
<div class="line">  {</div>
<div class="line">    {</div>
<div class="line">      std::vector&lt;unsigned int&gt; subdivisions(dim, 1);</div>
<div class="line">      subdivisions[0] = 4;</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> bottom_left = (dim == 2 ?                </div>
<div class="line">                                        <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(-2, -1) :    <span class="comment">// 2d case</span></div>
<div class="line">                                        <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(-2, 0, -1)); <span class="comment">// 3d case</span></div>
<div class="line"> </div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> top_right = (dim == 2 ?              </div>
<div class="line">                                      <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(2, 0) :    <span class="comment">// 2d case</span></div>
<div class="line">                                      <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(2, 1, 0)); <span class="comment">// 3d case</span></div>
<div class="line"> </div>
<div class="line">      <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>,</div>
<div class="line">                                                subdivisions,</div>
<div class="line">                                                bottom_left,</div>
<div class="line">                                                top_right);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.active_cell_iterators())</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div>
<div class="line">        <span class="keywordflow">if</span> (face-&gt;center()[dim - 1] == 0)</div>
<div class="line">          face-&gt;set_all_boundary_ids(1);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.refine_global(4 - dim);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle = 0; refinement_cycle &lt; 6;</div>
<div class="line">         ++refinement_cycle)</div>
<div class="line">      {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Refinement cycle &quot;</span> &lt;&lt; refinement_cycle &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (refinement_cycle &gt; 0)</div>
<div class="line">          refine_mesh();</div>
<div class="line"> </div>
<div class="line">        setup_dofs();</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Assembling...&quot;</span> &lt;&lt; std::endl &lt;&lt; std::flush;</div>
<div class="line">        assemble_system();</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving...&quot;</span> &lt;&lt; std::flush;</div>
<div class="line">        solve();</div>
<div class="line"> </div>
<div class="line">        output_results(refinement_cycle);</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; std::endl;</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line">} <span class="comment">// namespace Step22</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">using namespace </span>Step22;</div>
<div class="line"> </div>
<div class="line">      StokesProblem&lt;2&gt; flow_problem(1);</div>
<div class="line">      flow_problem.run();</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceinternal_html_aa5bef221c94bc6b9c5441c306a72cdbaa2063c1608d6e0baf80249c42e2be5804"><div class="ttname"><a href="namespaceinternal.html#aa5bef221c94bc6b9c5441c306a72cdbaa2063c1608d6e0baf80249c42e2be5804">internal::EvaluatorQuantity::value</a></div><div class="ttdeci">@ value</div></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
