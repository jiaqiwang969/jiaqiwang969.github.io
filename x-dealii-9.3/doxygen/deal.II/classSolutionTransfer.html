<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classSolutionTransfer.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: SolutionTransfer&lt; dim, VectorType, DoFHandlerType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.3.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.3.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classSolutionTransfer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SolutionTransfer&lt; dim, VectorType, DoFHandlerType &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__numerics.html">Numerical algorithms</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="numerics_2solution__transfer_8h_source.html">deal.II/numerics/solution_transfer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSolutionTransfer_1_1Pointerstruct.html">Pointerstruct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a51ca915311f5f1edf0c81b549541dbdb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolutionTransfer.html#a51ca915311f5f1edf0c81b549541dbdb">SolutionTransfer</a> (const DoFHandlerType &amp;dof)</td></tr>
<tr class="separator:a51ca915311f5f1edf0c81b549541dbdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66670df7484e20dd5d3d6f1a1b4d2add"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolutionTransfer.html#a66670df7484e20dd5d3d6f1a1b4d2add">~SolutionTransfer</a> ()</td></tr>
<tr class="separator:a66670df7484e20dd5d3d6f1a1b4d2add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed191ba55286dcc60dbbe2d5726b91f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolutionTransfer.html#a3ed191ba55286dcc60dbbe2d5726b91f">clear</a> ()</td></tr>
<tr class="separator:a3ed191ba55286dcc60dbbe2d5726b91f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0192f0cea35d139efa08d2415b7935"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolutionTransfer.html#a3c0192f0cea35d139efa08d2415b7935">prepare_for_pure_refinement</a> ()</td></tr>
<tr class="separator:a3c0192f0cea35d139efa08d2415b7935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6dc5e5a74b166b0dea35f5a64694e69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolutionTransfer.html#ae6dc5e5a74b166b0dea35f5a64694e69">prepare_for_coarsening_and_refinement</a> (const std::vector&lt; VectorType &gt; &amp;all_in)</td></tr>
<tr class="separator:ae6dc5e5a74b166b0dea35f5a64694e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c29cbe7cfc892b6a0e2852f9b542195"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolutionTransfer.html#a0c29cbe7cfc892b6a0e2852f9b542195">prepare_for_coarsening_and_refinement</a> (const VectorType &amp;in)</td></tr>
<tr class="separator:a0c29cbe7cfc892b6a0e2852f9b542195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b74b1d43d76f40eed53d674a8c31b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolutionTransfer.html#a97b74b1d43d76f40eed53d674a8c31b8">refine_interpolate</a> (const VectorType &amp;in, VectorType &amp;out) const</td></tr>
<tr class="separator:a97b74b1d43d76f40eed53d674a8c31b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae067f9b520ed50c86a9ff4c7776d16cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolutionTransfer.html#ae067f9b520ed50c86a9ff4c7776d16cb">interpolate</a> (const std::vector&lt; VectorType &gt; &amp;all_in, std::vector&lt; VectorType &gt; &amp;all_out) const</td></tr>
<tr class="separator:ae067f9b520ed50c86a9ff4c7776d16cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac20bf49183b53b80ee42b9c9de3b912a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolutionTransfer.html#ac20bf49183b53b80ee42b9c9de3b912a">interpolate</a> (const VectorType &amp;in, VectorType &amp;out) const</td></tr>
<tr class="separator:ac20bf49183b53b80ee42b9c9de3b912a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539165cdfce0bb1a8212d0e03dae5ea8"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolutionTransfer.html#a539165cdfce0bb1a8212d0e03dae5ea8">memory_consumption</a> () const</td></tr>
<tr class="separator:a539165cdfce0bb1a8212d0e03dae5ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ga3721cde4a3f10d51ff0106026c015f5f"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga3721cde4a3f10d51ff0106026c015f5f">ExcNotPrepared</a> ()</td></tr>
<tr class="separator:ga3721cde4a3f10d51ff0106026c015f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3f98b15759a4ee54dbdf0e48f505025"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gab3f98b15759a4ee54dbdf0e48f505025">ExcAlreadyPrepForRef</a> ()</td></tr>
<tr class="separator:gab3f98b15759a4ee54dbdf0e48f505025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c08362d31f90c2a0abdbf6524dd6cc7"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga0c08362d31f90c2a0abdbf6524dd6cc7">ExcAlreadyPrepForCoarseAndRef</a> ()</td></tr>
<tr class="separator:ga0c08362d31f90c2a0abdbf6524dd6cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:ad03cb34b1ace26f6cc38e9ecaa5eab46"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolutionTransfer.html#ad03cb34b1ace26f6cc38e9ecaa5eab46">PreparationState</a> { <a class="el" href="classSolutionTransfer.html#ad03cb34b1ace26f6cc38e9ecaa5eab46af0ca00a1fbc5e9b0ac30f88c03290be8">none</a>
, <a class="el" href="classSolutionTransfer.html#ad03cb34b1ace26f6cc38e9ecaa5eab46a356685bb252a3b5b18b4252ea9425c27">pure_refinement</a>
, <a class="el" href="classSolutionTransfer.html#ad03cb34b1ace26f6cc38e9ecaa5eab46a3be89a5036cd26755bb67c44f6c58b40">coarsening_and_refinement</a>
 }</td></tr>
<tr class="separator:ad03cb34b1ace26f6cc38e9ecaa5eab46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a915d45872cc7d604eb4e3621dd9487c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const DoFHandlerType, <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt; dim, VectorType, DoFHandlerType &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolutionTransfer.html#a915d45872cc7d604eb4e3621dd9487c7">dof_handler</a></td></tr>
<tr class="separator:a915d45872cc7d604eb4e3621dd9487c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0520033cc7cf67ce3c85542db4b3d41e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolutionTransfer.html#a0520033cc7cf67ce3c85542db4b3d41e">n_dofs_old</a></td></tr>
<tr class="separator:a0520033cc7cf67ce3c85542db4b3d41e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef958d2b9c74657af8202458f47416d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSolutionTransfer.html#ad03cb34b1ace26f6cc38e9ecaa5eab46">PreparationState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolutionTransfer.html#a9ef958d2b9c74657af8202458f47416d">prepared_for</a></td></tr>
<tr class="separator:a9ef958d2b9c74657af8202458f47416d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a270e07ab5108066b6889c98908145bdd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolutionTransfer.html#a270e07ab5108066b6889c98908145bdd">indices_on_cell</a></td></tr>
<tr class="separator:a270e07ab5108066b6889c98908145bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584314a20a2e1a2fce88d0b658f174ba"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::pair&lt; unsigned int, unsigned int &gt;, <a class="el" href="structSolutionTransfer_1_1Pointerstruct.html">Pointerstruct</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolutionTransfer.html#a584314a20a2e1a2fce88d0b658f174ba">cell_map</a></td></tr>
<tr class="separator:a584314a20a2e1a2fce88d0b658f174ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1422cf92e0b8132bf5471b00a2fddec7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolutionTransfer.html#a1422cf92e0b8132bf5471b00a2fddec7">dof_values_on_cell</a></td></tr>
<tr class="separator:a1422cf92e0b8132bf5471b00a2fddec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, typename VectorType = Vector&lt;double&gt;, typename DoFHandlerType = DoFHandler&lt;dim&gt;&gt;<br />
class SolutionTransfer&lt; dim, VectorType, DoFHandlerType &gt;</h3>

<p>This class implements the transfer of a discrete FE function (e.g. a solution vector) from one mesh to another that is obtained from the first by a single refinement and/or coarsening step. During interpolation the vector is reinitialized to the new size and filled with the interpolated values. This class is used in the <a class="el" href="step_15.html">step-15</a>, <a class="el" href="step_26.html">step-26</a>, <a class="el" href="step_31.html">step-31</a>, and <a class="el" href="step_33.html">step-33</a> tutorial programs. A version of this class that works on parallel triangulations is available as <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a>.</p>
<h3>Usage</h3>
<p>This class implements the algorithms in two different ways: </p><ul>
<li>
<p class="startli">If the grid will only be refined (i.e. no cells are coarsened) then use <code><a class="el" href="classSolutionTransfer.html">SolutionTransfer</a></code> as follows: </p><div class="fragment"><div class="line"><a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim, double&gt;</a> soltrans(*<a class="code" href="classSolutionTransfer.html#a915d45872cc7d604eb4e3621dd9487c7">dof_handler</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// flag some cells for refinement, e.g.</span></div>
<div class="line"><a class="code" href="namespaceGridRefinement.html#ae90dc87c4db158b8d01f6d564ac614e5">GridRefinement::refine_and_coarsen_fixed_fraction</a>(*tria,</div>
<div class="line">                                                  error_indicators,</div>
<div class="line">                                                  0.3,</div>
<div class="line">                                                  0);</div>
<div class="line"><span class="comment">// prepare the triangulation for refinement,</span></div>
<div class="line">tria-&gt;prepare_coarsening_and_refinement();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// tell the SolutionTransfer object that we intend to do pure refinement,</span></div>
<div class="line">soltrans.prepare_for_pure_refinement();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// actually execute the refinement,</span></div>
<div class="line">tria-&gt;execute_coarsening_and_refinement();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// and redistribute dofs.</span></div>
<div class="line"><a class="code" href="classSolutionTransfer.html#a915d45872cc7d604eb4e3621dd9487c7">dof_handler</a>-&gt;distribute_dofs (fe);</div>
<div class="ttc" id="aclassSolutionTransfer_html"><div class="ttname"><a href="classSolutionTransfer.html">SolutionTransfer</a></div><div class="ttdef"><b>Definition:</b> <a href="numerics_2solution__transfer_8h_source.html#l00338">solution_transfer.h:339</a></div></div>
<div class="ttc" id="aclassSolutionTransfer_html_a915d45872cc7d604eb4e3621dd9487c7"><div class="ttname"><a href="classSolutionTransfer.html#a915d45872cc7d604eb4e3621dd9487c7">SolutionTransfer::dof_handler</a></div><div class="ttdeci">SmartPointer&lt; const DoFHandlerType, SolutionTransfer&lt; dim, VectorType, DoFHandlerType &gt; &gt; dof_handler</div><div class="ttdef"><b>Definition:</b> <a href="numerics_2solution__transfer_8h_source.html#l00481">solution_transfer.h:481</a></div></div>
<div class="ttc" id="anamespaceGridRefinement_html_ae90dc87c4db158b8d01f6d564ac614e5"><div class="ttname"><a href="namespaceGridRefinement.html#ae90dc87c4db158b8d01f6d564ac614e5">GridRefinement::refine_and_coarsen_fixed_fraction</a></div><div class="ttdeci">void refine_and_coarsen_fixed_fraction(Triangulation&lt; dim, spacedim &gt; &amp;tria, const Vector&lt; Number &gt; &amp;criteria, const double top_fraction, const double bottom_fraction, const unsigned int max_n_cells=std::numeric_limits&lt; unsigned int &gt;::max(), const VectorTools::NormType norm_type=VectorTools::NormType::L1_norm)</div><div class="ttdef"><b>Definition:</b> <a href="grid_2grid__refinement_8cc_source.html#l00390">grid_refinement.cc:390</a></div></div>
</div><!-- fragment --><p class="interli">Then to proceed do </p><div class="fragment"><div class="line"><span class="comment">// take a copy of the solution vector</span></div>
<div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution_old(solution);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// resize solution vector to the correct size, as the @p refine_interpolate</span></div>
<div class="line"><span class="comment">// function requires the vectors to be of right sizes</span></div>
<div class="line">solution.reinit(<a class="code" href="classSolutionTransfer.html#a915d45872cc7d604eb4e3621dd9487c7">dof_handler</a>-&gt;n_dofs());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// and finally interpolate</span></div>
<div class="line">soltrans.refine_interpolate(solution_old, solution);</div>
<div class="ttc" id="aclassVector_html"><div class="ttname"><a href="classVector.html">Vector&lt; double &gt;</a></div></div>
</div><!-- fragment --><p class="interli">Although the <code>refine_interpolate</code> functions are allowed to be called multiple times, e.g. for interpolating several solution vectors, there is the following possibility of interpolating several functions simultaneously. </p><div class="fragment"><div class="line">std::vector&lt;Vector&lt;double&gt; &gt; solutions_old(n_vectors, <a class="code" href="classVector.html">Vector&lt;double&gt;</a> (n));</div>
<div class="line">...</div>
<div class="line">std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt; solutions(n_vectors, <a class="code" href="classVector.html">Vector&lt;double&gt;</a> (n));</div>
<div class="line">soltrans.refine_interpolate(solutions_old, solutions);</div>
</div><!-- fragment --><p> This is used in several of the tutorial programs, for example <a class="el" href="step_31.html">step-31</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">If the grid has cells that will be coarsened, then use <code><a class="el" href="classSolutionTransfer.html">SolutionTransfer</a></code> as follows: </p><div class="fragment"><div class="line"><a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim, Vector&lt;double&gt;</a> &gt; soltrans(*<a class="code" href="classSolutionTransfer.html#a915d45872cc7d604eb4e3621dd9487c7">dof_handler</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// flag some cells for refinement and coarsening, e.g.</span></div>
<div class="line"><a class="code" href="namespaceGridRefinement.html#ae90dc87c4db158b8d01f6d564ac614e5">GridRefinement::refine_and_coarsen_fixed_fraction</a>(*tria,</div>
<div class="line">                                                  error_indicators,</div>
<div class="line">                                                  0.3,</div>
<div class="line">                                                  0.05);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// prepare the triangulation,</span></div>
<div class="line">tria-&gt;prepare_coarsening_and_refinement();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// prepare the SolutionTransfer object for coarsening and refinement and give</span></div>
<div class="line"><span class="comment">// the solution vector that we intend to interpolate later,</span></div>
<div class="line">soltrans.prepare_for_coarsening_and_refinement(solution);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// actually execute the refinement,</span></div>
<div class="line">tria-&gt;execute_coarsening_and_refinement ();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// redistribute dofs,</span></div>
<div class="line"><a class="code" href="classSolutionTransfer.html#a915d45872cc7d604eb4e3621dd9487c7">dof_handler</a>-&gt;distribute_dofs (fe);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// and interpolate the solution</span></div>
<div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> interpolate_solution(<a class="code" href="classSolutionTransfer.html#a915d45872cc7d604eb4e3621dd9487c7">dof_handler</a>-&gt;n_dofs());</div>
<div class="line">soltrans.interpolate(solution, interpolated_solution);</div>
</div><!-- fragment --><p class="interli">If the grid is partitioned across several MPI processes, then it is important to note that the old solution(s) must be copied to one that also provides access to the locally relevant DoF values (these values required for the interpolation process): </p><div class="fragment"><div class="line"><span class="comment">// Create initial indexsets pertaining to the grid before refinement</span></div>
<div class="line"><a class="code" href="classIndexSet.html">IndexSet</a> locally_owned_dofs, locally_relevant_dofs;</div>
<div class="line">locally_owned_dofs = <a class="code" href="classSolutionTransfer.html#a915d45872cc7d604eb4e3621dd9487c7">dof_handler</a>.locally_owned_dofs();</div>
<div class="line"><a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(<a class="code" href="classSolutionTransfer.html#a915d45872cc7d604eb4e3621dd9487c7">dof_handler</a>, locally_relevant_dofs);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The solution vector only knows about locally owned DoFs</span></div>
<div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> solution;</div>
<div class="line">solution.<a class="code" href="group__TrilinosWrappers.html#ga655ae9c8d3595133abe1131fcbb97b6d">reinit</a>(locally_owned_dofs,</div>
<div class="line">                mpi_communicator);</div>
<div class="line">...</div>
<div class="line"><span class="comment">// Transfer solution to vector that provides access to locally relevant DoFs</span></div>
<div class="line">TrilinosWrappers::MPI::Vector old_solution;</div>
<div class="line">old_solution.reinit(locally_owned_dofs,</div>
<div class="line">                    locally_relevant_dofs,</div>
<div class="line">                    mpi_communicator);</div>
<div class="line">old_solution = solution;</div>
<div class="line">...</div>
<div class="line"><span class="comment">// Refine grid</span></div>
<div class="line"><span class="comment">// Recreate locally_owned_dofs and locally_relevant_dofs index sets</span></div>
<div class="line">...</div>
<div class="line">solution.<a class="code" href="group__TrilinosWrappers.html#ga655ae9c8d3595133abe1131fcbb97b6d">reinit</a>(locally_owned_dofs, mpi_communicator);</div>
<div class="line">soltrans.refine_interpolate(old_solution, solution);</div>
<div class="ttc" id="aclassIndexSet_html"><div class="ttname"><a href="classIndexSet.html">IndexSet</a></div><div class="ttdef"><b>Definition:</b> <a href="index__set_8h_source.html#l00072">index_set.h:73</a></div></div>
<div class="ttc" id="aclassTrilinosWrappers_1_1MPI_1_1Vector_html"><div class="ttname"><a href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a></div><div class="ttdef"><b>Definition:</b> <a href="trilinos__vector_8h_source.html#l00403">trilinos_vector.h:404</a></div></div>
<div class="ttc" id="agroup__TrilinosWrappers_html_ga655ae9c8d3595133abe1131fcbb97b6d"><div class="ttname"><a href="group__TrilinosWrappers.html#ga655ae9c8d3595133abe1131fcbb97b6d">TrilinosWrappers::MPI::Vector::reinit</a></div><div class="ttdeci">void reinit(const Vector &amp;v, const bool omit_zeroing_entries=false, const bool allow_different_maps=false)</div><div class="ttdef"><b>Definition:</b> <a href="trilinos__vector_8cc_source.html#l00198">trilinos_vector.cc:198</a></div></div>
<div class="ttc" id="anamespaceDoFTools_html_acad7e0841b9046eaafddc4c617ab1d9d"><div class="ttname"><a href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a></div><div class="ttdeci">void extract_locally_relevant_dofs(const DoFHandler&lt; dim, spacedim &gt; &amp;dof_handler, IndexSet &amp;dof_set)</div><div class="ttdef"><b>Definition:</b> <a href="dof__tools_8cc_source.html#l01210">dof_tools.cc:1210</a></div></div>
</div><!-- fragment --><p class="endli">Multiple calls to the function <code>interpolate (const Vector&lt;number&gt; &amp;in, Vector&lt;number&gt; &amp;out)</code> are NOT allowed. Interpolating several functions can be performed in one step by using <code>void interpolate (const vector&lt;Vector&lt;number&gt; &gt;&amp;all_in, vector&lt;Vector&lt;number&gt; &gt;&amp;all_out) const</code>, and using the respective <code>prepare_for_coarsening_and_refinement</code> function taking several vectors as input before actually refining and coarsening the triangulation (see there). </p>
</li>
</ul>
<p>For deleting all stored data in <code><a class="el" href="classSolutionTransfer.html">SolutionTransfer</a></code> and reinitializing it use the <code><a class="el" href="classSolutionTransfer.html#a3ed191ba55286dcc60dbbe2d5726b91f">clear()</a></code> function.</p>
<p>The template argument <code>number</code> denotes the data type of the vectors you want to transfer.</p>
<h3>Interpolating in the presence of hanging nodes and boundary values</h3>
<p>The interpolation onto the new mesh is a local operation, i.e., it interpolates onto the new mesh only. If that new mesh has hanging nodes, you will therefore get a solution that does not satisfy hanging node constraints. The same is true with boundary values: the interpolated solution will just be the interpolation of the old solution at the boundary, and this may or may not satisfy boundary values at newly introduced boundary nodes.</p>
<p>Consequently, you may have to apply hanging node or boundary value constraints after interpolation. <a class="el" href="step_15.html">step-15</a> and <a class="el" href="step_26.html">step-26</a> have examples of dealing with this.</p>
<h3>Implementation</h3>
<ul>
<li>
<p class="startli">Solution transfer with only refinement. Assume that we have got a solution vector on the current (original) grid. Each entry of this vector belongs to one of the DoFs of the discretization. If we now refine the grid then the calling of <a class="el" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">DoFHandler::distribute_dofs()</a> will change at least some of the DoF indices. Hence we need to store the DoF indices of all active cells before the refinement. A pointer for each active cell is used to point to the vector of these DoF indices of that cell. This is done by <a class="el" href="classSolutionTransfer.html#a3c0192f0cea35d139efa08d2415b7935">prepare_for_pure_refinement()</a>.</p>
<p class="interli">In the function <code>refine_interpolate(in,out)</code> and on each cell where the pointer is set (i.e. the cells that were active in the original grid) we can now access the local values of the solution vector <code>in</code> on that cell by using the stored DoF indices. These local values are interpolated and set into the vector <code>out</code> that is at the end the discrete function <code>in</code> interpolated on the refined mesh.</p>
<p class="interli">The <code>refine_interpolate(in,out)</code> function can be called multiple times for arbitrary many discrete functions (solution vectors) on the original grid.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Solution transfer with coarsening and refinement. After calling <a class="el" href="classTriangulation.html#abf55199c30b0330cf9bf98e2582078e1">Triangulation::prepare_coarsening_and_refinement</a> the coarsen flags of either all or none of the children of a (father-)cell are set. While coarsening (<a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">Triangulation::execute_coarsening_and_refinement</a>) the cells that are not needed any more will be deleted from the <a class="el" href="classTriangulation.html">Triangulation</a>.</p>
<p class="interli">For the interpolation from the (to be coarsenend) children to their father the children cells are needed. Hence this interpolation and the storing of the interpolated values of each of the discrete functions that we want to interpolate needs to take place before these children cells are coarsened (and deleted!!). Again a pointer for each relevant cell is set to point to these values (see below). Additionally the DoF indices of the cells that will not be coarsened need to be stored according to the solution transfer with pure refinement (cf there). All this is performed by <code>prepare_for_coarsening_and_refinement(all_in)</code> where the <code>vector&lt;Vector&lt;number&gt; &gt; all_in</code> includes all discrete functions to be interpolated onto the new grid.</p>
<p class="interli">As we need two different kinds of pointers (<code>vector&lt;unsigned int&gt; *</code> for the Dof indices and <code>vector&lt;Vector&lt;number&gt; &gt; *</code> for the interpolated DoF values) we use the <code><a class="el" href="structSolutionTransfer_1_1Pointerstruct.html">Pointerstruct</a></code> that includes both of these pointers and the pointer for each cell points to these <code>Pointerstructs</code>. On each cell only one of the two different pointers is used at one time hence we could use a <code>void * pointer</code> as <code>vector&lt;unsigned int&gt; *</code> at one time and as <code>vector&lt;Vector&lt;number&gt; &gt; *</code> at the other but using this <code><a class="el" href="structSolutionTransfer_1_1Pointerstruct.html">Pointerstruct</a></code> in between makes the use of these pointers more safe and gives better possibility to expand their usage.</p>
<p class="endli">In <code>interpolate(all_in, all_out)</code> the refined cells are treated according to the solution transfer while pure refinement. Additionally, on each cell that is coarsened (hence previously was a father cell), the values of the discrete functions in <code>all_out</code> are set to the stored local interpolated values that are accessible due to the 'vector&lt;Vector&lt;number&gt; &gt; *' pointer in <code><a class="el" href="structSolutionTransfer_1_1Pointerstruct.html">Pointerstruct</a></code> that is pointed to by the pointer of that cell. It is clear that <code>interpolate(all_in, all_out)</code> only can be called with the <code>vector&lt;Vector&lt;number&gt; &gt; all_in</code> that previously was the parameter of the <code>prepare_for_coarsening_and_refinement(all_in)</code> function. Hence <code>interpolate(all_in, all_out)</code> can (in contrast to <code>refine_interpolate(in, out)</code>) only be called once. </p>
</li>
</ul>
<h3>Interaction with hanging nodes</h3>
<p>This class does its best to represent on the new mesh the finite element function that existed on the old mesh, but this may lead to situations where the function on the new mesh is no longer conforming at hanging nodes. To this end, consider a situation of a twice refined mesh that started with a single square cell (i.e., we now have 16 cells). Consider also that we coarsen 4 of the cells back to the first refinement level. In this case, we end up with a mesh that will look as follows if we were to use a \(Q_1\) element:</p>
<div class="image">
<img src="hanging_nodes.png" alt=""/>
</div>
<p>The process of interpolating from the old to the new mesh would imply that the values of the finite element function will not change on all of the cells that remained as they are (i.e., the fine cells) but that on the coarse cell at the top right, the four values at the vertices are obtained by interpolating down from its former children. If the original function was not linear, this implies that the marked hanging nodes will retain their old values which, in general, will not lead to a continuous function along the corresponding edges. In other words, the solution vector obtained after <a class="el" href="classSolutionTransfer.html#ae067f9b520ed50c86a9ff4c7776d16cb">SolutionTransfer::interpolate()</a> does not satisfy hanging node constraints: it corresponds to the pointwise interpolation, but not to the interpolation <em>onto the new finite element space that contains constraints from hanging nodes</em>.</p>
<p>Whether this is a problem you need to worry about or not depends on your application. The situation is easily corrected, of course, by applying <a class="el" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">AffineConstraints::distribute()</a> to your solution vector after transfer, using a constraints object computed on the new <a class="el" href="classDoFHandler.html">DoFHandler</a> object (you probably need to create this object anyway if you have hanging nodes). This is also what is done, for example, in <a class="el" href="step_15.html">step-15</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This situation can only happen if you do coarsening. If all cells remain as they are or are refined, then <a class="el" href="classSolutionTransfer.html#ae067f9b520ed50c86a9ff4c7776d16cb">SolutionTransfer::interpolate()</a> computes a new vector of nodal values, but the function represented is of course exactly the same because the old finite element space is a subspace of the new one. Thus, if the old function was conforming (i.e., satisfied hanging node constraints), then so does the new one, and it is not necessary to call <a class="el" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">AffineConstraints::distribute()</a>.</dd></dl>
<h3>Implementation in the context of hp-finite elements</h3>
<p>In the case of DoFHandlers with hp-capabilities, nothing defines which of the finite elements that are part of the <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> associated with the <a class="el" href="classDoFHandler.html">DoFHandler</a>, should be considered on cells that are not active (i.e., that have children). This is because degrees of freedom are only allocated for active cells and, in fact, it is not allowed to set an active FE index on non- active cells using DoFAccessor::set_active_fe_index().</p>
<p>It is, thus, not entirely natural what should happen if, for example, a few cells are coarsened away. This class then implements the following algorithm:</p><ul>
<li>If a cell is refined, then the values of the solution vector(s) are interpolated before refinement on the to-be-refined cell from the space of the active finite element to the one of the future finite element. These values are then distributed on the finite element spaces of the children post-refinement. This may lose information if, for example, the old cell used a Q2 space and the children use Q1 spaces, or the information may be prolonged if the mother cell used a Q1 space and the children are Q2s.</li>
<li>If cells are to be coarsened, then the values from the child cells are interpolated to the mother cell using the largest of the child cell future finite element spaces, which will be identified as the least dominant element following the <a class="el" href="namespaceFiniteElementDomination.html">FiniteElementDomination</a> logic (consult <a class="el" href="classhp_1_1FECollection.html#aae4e336f83e16ba6291d3748d52438d8">hp::FECollection::find_dominated_fe_extended()</a> for more information). For example, if the children of a cell use Q1, Q2 and Q3 spaces, then the values from the children are interpolated into a Q3 space on the mother cell. After refinement, this Q3 function on the mother cell is then interpolated into the space the user has selected for this cell (which may be different from Q3, in this example, if the user has set the active FE index for a different space post-refinement and before calling <a class="el" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">DoFHandler::distribute_dofs()</a>).</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>In the context of hp-refinement, if cells are coarsened or the polynomial degree is lowered on some cells, then the old finite element space is not a subspace of the new space and you may run into the same situation as discussed above with hanging nodes. You may want to consider calling <a class="el" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">AffineConstraints::distribute()</a> on the vector obtained by transferring the solution. </dd></dl>

<p class="definition">Definition at line <a class="el" href="numerics_2solution__transfer_8h_source.html#l00338">338</a> of file <a class="el" href="numerics_2solution__transfer_8h_source.html">solution_transfer.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ad03cb34b1ace26f6cc38e9ecaa5eab46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad03cb34b1ace26f6cc38e9ecaa5eab46">&#9670;&nbsp;</a></span>PreparationState</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType  = Vector&lt;double&gt;, typename DoFHandlerType  = DoFHandler&lt;dim&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classSolutionTransfer.html#ad03cb34b1ace26f6cc38e9ecaa5eab46">SolutionTransfer::PreparationState</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Declaration of <code>PreparationState</code> that denotes the three possible states of the <code><a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>:</code> being prepared for 'pure refinement', prepared for 'coarsening and refinement' or not prepared. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad03cb34b1ace26f6cc38e9ecaa5eab46af0ca00a1fbc5e9b0ac30f88c03290be8"></a>none&#160;</td><td class="fielddoc"><p>The <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a> is not yet prepared. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad03cb34b1ace26f6cc38e9ecaa5eab46a356685bb252a3b5b18b4252ea9425c27"></a>pure_refinement&#160;</td><td class="fielddoc"><p>The <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a> is prepared for purely refinement. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad03cb34b1ace26f6cc38e9ecaa5eab46a3be89a5036cd26755bb67c44f6c58b40"></a>coarsening_and_refinement&#160;</td><td class="fielddoc"><p>The <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a> is prepared for coarsening and refinement. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="numerics_2solution__transfer_8h_source.html#l00493">493</a> of file <a class="el" href="numerics_2solution__transfer_8h_source.html">solution_transfer.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a51ca915311f5f1edf0c81b549541dbdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ca915311f5f1edf0c81b549541dbdb">&#9670;&nbsp;</a></span>SolutionTransfer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt; dim, VectorType, DoFHandlerType &gt;::<a class="el" href="classSolutionTransfer.html">SolutionTransfer</a> </td>
          <td>(</td>
          <td class="paramtype">const DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor, takes the current <a class="el" href="classDoFHandler.html">DoFHandler</a> as argument. </p>

<p class="definition">Definition at line <a class="el" href="numerics_2solution__transfer_8cc_source.html#l00046">46</a> of file <a class="el" href="numerics_2solution__transfer_8cc_source.html">solution_transfer.cc</a>.</p>

</div>
</div>
<a id="a66670df7484e20dd5d3d6f1a1b4d2add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66670df7484e20dd5d3d6f1a1b4d2add">&#9670;&nbsp;</a></span>~SolutionTransfer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt; dim, VectorType, DoFHandlerType &gt;::~<a class="el" href="classSolutionTransfer.html">SolutionTransfer</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor </p>

<p class="definition">Definition at line <a class="el" href="numerics_2solution__transfer_8cc_source.html#l00066">66</a> of file <a class="el" href="numerics_2solution__transfer_8cc_source.html">solution_transfer.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3ed191ba55286dcc60dbbe2d5726b91f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ed191ba55286dcc60dbbe2d5726b91f">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt; dim, VectorType, DoFHandlerType &gt;::clear</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinit this class to the state that it has directly after calling the Constructor </p>

<p class="definition">Definition at line <a class="el" href="numerics_2solution__transfer_8cc_source.html#l00075">75</a> of file <a class="el" href="numerics_2solution__transfer_8cc_source.html">solution_transfer.cc</a>.</p>

</div>
</div>
<a id="a3c0192f0cea35d139efa08d2415b7935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c0192f0cea35d139efa08d2415b7935">&#9670;&nbsp;</a></span>prepare_for_pure_refinement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt; dim, VectorType, DoFHandlerType &gt;::prepare_for_pure_refinement</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prepares the <code><a class="el" href="classSolutionTransfer.html">SolutionTransfer</a></code> for pure refinement. It stores the dof indices of each cell. After calling this function only calling the <code>refine_interpolate</code> functions is allowed. </p>

<p class="definition">Definition at line <a class="el" href="numerics_2solution__transfer_8cc_source.html#l00088">88</a> of file <a class="el" href="numerics_2solution__transfer_8cc_source.html">solution_transfer.cc</a>.</p>

</div>
</div>
<a id="ae6dc5e5a74b166b0dea35f5a64694e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6dc5e5a74b166b0dea35f5a64694e69">&#9670;&nbsp;</a></span>prepare_for_coarsening_and_refinement() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt; dim, VectorType, DoFHandlerType &gt;::prepare_for_coarsening_and_refinement </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>all_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prepares the <code><a class="el" href="classSolutionTransfer.html">SolutionTransfer</a></code> for coarsening and refinement. It stores the dof indices of each cell and stores the dof values of the vectors in <code>all_in</code> in each cell that'll be coarsened. <code>all_in</code> includes all vectors that are to be interpolated onto the new (refined and/or coarsenend) grid. </p>

<p class="definition">Definition at line <a class="el" href="numerics_2solution__transfer_8cc_source.html#l00280">280</a> of file <a class="el" href="numerics_2solution__transfer_8cc_source.html">solution_transfer.cc</a>.</p>

</div>
</div>
<a id="a0c29cbe7cfc892b6a0e2852f9b542195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c29cbe7cfc892b6a0e2852f9b542195">&#9670;&nbsp;</a></span>prepare_for_coarsening_and_refinement() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt; dim, VectorType, DoFHandlerType &gt;::prepare_for_coarsening_and_refinement </td>
          <td>(</td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as previous function but for only one discrete function to be interpolated. </p>

<p class="definition">Definition at line <a class="el" href="numerics_2solution__transfer_8cc_source.html#l00435">435</a> of file <a class="el" href="numerics_2solution__transfer_8cc_source.html">solution_transfer.cc</a>.</p>

</div>
</div>
<a id="a97b74b1d43d76f40eed53d674a8c31b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b74b1d43d76f40eed53d674a8c31b8">&#9670;&nbsp;</a></span>refine_interpolate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt; dim, VectorType, DoFHandlerType &gt;::refine_interpolate </td>
          <td>(</td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function interpolates the discrete function <code>in</code>, which is a vector on the grid before the refinement, to the function <code>out</code> which then is a vector on the refined grid. It assumes the vectors having the right sizes (i.e. <code>in.size()==n_dofs_old</code>, <code>out.size()==n_dofs_refined</code>)</p>
<p>Calling this function is allowed only if <code>prepare_for_pure_refinement</code> is called and the refinement is executed before. Multiple calling of this function is allowed. e.g. for interpolating several functions. </p>

<p class="definition">Definition at line <a class="el" href="numerics_2solution__transfer_8cc_source.html#l00137">137</a> of file <a class="el" href="numerics_2solution__transfer_8cc_source.html">solution_transfer.cc</a>.</p>

</div>
</div>
<a id="ae067f9b520ed50c86a9ff4c7776d16cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae067f9b520ed50c86a9ff4c7776d16cb">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt; dim, VectorType, DoFHandlerType &gt;::interpolate </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>all_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>all_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function interpolates the discrete functions that are stored in <code>all_in</code> onto the refined and/or coarsenend grid. It assumes the vectors in <code>all_in</code> denote the same vectors as in <code>all_in</code> as parameter of <code>prepare_for_refinement_and_coarsening(all_in)</code>. However, there is no way of verifying this internally, so be careful here.</p>
<p>Calling this function is allowed only if first <a class="el" href="classTriangulation.html#abf55199c30b0330cf9bf98e2582078e1">Triangulation::prepare_coarsening_and_refinement</a>, second <code><a class="el" href="classSolutionTransfer.html#ae6dc5e5a74b166b0dea35f5a64694e69">SolutionTransfer::prepare_for_coarsening_and_refinement</a></code>, an then third <a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">Triangulation::execute_coarsening_and_refinement</a> are called before. Multiple calling of this function is NOT allowed. Interpolating several functions can be performed in one step.</p>
<p>The number of output vectors is assumed to be the same as the number of input vectors. Also, the sizes of the output vectors are assumed to be of the right size (<code>n_dofs_refined</code>). Otherwise an assertion will be thrown. </p>

<p class="definition">Definition at line <a class="el" href="numerics_2solution__transfer_8cc_source.html#l00446">446</a> of file <a class="el" href="numerics_2solution__transfer_8cc_source.html">solution_transfer.cc</a>.</p>

</div>
</div>
<a id="ac20bf49183b53b80ee42b9c9de3b912a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac20bf49183b53b80ee42b9c9de3b912a">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt; dim, VectorType, DoFHandlerType &gt;::interpolate </td>
          <td>(</td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as the previous function. It interpolates only one function. It assumes the vectors having the right sizes (i.e. <code>in.size()==n_dofs_old</code>, <code>out.size()==n_dofs_refined</code>)</p>
<p>Multiple calling of this function is NOT allowed. Interpolating several functions can be performed in one step by using <code>interpolate (all_in, all_out)</code> </p>

<p class="definition">Definition at line <a class="el" href="numerics_2solution__transfer_8cc_source.html#l00590">590</a> of file <a class="el" href="numerics_2solution__transfer_8cc_source.html">solution_transfer.cc</a>.</p>

</div>
</div>
<a id="a539165cdfce0bb1a8212d0e03dae5ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a539165cdfce0bb1a8212d0e03dae5ea8">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt; dim, VectorType, DoFHandlerType &gt;::memory_consumption</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. </p>

<p class="definition">Definition at line <a class="el" href="numerics_2solution__transfer_8cc_source.html#l00610">610</a> of file <a class="el" href="numerics_2solution__transfer_8cc_source.html">solution_transfer.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a915d45872cc7d604eb4e3621dd9487c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a915d45872cc7d604eb4e3621dd9487c7">&#9670;&nbsp;</a></span>dof_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType  = Vector&lt;double&gt;, typename DoFHandlerType  = DoFHandler&lt;dim&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;const DoFHandlerType, <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt;dim, VectorType, DoFHandlerType&gt; &gt; <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt; dim, VectorType, DoFHandlerType &gt;::dof_handler</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the degree of freedom handler to work with. </p>

<p class="definition">Definition at line <a class="el" href="numerics_2solution__transfer_8h_source.html#l00481">481</a> of file <a class="el" href="numerics_2solution__transfer_8h_source.html">solution_transfer.h</a>.</p>

</div>
</div>
<a id="a0520033cc7cf67ce3c85542db4b3d41e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0520033cc7cf67ce3c85542db4b3d41e">&#9670;&nbsp;</a></span>n_dofs_old</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType  = Vector&lt;double&gt;, typename DoFHandlerType  = DoFHandler&lt;dim&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt; dim, VectorType, DoFHandlerType &gt;::n_dofs_old</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores the number of DoFs before the refinement and/or coarsening. </p>

<p class="definition">Definition at line <a class="el" href="numerics_2solution__transfer_8h_source.html#l00486">486</a> of file <a class="el" href="numerics_2solution__transfer_8h_source.html">solution_transfer.h</a>.</p>

</div>
</div>
<a id="a9ef958d2b9c74657af8202458f47416d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ef958d2b9c74657af8202458f47416d">&#9670;&nbsp;</a></span>prepared_for</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType  = Vector&lt;double&gt;, typename DoFHandlerType  = DoFHandler&lt;dim&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSolutionTransfer.html#ad03cb34b1ace26f6cc38e9ecaa5eab46">PreparationState</a> <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt; dim, VectorType, DoFHandlerType &gt;::prepared_for</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Definition of the respective variable. </p>

<p class="definition">Definition at line <a class="el" href="numerics_2solution__transfer_8h_source.html#l00512">512</a> of file <a class="el" href="numerics_2solution__transfer_8h_source.html">solution_transfer.h</a>.</p>

</div>
</div>
<a id="a270e07ab5108066b6889c98908145bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a270e07ab5108066b6889c98908145bdd">&#9670;&nbsp;</a></span>indices_on_cell</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType  = Vector&lt;double&gt;, typename DoFHandlerType  = DoFHandler&lt;dim&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&gt; &gt; <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt; dim, VectorType, DoFHandlerType &gt;::indices_on_cell</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Is used for <code>prepare_for_refining</code> (of course also for <code>repare_for_refining_and_coarsening</code>) and stores all dof indices of the cells that'll be refined </p>

<p class="definition">Definition at line <a class="el" href="numerics_2solution__transfer_8h_source.html#l00520">520</a> of file <a class="el" href="numerics_2solution__transfer_8h_source.html">solution_transfer.h</a>.</p>

</div>
</div>
<a id="a584314a20a2e1a2fce88d0b658f174ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a584314a20a2e1a2fce88d0b658f174ba">&#9670;&nbsp;</a></span>cell_map</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType  = Vector&lt;double&gt;, typename DoFHandlerType  = DoFHandler&lt;dim&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::pair&lt;unsigned int, unsigned int&gt;, <a class="el" href="structSolutionTransfer_1_1Pointerstruct.html">Pointerstruct</a>&gt; <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt; dim, VectorType, DoFHandlerType &gt;::cell_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map mapping from level and index of cell to the <code>Pointerstructs</code> (cf. there). This map makes it possible to keep all the information needed to transfer the solution inside this object rather than using user pointers of the <a class="el" href="classTriangulation.html">Triangulation</a> for this purpose. </p>

<p class="definition">Definition at line <a class="el" href="numerics_2solution__transfer_8h_source.html#l00567">567</a> of file <a class="el" href="numerics_2solution__transfer_8h_source.html">solution_transfer.h</a>.</p>

</div>
</div>
<a id="a1422cf92e0b8132bf5471b00a2fddec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1422cf92e0b8132bf5471b00a2fddec7">&#9670;&nbsp;</a></span>dof_values_on_cell</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType  = Vector&lt;double&gt;, typename DoFHandlerType  = DoFHandler&lt;dim&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="classVector.html">Vector</a>&lt;typename VectorType::value_type&gt; &gt; &gt; <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>&lt; dim, VectorType, DoFHandlerType &gt;::dof_values_on_cell</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Is used for <code>prepare_for_refining_and_coarsening</code> The interpolated dof values of all cells that'll be coarsened will be stored in this vector. </p>

<p class="definition">Definition at line <a class="el" href="numerics_2solution__transfer_8h_source.html#l00574">574</a> of file <a class="el" href="numerics_2solution__transfer_8h_source.html">solution_transfer.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/numerics/<a class="el" href="numerics_2solution__transfer_8h_source.html">solution_transfer.h</a></li>
<li>source/numerics/<a class="el" href="numerics_2solution__transfer_8cc_source.html">solution_transfer.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
