<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_31.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-31 tutorial program  。</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.3.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.3.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">The step-31 tutorial program 。 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>本教程取决于 <a class="el" href="step_22.html">step-22</a> 。</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#TheBoussinesqequations">The Boussinesq equations</a><a href="#TheBoussinesqequations">The Boussinesq equations</a>
        <li><a href="#Boundaryandinitialconditions">Boundary and initial conditions</a><a href="#Boundaryandinitialconditions">Boundary and initial conditions</a>
        <li><a href="#Solutionapproach">Solution approach</a><a href="#Solutionapproach">Solution approach</a>
      <ul>
        <li><a href="#Timestepping">Time stepping</a><a href="#Timestepping">Time stepping</a>
        <li><a href="#WeakformandspacediscretizationfortheStokespart">Weak form and space discretization for the Stokes part</a><a href="#WeakformandspacediscretizationfortheStokespart">Weak form and space discretization for the Stokes part</a>
        <li><a href="#Stabilizationweakformandspacediscretizationforthetemperatureequation">Stabilization, weak form and space discretization for the temperature equation</a><a href="#Stabilizationweakformandspacediscretizationforthetemperatureequation">Stabilization, weak form and space discretization for the temperature equation</a>
        <li><a href="#Linearsolvers">Linear solvers</a><a href="#Linearsolvers">Linear solvers</a>
      <ul>
        <li><a href="#LinearsolversfortheStokesproblem">Linear solvers for the Stokes problem</a><a href="#LinearsolversfortheStokesproblem">Linear solvers for the Stokes problem</a>
        <li><a href="#Linearsolversforthetemperatureequation">Linear solvers for the temperature equation</a><a href="#Linearsolversforthetemperatureequation">Linear solvers for the temperature equation</a>
      </ul>
      </ul>
        <li><a href="#Implementationdetails">Implementation details</a><a href="#Implementationdetails">Implementation details</a>
      <ul>
        <li><a href="#UsingdifferentDoFHandlerobjects">Using different DoFHandler objects</a><a href="#UsingdifferentDoFHandlerobjects">Using different DoFHandler objects</a>
        <li><a href="#UsingTrilinos">Using Trilinos</a><a href="#UsingTrilinos">Using Trilinos</a>
      </ul>
        <li><a href="#Thetestcase">The testcase</a><a href="#Thetestcase">The testcase</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a><a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a><a href="#Includefiles">Include files</a>
        <li><a href="#Equationdata">Equation data</a><a href="#Equationdata">Equation data</a>
        <li><a href="#Linearsolversandpreconditioners">Linear solvers and preconditioners</a><a href="#Linearsolversandpreconditioners">Linear solvers and preconditioners</a>
      <ul>
        <li><a href="#ThecodeInverseMatrixcodeclasstemplate">The <code>InverseMatrix</code> class template</a><a href="#ThecodeInverseMatrixcodeclasstemplate">The <code>InverseMatrix</code> class template</a>
        <li><a href="#Schurcomplementpreconditioner">Schur complement preconditioner</a><a href="#Schurcomplementpreconditioner">Schur complement preconditioner</a>
      </ul>
        <li><a href="#ThecodeBoussinesqFlowProblemcodeclasstemplate">The <code>BoussinesqFlowProblem</code> class template</a><a href="#ThecodeBoussinesqFlowProblemcodeclasstemplate">The <code>BoussinesqFlowProblem</code> class template</a>
        <li><a href="#BoussinesqFlowProblemclassimplementation">BoussinesqFlowProblem class implementation</a><a href="#BoussinesqFlowProblemclassimplementation">BoussinesqFlowProblem class implementation</a>
      <ul>
        <li><a href="#BoussinesqFlowProblemBoussinesqFlowProblem">BoussinesqFlowProblem::BoussinesqFlowProblem</a><a href="#BoussinesqFlowProblemBoussinesqFlowProblem">BoussinesqFlowProblem::BoussinesqFlowProblem</a>
        <li><a href="#BoussinesqFlowProblemget_maximal_velocity">BoussinesqFlowProblem::get_maximal_velocity</a><a href="#BoussinesqFlowProblemget_maximal_velocity">BoussinesqFlowProblem::get_maximal_velocity</a>
        <li><a href="#BoussinesqFlowProblemget_extrapolated_temperature_range">BoussinesqFlowProblem::get_extrapolated_temperature_range</a> ]<a href="#BoussinesqFlowProblemget_extrapolated_temperature_range">BoussinesqFlowProblem::get_extrapolated_temperature_range</a>
        <li><a href="#BoussinesqFlowProblemcompute_viscosity">BoussinesqFlowProblem::compute_viscosity</a><a href="#BoussinesqFlowProblemcompute_viscosity">BoussinesqFlowProblem::compute_viscosity</a>
        <li><a href="#BoussinesqFlowProblemsetup_dofs">BoussinesqFlowProblem::setup_dofs</a><a href="#BoussinesqFlowProblemsetup_dofs">BoussinesqFlowProblem::setup_dofs</a>
        <li><a href="#BoussinesqFlowProblemassemble_stokes_preconditioner">BoussinesqFlowProblem::assemble_stokes_preconditioner</a><a href="#BoussinesqFlowProblemassemble_stokes_preconditioner">BoussinesqFlowProblem::assemble_stokes_preconditioner</a>
        <li><a href="#BoussinesqFlowProblembuild_stokes_preconditioner">BoussinesqFlowProblem::build_stokes_preconditioner</a><a href="#BoussinesqFlowProblembuild_stokes_preconditioner">BoussinesqFlowProblem::build_stokes_preconditioner</a>
        <li><a href="#BoussinesqFlowProblemassemble_stokes_system">BoussinesqFlowProblem::assemble_stokes_system</a><a href="#BoussinesqFlowProblemassemble_stokes_system">BoussinesqFlowProblem::assemble_stokes_system</a>
        <li><a href="#BoussinesqFlowProblemassemble_temperature_matrix">BoussinesqFlowProblem::assemble_temperature_matrix</a><a href="#BoussinesqFlowProblemassemble_temperature_matrix">BoussinesqFlowProblem::assemble_temperature_matrix</a>
        <li><a href="#BoussinesqFlowProblemassemble_temperature_system">BoussinesqFlowProblem::assemble_temperature_system</a><a href="#BoussinesqFlowProblemassemble_temperature_system">BoussinesqFlowProblem::assemble_temperature_system</a>
        <li><a href="#BoussinesqFlowProblemsolve">BoussinesqFlowProblem::solve</a><a href="#BoussinesqFlowProblemsolve">BoussinesqFlowProblem::solve</a>
        <li><a href="#BoussinesqFlowProblemoutput_results">BoussinesqFlowProblem::output_results</a><a href="#BoussinesqFlowProblemoutput_results">BoussinesqFlowProblem::output_results</a>
        <li><a href="#BoussinesqFlowProblemrefine_mesh">BoussinesqFlowProblem::refine_mesh</a><a href="#BoussinesqFlowProblemrefine_mesh">BoussinesqFlowProblem::refine_mesh</a>
        <li><a href="#BoussinesqFlowProblemrun">BoussinesqFlowProblem::run</a><a href="#BoussinesqFlowProblemrun">BoussinesqFlowProblem::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a> ]<a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Resultsin2d"> Results in 2d </a><a href="#Resultsin2d"> Results in 2d </a>
        <li><a href="#Resultsin3d"> Results in 3d </a><a href="#Resultsin3d"> Results in 3d </a>
        <li><a href="#Numericalexperimentstodetermineoptimalparameters"> Numerical experiments to determine optimal parameters </a><a href="#Numericalexperimentstodetermineoptimalparameters"> Numerical experiments to determine optimal parameters </a>
      <ul>
        <li><a href="#Choosingicsubksubiandbeta"> Choosing <i>c<sub>k</sub></i><a href="#Choosingicsubksubiandbeta"> Choosing <i>c<sub>k</sub></i> and beta </a><i>c<sub>k</sub></i> and beta </a>
      <ul>
        <li><a href="#ResultsforQsub1subelements">Results for Q<sub>1</sub> elements</a><a href="#ResultsforQsub1subelements">Results for Q<sub>1</sub> elements</a>
        <li><a href="#ResultsforQsub2subelements">Results for Q<sub>2</sub> elements</a><a href="#ResultsforQsub2subelements">Results for Q<sub>2</sub> elements</a>
        <li><a href="#Resultsfor3d">Results for 3d</a><a href="#Resultsfor3d">Results for 3d</a>
        <li><a href="#Conclusions">Conclusions</a><a href="#Conclusions">Conclusions</a>
      </ul>
      </ul>
        <li><a href="#Possibilitiesforextensions"> Possibilities for extensions </a><a href="#Possibilitiesforextensions"> Possibilities for extensions </a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a><a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
</p>
<p><br  />
 <br  />
</p>
<p><em>This program was contributed by Martin Kronbichler and Wolfgang Bangerth. <br  />
 This material is based upon work partly supported by the National Science Foundation under Award No. EAR-0426271 and The California Institute of Technology. Any opinions, findings, and conclusions or recommendations expressed in this publication are those of the author and do not necessarily reflect the views of the National Science Foundation or of The California Institute of Technology. </em></p>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p><a class="anchor" id="TheBoussinesqequations"></a></p><h3>The Boussinesq equations</h3>
<p>这个程序涉及一个有趣的物理问题：如果流体（即液体或气体）遇到由温差引起的浮力差异，它是如何表现的？很明显，流体中温度较高（因此较轻）的部分会上升，温度较低（密度较大）的部分会在重力作用下下沉。</p>
<p>在流体运动速度足够慢，以至于可以忽略惯性效应的情况下，描述这种行为的方程是Boussinesq方程，内容如下。 </p><p class="formulaDsp">
\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla p &amp;=&amp; -\rho\; \beta \; T\; \mathbf{g}, \\ \nabla \cdot {\mathbf u} &amp;=&amp; 0, \\ \frac{\partial T}{\partial t} + {\mathbf u} \cdot \nabla T - \nabla \cdot \kappa \nabla T &amp;=&amp; \gamma. \end{eqnarray*}
</p>
<p>这些方程属于矢量值问题的范畴（这一主题的顶层概述可在 <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> 模块中找到）。这里， \(\mathbf u\) 是速度场， \(p\) 是压力， \(T\) 是流体的温度。 \(\varepsilon ({\mathbf u}) = \frac 12 [(\nabla{\mathbf u}) + (\nabla {\mathbf u})^T]\) 是速度的对称梯度。可以看出，速度和压力可以解决描述不可压缩流体运动的斯托克斯方程，这个方程我们以前在 <a class="el" href="step_22.html">step-22</a> 中考虑过；我们将广泛借鉴在该程序中获得的经验，特别是关于高效线性斯托克斯求解器的经验。</p>
<p>流体运动的强制项是流体的浮力，表示为密度 \(\rho\) 、热膨胀系数 \(\beta\) 、温度 \(T\) 和指向下方的重力矢量 \(\mathbf{g}\) 的积。(在 <a class="el" href="step_32.html">step-32</a> 的介绍中给出了为什么右手边看起来像它的推导) 。前两个方程描述了流体如何通过移动对温差做出反应，第三个方程说明了流体运动如何影响温度场：它是一个平流扩散方程，即温度附着在流体颗粒上，并在流场中平流，还有一个额外的扩散（热传导）项。在许多应用中，扩散系数相当小，温度方程实际上是传输的，而不是扩散主导的，因此其特征是双曲而不是椭圆；我们在开发稳定的离散化时必须考虑到这一点。</p>
<p>在上述方程中，右侧的 \(\gamma\) 项表示热源，可能是一个空间和时间上的变化函数。 \(\eta\) 和 \(\kappa\) 表示粘度和扩散系数，在本教程程序中我们假定这两个系数为常数。当 \(\eta\) 取决于温度时，更普遍的情况是物理应用中的一个重要因素。大多数材料随着温度的升高而变得更加流动（即 \(\eta\) 随着 \(T\) 的降低而降低）；有时，如在温度接近熔点的岩石矿物的情况下， \(\eta\) 可能在典型的温度范围内发生数量级的变化。</p>
<p>我们注意到，上述斯托克斯方程可以通过引入<a href="http://en.wikipedia.org/wiki/Rayleigh_number" target="_top">Rayleigh number</a> \(\mathrm{Ra}=\frac{\|\mathbf{g}\| \beta \rho}{\eta \kappa} \delta T L^3\) ，使用典型的长度尺度 \(L\) 、典型的温度差 \(\delta T\) 、密度 \(\rho\) 、热扩散率 \(\eta\) 和热导率 \(\kappa\) 进行非维化。 \(\mathrm{Ra}\) 是一个无量纲数字，它描述了由温差引起的浮力变化导致的热传输和由热扩散导致的热传输的比率。一个小的瑞利数意味着浮力相对于粘度来说并不强，流体运动 \(\mathbf{u}\) 足够慢，所以热扩散 \(\kappa\nabla T\) 是主要的热传输项。另一方面，具有高雷利数的流体将显示出主导热传导的强烈对流。</p>
<p>对于我们感兴趣的计算热对流的大多数流体，瑞利数是非常大的，通常是 \(10^6\) 或更大。从方程的结构中，我们看到这将导致大的压力差和大的速度。因此， \(T\) 的对流扩散方程中的对流项也将非常大，这个方程的精确解将要求我们选择小的时间步长。因此，具有大的瑞利数的问题是很难用数值解决的，原因类似于当<a href="http://en.wikipedia.org/wiki/Reynolds_number">Reynolds number \(\mathrm{Re}\)</a>很大时，解决<a href="http://en.wikipedia.org/wiki/Navier-stokes_equations">Navier-Stokes equations</a>很难。</p>
<p>请注意，大的瑞利数不一定涉及大的绝对速度。例如，地幔中的瑞利数大于 \(10^6\) 。然而，速度却很小：该材料实际上是固体岩石，但它的温度和压力很高，可以非常缓慢地流动，每年最多只有几厘米的速度。然而，这可能会导致在数百万年的时间尺度上的混合，这个时间尺度比相同数量的热量通过热传导分布的时间尺度要短得多，而且这个时间尺度与影响地球内部和表面结构的演变有关。</p>
<dl class="section note"><dt>Note</dt><dd>如果你有兴趣使用该程序作为你自己实验的基础，你也会想看看它在 <a class="el" href="step_32.html">step-32</a> 中的延续。此外， <a class="el" href="step_32.html">step-32</a> 后来被发展成更大的开放源代码ASPECT（见https://aspect.geodynamics.org/），它可以解决现实的问题，在试图将 <a class="el" href="step_31.html">step-31</a> 变形为可以解决任何你想解决的问题之前，你可能想要调查一下。</dd></dl>
<p><a class="anchor" id="Boundaryandinitialconditions"></a></p><h3>Boundary and initial conditions</h3>
<p>由于Boussinesq方程是在流体运动的惯性不起作用的假设下推导出来的，所以流场在每个时间完全由当时的浮力差决定，而不是由以前的流场决定。这反映在上面的前两个方程是不包含时间导数的稳态斯托克斯方程的事实。因此，我们不需要速度或压力的初始条件。另一方面，温度场确实满足有时间导数的方程，所以我们需要 \(T\) 的初始条件。</p>
<p>至于边界条件：如果 \(\kappa&gt;0\) ，那么温度满足一个二阶微分方程，需要边界周围所有时间的边界数据。这些数据可以是规定的边界温度 \(T|_{\partial\Omega}=T_b\) （Dirichlet边界条件），也可以是规定的热通量 \(\mathbf{n}\cdot\kappa\nabla T|_{\partial\Omega}=\phi\) ；在本程序中，我们将使用一个绝缘的边界条件，即规定没有热通量。 \(\phi=0\) .</p>
<p>同样，速度场要求我们提出边界条件。这些条件可以是 \(\mathbf{u}=0\) 上的无滑移无通量条件 \(\partial\Omega\) ，如果流体粘在边界上，或者无正常通量条件 \(\mathbf n \cdot \mathbf u = 0\) ，如果流体可以沿边界流动但不能穿过边界，或者任何数量的其他物理上合理的条件。在这个程序中，我们将使用无正常通量条件。</p>
<p><a class="anchor" id="Solutionapproach"></a></p><h3>Solution approach</h3>
<p>与 <a class="el" href="step_21.html">step-21</a> 中求解的方程一样，我们这里有一个微分代数方程（DAE）系统：就时间变量而言，只有温度方程是微分方程，而 \(\mathbf{u}\) 和 \(p\) 的斯托克斯系统没有时间导数，因此属于必须在每个时间瞬间保持的那种代数约束。与 <a class="el" href="step_21.html">step-21</a> 的主要区别是，那里的代数约束是一个形式为 </p><p class="formulaDsp">
\begin{eqnarray*} \mathbf u + {\mathbf K}\lambda \nabla p &amp;=&amp; 0, \\ \nabla\cdot \mathbf u &amp;=&amp; f, \end{eqnarray*}
</p>
<p>的混合拉普拉斯系统</p>
<p>而现在我们有一个斯托克斯系统 </p><p class="formulaDsp">
\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla p &amp;=&amp; f, \\ \nabla\cdot \mathbf u &amp;=&amp; 0, \end{eqnarray*}
</p>
<p>其中 \(\nabla \cdot \eta \varepsilon (\cdot)\) 是一个类似于拉普拉斯 \(\Delta\) 的算子，应用于一个矢量场。</p>
<p>鉴于与我们在 <a class="el" href="step_21.html">step-21</a> 中所做的相似，我们选择类似的方法可能并不令人惊讶，尽管我们将不得不对微分算子左上角的算子变化进行调整。</p>
<p><a class="anchor" id="Timestepping"></a></p><h4>Time stepping</h4>
<p>作为DAE的问题结构允许我们使用与我们已经在 <a class="el" href="step_21.html">step-21</a> 中使用的相同策略，即我们使用时间滞后方案：我们首先解决温度方程（使用外推的速度场），然后将新的温度解插入速度方程的右侧。不过，我们在代码中实现这一方案的方式是从一个稍微不同的角度来看问题。我们首先使用前一个时间步长的温度场来求解速度和压力的斯托克斯方程，这意味着我们得到前一个时间步长的速度。换句话说，我们首先将时间步长 \(n - 1\) 的斯托克斯系统解为 </p><p class="formulaDsp">
\begin{eqnarray*} -\nabla \cdot (2\eta \varepsilon ({\mathbf u}^{n-1})) + \nabla p^{n-1} &amp;=&amp; -\rho\; \beta \; T^{n-1} \mathbf{g}, \\ \nabla \cdot {\mathbf u}^{n-1} &amp;=&amp; 0, \end{eqnarray*}
</p>
<p>然后用外推的速度场解温度方程 \(n\) 。</p>
<p>与 <a class="el" href="step_21.html">step-21</a> 相比，我们在这里使用高阶时间步长方案，即<a href="http://en.wikipedia.org/wiki/Backward_differentiation_formula">Backward Differentiation Formula scheme of order 2 (BDF-2 in short)</a>，用 \(\frac{\frac 32 T^{n}-2T^{n-1}+\frac 12 T^{n-2}}{k}\) 的（单边）差分商取代时间导数 \(\frac{\partial T}{\partial t}\) ， \(k\) 是时间步长大小。这就得到了离散化的时间温度方程 </p><p class="formulaDsp">
\begin{eqnarray*} \frac 32 T^n - k\nabla \cdot \kappa \nabla T^n &amp;=&amp; 2 T^{n-1} - \frac 12 T^{n-2} - k(2{\mathbf u}^{n-1} - {\mathbf u}^{n-2} ) \cdot \nabla (2T^{n-1}-T^{n-2}) + k\gamma. \end{eqnarray*}
</p>
<p>注意温度方程是如何被半显式解决的：扩散被隐式处理，而平流被显式处理，使用温度和速度的外推（或前推），包括刚刚计算的速度 \({\mathbf u}^{n-1}\) 。对当前时间水平的正向投影 \(n\) 是由泰勒扩展得出的 \(T^n \approx T^{n-1} + k_n \frac{\partial T}{\partial t} \approx T^{n-1} + k_n \frac{T^{n-1}-T^{n-2}}{k_n} = 2T^{n-1}-T^{n-2}\) 。我们需要这个投影来保持BDF-2方案的精度。换句话说，我们在显式右手边使用的温度场是当前温度场的二阶近似&mdash; 不完全是显式时间步进方案，但从特征上看也不会太远。</p>
<p>温度外推的引入将时间步长限制在<a href="http://en.wikipedia.org/wiki/Courant–Friedrichs–Lewy_condition">Courant-Friedrichs-Lewy (CFL) condition</a>，就像在 <a class="el" href="step_21.html">@ref step_21 </a>step-21" "中一样。（如果我们隐式处理平流项，我们就不会有这个稳定条件，因为BDF-2方案是A稳定的，代价是我们需要在每个时间步长建立一个新的温度矩阵）。我们将在<a href="#Results">results section</a>中讨论时间步长的确切选择，但目前重要的是，这个CFL条件意味着时间步长 \(k\) 可能在不同的时间步长中发生变化，我们必须稍微修改上述公式。如果 \(k_n,k_{n-1}\) 是当前和前一个时间步长的时间步长，那么我们使用近似值</p>
<p class="formulaDsp">
\begin{align*} \frac{\partial T}{\partial t} \approx \frac 1{k_n} \left( \frac{2k_n+k_{n-1}}{k_n+k_{n-1}} T^{n} - \frac{k_n+k_{n-1}}{k_{n-1}}T^{n-1} + \frac{k_n^2}{k_{n-1}(k_n+k_{n-1})} T^{n-2} \right) \end{align*}
</p>
<p>和</p>
<p class="formulaDsp">
\begin{align*} T^n \approx T^{n-1} + k_n \frac{\partial T}{\partial t} \approx T^{n-1} + k_n \frac{T^{n-1}-T^{n-2}}{k_{n-1}} = \left(1+\frac{k_n}{k_{n-1}}\right)T^{n-1}-\frac{k_n}{k_{n-1}}T^{n-2}, \end{align*}
</p>
<p>并将上述方程概括如下。 </p><p class="formulaDsp">
\begin{eqnarray*} \frac{2k_n+k_{n-1}}{k_n+k_{n-1}} T^n - k_n\nabla \cdot \kappa \nabla T^n &amp;=&amp; \frac{k_n+k_{n-1}}{k_{n-1}} T^{n-1} - \frac{k_n^2}{k_{n-1}(k_n+k_{n-1})} T^{n-2} - k_n{\mathbf u}^{*,n} \cdot \nabla T^{*,n} + k_n\gamma, \end{eqnarray*}
</p>
<p>其中 \({(\cdot)}^{*,n} = \left(1+\frac{k_n}{k_{n-1}}\right)(\cdot)^{n-1} - \frac{k_n}{k_{n-1}}(\cdot)^{n-2}\) 表示速度 \(\mathbf u\) 和温度 \(T\) 外推到时间水平 \(n\) ，使用前两个时间步骤的值。这不是一个容易读懂的方程，但会为我们提供所需的高阶精度。作为一致性检查，很容易验证，如果 \(k_n=k_{n-1}\) ，它可以还原成与上面相同的方程。</p>
<p>最后我们注意到，选择高阶时间步长方案当然会迫使我们在内存中保留更多的时间步长；特别是，我们在这里需要保留 \(T^{n-2}\) ，一个我们以前可以抛弃的向量。这似乎是一个麻烦，我们以前只用一阶时间步进方案就能避免，但正如我们在下面讨论稳定化问题时看到的，我们无论如何都需要这个向量，所以保留它进行时间离散化基本上是免费的，并使我们有机会使用高阶方案。</p>
<p><a class="anchor" id="WeakformandspacediscretizationfortheStokespart"></a></p><h4>Weak form and space discretization for the Stokes part</h4>
<p>与解决混合拉普拉斯方程一样，解决斯托克斯方程需要我们为速度和压力变量选择特定的有限元对。因为这在 <a class="el" href="step_22.html">step-22</a> 中已经讨论过了，所以我们只简单介绍一下这个话题。这里，我们使用稳定对 \(Q_{p+1}^d \times Q_p, p\ge 1\) 。这些都是连续元素，所以我们可以通过部分积分和用离散函数替代连续函数来形成斯托克斯方程的弱形式，没有问题。 </p><p class="formulaDsp">
\begin{eqnarray*} (\nabla {\mathbf v}_h, 2\eta \varepsilon ({\mathbf u}^{n-1}_h)) - (\nabla \cdot {\mathbf v}_h, p^{n-1}_h) &amp;=&amp; -({\mathbf v}_h, \rho\; \beta \; T^{n-1}_h \mathbf{g}), \\ (q_h, \nabla \cdot {\mathbf u}^{n-1}_h) &amp;=&amp; 0, \end{eqnarray*}
</p>
<p>为所有测试函数 \(\mathbf v_h, q_h\) 。第一个方程的第一项被认为是张量之间的内积，即 \((\nabla {\mathbf v}_h, \eta \varepsilon ({\mathbf u}^{n-1}_h))_\Omega = \int_\Omega \sum_{i,j=1}^d [\nabla {\mathbf v}_h]_{ij} \eta [\varepsilon ({\mathbf u}^{n-1}_h)]_{ij}\, dx\) 。因为这个乘积中的第二个张量是对称的，所以 \(\nabla {\mathbf v}_h\) 的反对称成分不起作用，如果我们用 \(\mathbf v_h\) 的对称梯度代替，会导致完全相同的形式。因此，我们考虑并实施的表述是 </p><p class="formulaDsp">
\begin{eqnarray*} (\varepsilon({\mathbf v}_h), 2\eta \varepsilon ({\mathbf u}^{n-1}_h)) - (\nabla \cdot {\mathbf v}_h, p^{n-1}_h) &amp;=&amp; -({\mathbf v}_h, \rho\; \beta \; T^{n-1}_h \mathbf{g}), \\ (q_h, \nabla \cdot {\mathbf u}^{n-1}_h) &amp;=&amp; 0. \end{eqnarray*}
</p>
<p>这与我们在 <a class="el" href="step_22.html">step-22</a> 中已经讨论过的完全一样，这里没有什么可说的了。</p>
<p><a class="anchor" id="Stabilizationweakformandspacediscretizationforthetemperatureequation"></a></p><h4>Stabilization, weak form and space discretization for the temperature equation</h4>
<p>更有趣的问题是如何处理温度平流-扩散方程。默认情况下，并不是这个方程的所有离散化都是同样稳定的，除非我们要么做一些像上卷，稳定化，或者所有这些。实现这一目标的方法之一是使用不连续元素（即我们在 <a class="el" href="step_12.html">step-12</a> 中离散传输方程时使用的FE_DGQ类，或者在 <a class="el" href="step_20.html">step-20</a> 和 <a class="el" href="step_21.html">step-21</a> 中离散压力时使用的FE_DGQ类），并在单元间的界面上定义一个考虑到上卷的通量。如果我们有一个纯粹的平流问题，这可能是最简单的方法。然而，这里我们也有一些扩散，用不连续元素对拉普拉斯算子进行离散化是很麻烦的，因为有大量的附加项需要在单元间的每个面上进行积分。不连续元素还有一个缺点，即使用数值通量会带来额外的数值扩散，这种扩散无处不在，而我们真的希望将数值扩散的影响降到最低，只在需要稳定方案的地方应用它。</p>
<p>因此，一个更好的选择是在模型中加入一些非线性粘性。从本质上讲，这样做的目的是将温度方程从 </p><p class="formulaDsp">
\begin{eqnarray*} \frac{\partial T}{\partial t} + {\mathbf u} \cdot \nabla T - \nabla \cdot \kappa \nabla T &amp;=&amp; \gamma \end{eqnarray*}
</p>
<p>的形式转变为 </p><p class="formulaDsp">
\begin{eqnarray*} \frac{\partial T}{\partial t} + {\mathbf u} \cdot \nabla T - \nabla \cdot \kappa \nabla T &amp;=&amp; \gamma \end{eqnarray*}
</p>
<p>的形式。</p>
<p>转变为 </p><p class="formulaDsp">
\begin{eqnarray*} \frac{\partial T}{\partial t} + {\mathbf u} \cdot \nabla T - \nabla \cdot (\kappa+\nu(T)) \nabla T &amp;=&amp; \gamma, \end{eqnarray*}
</p>
<p>这样的形式。</p>
<p>其中 \(\nu(T)\) 是一个额外的粘性（扩散）项，只在冲击和其他不连续点附近起作用。 \(\nu(T)\) 的选择方式是，如果 \(T\) 满足原始方程，则额外的粘性为零。</p>
<p>为了实现这一点，文献中包含了许多方法。我们在此将遵循Guermond和Popov开发的一种方法，它建立在一个适当定义的残差和额外粘度的极限程序之上。为此，让我们定义一个残差 \(R_\alpha(T)\) 如下。 </p><p class="formulaDsp">
\begin{eqnarray*} R_\alpha(T) = \left( \frac{\partial T}{\partial t} + {\mathbf u} \cdot \nabla T - \nabla \cdot \kappa \nabla T - \gamma \right) T^{\alpha-1} \end{eqnarray*}
</p>
<p>其中我们稍后将从 \([1,2]\) 范围内选择稳定指数 \(\alpha\) 。请注意，如果 \(T\) 满足温度方程， \(R_\alpha(T)\) 将为零，因为此时括号内的项将为零。将条款相乘，我们得到以下完全等同的形式。 </p><p class="formulaDsp">
\begin{eqnarray*} R_\alpha(T) = \frac 1\alpha \frac{\partial (T^\alpha)}{\partial t} + \frac 1\alpha {\mathbf u} \cdot \nabla (T^\alpha) - \frac 1\alpha \nabla \cdot \kappa \nabla (T^\alpha) + \kappa(\alpha-1) T^{\alpha-2} |\nabla T|^2 - \gamma T^{\alpha-1} \end{eqnarray*}
</p>
<p>有了这个残差，我们现在可以把人工黏度定义为一个片状常数函数，分别定义在直径为 \(h_K\) 的每个单元上，如下所示。 </p><p class="formulaDsp">
\begin{eqnarray*} \nu_\alpha(T)|_K = \beta \|\mathbf{u}\|_{L^\infty(K)} \min\left\{ h_K, h_K^\alpha \frac{\|R_\alpha(T)\|_{L^\infty(K)}}{c(\mathbf{u},T)} \right\} \end{eqnarray*}
</p>
<p>这里， \(\beta\) 是一个稳定常数（维度分析显示它是无单位的，因此与缩放无关；我们将在<a href="#Results">results section</a>中讨论它的选择）， \(c(\mathbf{u},T)\) 是一个归一化常数，必须有单位 \(\frac{m^{\alpha-1}K^\alpha}{s}\) 。我们将选择它作为 \(c(\mathbf{u},T) = c_R\ \|\mathbf{u}\|_{L^\infty(\Omega)} \ \mathrm{var}(T) \ |\mathrm{diam}(\Omega)|^{\alpha-2}\) ，其中 \(\mathrm{var}(T)=\max_\Omega T - \min_\Omega T\) 是目前温度值的范围（记住，浮力是由温度变化驱动的，而不是绝对温度）， \(c_R\) 是一个无尺寸常数。为了理解这个方法为什么有效，请考虑这个问题。如果在一个特定的单元 \(K\) 上，温度场是平滑的，那么我们希望那里的残差很小（事实上是在 \({\cal O}(h_K)\) 的数量级上），注入人工扩散的稳定项将有 \(h_K^{\alpha+1}\) &amp;mdash；也就是说，相当小，就像我们希望它在没有必要进行额外扩散时那样。另一方面，如果我们处于或接近温度场的不连续性，那么残差就会很大；然后 \(\nu_\alpha(T)\) 定义中的最小操作将确保稳定化具有大小 \(h_K\) &amp;mdash；确保方案稳定的最佳人工粘性量。</p>
<p>这个方案是否真的有效，是一个很好的问题。Guermond和Popov的计算表明，这种形式的稳定化实际上比周围大多数其他稳定化方案（例如流线扩散，仅举最简单的一种）表现得更好。此外，对于 \(\alpha\in [1,2)\) ，他们甚至可以证明，对于线性传输方程，它比流线扩散产生更好的收敛阶数。对于 \(\alpha=2\) ，目前没有理论结果，但数值测试表明，其结果比 \(\alpha=1\) 好得多。</p>
<p>一个更实际的问题是如何将这种人工扩散引入我们想解决的方程中。请注意，数值粘度 \(\nu(T)\) 是随温度变化的，所以我们要解决的方程在 \(T\) 中是非线性的&mdash; 不是人们所希望的稳定方程的简单方法，如果我们意识到 \(\nu(T)\) 在 \(T\) 中是不可微分的，那就更不是了。然而，我们没有理由绝望：我们仍然要在时间上进行离散，我们可以明确地处理这个术语。</p>
<p>在稳定参数的定义中，我们用 \(\frac{\partial T}{\partial t} \approx \frac{T^{n-1}-T^{n-2}}{k^{n-1}}\) 对时间导数进行近似。这个近似只利用了可用的时间数据，这就是我们需要存储前两个时间步长的数据的原因（这使我们能够使用BDF-2方案而不需要额外的存储成本）。我们现在可以简单地在 \(t_{n-1}\) 处评估其余的项，但这样一来，离散残差无非是一个向后的欧拉近似，它只有一阶精度。因此，在平滑解的情况下，尽管外部BDF-2方案和空间FE离散化的时间精度为二阶，但残差仍为 \(h\) 阶。这当然不是我们想要的（事实上，我们希望在解决方案表现良好的区域有较小的残差），所以需要更谨慎一些。这个问题的关键是观察我们构建的第一导数实际上是以 \(t_{n-\frac{3}{2}}\) 为中心的。如果我们通过使用近似值 \(\frac 12 T^{n-1}+\frac 12 T^{n-2}\) 来评估 \(t_{n-\frac{3}{2}}\) 处的所有空间项，我们就能得到所需的二阶精确残差计算，这意味着我们将非线性粘度作为这个中间温度的函数来计算， \(\nu_\alpha = \nu_\alpha\left(\frac 12 T^{n-1}+\frac 12 T^{n-2}\right)\) 。请注意，这种对残差的评估无非是一个Crank-Nicholson方案，所以我们可以肯定，现在一切正常。人们可能会想，现在的数值粘度没有在时间 \(n\) 进行评估（相对于方程的其余部分），这是否是一个问题。然而，这种偏移是不严谨的。对于平滑解， \(\nu_\alpha\) 将连续变化，所以时间偏移的误差比非线性粘度本身要小 \(k\) 倍，也就是说，它是一个被遗漏的小的高阶贡献。这很好，因为该项本身已经达到了光滑区域的离散化误差水平。</p>
<p>使用上面介绍的BDF-2方案，对于更简单的大小为 \(k\) 的均匀时间步长的情况，可以得到 </p><p class="formulaDsp">
\begin{eqnarray*} \frac 32 T^n - k\nabla \cdot \kappa \nabla T^n &amp;=&amp; 2 T^{n-1} - \frac 12 T^{n-2} \\ &amp;&amp; + k\nabla \cdot \left[ \nu_\alpha\left(\frac 12 T^{n-1}+\frac 12 T^{n-2}\right) \ \nabla (2T^{n-1}-T^{n-2}) \right] \\ &amp;&amp; - k(2{\mathbf u}^{n-1}-{\mathbf u}^{n-2}) \cdot \nabla (2T^{n-1}-T^{n-2}) \\ &amp;&amp; + k\gamma. \end{eqnarray*}
</p>
<p>在这个方程的左侧，仍然是来自时间导数和原始（物理）扩散的项，我们以隐式方式处理（这实际上是一个很好的项：从左侧产生的矩阵是质量矩阵和拉普拉斯矩阵的倍数&amp;mdash；两者都是正定的，如果时间步长 \(k\) 很小，和很容易反演）。在右侧，第一行的条款是时间导数的结果；第二行是时间 \(t_{n-\frac 32}\) 的人工扩散；第三行包含平流条款，第四行是来源。请注意，人工扩散对当前时间的外推温度的作用，与我们在时间步长一节中讨论的平流作用相同。</p>
<p>我们在现实中必须使用的非均匀时间步长的形式有点复杂（这就是为什么我们先展示了上面的简单形式），其内容是：。 </p><p class="formulaDsp">
\begin{eqnarray*} \frac{2k_n+k_{n-1}}{k_n+k_{n-1}} T^n - k_n\nabla \cdot \kappa \nabla T^n &amp;=&amp; \frac{k_n+k_{n-1}}{k_{n-1}} T^{n-1} - \frac{k_n^2}{k_{n-1}(k_n+k_{n-1})} T^{n-2} \\ &amp;&amp; + k_n\nabla \cdot \left[ \nu_\alpha\left(\frac 12 T^{n-1}+\frac 12 T^{n-2}\right) \ \nabla \left[ \left(1+\frac{k_n}{k_{n-1}}\right)T^{n-1}-\frac{k_n}{k_{n-1}}T^{n-2} \right] \right] \\ &amp;&amp; - k_n \left[ \left(1+\frac{k_n}{k_{n-1}}\right){\mathbf u}^{n-1} - \frac{k_n}{k_{n-1}}{\mathbf u}^{n-2} \right] \cdot \nabla \left[ \left(1+\frac{k_n}{k_{n-1}}\right)T^{n-1}-\frac{k_n}{k_{n-1}}T^{n-2} \right] \\ &amp;&amp; + k_n\gamma. \end{eqnarray*}
</p>
<p>在解决了所有这些问题之后，弱形式自然而然地从最后一个方程中显示的强形式中产生，我们立即得到了离散化方程的弱形式。 </p><p class="formulaDsp">
\begin{eqnarray*} \frac{2k_n+k_{n-1}}{k_n+k_{n-1}} (\tau_h,T_h^n) + k_n (\nabla \tau_h, \kappa \nabla T_h^n) &amp;=&amp; \biggl(\tau_h, \frac{k_n+k_{n-1}}{k_{n-1}} T_h^{n-1} - \frac{k_n^2}{k_{n-1}(k_n+k_{n-1})} T_h^{n-2} \\ &amp;&amp;\qquad - k_n \left[ \left(1+\frac{k_n}{k_{n-1}}\right){\mathbf u}^{n-1} - \frac{k_n}{k_{n-1}}{\mathbf u}^{n-2} \right] \cdot \nabla \left[ \left(1+\frac{k_n}{k_{n-1}}\right)T^{n-1}-\frac{k_n}{k_{n-1}}T^{n-2} \right] + k_n\gamma \biggr) \\ &amp;&amp; - k_n \left(\nabla \tau_h, \nu_\alpha\left(\frac 12 T_h^{n-1}+\frac 12 T_h^{n-2}\right) \ \nabla \left[ \left(1+\frac{k_n}{k_{n-1}}\right)T^{n-1}-\frac{k_n}{k_{n-1}}T^{n-2} \right] \right) \end{eqnarray*}
</p>
<p>对于所有离散测试函数 \(\tau_h\) 。在这里，扩散项已经通过部分积分，我们已经使用了我们将不施加热通量， \(\mathbf{n}\cdot\kappa\nabla T|_{\partial\Omega}=0\) 。</p>
<p>这就产生了一个矩阵方程，其形式为 </p><p class="formulaDsp">
\begin{eqnarray*} \left( \frac{2k_n+k_{n-1}}{k_n+k_{n-1}} M+k_n A_T\right) T_h^n = F(U_h^{n-1}, U_h^{n-2},T_h^{n-1},T_h^{n-2}), \end{eqnarray*}
</p>
<p>考虑到左边的矩阵结构（两个正定矩阵之和），可以用共轭梯度法轻松解决。</p>
<p><a class="anchor" id="Linearsolvers"></a></p><h4>Linear solvers</h4>
<p>如上所述，我们解决速度/压力和温度的联合系统的方法是使用算子拆分，我们首先用旧的温度场解决速度和压力的斯托克斯系统，然后用刚计算出的速度场解决新的温度场。关于算子拆分方法的更广泛的讨论可以在 <a class="el" href="step_58.html">step-58</a> 中找到）。</p>
<p><a class="anchor" id="LinearsolversfortheStokesproblem"></a></p><h5>Linear solvers for the Stokes problem</h5>
<p>解决来自斯托克斯系统的线性方程在 <a class="el" href="step_22.html">step-22</a> 中得到了详细的讨论。特别是在该方案的结果部分，我们讨论了一些替代性的线性求解策略，结果发现它们比原来的方法更有效。在那里确定的最佳替代方案是使用GMRES求解器，以涉及Schur补码的块状矩阵为前提条件。具体来说，斯托克斯算子导致了一个块状结构矩阵 </p><p class="formulaDsp">
\begin{eqnarray*} \left(\begin{array}{cc} A &amp; B^T \\ B &amp; 0 \end{array}\right) \end{eqnarray*}
</p>
<p>正如那里所讨论的，一个好的预处理程序是 </p><p class="formulaDsp">
\begin{eqnarray*} P = \left(\begin{array}{cc} A &amp; 0 \\ B &amp; -S \end{array}\right), \qquad \text{or equivalently} \qquad P^{-1} = \left(\begin{array}{cc} A^{-1} &amp; 0 \\ S^{-1} B A^{-1} &amp; -S^{-1} \end{array}\right) \end{eqnarray*}
</p>
<p>其中 \(S\) 是斯托克斯算子的舒尔补码 \(S=B^TA^{-1}B\) 。当然，这个预处理程序是没有用的，因为我们不能形成矩阵的各种倒数，但我们可以用下面的方法作为预处理程序。 </p><p class="formulaDsp">
\begin{eqnarray*} \tilde P^{-1} = \left(\begin{array}{cc} \tilde A^{-1} &amp; 0 \\ \tilde S^{-1} B \tilde A^{-1} &amp; -\tilde S^{-1} \end{array}\right) \end{eqnarray*}
</p>
<p>其中 \(\tilde A^{-1},\tilde S^{-1}\) 是反矩阵的近似值。特别是，事实证明 \(S\) 与质量矩阵在频谱上是等价的，因此用适用于压力空间上的质量矩阵的CG求解器取代 \(\tilde S^{-1}\) 是一个不错的选择。与 <a class="el" href="step_22.html">step-22</a> 稍有不同的是，我们这里的动量方程中有一个系数 \(\eta\) ，通过与那里相同的推导，我们应该得出结论，我们应该使用的是有条目 \(\tilde S_{ij}=(\eta^{-1}\varphi_i,\varphi_j)\) 的加权质量矩阵。</p>
<p>要想出一个好的替代品 \(\tilde A^{-1}\) 则更为复杂，它对应于矢量值速度场的离散化对称拉普拉斯，即 \(A_{ij} = (\varepsilon {\mathbf v}_i, 2\eta \varepsilon ({\mathbf v}_j))\) 。在 <a class="el" href="step_22.html">step-22</a> 中，我们使用了 \(A\) 的稀疏LU分解（使用SparseDirectUMFPACK类）用于 \(\tilde A^{-1}\) &mdash;完美的预处理&mdash;在2D中，但对于3D，内存和计算时间通常不足以实际计算这个分解；因此，我们在3D中只使用不完全LU分解（ILU，使用稀疏ILU类）。</p>
<p>对于这个程序，我们想走得更远一点。为此，请注意，矢量场上的对称化双线性形式 \((\varepsilon {\mathbf v}_i, 2 \eta \varepsilon ({\mathbf v}_j))\) 与非对称化版本 \((\nabla {\mathbf v}_i, \eta \nabla {\mathbf v}_j) = \sum_{k,l=1}^d (\partial_k ({\mathbf v}_i)_l, \eta \partial_k ({\mathbf v}_j)_l) \) 相差不大（请注意，在这个形式中因子2已经消失了）。然而，后者的优点是测试函数的 <code>dim</code> 矢量分量是不耦合的（好吧，几乎如此，见下文），也就是说，得到的矩阵是块对角线的：每个矢量分量有一个块，这些块中的每个都等于这个矢量分量的拉普拉斯矩阵。因此，假设我们以这样的方式排列自由度，即首先对速度的所有 \(x\) -分量进行编号，然后是 \(y\) -分量，然后是 \(z\) -分量，那么与这种略有不同的双线性形式相关的矩阵 \(\hat A\) 的形式是 </p><p class="formulaDsp">
\begin{eqnarray*} \hat A = \left(\begin{array}{ccc} A_s &amp; 0 &amp; 0 \\ 0 &amp; A_s &amp; 0 \\ 0 &amp; 0 &amp; A_s \end{array}\right) \end{eqnarray*}
</p>
<p>其中 \(A_s\) 是一个拉普拉斯矩阵，其大小等于与矢量值速度的每个分量相关的形状函数的数量。有了这个矩阵，我们就可以将速度矩阵 \(A\) 的预处理定义如下。 </p><p class="formulaDsp">
\begin{eqnarray*} \tilde A^{-1} = \left(\begin{array}{ccc} \tilde A_s^{-1} &amp; 0 &amp; 0 \\ 0 &amp; \tilde A_s^{-1} &amp; 0 \\ 0 &amp; 0 &amp; \tilde A_s^{-1} \end{array}\right), \end{eqnarray*}
</p>
<p>其中 \(\tilde A_s^{-1}\) 是拉普拉斯矩阵的预处理程序&mdash;我们非常清楚如何建立良好的预处理程序!</p>
<p>在现实中，故事并不那么简单。为了使矩阵 \(\tilde A\) 明确，我们需要通过应用边界条件使各个块 \(\tilde A_s\) 明确。我们可以尝试通过在边界周围应用迪里希特边界条件来做到这一点，然后，如果后者的矩阵是由斯托克斯问题产生的，我们在领域周围的速度分量上也有迪里希特边界条件，即如果我们执行 \(\mathbf{u} = 0\) ，那么如此定义的前置条件 \(\tilde A^{-1}\) 就会成为 \(A\) 的一个好前置条件。</p>
<p>不幸的是，这个 "如果 "是 "如果且仅是如果"：在下面的程序中，我们希望使用 \(\mathbf u \cdot \mathbf n = 0\) 形式的无通量边界条件（即允许平行于边界的流动，但没有通量通过边界）。在这种情况下，事实证明，上面定义的块状对角线矩阵不是一个好的预处理程序，因为它忽略了边界处分量的耦合。因此，更好的方法是如果我们将矩阵 \(\hat A\) 建立为矢量拉普拉斯矩阵 \(\hat A_{ij} = (\nabla {\mathbf v}_i, \eta \nabla {\mathbf v}_j)\) ，然后应用与我们应用于 \(A\) 相同的边界条件。如果这是一个围绕域的迪里希特边界条件， \(\hat A\) 将像上面那样解耦为三个对角线块，如果边界条件是 \(\mathbf u \cdot \mathbf n = 0\) 的形式，那么这将在边界引入自由度的耦合，但只在那里。事实上，这被证明是一个比上面介绍的更好的预处理程序，而且几乎具有我们希望得到的所有好处。</p>
<p>总结这整个故事，我们可以观察到。 </p><ul>
<li>
<p class="startli">与我们在 <a class="el" href="step_22.html">step-22</a> 中从对称梯度产生的原始矩阵 \(A\) 中建立一个预处理器相比，我们不得不期望基于拉普拉斯双线性形式的预处理器表现得更差，因为它没有考虑到矢量成分之间的耦合。 </p><pre class="fragment">&lt;li&gt;  另一方面，拉普拉斯矩阵的预处理程序通常更成熟，比矢量问题的预处理程序性能更好。例如，在写这篇文章的时候，代数多网格（AMG）算法对于标量问题已经非常成熟，但对于矢量问题却不是如此。

&lt;li&gt; 在建立这个预处理程序时，我们必须建立起矩阵 @f$\hat A@f$ 及其预处理程序。虽然这意味着我们必须存储一个之前不需要的额外矩阵，但与存储耦合矩阵 @f$A@f$ 的预处理程序相比，预处理程序 @f$\tilde A_s^{-1}@f$ 可能需要的内存要少得多。这是因为矩阵 @f$A_s@f$ 在所有对应于内部自由度的行中每行只有三分之一的条目，并且只在边界条件引入耦合的部分包含向量分量间的耦合。因此，存储该矩阵是比较便宜的，我们可以预期，计算和存储预处理程序 @f$\tilde A_s@f$ 也将比为完全耦合的矩阵做这些事情便宜得多。  &lt;/ul&gt;   
</pre><p class="interli"><a class="anchor" id="Linearsolversforthetemperatureequation"></a></p><h5>Linear solvers for the temperature equation</h5>
<p class="interli"></p>
<p class="interli">这是最容易的部分。温度方程的矩阵具有 \(\alpha M + \beta A\) 的形式，其中 \(M,A\) 是温度空间上的质量和刚度矩阵， \(\alpha,\beta\) 是与时间步进方案以及当前和前一个时间步进有关的常数。这是一个对称正定和一个对称正半定矩阵之和，其结果也是对称正定的。此外， \(\frac\beta\alpha\) 是一个与时间步长成正比的数字，因此只要网格很细就会变小，从而阻尼当时条件不好的刚度矩阵的影响。</p>
<p class="interli">因此，用共轭梯度算法反演这个矩阵，使用一个简单的预处理程序，与反演斯托克斯矩阵相比是微不足道和非常便宜的。</p>
<p class="interli"><a class="anchor" id="Implementationdetails"></a></p><h3>Implementation details</h3>
<p class="interli"></p>
<p class="interli"><a class="anchor" id="UsingdifferentDoFHandlerobjects"></a></p><h4>Using different <a class="el" href="classDoFHandler.html">DoFHandler</a> objects</h4>
<p class="interli"></p>
<p class="interli">关于下面的程序，值得预先解释的一件事是使用了两个不同的DoFHandler对象。如果我们看一下上述方程的结构和它们的求解方案，就会发现几乎没有什么共同点可以使斯托克斯部分和温度部分保持一致。在我们以前讨论 <a class="el" href="group__vector__valued.html">矢量值问题 </a>的所有教程程序中，我们总是只使用一个有几个矢量分量的单一有限元，以及一个DoFHandler对象。有时，我们将得到的矩阵分解成若干块，以方便特定的求解器方案；例如，在当前程序所基于的斯托克斯方程的 <a class="el" href="step_22.html">step-22</a> 程序中就是如此。</p>
<p class="interli">当然，我们在这里也可以这样做。我们将得到的线性系统看起来像这样。 </p><p class="formulaDsp">
\begin{eqnarray*} \left(\begin{array}{ccc} A &amp; B^T &amp; 0 \\ B &amp; 0 &amp;0 \\ C &amp; 0 &amp; K \end{array}\right) \left(\begin{array}{ccc} U^{n-1} \\ P^{n-1} \\ T^n \end{array}\right) = \left(\begin{array}{ccc} F_U(T^{n-1}) \\ 0 \\ F_T(U^{n-1},U^{n-2},T^{n-1},T^{n-2}) \end{array}\right). \end{eqnarray*}
</p>
<p class="interli">这方面的问题是。我们从未同时使用整个矩阵。事实上，它从未真正同时存在。如上所述， \(K\) 和 \(F_T\) 取决于已经计算出的解 \(U^n\) ，在第一种情况下，通过时间步长（取决于 \(U^n\) ，因为它必须满足一个CFL条件）。所以我们只有在已经解决了左上角 \(2\times 2\) 块斯托克斯系统后才能组装它，而一旦我们转向温度方程，我们就不再需要斯托克斯部分了；我们为一个在任何时候都不会作为一个整体存在于内存中的矩阵建立一个对象，这导致我们在 <a class="el" href="step_21.html">step-21</a> 中跳了一些圈套，所以我们不要重复这类错误。此外，我们实际上并没有建立矩阵 \(C\) ：因为当我们进入温度方程时，我们已经知道了 \(U^n\) ，而且因为我们必须在这个时候组装右侧的 \(F_T\) ，我们只是将项 \(CU^n\) 移到右侧，并将其与所有其他项组装在一起。这意味着矩阵中不存在温度变量和斯托克斯变量耦合的部分，因此所有自由度的全局列举不再重要：如果我们有所有斯托克斯自由度的列举，以及所有温度自由度的独立列举就足够了。</p>
<p class="interli">从本质上讲，将<em>everything</em>放入一个块矩阵中并没有什么用处（当然，对于 \(2\times 2\) 斯托克斯部分也有同样好的理由这样做），或者，就这一点而言，将所有东西放入同一个DoFHandler对象。</p>
<p class="interli">但是这样做是否有<em>downsides</em>的好处呢？这些问题是存在的，尽管它们一开始可能并不明显。主要问题是，如果我们需要创建一个包含速度、压力和温度形状函数的全局有限元，并使用它来初始化DoFHandler。但是我们也用这个有限元对象来初始化我们使用的所有FEValues或FEFaceValues对象。这可能看起来不是什么大问题，但是想象一下，例如，当我们评估我们需要用来计算人工粘度 \(\nu_\alpha(T)|_K\) 的残差 \( R_\alpha(T) = \left( \frac{\partial T}{\partial t} + {\mathbf u} \cdot \nabla T - \nabla \cdot \kappa \nabla T - \gamma \right) T^{\alpha-1} \) 时，会发生什么。 为此，我们需要温度的拉普拉斯，我们使用形状函数的二阶导数（Hessians）张量来计算（为此我们必须给FEValues对象加上 <code>update_hessians</code> 标志）。现在，如果我们有一个包含速度、压力和温度的形状函数的有限性，这意味着我们必须计算<em>all</em>形状函数的Hessians，包括速度的许多高阶形状函数。这是很多我们不需要的计算，事实上，如果要这样做（正如我们在程序的早期版本中所做的那样），组装右手边大约需要整个计算时间的四分之一。</p>
<p class="interli">所以我们要做的是使用两个不同的有限元对象，一个用于斯托克斯成分，一个用于温度。这样就有了两个不同的DoFHandlers，两个稀疏模式和两个用于斯托克斯和温度部分的矩阵，等等。每当我们要组装包含温度和斯托克斯形状函数的东西时（特别是斯托克斯和温度方程的右侧），我们就使用两个FEValues对象，用两个单元格迭代器进行初始化，通过与同一三角化对象相关的两个DoFHandler对象进行平行行走。对于这两个FEValues对象，我们当然使用相同的正交对象，这样我们就可以在同一组正交点上进行迭代，但是每个FEValues对象将只根据它实际需要计算的内容来获得更新标志。特别是，当我们像上面那样计算残差时，我们只要求得到斯托克斯形状函数的值，但也要求得到温度形状函数的Hessians &amp;mdash；确实便宜得多，而且事实证明：组装温度方程的右手边现在是程序中几乎无法测量的一个组成部分。</p>
<p class="interli">有了这些变化，对程序进行计时就会发现只有以下操作与整个运行时间有关。 </p><ul>
<li>
解决斯托克斯系统：运行时间的72。 </li>
<li>
组装斯托克斯预处理程序，并使用Trilinos ML包计算代数多网格层次：占运行时间的11。 </li>
<li>
函数 <code>BoussinesqFlowProblem::setup_dofs</code> ：占总体运行时间的7。 </li>
<li>
组装斯托克斯和温度右侧向量以及组装矩阵。7%. </li>
</ul>
<p>从本质上讲，这意味着除了代数多重网格外，所有的瓶颈都已被消除。</p>
<p class="interli"><a class="anchor" id="UsingTrilinos"></a></p><h4>Using Trilinos</h4>
<p class="interli"></p>
<p class="interli">与我们在 <a class="el" href="step_17.html">step-17</a> 和 <a class="el" href="step_18.html">step-18</a> 中使用PETSc来支持我们的线性代数需求一样，我们在这个程序中使用了<a href="http://trilinos.org">Trilinos</a>库的接口（安装说明见deal.II README文件）。Trilinos是一个非常大的集合，包含了所有与线性和非线性代数有关的东西，以及围绕这些东西的各种工具（看起来它在未来也会向许多其他方向发展）。</p>
<p class="interli">使用Trilinos的主要原因，类似于我们探索的PETSc，是它是一个非常强大的库，比deal.II自己的线性代数库提供了很多工具。这尤其包括在集群上以parallel方式工作的能力，使用MPI，以及更多种类的前置条件器。在后一类中，最有趣的能力之一是Trilinos ML包的存在，它实现了代数多栅（AMG）方法。我们将使用这个预处理程序对动量方程的二阶算子部分进行预处理。我们将在 <a class="el" href="step_32.html">step-32</a> 中探讨以并行方式解决问题的能力，使用的问题与这里讨论的相同。</p>
<p class="interli">我们在 <a class="el" href="step_17.html">step-17</a> 和 <a class="el" href="step_18.html">step-18</a> 中使用的PETSc无疑是一个强大的库，它提供了大量处理矩阵、向量、迭代求解器和预处理器的函数，以及许多其他东西，其中大部分在parallel中运行得很好。然而，它比Trilinos早了几年，是用C语言编写的，而且一般来说不像其他一些库那样容易使用。因此，deal.II也获得了与Trilinos的接口，Trilinos与PETSc有很多相同的功能。然而，它是一个年轻了好几年的项目，是用C++编写的，其作者一般都非常重视软件设计。</p>
<p class="interli"><a class="anchor" id="Thetestcase"></a></p><h3>The testcase</h3>
<p class="interli"></p>
<p class="interli">我们在这里要解决的情况如下：我们用 \(\kappa=10^{-6}, \eta=1, \rho=1, \beta=10\) 解决上述的Boussinesq方程，即一个相对缓慢运动的流体，它几乎没有热扩散传导性，主要通过对流来传输热量。在边界上，我们将要求速度（ \(\mathrm{n}\cdot\mathrm{u}=0\) ）和温度（ \(\mathrm{n}\cdot\nabla T=0\) ）没有正态流量。这是 <a class="el" href="step_22.html">step-22</a> 介绍中讨论的情况之一，固定了速度的一个分量，同时允许流动与边界平行。还有 <code>dim-1</code> 分量需要固定，即法向应力的切向分量；对于这些分量，我们选择同质条件，这意味着我们不需要任何特殊条件。初始条件只对温度场是必要的，我们选择它为恒定的零。</p>
<p class="interli">然后，问题的演变完全由温度方程的右侧 \(\gamma(\mathrm{x},t)\) 驱动，即由热源和汇驱动。在这里，我们选择了一个在圣诞讲座前发明的设置：美国的教室里当然禁止使用真实的蜡烛，但允许使用虚拟的蜡烛。因此，我们选择了三个球形的热源，不等距地靠近领域的底部，模仿三个蜡烛的样子。位于这些热源处的流体，最初处于静止状态，然后被加热，随着温度的升高，获得浮力，上升；更多的流体被拖上来，穿过热源，导致三个热羽上升，直到被外面下沉的流体循环捕获，取代因加热而上升的空气。<a class="anchor" id="CommProg"></a></p><h1>The commented program</h1>
<p class="interli"></p>
<p class="interli"><a class="anchor" id="Includefiles"></a></p><h3>Include files</h3>
<p class="interli"></p>
<p class="interli">像往常一样，第一步是包括这些著名的deal.II库文件和一些C++头文件的功能。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__gmres_8h.html">deal.II/lac/solver_gmres.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparsity__pattern_8h.html">deal.II/lac/block_sparsity_pattern.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2solution__transfer_8h.html">deal.II/numerics/solution_transfer.h</a>&gt;</span></div>
<div class="ttc" id="aaffine__constraints_8h_html"><div class="ttname"><a href="affine__constraints_8h.html">affine_constraints.h</a></div></div>
<div class="ttc" id="ablock__sparsity__pattern_8h_html"><div class="ttname"><a href="block__sparsity__pattern_8h.html">block_sparsity_pattern.h</a></div></div>
<div class="ttc" id="adof__renumbering_8h_html"><div class="ttname"><a href="dof__renumbering_8h.html">dof_renumbering.h</a></div></div>
<div class="ttc" id="adof__tools_8h_html"><div class="ttname"><a href="dof__tools_8h.html">dof_tools.h</a></div></div>
<div class="ttc" id="adofs_2dof__handler_8h_html"><div class="ttname"><a href="dofs_2dof__handler_8h.html">dof_handler.h</a></div></div>
<div class="ttc" id="aerror__estimator_8h_html"><div class="ttname"><a href="error__estimator_8h.html">error_estimator.h</a></div></div>
<div class="ttc" id="afe_2fe__values_8h_html"><div class="ttname"><a href="fe_2fe__values_8h.html">fe_values.h</a></div></div>
<div class="ttc" id="afe__q_8h_html"><div class="ttname"><a href="fe__q_8h.html">fe_q.h</a></div></div>
<div class="ttc" id="afe__system_8h_html"><div class="ttname"><a href="fe__system_8h.html">fe_system.h</a></div></div>
<div class="ttc" id="afull__matrix_8h_html"><div class="ttname"><a href="full__matrix_8h.html">full_matrix.h</a></div></div>
<div class="ttc" id="agrid_2grid__refinement_8h_html"><div class="ttname"><a href="grid_2grid__refinement_8h.html">grid_refinement.h</a></div></div>
<div class="ttc" id="agrid_2tria_8h_html"><div class="ttname"><a href="grid_2tria_8h.html">tria.h</a></div></div>
<div class="ttc" id="agrid__generator_8h_html"><div class="ttname"><a href="grid__generator_8h.html">grid_generator.h</a></div></div>
<div class="ttc" id="agrid__tools_8h_html"><div class="ttname"><a href="grid__tools_8h.html">grid_tools.h</a></div></div>
<div class="ttc" id="ainclude_2deal_8II_2base_2utilities_8h_html"><div class="ttname"><a href="include_2deal_8II_2base_2utilities_8h.html">utilities.h</a></div></div>
<div class="ttc" id="alogstream_8h_html"><div class="ttname"><a href="logstream_8h.html">logstream.h</a></div></div>
<div class="ttc" id="anumerics_2data__out_8h_html"><div class="ttname"><a href="numerics_2data__out_8h.html">data_out.h</a></div></div>
<div class="ttc" id="anumerics_2solution__transfer_8h_html"><div class="ttname"><a href="numerics_2solution__transfer_8h.html">solution_transfer.h</a></div></div>
<div class="ttc" id="aquadrature__lib_8h_html"><div class="ttname"><a href="quadrature__lib_8h.html">quadrature_lib.h</a></div></div>
<div class="ttc" id="asolver__cg_8h_html"><div class="ttname"><a href="solver__cg_8h.html">solver_cg.h</a></div></div>
<div class="ttc" id="asolver__gmres_8h_html"><div class="ttname"><a href="solver__gmres_8h.html">solver_gmres.h</a></div></div>
<div class="ttc" id="avector__tools_8h_html"><div class="ttname"><a href="vector__tools_8h.html">vector_tools.h</a></div></div>
</div><!-- fragment --><p class="interli">然后，我们需要包括一些头文件，这些文件提供了向量、矩阵和预处理器类，这些类实现了各自的Trilinos类的接口。特别是，我们将需要基于Trilinos的矩阵和向量类的接口，以及Trilinos预处理程序。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__sparse__matrix_8h.html">deal.II/lac/trilinos_sparse_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__block__sparse__matrix_8h.html">deal.II/lac/trilinos_block_sparse_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__vector_8h.html">deal.II/lac/trilinos_vector.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__parallel__block__vector_8h.html">deal.II/lac/trilinos_parallel_block_vector.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__precondition_8h.html">deal.II/lac/trilinos_precondition.h</a>&gt;</span></div>
<div class="ttc" id="aindex__set_8h_html"><div class="ttname"><a href="index__set_8h.html">index_set.h</a></div></div>
<div class="ttc" id="atrilinos__block__sparse__matrix_8h_html"><div class="ttname"><a href="trilinos__block__sparse__matrix_8h.html">trilinos_block_sparse_matrix.h</a></div></div>
<div class="ttc" id="atrilinos__parallel__block__vector_8h_html"><div class="ttname"><a href="trilinos__parallel__block__vector_8h.html">trilinos_parallel_block_vector.h</a></div></div>
<div class="ttc" id="atrilinos__precondition_8h_html"><div class="ttname"><a href="trilinos__precondition_8h.html">trilinos_precondition.h</a></div></div>
<div class="ttc" id="atrilinos__sparse__matrix_8h_html"><div class="ttname"><a href="trilinos__sparse__matrix_8h.html">trilinos_sparse_matrix.h</a></div></div>
<div class="ttc" id="atrilinos__vector_8h_html"><div class="ttname"><a href="trilinos__vector_8h.html">trilinos_vector.h</a></div></div>
</div><!-- fragment --><p class="interli">最后，这里有几个C++头文件，还没有被上述头文件之一包含。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;limits&gt;</span></div>
</div><!-- fragment --><p class="interli">在这个头文件的最后，我们将所有deal.II的名字导入到全局命名空间。</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step31</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
<div class="ttc" id="anamespacedealii_html"><div class="ttname"><a href="namespacedealii.html">dealii</a></div><div class="ttdef"><b>Definition:</b> <a href="namespace__dealii_8h_source.html#l00025">namespace_dealii.h:26</a></div></div>
</div><!-- fragment --><p class="interli"><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p class="interli"></p>
<p class="interli">同样，程序的下一阶段是定义方程数据，也就是各种边界条件、右手边和初始条件（记住，我们要解决的是一个时间依赖的系统）。这个定义的基本策略与 <a class="el" href="step_22.html">step-22</a> 中的相同。不过关于细节，还是有一些区别。</p>
<p class="interli">首先，我们没有在速度上设置任何不均匀的边界条件，因为正如介绍中所解释的，我们将使用无流条件 \(\mathbf{n}\cdot\mathbf{u}=0\) 。所以剩下的是应力张量法线分量的切向部分的 <code>dim-1</code> 条件， \(\textbf{n} \cdot [p \textbf{1} - \eta\varepsilon(\textbf{u})]\) ；我们假定这些分量的值是同质的，也就是说，一个自然的边界条件，不需要具体的动作（它作为零项出现在弱形式的右边）。</p>
<p class="interli">对于温度 \(T\) ，我们假设没有热能通量，即 \(\mathbf{n} \cdot \kappa \nabla T=0\) 。这也是一个边界条件，不需要我们做任何特别的事情。 <br  />
</p>
<p class="interli">其次，我们必须设置温度的初始条件（速度和压力不需要初始条件，因为我们在这里考虑的准稳态情况下的斯托克斯方程没有速度或压力的时间导数）。在这里，我们选择了一个非常简单的测试案例，即初始温度为零，所有动力学都由温度的右手边驱动。 <br  />
</p>
<p class="interli">第三，我们需要定义温度方程的右边。我们选择它在域的底部某处的三个圆（或三维球体）内是恒定的，正如介绍中所解释的那样，而在域外是零。 <br  />
</p>
<p class="interli">最后，或者说首先，在这个命名空间的顶部，我们定义了我们需要的各种材料常数（ \(\eta,\kappa\) ，密度 \(\rho\) 和热膨胀系数 \(\beta\) ）。</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>EquationData</div>
<div class="line">{</div>
<div class="line">  constexpr <span class="keywordtype">double</span> eta     = 1;</div>
<div class="line">  constexpr <span class="keywordtype">double</span> kappa   = 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-6;</div>
<div class="line">  constexpr <span class="keywordtype">double</span> beta    = 10;</div>
<div class="line">  constexpr <span class="keywordtype">double</span> density = 1;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keyword">class </span>TemperatureInitialValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    TemperatureInitialValues()</div>
<div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="namespaceinternal.html#aa5bef221c94bc6b9c5441c306a72cdbaa2063c1608d6e0baf80249c42e2be5804">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div>
<div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div>
<div class="line">                              <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  value)<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div>
<div class="line">        <a class="code" href="namespaceinternal.html#aa5bef221c94bc6b9c5441c306a72cdbaa2063c1608d6e0baf80249c42e2be5804">value</a>(c) = TemperatureInitialValues&lt;dim&gt;::value(p, c);</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keyword">class </span>TemperatureRightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    TemperatureRightHandSide()</div>
<div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="namespaceinternal.html#aa5bef221c94bc6b9c5441c306a72cdbaa2063c1608d6e0baf80249c42e2be5804">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div>
<div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      (void)component;</div>
<div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0,</div>
<div class="line">             <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Invalid operation for a scalar function.&quot;</span>));</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((dim == 2) || (dim == 3), <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">      <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> source_centers[3] = {</div>
<div class="line">        (dim == 2 ? <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(.3, .1) : <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(.3, .5, .1)),</div>
<div class="line">        (dim == 2 ? <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(.45, .1) : <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(.45, .5, .1)),</div>
<div class="line">        (dim == 2 ? <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(.75, .1) : <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(.75, .5, .1))};</div>
<div class="line">      <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> source_radius = (dim == 2 ? 1. / 32 : 1. / 8);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">return</span> ((source_centers[0].distance(p) &lt; source_radius) ||</div>
<div class="line">                  (source_centers[1].<a class="code" href="classPoint.html#a3df8e6ab311dab9337c8d7b039c7b815">distance</a>(p) &lt; source_radius) ||</div>
<div class="line">                  (source_centers[2].distance(p) &lt; source_radius) ?</div>
<div class="line">                1 :</div>
<div class="line">                0);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div>
<div class="line">                              <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  value)<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div>
<div class="line">        <a class="code" href="namespaceinternal.html#aa5bef221c94bc6b9c5441c306a72cdbaa2063c1608d6e0baf80249c42e2be5804">value</a>(c) = TemperatureRightHandSide&lt;dim&gt;::value(p, c);</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">} <span class="comment">// namespace EquationData</span></div>
<div class="ttc" id="aclassFunction_html"><div class="ttname"><a href="classFunction.html">Function</a></div><div class="ttdef"><b>Definition:</b> <a href="function_8h_source.html#l00150">function.h:153</a></div></div>
<div class="ttc" id="aclassPoint_html"><div class="ttname"><a href="classPoint.html">Point</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2point_8h_source.html#l00110">point.h:111</a></div></div>
<div class="ttc" id="aclassPoint_html_a3df8e6ab311dab9337c8d7b039c7b815"><div class="ttname"><a href="classPoint.html#a3df8e6ab311dab9337c8d7b039c7b815">Point::distance</a></div><div class="ttdeci">numbers::NumberTraits&lt; Number &gt;::real_type distance(const Point&lt; dim, Number &gt; &amp;p) const</div></div>
<div class="ttc" id="aclassVector_html"><div class="ttname"><a href="classVector.html">Vector&lt; double &gt;</a></div></div>
<div class="ttc" id="agroup__Exceptions_html_ga70a0bb353656e704acf927945277bbc6"><div class="ttname"><a href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a></div><div class="ttdeci">#define Assert(cond, exc)</div><div class="ttdef"><b>Definition:</b> <a href="include_2deal_8II_2base_2exceptions_8h_source.html#l01473">exceptions.h:1473</a></div></div>
<div class="ttc" id="agroup__Exceptions_html_ga7b52b286796c23ef9ff178faf7a4b68f"><div class="ttname"><a href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">StandardExceptions::ExcNotImplemented</a></div><div class="ttdeci">static ::ExceptionBase &amp; ExcNotImplemented()</div></div>
<div class="ttc" id="agroup__Exceptions_html_gae9a45f517af1401c50811a11083f9114"><div class="ttname"><a href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">StandardExceptions::ExcMessage</a></div><div class="ttdeci">static ::ExceptionBase &amp; ExcMessage(std::string arg1)</div></div>
<div class="ttc" id="anamespacePhysics_1_1Elasticity_1_1Kinematics_html_a9587d5229555daa5b1fa1ba2f8a40adb"><div class="ttname"><a href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">Physics::Elasticity::Kinematics::e</a></div><div class="ttdeci">SymmetricTensor&lt; 2, dim, Number &gt; e(const Tensor&lt; 2, dim, Number &gt; &amp;F)</div></div>
<div class="ttc" id="anamespaceinternal_html_aa5bef221c94bc6b9c5441c306a72cdbaa2063c1608d6e0baf80249c42e2be5804"><div class="ttname"><a href="namespaceinternal.html#aa5bef221c94bc6b9c5441c306a72cdbaa2063c1608d6e0baf80249c42e2be5804">internal::EvaluatorQuantity::value</a></div><div class="ttdeci">@ value</div></div>
</div><!-- fragment --><p class="interli"><a class="anchor" id="Linearsolversandpreconditioners"></a> </p><h3>Linear solvers and preconditioners</h3>
<p class="interli"></p>
<p class="interli">本节介绍了一些用于解决斯托克斯系统线性方程的对象，我们需要在每个时间步长中解决这些方程。这里使用的许多想法与 <a class="el" href="step_20.html">step-20</a> 相同，其中介绍了基于Schur补数的预处理和求解器，实际接口来自 <a class="el" href="step_22.html">step-22</a> （特别是 <a class="el" href="step_22.html">step-22</a> 的 "结果 "部分的讨论，其中我们介绍了直接Schur补数方法的替代方案）。然而，请注意，这里我们不使用Schur补数来解决Stokes方程，尽管在预处理程序中出现了一个近似的Schur补数（压力空间的质量矩阵）。</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>LinearSolvers</div>
<div class="line">{</div>
</div><!-- fragment --><p class="interli"><a class="anchor" id="ThecodeInverseMatrixcodeclasstemplate"></a> </p><h4>The <code>InverseMatrix</code> class template</h4>
<p class="interli"></p>
<p class="interli">该类是一个接口，用于计算 "倒置 "矩阵对矢量的作用（使用 <code>vmult</code> 操作），其方式与 <a class="el" href="step_22.html">step-22</a> 中的相应类相同：当请求该类对象的乘积时，我们使用CG方法解决与该矩阵有关的线性方程组，由（模板化）类的预处理程序加速 <code>PreconditionerType</code> 。 <br  />
</p>
<p class="interli">与 <a class="el" href="step_22.html">step-22</a> 中同一类别的实现略有不同，我们让 <code>vmult</code> 函数接受任何类型的向量（不过，如果矩阵不允许与这种向量进行矩阵-向量乘积，它将产生编译器错误）。 <br  />
</p>
<p class="interli">其次，我们捕捉解算器可能抛出的任何异常。原因如下。在调试这样的程序时，偶尔会犯一个错误，即把一个不确定或不对称的矩阵或预处理程序传递给当前类。在这种情况下，求解器将不能收敛并抛出一个运行时异常。如果在这里没有被捕捉到，它将在调用堆栈中传播，并可能最终在 <code>main()</code> 中被发现，在那里我们将输出一个错误信息，说CG求解器失败。那么问题来了。哪个CG求解器？倒置质量矩阵的那个？用拉普拉斯算子反转左上角块的那个？还是在当前代码中我们使用线性求解器的其他几个嵌套位置中的一个CG求解器？在运行时异常中没有这方面的指示，因为它没有存储我们到达产生异常的地方的调用栈。 <br  />
</p>
<p class="interli">因此，与其让异常自由传播到 <code>main()</code> ，不如将运行时异常转换为一个断言，该断言失败后会触发对 <code><a class="el" href="namespacedeal__II__exceptions_1_1internals.html#a600f8f191a6ce368afda0074dd7ea1dc">abort()</a></code> 的调用，使我们能够在调试器中追溯我们是如何到达当前位置的。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div>
<div class="line"><span class="keyword">class </span>InverseMatrix : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  InverseMatrix(<span class="keyword">const</span> MatrixType &amp;        m,</div>
<div class="line">                <span class="keyword">const</span> PreconditionerType &amp;preconditioner);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div>
<div class="line">  <span class="keywordtype">void</span> vmult(VectorType &amp;dst, <span class="keyword">const</span> VectorType &amp;src) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const MatrixType&gt;</a> <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>;</div>
<div class="line">  <span class="keyword">const</span> PreconditionerType &amp;           preconditioner;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div>
<div class="line">InverseMatrix&lt;MatrixType, PreconditionerType&gt;::InverseMatrix(</div>
<div class="line">  <span class="keyword">const</span> MatrixType &amp;        m,</div>
<div class="line">  <span class="keyword">const</span> PreconditionerType &amp;preconditioner)</div>
<div class="line">  : <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>(&amp;m)</div>
<div class="line">  , preconditioner(preconditioner)</div>
<div class="line">{}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div>
<div class="line"><span class="keywordtype">void</span> InverseMatrix&lt;MatrixType, PreconditionerType&gt;::vmult(</div>
<div class="line">  VectorType &amp;      dst,</div>
<div class="line">  <span class="keyword">const</span> VectorType &amp;src)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>        solver_control(src.size(), 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-7 * src.l2_norm());</div>
<div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;VectorType&gt;</a> cg(solver_control);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  dst = 0;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      cg.solve(*<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, dst, src, preconditioner);</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>)</div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>.what()));</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclassSmartPointer_html"><div class="ttname"><a href="classSmartPointer.html">SmartPointer</a></div><div class="ttdef"><b>Definition:</b> <a href="smartpointer_8h_source.html#l00067">smartpointer.h:68</a></div></div>
<div class="ttc" id="aclassSolverCG_html"><div class="ttname"><a href="classSolverCG.html">SolverCG</a></div><div class="ttdef"><b>Definition:</b> <a href="solver__cg_8h_source.html#l00095">solver_cg.h:96</a></div></div>
<div class="ttc" id="aclassSolverControl_html"><div class="ttname"><a href="classSolverControl.html">SolverControl</a></div><div class="ttdef"><b>Definition:</b> <a href="solver__control_8h_source.html#l00065">solver_control.h:66</a></div></div>
<div class="ttc" id="aclassSubscriptor_html"><div class="ttname"><a href="classSubscriptor.html">Subscriptor</a></div><div class="ttdef"><b>Definition:</b> <a href="subscriptor_8h_source.html#l00061">subscriptor.h:62</a></div></div>
<div class="ttc" id="anamespaceLAPACKSupport_html_a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003"><div class="ttname"><a href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">LAPACKSupport::matrix</a></div><div class="ttdeci">@ matrix</div><div class="ttdoc">Contents is actually a matrix.</div><div class="ttdef"><b>Definition:</b> <a href="lapack__support_8h_source.html#l00058">lapack_support.h:58</a></div></div>
</div><!-- fragment --><p class="interli"><a class="anchor" id="Schurcomplementpreconditioner"></a> </p><h4>Schur complement preconditioner</h4>
<p class="interli"></p>
<p class="interli">这是在介绍中详细描述的Schur补码预处理的实现。与 <a class="el" href="step_20.html">step-20</a> 和 <a class="el" href="step_22.html">step-22</a> 相反，我们使用GMRES一次性解决块系统，并使用块结构矩阵的Schur补码来建立一个良好的预处理程序。 <br  />
</p>
<p class="interli">让我们看一下介绍中描述的理想的预处理矩阵 \(P=\left(\begin{array}{cc} A &amp; 0 \\ B &amp; -S \end{array}\right)\) 。如果我们在线性系统的求解中应用这个矩阵，迭代式GMRES求解器的收敛性将受矩阵 </p><p class="formulaDsp">
\begin{eqnarray*} P^{-1}\left(\begin{array}{cc} A &amp; B^T \\ B &amp; 0 \end{array}\right) = \left(\begin{array}{cc} I &amp; A^{-1} B^T \\ 0 &amp; I \end{array}\right), \end{eqnarray*}
</p>
<p>的制约，这确实非常简单。基于精确矩阵的GMRES求解器将在一次迭代中收敛，因为所有的特征值都是相等的（任何Krylov方法最多需要多少次迭代就有多少个不同的特征值）。Silvester和Wathen提出了这样一个用于受阻斯托克斯系统的预处理程序（"稳定的斯托克斯系统的快速迭代解第二部分。 Using general block preconditioners", SIAM J. Numer. Anal., 31 (1994), pp. 1352-1367）。)</p>
<p class="interli">用 \(\tilde{P}\) 代替 \(P\) 可以保持这种精神：乘积 \(P^{-1} A\) 仍将接近于特征值为1的矩阵，其分布不取决于问题的大小。这让我们希望能够得到一个与问题规模无关的GMRES迭代次数。 <br  />
</p>
<p class="interli">已经通过 <a class="el" href="step_20.html">step-20</a> 和 <a class="el" href="step_22.html">step-22</a> 教程的deal.II用户当然可以想象我们将如何实现这一点。 我们用一些从InverseMatrix类中建立的近似逆矩阵来代替 \(P^{-1}\) 中的精确逆矩阵，而逆舒尔补码将由压力质量矩阵 \(M_p\) 来近似（如介绍中提到的由 \(\eta^{-1}\) 加权）。正如在 <a class="el" href="step_22.html">step-22</a> 的结果部分所指出的，我们可以通过应用一个预处理程序来取代 \(A\) 的精确逆，在这种情况下，如介绍中所解释的那样，在一个矢量拉普拉斯矩阵上。这确实增加了（外部）GMRES迭代的数量，但仍然比精确的逆要便宜得多，因为 <em> 的每个 </em> 外部求解器步骤（使用AMG预处理器）需要20到35次CG迭代。 <br  />
</p>
<p class="interli">考虑到上述解释，我们定义了一个具有 <code>vmult</code> 功能的预处理类，这是我们在程序代码中进一步与通常的求解器函数交互所需要的。 <br  />
</p>
<p class="interli">首先是声明。这与 <a class="el" href="step_20.html">step-20</a> 中Schur补码的定义相似，不同的是我们在构造函数中需要更多的预处理程序，而且我们在这里使用的矩阵是建立在Trilinos之上的。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div>
<div class="line"><span class="keyword">class </span>BlockSchurPreconditioner : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  BlockSchurPreconditioner(</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;S,</div>
<div class="line">    <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a>,</div>
<div class="line">                        PreconditionerTypeMp&gt; &amp;Mpinv,</div>
<div class="line">    <span class="keyword">const</span> PreconditionerTypeA &amp;                Apreconditioner);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> vmult(<a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;      dst,</div>
<div class="line">             <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;src) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const TrilinosWrappers::BlockSparseMatrix&gt;</a></div>
<div class="line">    stokes_matrix;</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer</a>&lt;<span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="namespaceLinearAlgebraDealII.html#a912abe2208022aec6753876bcc72f6bf">TrilinosWrappers::SparseMatrix</a>,</div>
<div class="line">                                         PreconditionerTypeMp&gt;&gt;</div>
<div class="line">                             m_inverse;</div>
<div class="line">  <span class="keyword">const</span> PreconditionerTypeA &amp;a_preconditioner;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">mutable</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> tmp;</div>
<div class="line">};</div>
<div class="ttc" id="aclassTrilinosWrappers_1_1BlockSparseMatrix_html"><div class="ttname"><a href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a></div><div class="ttdef"><b>Definition:</b> <a href="trilinos__block__sparse__matrix_8h_source.html#l00071">trilinos_block_sparse_matrix.h:72</a></div></div>
<div class="ttc" id="aclassTrilinosWrappers_1_1MPI_1_1BlockVector_html"><div class="ttname"><a href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a></div><div class="ttdef"><b>Definition:</b> <a href="trilinos__parallel__block__vector_8h_source.html#l00074">trilinos_parallel_block_vector.h:75</a></div></div>
<div class="ttc" id="aclassTrilinosWrappers_1_1MPI_1_1Vector_html"><div class="ttname"><a href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a></div><div class="ttdef"><b>Definition:</b> <a href="trilinos__vector_8h_source.html#l00403">trilinos_vector.h:404</a></div></div>
<div class="ttc" id="aclassTrilinosWrappers_1_1SparseMatrix_html"><div class="ttname"><a href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a></div><div class="ttdef"><b>Definition:</b> <a href="trilinos__sparse__matrix_8h_source.html#l00510">trilinos_sparse_matrix.h:511</a></div></div>
<div class="ttc" id="anamespaceLinearAlgebraDealII_html_a912abe2208022aec6753876bcc72f6bf"><div class="ttname"><a href="namespaceLinearAlgebraDealII.html#a912abe2208022aec6753876bcc72f6bf">LinearAlgebraDealII::SparseMatrix</a></div><div class="ttdeci">SparseMatrix&lt; double &gt; SparseMatrix</div><div class="ttdef"><b>Definition:</b> <a href="generic__linear__algebra_8h_source.html#l00053">generic_linear_algebra.h:53</a></div></div>
</div><!-- fragment --><p class="interli">当使用 <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> 或 <a class="el" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a>, 时，Vector使用IndexSet进行初始化。IndexSet不仅用于调整 <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> 的大小，而且还将 <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> 中的一个索引与一个自由度联系起来（更详细的解释见 <a class="el" href="step_40.html">step-40</a> ）。函数complete_index_set()创建了一个IndexSet，每个有效的索引都是这个集合的一部分。请注意，这个程序只能按顺序运行，如果并行使用，将抛出一个异常。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div>
<div class="line">BlockSchurPreconditioner&lt;PreconditionerTypeA, PreconditionerTypeMp&gt;::</div>
<div class="line">  BlockSchurPreconditioner(</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;S,</div>
<div class="line">    <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a>,</div>
<div class="line">                        PreconditionerTypeMp&gt; &amp;Mpinv,</div>
<div class="line">    <span class="keyword">const</span> PreconditionerTypeA &amp;                Apreconditioner)</div>
<div class="line">  : stokes_matrix(&amp;S)</div>
<div class="line">  , m_inverse(&amp;Mpinv)</div>
<div class="line">  , a_preconditioner(Apreconditioner)</div>
<div class="line">  , tmp(<a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(stokes_matrix-&gt;block(1, 1).m()))</div>
<div class="line">{}</div>
<div class="ttc" id="aclassIndexSet_html_ad28b2e725afda38ffdef1bf61d5cadd4"><div class="ttname"><a href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">IndexSet::complete_index_set</a></div><div class="ttdeci">IndexSet complete_index_set(const IndexSet::size_type N)</div><div class="ttdef"><b>Definition:</b> <a href="index__set_8h_source.html#l01013">index_set.h:1013</a></div></div>
</div><!-- fragment --><p class="interli">接下来是 <code>vmult</code> 函数。我们以三个连续的步骤来实现上面描述的 \(P^{-1}\) 的动作。 在公式中，我们要计算 \(Y=P^{-1}X\) ，其中 \(X,Y\) 都是有两个块分量的向量。 <br  />
</p>
<p class="interli">第一步用矩阵 \(A\) 的前置条件乘以速度部分，即我们计算 \(Y_0={\tilde A}^{-1}X_0\) 。 然后将得到的速度矢量乘以 \(B\) 并减去压力，即我们要计算 \(X_1-BY_0\) 。这第二步只作用于压力向量，由我们矩阵类的残差函数完成，只是符号不对。因此，我们改变临时压力向量中的符号，最后乘以反压力质量矩阵，得到最终的压力向量，完成我们对斯托克斯预处理的工作。</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div>
<div class="line">  <span class="keywordtype">void</span></div>
<div class="line">  BlockSchurPreconditioner&lt;PreconditionerTypeA, PreconditionerTypeMp&gt;::vmult(</div>
<div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;      dst,</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;src)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    a_preconditioner.vmult(dst.<a class="code" href="group__Exceptions.html#gae05a0e26814f032473ed2ef66da018bd">block</a>(0), src.<a class="code" href="group__Exceptions.html#gae05a0e26814f032473ed2ef66da018bd">block</a>(0));</div>
<div class="line">    stokes_matrix-&gt;block(1, 0).residual(tmp, dst.<a class="code" href="group__Exceptions.html#gae05a0e26814f032473ed2ef66da018bd">block</a>(0), src.<a class="code" href="group__Exceptions.html#gae05a0e26814f032473ed2ef66da018bd">block</a>(1));</div>
<div class="line">    tmp *= -1;</div>
<div class="line">    m_inverse-&gt;vmult(dst.<a class="code" href="group__Exceptions.html#gae05a0e26814f032473ed2ef66da018bd">block</a>(1), tmp);</div>
<div class="line">  }</div>
<div class="line">} <span class="comment">// namespace LinearSolvers</span></div>
<div class="ttc" id="agroup__Exceptions_html_gae05a0e26814f032473ed2ef66da018bd"><div class="ttname"><a href="group__Exceptions.html#gae05a0e26814f032473ed2ef66da018bd">BlockVectorBase::block</a></div><div class="ttdeci">BlockType &amp; block(const unsigned int i)</div></div>
</div><!-- fragment --><p class="interli"><a class="anchor" id="ThecodeBoussinesqFlowProblemcodeclasstemplate"></a></p><h3>The <code>BoussinesqFlowProblem</code> class template</h3>
<p class="interli"></p>
<p class="interli">定义解决随时间变化的Boussinesq问题的顶层逻辑的类，主要是基于 <a class="el" href="step_22.html">step-22</a> 的教程程序。主要区别在于，现在我们还必须求解温度方程，这迫使我们为温度变量以及当前和之前的时间步骤的矩阵、右手边和求解向量设置第二个DoFHandler对象。正如介绍中提到的，所有的线性代数对象都将使用相应的Trilinos功能的包装器。 <br  />
</p>
<p class="interli">这个类的成员函数让人想起 <a class="el" href="step_21.html">step-21</a> ，在那里我们也使用了一个交错的方案，首先解决流动方程（这里是斯托克斯方程，在 <a class="el" href="step_21.html">step-21</a> 中是达西流动），然后更新平流量（这里是温度，那里是饱和度）。新的函数主要涉及到确定时间步长，以及人工粘性稳定的适当大小。 <br  />
</p>
<p class="interli">最后三个变量表示在下一次调用相应的建立函数时，是否需要重新建立各种矩阵或预处理程序。这使得我们可以将相应的 <code>if</code> 移到相应的函数中，从而保持我们的主 <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> 函数的简洁和易读。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>BoussinesqFlowProblem</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  BoussinesqFlowProblem();</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">void</span>   setup_dofs();</div>
<div class="line">  <span class="keywordtype">void</span>   assemble_stokes_preconditioner();</div>
<div class="line">  <span class="keywordtype">void</span>   build_stokes_preconditioner();</div>
<div class="line">  <span class="keywordtype">void</span>   assemble_stokes_system();</div>
<div class="line">  <span class="keywordtype">void</span>   assemble_temperature_system(<span class="keyword">const</span> <span class="keywordtype">double</span> maximal_velocity);</div>
<div class="line">  <span class="keywordtype">void</span>   assemble_temperature_matrix();</div>
<div class="line">  <span class="keywordtype">double</span> get_maximal_velocity() <span class="keyword">const</span>;</div>
<div class="line">  std::pair&lt;double, double&gt; get_extrapolated_temperature_range() <span class="keyword">const</span>;</div>
<div class="line">  <span class="keywordtype">void</span>                      solve();</div>
<div class="line">  <span class="keywordtype">void</span>                      output_results() <span class="keyword">const</span>;</div>
<div class="line">  <span class="keywordtype">void</span>                      refine_mesh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_grid_level);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">double</span> compute_viscosity(</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_temperature,</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_temperature,</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_temperature_grads,</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_temperature_grads,</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_temperature_laplacians,</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_temperature_laplacians,</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_velocity_values,</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_velocity_values,</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        gamma_values,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_u_infty,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_T_variation,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                       cell_diameter) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div>
<div class="line">  <span class="keywordtype">double</span>             global_Omega_diameter;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        stokes_degree;</div>
<div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>             stokes_fe;</div>
<div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           stokes_dof_handler;</div>
<div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> stokes_constraints;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  std::vector&lt;IndexSet&gt;               stokes_partitioning;</div>
<div class="line">  <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> stokes_matrix;</div>
<div class="line">  <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> stokes_preconditioner_matrix;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> stokes_solution;</div>
<div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> old_stokes_solution;</div>
<div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> stokes_rhs;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        temperature_degree;</div>
<div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>                 temperature_fe;</div>
<div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           temperature_dof_handler;</div>
<div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> temperature_constraints;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a> temperature_mass_matrix;</div>
<div class="line">  <a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a> temperature_stiffness_matrix;</div>
<div class="line">  <a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a> temperature_matrix;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> temperature_solution;</div>
<div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_temperature_solution;</div>
<div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_old_temperature_solution;</div>
<div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> temperature_rhs;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">double</span>       time_step;</div>
<div class="line">  <span class="keywordtype">double</span>       old_time_step;</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  std::shared_ptr&lt;TrilinosWrappers::PreconditionAMG&gt; Amg_preconditioner;</div>
<div class="line">  std::shared_ptr&lt;TrilinosWrappers::PreconditionIC&gt;  Mp_preconditioner;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">bool</span> rebuild_stokes_matrix;</div>
<div class="line">  <span class="keywordtype">bool</span> rebuild_temperature_matrices;</div>
<div class="line">  <span class="keywordtype">bool</span> rebuild_stokes_preconditioner;</div>
<div class="line">};</div>
<div class="ttc" id="aclassAffineConstraints_html"><div class="ttname"><a href="classAffineConstraints.html">AffineConstraints&lt; double &gt;</a></div></div>
<div class="ttc" id="aclassDoFHandler_html"><div class="ttname"><a href="classDoFHandler.html">DoFHandler</a></div><div class="ttdef"><b>Definition:</b> <a href="dofs_2dof__handler_8h_source.html#l00314">dof_handler.h:315</a></div></div>
<div class="ttc" id="aclassFESystem_html"><div class="ttname"><a href="classFESystem.html">FESystem</a></div><div class="ttdef"><b>Definition:</b> <a href="fe__system_8h_source.html#l00215">fe_system.h:216</a></div></div>
<div class="ttc" id="aclassFE__Q_html"><div class="ttname"><a href="classFE__Q.html">FE_Q</a></div><div class="ttdef"><b>Definition:</b> <a href="fe__q_8h_source.html#l00548">fe_q.h:549</a></div></div>
<div class="ttc" id="aclassTensor_html"><div class="ttname"><a href="classTensor.html">Tensor&lt; 1, dim &gt;</a></div></div>
<div class="ttc" id="aclassTriangulation_html"><div class="ttname"><a href="classTriangulation.html">Triangulation</a></div><div class="ttdef"><b>Definition:</b> <a href="grid_2tria_8h_source.html#l01127">tria.h:1128</a></div></div>
<div class="ttc" id="anamespaceWorkStream_1_1internal_1_1tbb__no__coloring_html_a8673698a405bf47aa24002aeb6d76d70"><div class="ttname"><a href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">WorkStream::internal::tbb_no_coloring::run</a></div><div class="ttdeci">void run(const Iterator &amp;begin, const typename identity&lt; Iterator &gt;::type &amp;end, Worker worker, Copier copier, const ScratchData &amp;sample_scratch_data, const CopyData &amp;sample_copy_data, const unsigned int queue_length, const unsigned int chunk_size)</div><div class="ttdef"><b>Definition:</b> <a href="work__stream_8h_source.html#l00691">work_stream.h:691</a></div></div>
<div class="ttc" id="ap4est__wrappers_8cc_html_ace00f2f80d9780ef9aa1007e1c22c6a4"><div class="ttname"><a href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a></div><div class="ttdeci">const ::parallel::distributed::Triangulation&lt; dim, spacedim &gt; * triangulation</div><div class="ttdef"><b>Definition:</b> <a href="p4est__wrappers_8cc_source.html#l00069">p4est_wrappers.cc:69</a></div></div>
</div><!-- fragment --><p class="interli"><a class="anchor" id="BoussinesqFlowProblemclassimplementation"></a> </p><h3>BoussinesqFlowProblem class implementation</h3>
<p class="interli"></p>
<p class="interli"><a class="anchor" id="BoussinesqFlowProblemBoussinesqFlowProblem"></a> </p><h4>BoussinesqFlowProblem::BoussinesqFlowProblem</h4>
<p class="interli"><br  />
</p>
<p class="interli">这个类的构造函数是 <a class="el" href="step_22.html">step-22</a> 中构造函数的扩展。我们需要添加涉及温度的各种变量。正如介绍中所讨论的，我们将再次使用 \(Q_2\times Q_1\) （Taylor-Hood）元素来表示斯托克斯部分，并使用 \(Q_2\) 元素表示温度。然而，通过使用存储斯托克斯和温度有限元的多项式程度的变量，很容易一致地修改这些元素的程度，以及在它们上使用的所有正交公式的下游。此外，我们还初始化了时间步长，以及矩阵组合和预处理的选项。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">BoussinesqFlowProblem&lt;dim&gt;::BoussinesqFlowProblem()</div>
<div class="line">  : <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::maximum_smoothing)</div>
<div class="line">  , global_Omega_diameter(std::numeric_limits&lt;<a class="code" href="classdouble.html">double</a>&gt;::quiet_NaN())</div>
<div class="line">  , stokes_degree(1)</div>
<div class="line">  , stokes_fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(stokes_degree + 1), dim, <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(stokes_degree), 1)</div>
<div class="line">  , stokes_dof_handler(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>)</div>
<div class="line">  ,</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  temperature_degree(2)</div>
<div class="line">  , temperature_fe(temperature_degree)</div>
<div class="line">  , temperature_dof_handler(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>)</div>
<div class="line">  ,</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  time_step(0)</div>
<div class="line">  , old_time_step(0)</div>
<div class="line">  , timestep_number(0)</div>
<div class="line">  , rebuild_stokes_matrix(true)</div>
<div class="line">  , rebuild_temperature_matrices(true)</div>
<div class="line">  , rebuild_stokes_preconditioner(true)</div>
<div class="line">{}</div>
<div class="ttc" id="aclassdouble_html"><div class="ttname"><a href="classdouble.html">double</a></div></div>
</div><!-- fragment --><p class="interli"><a class="anchor" id="BoussinesqFlowProblemget_maximal_velocity"></a> </p><h4>BoussinesqFlowProblem::get_maximal_velocity</h4>
<p class="interli"></p>
<p class="interli">这个类的真正功能是从一个辅助函数开始的，它决定了域内（事实上是正交点）的最大（ \(L_\infty\) ）速度。它是如何工作的，对所有已经达到本教程这一点的人来说应该是比较明显的。请注意，由于我们只对速度感兴趣，我们不使用 <code>stokes_fe_values.get_function_values</code> 来获取整个斯托克斯解的值（速度和压力），而是使用 <code>stokes_fe_values[velocities].get_function_values</code> 来提取速度部分。这有一个额外的好处，即我们得到的是张量&lt;1,dim&gt;，而不是向量&lt;double&gt;中的一些分量，使我们能够立即使用 <code><a class="el" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm()</a></code> 函数处理它，得到速度的大小。 <br  />
</p>
<p class="interli">唯一值得思考的一点是如何选择我们在这里使用的正交点。由于这个函数的目标是通过观察每个单元上的正交点来寻找域上的最大速度。所以我们应该问，我们应该如何最好地选择每个单元上的这些正交点。为此，回顾一下，如果我们有一个单一的 \(Q_1\) 场（而不是高阶的矢量值场），那么最大值将在网格的一个顶点达到。换句话说，我们应该使用QTrapezoid类，它的正交点只在单元的顶点。 <br  />
</p>
<p class="interli">对于高阶形状函数，情况更为复杂：最大值和最小值可能在形状函数的支持点之间的点上达到（对于通常的 \(Q_p\) 元素，支持点是等距的Lagrange插值点）；此外，由于我们正在寻找一个矢量值量的最大幅度，我们更不能肯定地说潜在的最大点集合在哪里。然而，从直觉上讲，如果不能证明，拉格朗日插值点似乎是比高斯点更好的选择。 <br  />
</p>
<p class="interli">现在有不同的方法来产生一个正交公式，其正交点等于有限元的插值点。一种选择是使用 <a class="el" href="classFiniteElement.html#a31950b76dd77043681a605d775b9f885">FiniteElement::get_unit_support_points()</a> 函数，将输出减少到一组唯一的点以避免重复的函数评估，并使用这些点创建一个正交对象。另一个选择，这里选择的是使用QTrapezoid类，并将其与QIterated类相结合，在每个坐标方向的若干子单元上重复QTrapezoid公式。为了覆盖所有的支持点，我们需要将其迭代 <code>stokes_degree+1</code> 次，因为这是使用中的斯托克斯元素的多项式程度。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">double</span> BoussinesqFlowProblem&lt;dim&gt;::get_maximal_velocity()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classQIterated.html">QIterated&lt;dim&gt;</a> quadrature_formula(<a class="code" href="classQTrapezoid.html">QTrapezoid&lt;1&gt;</a>(), stokes_degree + 1);</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points = quadrature_formula.size();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(stokes_fe, quadrature_formula, <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div>
<div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; velocity_values(n_q_points);</div>
<div class="line">  <span class="keywordtype">double</span>                      max_velocity = 0;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : stokes_dof_handler.active_cell_iterators())</div>
<div class="line">    {</div>
<div class="line">      fe_values.reinit(cell);</div>
<div class="line">      fe_values[velocities].get_function_values(stokes_solution,</div>
<div class="line">                                                velocity_values);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div>
<div class="line">        max_velocity = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_velocity, velocity_values[q].<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> max_velocity;</div>
<div class="line">}</div>
<div class="ttc" id="aclassFEValues_html"><div class="ttname"><a href="classFEValues.html">FEValues</a></div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__values_8h_source.html#l03905">fe_values.h:3906</a></div></div>
<div class="ttc" id="aclassQIterated_html"><div class="ttname"><a href="classQIterated.html">QIterated</a></div><div class="ttdef"><b>Definition:</b> <a href="include_2deal_8II_2base_2quadrature_8h_source.html#l00364">quadrature.h:365</a></div></div>
<div class="ttc" id="aclassQTrapezoid_html"><div class="ttname"><a href="classQTrapezoid.html">QTrapezoid</a></div><div class="ttdef"><b>Definition:</b> <a href="quadrature__lib_8h_source.html#l00118">quadrature_lib.h:119</a></div></div>
<div class="ttc" id="afe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea"><div class="ttname"><a href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a></div><div class="ttdeci">@ update_values</div><div class="ttdoc">Shape function values.</div><div class="ttdef"><b>Definition:</b> <a href="fe__update__flags_8h_source.html#l00078">fe_update_flags.h:78</a></div></div>
<div class="ttc" id="anamespaceLocalIntegrators_1_1Divergence_html_a8bcfc37d2a2be8faa18628a601ecf112"><div class="ttname"><a href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">LocalIntegrators::Divergence::norm</a></div><div class="ttdeci">double norm(const FEValuesBase&lt; dim &gt; &amp;fe, const ArrayView&lt; const std::vector&lt; Tensor&lt; 1, dim &gt;&gt;&gt; &amp;Du)</div><div class="ttdef"><b>Definition:</b> <a href="divergence_8h_source.html#l00472">divergence.h:472</a></div></div>
<div class="ttc" id="anamespaceVectorTools_1_1EvaluationFlags_html_ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420"><div class="ttname"><a href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">VectorTools::EvaluationFlags::max</a></div><div class="ttdeci">@ max</div><div class="ttdef"><b>Definition:</b> <a href="vector__tools__evaluate_8h_source.html#l00053">vector_tools_evaluate.h:53</a></div></div>
<div class="ttc" id="astructFEValuesExtractors_1_1Vector_html"><div class="ttname"><a href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a></div><div class="ttdef"><b>Definition:</b> <a href="fe__values__extractors_8h_source.html#l00150">fe_values_extractors.h:151</a></div></div>
</div><!-- fragment --><p class="interli"><a class="anchor" id="BoussinesqFlowProblemget_extrapolated_temperature_range"></a> </p><h4>BoussinesqFlowProblem::get_extrapolated_temperature_range</h4>
<p class="interli"></p>
<p class="interli">接下来是一个函数，确定从前两个时间步长推算到当前步长时， \(\Omega\) 内正交点的最低和最高温度。我们在计算人工粘性参数 \(\nu\) 时需要这个信息，正如介绍中所讨论的那样。 <br  />
</p>
<p class="interli">外推温度的公式是 \(\left(1+\frac{k_n}{k_{n-1}} \right)T^{n-1} + \frac{k_n}{k_{n-1}} T^{n-2}\) 。计算它的方法是在所有正交点上循环，如果当前值比前一个值大/小，则更新最大和最小值。在对所有正交点进行循环之前，我们将存储最大和最小值的变量初始化为最小和最大的可表示为双数的数字。然后我们就知道它比最小/最大值大/小，并且所有正交点的循环最终会用正确的值更新初始值。</p>
<p class="interli">这里唯一值得一提的其他复杂情况是，在第一个时间步骤中， \(T^{k-2}\) 当然还不能使用。在这种情况下，我们只能使用 \(T^{k-1}\) ，这是我们从初始温度得到的。作为正交点，我们使用与前一个函数相同的选择，但不同的是，现在重复的数量由温度场的多项式程度决定。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">std::pair&lt;double, double&gt;</div>
<div class="line">BoussinesqFlowProblem&lt;dim&gt;::get_extrapolated_temperature_range()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classQIterated.html">QIterated&lt;dim&gt;</a> quadrature_formula(<a class="code" href="classQTrapezoid.html">QTrapezoid&lt;1&gt;</a>(),</div>
<div class="line">                                          temperature_degree);</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points = quadrature_formula.size();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(temperature_fe, quadrature_formula, <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div>
<div class="line">  std::vector&lt;double&gt; old_temperature_values(n_q_points);</div>
<div class="line">  std::vector&lt;double&gt; old_old_temperature_values(n_q_points);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (timestep_number != 0)</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordtype">double</span> min_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div>
<div class="line">             max_temperature = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : temperature_dof_handler.active_cell_iterators())</div>
<div class="line">        {</div>
<div class="line">          fe_values.reinit(cell);</div>
<div class="line">          fe_values.get_function_values(old_temperature_solution,</div>
<div class="line">                                        old_temperature_values);</div>
<div class="line">          fe_values.get_function_values(old_old_temperature_solution,</div>
<div class="line">                                        old_old_temperature_values);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div>
<div class="line">            {</div>
<div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> temperature =</div>
<div class="line">                (1. + time_step / old_time_step) * old_temperature_values[q] -</div>
<div class="line">                time_step / old_time_step * old_old_temperature_values[q];</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">              min_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_temperature, temperature);</div>
<div class="line">              max_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_temperature, temperature);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">return</span> std::make_pair(min_temperature, max_temperature);</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keywordtype">double</span> min_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div>
<div class="line">             max_temperature = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : temperature_dof_handler.active_cell_iterators())</div>
<div class="line">        {</div>
<div class="line">          fe_values.reinit(cell);</div>
<div class="line">          fe_values.get_function_values(old_temperature_solution,</div>
<div class="line">                                        old_temperature_values);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div>
<div class="line">            {</div>
<div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> temperature = old_temperature_values[q];</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">              min_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_temperature, temperature);</div>
<div class="line">              max_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_temperature, temperature);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">return</span> std::make_pair(min_temperature, max_temperature);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceVectorTools_1_1EvaluationFlags_html_ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc"><div class="ttname"><a href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">VectorTools::EvaluationFlags::min</a></div><div class="ttdeci">@ min</div><div class="ttdef"><b>Definition:</b> <a href="vector__tools__evaluate_8h_source.html#l00059">vector_tools_evaluate.h:59</a></div></div>
</div><!-- fragment --><p class="interli"><a class="anchor" id="BoussinesqFlowProblemcompute_viscosity"></a></p><h4>BoussinesqFlowProblem::compute_viscosity</h4>
<p class="interli"></p>
<p class="interli">最后一个工具函数计算单元 \(\nu|_K\) 上的人工粘性参数 \(K\) ，作为外推温度、其梯度和Hessian（二阶导数）、速度、右手 \(\gamma\) 都在当前单元的正交点上的函数，以及在介绍中详细描述的各种其他参数。 <br  />
</p>
<p class="interli">这里有一些值得一提的通用常数。首先，我们需要固定 \(\beta\) ；我们选择 \(\beta=0.017\cdot dim\) ，这个选择在本教程程序的结果部分有详细讨论。其次是指数 \(\alpha\) ； \(\alpha=1\) 似乎对目前的程序来说工作正常，尽管选择 \(\alpha = 2\) 可能会有一些额外的好处。最后，有一件事需要特别说明。在第一个时间步骤中，速度等于零， \(\nu|_K\) 的公式没有定义。在这种情况下，我们返回 \(\nu|_K=5\cdot 10^3 \cdot h_K\) ，这个选择无疑更多的是出于启发式的考虑（不过，它与第二个时间步骤中大多数单元的返回值处于同一数量级）。</p>
<p class="interli">根据介绍中讨论的材料，该函数的其余部分应该是很明显的。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">double</span> BoussinesqFlowProblem&lt;dim&gt;::compute_viscosity(</div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_temperature,</div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_temperature,</div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_temperature_grads,</div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_temperature_grads,</div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_temperature_laplacians,</div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_temperature_laplacians,</div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_velocity_values,</div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_velocity_values,</div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        gamma_values,</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_u_infty,</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_T_variation,</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                       cell_diameter)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  constexpr <span class="keywordtype">double</span> beta  = 0.017 * dim;</div>
<div class="line">  constexpr <span class="keywordtype">double</span> alpha = 1.0;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (global_u_infty == 0)</div>
<div class="line">    <span class="keywordflow">return</span> 5<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-3 * cell_diameter;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = old_temperature.size();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">double</span> max_residual = 0;</div>
<div class="line">  <span class="keywordtype">double</span> max_velocity = 0;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> u =</div>
<div class="line">        (old_velocity_values[q] + old_old_velocity_values[q]) / 2;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> dT_dt =</div>
<div class="line">        (old_temperature[q] - old_old_temperature[q]) / old_time_step;</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> u_grad_T =</div>
<div class="line">        u * (old_temperature_grads[q] + old_old_temperature_grads[q]) / 2;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> kappa_Delta_T =</div>
<div class="line">        EquationData::kappa *</div>
<div class="line">        (old_temperature_laplacians[q] + old_old_temperature_laplacians[q]) /</div>
<div class="line">        2;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> residual =</div>
<div class="line">        <a class="code" href="numbers_8h.html#a0ebae11c64606a73e80a6328b1ab0802">std::abs</a>((dT_dt + u_grad_T - kappa_Delta_T - gamma_values[q]) *</div>
<div class="line">                 std::pow((old_temperature[q] + old_old_temperature[q]) / 2,</div>
<div class="line">                          alpha - 1.));</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">      max_residual = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(residual, max_residual);</div>
<div class="line">      max_velocity = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(std::sqrt(u * u), max_velocity);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> c_R            = <a class="code" href="numbers_8h.html#af44aee1db5cdcd0bab54e3c011d2be66">std::pow</a>(2., (4. - 2 * alpha) / dim);</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> global_scaling = c_R * global_u_infty * global_T_variation *</div>
<div class="line">                                <a class="code" href="numbers_8h.html#af44aee1db5cdcd0bab54e3c011d2be66">std::pow</a>(global_Omega_diameter, alpha - 2.);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> (</div>
<div class="line">    beta * max_velocity *</div>
<div class="line">    <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(cell_diameter,</div>
<div class="line">             std::pow(cell_diameter, alpha) * max_residual / global_scaling));</div>
<div class="line">}</div>
<div class="ttc" id="anumbers_8h_html_a0ebae11c64606a73e80a6328b1ab0802"><div class="ttname"><a href="numbers_8h.html#a0ebae11c64606a73e80a6328b1ab0802">std::abs</a></div><div class="ttdeci">::VectorizedArray&lt; Number, width &gt; abs(const ::VectorizedArray&lt; Number, width &gt; &amp;)</div><div class="ttdef"><b>Definition:</b> <a href="vectorization_8h_source.html#l05444">vectorization.h:5444</a></div></div>
<div class="ttc" id="anumbers_8h_html_af44aee1db5cdcd0bab54e3c011d2be66"><div class="ttname"><a href="numbers_8h.html#af44aee1db5cdcd0bab54e3c011d2be66">std::pow</a></div><div class="ttdeci">::VectorizedArray&lt; Number, width &gt; pow(const ::VectorizedArray&lt; Number, width &gt; &amp;, const Number p)</div><div class="ttdef"><b>Definition:</b> <a href="vectorization_8h_source.html#l05422">vectorization.h:5422</a></div></div>
</div><!-- fragment --><p class="interli"><a class="anchor" id="BoussinesqFlowProblemsetup_dofs"></a> </p><h4>BoussinesqFlowProblem::setup_dofs</h4>
<p class="interli"><br  />
</p>
<p class="interli">这个函数设置了我们这里的DoFHandler对象（一个用于斯托克斯部分，一个用于温度部分），以及将本程序中线性代数所需的各种对象设置为正确的尺寸。它的基本操作与我们在 <a class="el" href="step_22.html">step-22</a> 中的操作相似。 <br  />
</p>
<p class="interli">该函数的主体首先列举了斯托克斯和温度系统的所有自由度。对于斯托克斯部分，自由度被排序以确保速度优先于压力自由度，这样我们就可以将斯托克斯矩阵划分为一个 \(2\times 2\) 矩阵。作为与 <a class="el" href="step_22.html">step-22</a> 的区别，我们不进行任何额外的DoF重新编号。在那个程序中，它得到了回报，因为我们的求解器严重依赖ILU，而我们在这里使用AMG，它对DoF编号不敏感。用于反演压力质量矩阵的IC预处理程序当然会利用类似Cuthill-McKee的重新编号，但与速度部分相比，其成本很低，所以额外的工作并没有得到回报。 <br  />
</p>
<p class="interli">然后，我们继续生成悬挂节点约束，这些约束来自于两个DoFHandler对象的自适应网格细化。对于速度，我们通过向已经存储了悬挂节点约束矩阵的对象添加约束条件，施加无流边界条件 \(\mathbf{u}\cdot \mathbf{n}=0\) 。函数中的第二个参数描述了总dof向量中的第一个速度分量，这里是零。变量 <code>no_normal_flux_boundaries</code> 表示要设置无通量边界条件的边界指标；这里是边界指标0。</p>
<p class="interli">做完这些后，我们计算各块的自由度数量。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::setup_dofs()</div>
<div class="line">{</div>
<div class="line">  std::vector&lt;unsigned int&gt; stokes_sub_blocks(dim + 1, 0);</div>
<div class="line">  stokes_sub_blocks[dim] = 1;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  {</div>
<div class="line">    stokes_dof_handler.distribute_dofs(stokes_fe);</div>
<div class="line">    <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(stokes_dof_handler, stokes_sub_blocks);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    stokes_constraints.clear();</div>
<div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(stokes_dof_handler,</div>
<div class="line">                                            stokes_constraints);</div>
<div class="line">    std::set&lt;types::boundary_id&gt; no_normal_flux_boundaries;</div>
<div class="line">    no_normal_flux_boundaries.insert(0);</div>
<div class="line">    <a class="code" href="group__constraints.html#ga0d16c332aaa652e8905a6f48208e4500">VectorTools::compute_no_normal_flux_constraints</a>(stokes_dof_handler,</div>
<div class="line">                                                    0,</div>
<div class="line">                                                    no_normal_flux_boundaries,</div>
<div class="line">                                                    stokes_constraints);</div>
<div class="line">    stokes_constraints.close();</div>
<div class="line">  }</div>
<div class="line">  {</div>
<div class="line">    temperature_dof_handler.distribute_dofs(temperature_fe);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    temperature_constraints.clear();</div>
<div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(temperature_dof_handler,</div>
<div class="line">                                            temperature_constraints);</div>
<div class="line">    temperature_constraints.close();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; stokes_dofs_per_block =</div>
<div class="line">    <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(stokes_dof_handler, stokes_sub_blocks);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = stokes_dofs_per_block[0],</div>
<div class="line">                     n_p = stokes_dofs_per_block[1],</div>
<div class="line">                     n_T = temperature_dof_handler.n_dofs();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.n_active_cells()</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot; (on &quot;</span> &lt;&lt; <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.n_levels() &lt;&lt; <span class="stringliteral">&quot; levels)&quot;</span> &lt;&lt; std::endl</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; n_u + n_p + n_T &lt;&lt; <span class="stringliteral">&quot; (&quot;</span></div>
<div class="line">            &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_T &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl</div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="ttc" id="agroup__constraints_html_ga0d16c332aaa652e8905a6f48208e4500"><div class="ttname"><a href="group__constraints.html#ga0d16c332aaa652e8905a6f48208e4500">VectorTools::compute_no_normal_flux_constraints</a></div><div class="ttdeci">void compute_no_normal_flux_constraints(const DoFHandler&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned int first_vector_component, const std::set&lt; types::boundary_id &gt; &amp;boundary_ids, AffineConstraints&lt; double &gt; &amp;constraints, const Mapping&lt; dim, spacedim &gt; &amp;mapping=(ReferenceCells::get_hypercube&lt; dim &gt;() .template get_default_linear_mapping&lt; dim, spacedim &gt;()))</div></div>
<div class="ttc" id="agroup__constraints_html_ga3b4ea7dfd313e388d868c4e4aa685799"><div class="ttname"><a href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a></div><div class="ttdeci">void make_hanging_node_constraints(const DoFHandler&lt; dim, spacedim &gt; &amp;dof_handler, AffineConstraints&lt; number &gt; &amp;constraints)</div><div class="ttdef"><b>Definition:</b> <a href="dof__tools__constraints_8cc_source.html#l01787">dof_tools_constraints.cc:1787</a></div></div>
<div class="ttc" id="anamespaceDoFRenumbering_html_a52c1941406d1ce2937e29a46edf111f4"><div class="ttname"><a href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a></div><div class="ttdeci">void component_wise(DoFHandler&lt; dim, spacedim &gt; &amp;dof_handler, const std::vector&lt; unsigned int &gt; &amp;target_component=std::vector&lt; unsigned int &gt;())</div><div class="ttdef"><b>Definition:</b> <a href="dof__renumbering_8cc_source.html#l00681">dof_renumbering.cc:681</a></div></div>
<div class="ttc" id="anamespaceDoFTools_html_a796721b56b3a90e4e3973c7caae4c3d8"><div class="ttname"><a href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a></div><div class="ttdeci">std::vector&lt; types::global_dof_index &gt; count_dofs_per_fe_block(const DoFHandler&lt; dim, spacedim &gt; &amp;dof, const std::vector&lt; unsigned int &gt; &amp;target_block=std::vector&lt; unsigned int &gt;())</div><div class="ttdef"><b>Definition:</b> <a href="dof__tools_8cc_source.html#l02047">dof_tools.cc:2047</a></div></div>
</div><!-- fragment --><p class="interli">下一步是建立斯托克斯和温度系统矩阵的稀疏模式，以及我们建立斯托克斯预处理矩阵的预处理。与 <a class="el" href="step_22.html">step-22</a> 一样，我们选择使用DynamicSparsityPattern的封锁版本来创建模式。 <br  />
</p>
<p class="interli">因此，我们首先释放存储在矩阵中的内存，然后建立一个BlockDynamicSparsityPattern类型的对象，该对象由 \(2\times 2\) 块（用于斯托克斯系统矩阵和前置条件器）或DynamicSparsityPattern（用于温度部分）组成。然后我们用非零模式填充这些对象，考虑到对于斯托克斯系统矩阵，在压力-压力块中没有条目（但所有速度矢量分量相互耦合并与压力耦合）。同样，在斯托克斯预处理矩阵中，只有对角线块是非零的，因为我们使用了介绍中讨论的矢量拉普拉斯。这个算子只把拉普拉斯的每个矢量分量与它自己联系起来，而不是与其他矢量分量联系起来。然而，应用由无流边界条件产生的约束条件将在边界处再次耦合矢量分量）。 <br  />
</p>
<p class="interli">在生成稀疏模式时，我们直接应用悬挂节点和无流边界条件的约束。这种方法在 <a class="el" href="step_27.html">step-27</a> 中已经使用过了，但与早期教程中的方法不同，在早期教程中，我们首先建立原始的稀疏模式，然后才添加约束条件产生的条目。这样做的原因是，在以后的装配过程中，我们要在将本地道夫转移到全局道夫时立即分配约束。因此，在受限自由度的位置不会有数据写入，所以我们可以通过设置最后一个布尔标志为 <code>false</code> 来让 <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a> 函数省略这些条目。一旦疏散模式准备好了，我们就可以用它来初始化特里诺斯矩阵。由于Trilinos矩阵在内部存储了稀疏模式，因此在初始化矩阵之后，没有必要再保留稀疏模式。</p>
<div class="fragment"><div class="line">stokes_partitioning.resize(2);</div>
<div class="line">stokes_partitioning[0] = <a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(n_u);</div>
<div class="line">stokes_partitioning[1] = <a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(n_p);</div>
<div class="line">{</div>
<div class="line">  stokes_matrix.clear();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(2, 2);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  dsp.block(0, 0).reinit(n_u, n_u);</div>
<div class="line">  dsp.block(0, 1).reinit(n_u, n_p);</div>
<div class="line">  dsp.block(1, 0).reinit(n_p, n_u);</div>
<div class="line">  dsp.block(1, 1).reinit(n_p, n_p);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  dsp.collect_sizes();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div>
<div class="line">      <span class="keywordflow">if</span> (!((c == dim) &amp;&amp; (<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> == dim)))</div>
<div class="line">        coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">        coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div>
<div class="line">    stokes_dof_handler, coupling, dsp, stokes_constraints, <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  stokes_matrix.reinit(dsp);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">{</div>
<div class="line">  Amg_preconditioner.reset();</div>
<div class="line">  Mp_preconditioner.reset();</div>
<div class="line">  stokes_preconditioner_matrix.clear();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(2, 2);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  dsp.block(0, 0).reinit(n_u, n_u);</div>
<div class="line">  dsp.block(0, 1).reinit(n_u, n_p);</div>
<div class="line">  dsp.block(1, 0).reinit(n_p, n_u);</div>
<div class="line">  dsp.block(1, 1).reinit(n_p, n_p);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  dsp.collect_sizes();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div>
<div class="line">      <span class="keywordflow">if</span> (c == <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div>
<div class="line">        coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">        coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div>
<div class="line">    stokes_dof_handler, coupling, dsp, stokes_constraints, <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  stokes_preconditioner_matrix.reinit(dsp);</div>
<div class="line">}</div>
<div class="ttc" id="aclassBlockDynamicSparsityPattern_html"><div class="ttname"><a href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a></div><div class="ttdef"><b>Definition:</b> <a href="block__sparsity__pattern_8h_source.html#l00524">block_sparsity_pattern.h:526</a></div></div>
<div class="ttc" id="aclassTable_html"><div class="ttname"><a href="classTable.html">Table</a></div><div class="ttdef"><b>Definition:</b> <a href="table_8h_source.html#l00666">table.h:667</a></div></div>
<div class="ttc" id="agroup__constraints_html_gaf78e864edbfba7e0a7477457bfb96b26"><div class="ttname"><a href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a></div><div class="ttdeci">void make_sparsity_pattern(const DoFHandler&lt; dim, spacedim &gt; &amp;dof_handler, SparsityPatternType &amp;sparsity_pattern, const AffineConstraints&lt; number &gt; &amp;constraints=AffineConstraints&lt; number &gt;(), const bool keep_constrained_dofs=true, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id)</div><div class="ttdef"><b>Definition:</b> <a href="dof__tools__sparsity_8cc_source.html#l00064">dof_tools_sparsity.cc:64</a></div></div>
<div class="ttc" id="anamespaceDoFTools_html_ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba"><div class="ttname"><a href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a></div><div class="ttdeci">@ none</div><div class="ttdef"><b>Definition:</b> <a href="dof__tools_8h_source.html#l00231">dof_tools.h:231</a></div></div>
<div class="ttc" id="anamespaceDoFTools_html_ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec"><div class="ttname"><a href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a></div><div class="ttdeci">@ always</div><div class="ttdef"><b>Definition:</b> <a href="dof__tools_8h_source.html#l00235">dof_tools.h:235</a></div></div>
<div class="ttc" id="anamespacePhysics_1_1Elasticity_1_1Kinematics_html_a15728437b942dab0b0042eb06a407d2c"><div class="ttname"><a href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">Physics::Elasticity::Kinematics::d</a></div><div class="ttdeci">SymmetricTensor&lt; 2, dim, Number &gt; d(const Tensor&lt; 2, dim, Number &gt; &amp;F, const Tensor&lt; 2, dim, Number &gt; &amp;dF_dt)</div></div>
</div><!-- fragment --><p class="interli">温度矩阵（或者说，矩阵，因为我们提供了一个温度质量矩阵和一个温度刚度矩阵，它们将在时间离散化中被加在一起）的创建与斯托克斯矩阵的生成相同；只是在这里要容易得多，因为我们不需要照顾任何块或组件之间的耦合。注意我们是如何初始化三个温度矩阵的。我们只使用稀疏模式对第一个矩阵进行再初始化，而对其余两个再初始化则使用先前生成的矩阵。这样做的原因是，从一个已经生成的矩阵进行重新初始化，可以让Trilinos重新使用稀疏模式，而不是为每个副本生成一个新的模式。这可以节省一些时间和内存。</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  temperature_mass_matrix.clear();</div>
<div class="line">  temperature_stiffness_matrix.clear();</div>
<div class="line">  temperature_matrix.clear();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(n_T, n_T);</div>
<div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(temperature_dof_handler,</div>
<div class="line">                                  dsp,</div>
<div class="line">                                  temperature_constraints,</div>
<div class="line">                                  <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  temperature_matrix.reinit(dsp);</div>
<div class="line">  temperature_mass_matrix.reinit(temperature_matrix);</div>
<div class="line">  temperature_stiffness_matrix.reinit(temperature_matrix);</div>
<div class="line">}</div>
<div class="ttc" id="aclassDynamicSparsityPattern_html"><div class="ttname"><a href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a></div><div class="ttdef"><b>Definition:</b> <a href="dynamic__sparsity__pattern_8h_source.html#l00318">dynamic_sparsity_pattern.h:319</a></div></div>
</div><!-- fragment --><p class="interli">最后，我们为斯托克斯解 \(\mathbf u^{n-1}\) 和 \(\mathbf u^{n-2}\) ，以及温度 \(T^{n}\) 、 \(T^{n-1}\) 和 \(T^{n-2}\) （时间步进所需）和所有系统的右手边设置了正确的大小和块结构。</p>
<div class="fragment"><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> temperature_partitioning = <a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(n_T);</div>
<div class="line">  stokes_solution.reinit(stokes_partitioning, MPI_COMM_WORLD);</div>
<div class="line">  old_stokes_solution.reinit(stokes_partitioning, MPI_COMM_WORLD);</div>
<div class="line">  stokes_rhs.reinit(stokes_partitioning, MPI_COMM_WORLD);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  temperature_solution.reinit(temperature_partitioning, MPI_COMM_WORLD);</div>
<div class="line">  old_temperature_solution.reinit(temperature_partitioning, MPI_COMM_WORLD);</div>
<div class="line">  old_old_temperature_solution.reinit(temperature_partitioning,</div>
<div class="line">                                      MPI_COMM_WORLD);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  temperature_rhs.reinit(temperature_partitioning, MPI_COMM_WORLD);</div>
<div class="line">}</div>
<div class="ttc" id="aclassIndexSet_html"><div class="ttname"><a href="classIndexSet.html">IndexSet</a></div><div class="ttdef"><b>Definition:</b> <a href="index__set_8h_source.html#l00072">index_set.h:73</a></div></div>
</div><!-- fragment --><p class="interli"><a class="anchor" id="BoussinesqFlowProblemassemble_stokes_preconditioner"></a> </p><h4>BoussinesqFlowProblem::assemble_stokes_preconditioner</h4>
<p class="interli"><br  />
</p>
<p class="interli">这个函数组装了我们用于预处理斯托克斯系统的矩阵。我们需要的是速度分量上的矢量拉普拉斯矩阵和压力分量上的质量矩阵加权 \(\eta^{-1}\) 。我们首先生成一个适当阶数的正交对象，即FEValues对象，它可以给出正交点的值和梯度（连同正交权重）。接下来我们为单元格矩阵和局部与全局DoF之间的关系创建数据结构。向量 <code>grad_phi_u</code> and <code>phi_p</code> 将保存基函数的值，以便更快地建立局部矩阵，正如在 <a class="el" href="step_22.html">step-22</a> 中已经完成的那样。在我们开始对所有活动单元进行循环之前，我们必须指定哪些成分是压力，哪些是速度。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_stokes_preconditioner()</div>
<div class="line">{</div>
<div class="line">  stokes_preconditioner_matrix = 0;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(stokes_degree + 2);</div>
<div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     stokes_fe_values(stokes_fe,</div>
<div class="line">                                 quadrature_formula,</div>
<div class="line">                                 <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div>
<div class="line">                                   <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = stokes_fe.n_dofs_per_cell();</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.size();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div>
<div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  std::vector&lt;Tensor&lt;2, dim&gt;&gt; grad_phi_u(dofs_per_cell);</div>
<div class="line">  std::vector&lt;double&gt;         phi_p(dofs_per_cell);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : stokes_dof_handler.active_cell_iterators())</div>
<div class="line">    {</div>
<div class="line">      stokes_fe_values.reinit(cell);</div>
<div class="line">      local_matrix = 0;</div>
<div class="ttc" id="aclassFullMatrix_html"><div class="ttname"><a href="classFullMatrix.html">FullMatrix&lt; double &gt;</a></div></div>
<div class="ttc" id="aclassQGauss_html"><div class="ttname"><a href="classQGauss.html">QGauss</a></div><div class="ttdef"><b>Definition:</b> <a href="quadrature__lib_8h_source.html#l00038">quadrature_lib.h:39</a></div></div>
<div class="ttc" id="afe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85"><div class="ttname"><a href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a></div><div class="ttdeci">@ update_JxW_values</div><div class="ttdoc">Transformed quadrature weights.</div><div class="ttdef"><b>Definition:</b> <a href="fe__update__flags_8h_source.html#l00129">fe_update_flags.h:129</a></div></div>
<div class="ttc" id="afe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20"><div class="ttname"><a href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a></div><div class="ttdeci">@ update_gradients</div><div class="ttdoc">Shape function gradients.</div><div class="ttdef"><b>Definition:</b> <a href="fe__update__flags_8h_source.html#l00084">fe_update_flags.h:84</a></div></div>
<div class="ttc" id="astructFEValuesExtractors_1_1Scalar_html"><div class="ttname"><a href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="ttdef"><b>Definition:</b> <a href="fe__values__extractors_8h_source.html#l00095">fe_values_extractors.h:96</a></div></div>
</div><!-- fragment --><p class="interli">本地矩阵的建立相当简单。只有一个拉普拉斯项（关于速度）和一个由 \(\eta^{-1}\) 加权的质量矩阵需要生成，所以本地矩阵的创建在两行中完成。一旦本地矩阵准备好了（在每个正交点上循环查看本地矩阵的行和列），我们就可以得到本地DoF指数，并将本地信息写入全局矩阵。我们像在 <a class="el" href="step_27.html">step-27</a> 中那样做，也就是说，我们直接应用本地悬挂节点的约束。这样做，我们就不必事后再做，也不会在消除约束时把实际上会再次设置为零的条目写进矩阵中。</p>
<div class="fragment"><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div>
<div class="line">        {</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div>
<div class="line">            {</div>
<div class="line">              grad_phi_u[k] = stokes_fe_values[velocities].gradient(k, q);</div>
<div class="line">              phi_p[k]      = stokes_fe_values[pressure].value(k, q);</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div>
<div class="line">              local_matrix(i, j) +=</div>
<div class="line">                (EquationData::eta *</div>
<div class="line">                   <a class="code" href="classSymmetricTensor.html#ab14ac27fc9ab74d4de531698b492d8de">scalar_product</a>(grad_phi_u[i], grad_phi_u[j]) +</div>
<div class="line">                 (1. / EquationData::eta) * phi_p[i] * phi_p[j]) *</div>
<div class="line">                stokes_fe_values.JxW(q);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div>
<div class="line">      stokes_constraints.distribute_local_to_global(</div>
<div class="line">        local_matrix, local_dof_indices, stokes_preconditioner_matrix);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclassSymmetricTensor_html_ab14ac27fc9ab74d4de531698b492d8de"><div class="ttname"><a href="classSymmetricTensor.html#ab14ac27fc9ab74d4de531698b492d8de">SymmetricTensor::scalar_product</a></div><div class="ttdeci">constexpr ProductType&lt; Number, OtherNumber &gt;::type scalar_product(const SymmetricTensor&lt; 2, dim, Number &gt; &amp;t1, const SymmetricTensor&lt; 2, dim, OtherNumber &gt; &amp;t2)</div><div class="ttdef"><b>Definition:</b> <a href="symmetric__tensor_8h_source.html#l03693">symmetric_tensor.h:3693</a></div></div>
</div><!-- fragment --><p class="interli"><a class="anchor" id="BoussinesqFlowProblembuild_stokes_preconditioner"></a></p><h4>BoussinesqFlowProblem::build_stokes_preconditioner</h4>
<p class="interli"><br  />
</p>
<p class="interli">这个函数生成将用于Schur互补块状预处理的内部预处理。由于只有当矩阵发生变化时才需要重新生成预处理程序，因此在矩阵没有变化的情况下，该函数不需要做任何事情（即标志 <code>rebuild_stokes_preconditioner</code> 的值为 <code>false</code> ）。否则它的第一个任务是调用 <code>assemble_stokes_preconditioner</code> 来生成预处理矩阵。 <br  />
</p>
<p class="interli">接下来，我们为速度-速度矩阵 \(A\) 设置预处理器。正如介绍中所解释的，我们将使用基于矢量拉普拉斯矩阵 \(\hat{A}\) 的AMG预处理器（它在频谱上与斯托克斯矩阵 \(A\) 接近）。通常， <a class="el" href="classTrilinosWrappers_1_1PreconditionAMG.html">TrilinosWrappers::PreconditionAMG</a> 类可以被看作是一个好的黑箱预处理器，不需要任何特殊的知识。然而，在这种情况下，我们必须小心：由于我们为一个矢量问题建立了一个AMG，我们必须告诉预处理程序设置哪些道夫属于哪个矢量分量。我们使用函数 <a class="el" href="namespaceDoFTools.html#afc96893388fe1a55c6ae5ae19ba52c6d">DoFTools::extract_constant_modes</a>, 来做这件事，该函数生成一组 <code>dim</code> 向量，其中每个向量在向量问题的相应分量中为1，在其他地方为0。因此，这些是每个分量上的常数模式，这解释了变量的名称。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::build_stokes_preconditioner()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (rebuild_stokes_preconditioner == <span class="keyword">false</span>)</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Rebuilding Stokes preconditioner...&quot;</span> &lt;&lt; std::flush;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  assemble_stokes_preconditioner();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  Amg_preconditioner = std::make_shared&lt;TrilinosWrappers::PreconditionAMG&gt;();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  std::vector&lt;std::vector&lt;bool&gt;&gt; constant_modes;</div>
<div class="line">  <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a>     velocity_components(0);</div>
<div class="line">  <a class="code" href="namespaceDoFTools.html#afc96893388fe1a55c6ae5ae19ba52c6d">DoFTools::extract_constant_modes</a>(stokes_dof_handler,</div>
<div class="line">                                   stokes_fe.component_mask(</div>
<div class="line">                                     velocity_components),</div>
<div class="line">                                   constant_modes);</div>
<div class="line">  <a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html">TrilinosWrappers::PreconditionAMG::AdditionalData</a> amg_data;</div>
<div class="line">  amg_data.<a class="code" href="group__TrilinosWrappers.html#ga133c7bf7e618aaab51cd84214b731532">constant_modes</a> = constant_modes;</div>
<div class="ttc" id="agroup__TrilinosWrappers_html_ga133c7bf7e618aaab51cd84214b731532"><div class="ttname"><a href="group__TrilinosWrappers.html#ga133c7bf7e618aaab51cd84214b731532">TrilinosWrappers::PreconditionAMG::AdditionalData::constant_modes</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; bool &gt; &gt; constant_modes</div><div class="ttdef"><b>Definition:</b> <a href="trilinos__precondition_8h_source.html#l01516">trilinos_precondition.h:1516</a></div></div>
<div class="ttc" id="anamespaceDoFTools_html_afc96893388fe1a55c6ae5ae19ba52c6d"><div class="ttname"><a href="namespaceDoFTools.html#afc96893388fe1a55c6ae5ae19ba52c6d">DoFTools::extract_constant_modes</a></div><div class="ttdeci">void extract_constant_modes(const DoFHandler&lt; dim, spacedim &gt; &amp;dof_handler, const ComponentMask &amp;component_mask, std::vector&lt; std::vector&lt; bool &gt;&gt; &amp;constant_modes)</div><div class="ttdef"><b>Definition:</b> <a href="dof__tools_8cc_source.html#l01304">dof_tools.cc:1304</a></div></div>
<div class="ttc" id="astructTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData_html"><div class="ttname"><a href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html">TrilinosWrappers::PreconditionAMG::AdditionalData</a></div><div class="ttdef"><b>Definition:</b> <a href="trilinos__precondition_8h_source.html#l01353">trilinos_precondition.h:1354</a></div></div>
</div><!-- fragment --><p class="interli">接下来，我们再设置一些AMG预处理程序的选项。特别是，我们需要告诉AMG设置，我们对速度矩阵使用二次基函数（这意味着矩阵中有更多的非零元素，因此需要在内部选择一个更稳健的算法）。此外，我们希望能够控制粗化结构的建立方式。Trilinos平滑聚合AMG的方法是寻找哪些矩阵条目与对角线条目大小相似，以便代数式地建立一个粗网格结构。通过将参数 <code>aggregation_threshold</code> 设置为0.02，我们指定所有尺寸超过该行中一些对角线枢轴的百分之二的条目应该形成一个粗网格点。这个参数是比较特别的，对它进行一些微调会影响预处理程序的性能。根据经验，较大的 <code>aggregation_threshold</code> 值会减少迭代次数，但增加每次迭代的费用。查看Trilinos文档将提供更多关于这些参数的信息。有了这个数据集，我们就用我们想要的矩阵来初始化预处理程序。 <br  />
</p>
<p class="interli">最后，我们还要初始化预处理程序，以反转压力质量矩阵。这个矩阵是对称的，表现良好，所以我们可以选择一个简单的预处理程序。我们坚持使用不完全Cholesky（IC）因子化预处理程序，它是为对称矩阵设计的。我们也可以选择SSOR预处理器，其松弛系数约为1.2，但IC对我们的例子来说更便宜。我们将预处理器包裹在一个 <code>std::shared_ptr</code> 指针中，这使得下次重新创建预处理器更加容易，因为我们不必关心破坏以前使用的对象。</p>
<div class="fragment"><div class="line">  amg_data.<a class="code" href="group__TrilinosWrappers.html#ga852e93b85f68573cd0eedfe62c0f6bdc">elliptic</a>              = <span class="keyword">true</span>;</div>
<div class="line">  amg_data.<a class="code" href="group__TrilinosWrappers.html#ga8bb24e061826fbdfb49aeb24f80e02fd">higher_order_elements</a> = <span class="keyword">true</span>;</div>
<div class="line">  amg_data.<a class="code" href="group__TrilinosWrappers.html#ga7bcc5fa85afdb96d90416e7bf182edd0">smoother_sweeps</a>       = 2;</div>
<div class="line">  amg_data.<a class="code" href="group__TrilinosWrappers.html#ga36b8fa00a7ce0a5ed1ab0cddd41e4f9f">aggregation_threshold</a> = 0.02;</div>
<div class="line">  Amg_preconditioner-&gt;initialize(stokes_preconditioner_matrix.block(0, 0),</div>
<div class="line">                                 amg_data);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  Mp_preconditioner = std::make_shared&lt;TrilinosWrappers::PreconditionIC&gt;();</div>
<div class="line">  Mp_preconditioner-&gt;initialize(stokes_preconditioner_matrix.block(1, 1));</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  rebuild_stokes_preconditioner = <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__TrilinosWrappers_html_ga36b8fa00a7ce0a5ed1ab0cddd41e4f9f"><div class="ttname"><a href="group__TrilinosWrappers.html#ga36b8fa00a7ce0a5ed1ab0cddd41e4f9f">TrilinosWrappers::PreconditionAMG::AdditionalData::aggregation_threshold</a></div><div class="ttdeci">double aggregation_threshold</div><div class="ttdef"><b>Definition:</b> <a href="trilinos__precondition_8h_source.html#l01498">trilinos_precondition.h:1498</a></div></div>
<div class="ttc" id="agroup__TrilinosWrappers_html_ga7bcc5fa85afdb96d90416e7bf182edd0"><div class="ttname"><a href="group__TrilinosWrappers.html#ga7bcc5fa85afdb96d90416e7bf182edd0">TrilinosWrappers::PreconditionAMG::AdditionalData::smoother_sweeps</a></div><div class="ttdeci">unsigned int smoother_sweeps</div><div class="ttdef"><b>Definition:</b> <a href="trilinos__precondition_8h_source.html#l01528">trilinos_precondition.h:1528</a></div></div>
<div class="ttc" id="agroup__TrilinosWrappers_html_ga852e93b85f68573cd0eedfe62c0f6bdc"><div class="ttname"><a href="group__TrilinosWrappers.html#ga852e93b85f68573cd0eedfe62c0f6bdc">TrilinosWrappers::PreconditionAMG::AdditionalData::elliptic</a></div><div class="ttdeci">bool elliptic</div><div class="ttdef"><b>Definition:</b> <a href="trilinos__precondition_8h_source.html#l01469">trilinos_precondition.h:1469</a></div></div>
<div class="ttc" id="agroup__TrilinosWrappers_html_ga8bb24e061826fbdfb49aeb24f80e02fd"><div class="ttname"><a href="group__TrilinosWrappers.html#ga8bb24e061826fbdfb49aeb24f80e02fd">TrilinosWrappers::PreconditionAMG::AdditionalData::higher_order_elements</a></div><div class="ttdeci">bool higher_order_elements</div><div class="ttdef"><b>Definition:</b> <a href="trilinos__precondition_8h_source.html#l01475">trilinos_precondition.h:1475</a></div></div>
</div><!-- fragment --><p class="interli"><a class="anchor" id="BoussinesqFlowProblemassemble_stokes_system"></a></p><h4>BoussinesqFlowProblem::assemble_stokes_system</h4>
<p class="interli"><br  />
</p>
<p class="interli">我们用于推进耦合的斯托克斯-温度系统的时间滞后方案迫使我们将装配（以及线性系统的求解）分成两个步骤。第一步是创建斯托克斯系统的矩阵和右手边，第二步是创建温度道夫的矩阵和右手边，这取决于速度的线性系统的结果。 <br  />
</p>
<p class="interli">这个函数在每个时间步的开始被调用。在第一个时间步骤中，或者如果网格已经改变，由 <code>rebuild_stokes_matrix</code> 表示，我们需要组装斯托克斯矩阵；另一方面，如果网格没有改变，矩阵已经可用，这就没有必要了，我们需要做的是组装右手边的矢量，在每个时间步骤中改变。 <br  />
</p>
<p class="interli">关于实施的技术细节，与 <a class="el" href="step_22.html">step-22</a> 相比没有太大变化。我们重置矩阵和向量，在单元格上创建正交公式，然后创建相应的FEValues对象。对于更新标志，我们只在完全装配的情况下需要基函数导数，因为右手边不需要它们；像往常一样，根据当前需要选择最小的标志集，使程序中进一步调用 <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit</a> 的效率更高。 <br  />
</p>
<p class="interli">有一件事需要评论&amp;ndash；因为我们有一个单独的有限元和DoFHandler来处理温度问题，所以我们需要生成第二个FEValues对象来正确评估温度解决方案。要实现这一点并不复杂：只需使用温度结构，并为我们需要用于评估温度解决方案的基函数值设置一个更新标志。这里需要记住的唯一重要部分是，两个FEValues对象使用相同的正交公式，以确保我们在循环计算两个对象的正交点时得到匹配的信息。 <br  />
</p>
<p class="interli">申报过程中，对数组的大小、本地矩阵和右手边的创建以及本地道夫的指数与全局系统相比的向量都有一些快捷方式。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_stokes_system()</div>
<div class="line">{</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Assembling...&quot;</span> &lt;&lt; std::flush;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (rebuild_stokes_matrix == <span class="keyword">true</span>)</div>
<div class="line">    stokes_matrix = 0;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  stokes_rhs = 0;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(stokes_degree + 2);</div>
<div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     stokes_fe_values(</div>
<div class="line">    stokes_fe,</div>
<div class="line">    quadrature_formula,</div>
<div class="line">    <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div>
<div class="line">      (rebuild_stokes_matrix == <span class="keyword">true</span> ? <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> : <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>(0)));</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> temperature_fe_values(temperature_fe,</div>
<div class="line">                                      quadrature_formula,</div>
<div class="line">                                      <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = stokes_fe.n_dofs_per_cell();</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.size();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     local_rhs(dofs_per_cell);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div>
<div class="ttc" id="afe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52f"><div class="ttname"><a href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a></div><div class="ttdeci">UpdateFlags</div><div class="ttdef"><b>Definition:</b> <a href="fe__update__flags_8h_source.html#l00066">fe_update_flags.h:67</a></div></div>
<div class="ttc" id="afe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a"><div class="ttname"><a href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a></div><div class="ttdeci">@ update_quadrature_points</div><div class="ttdoc">Transformed quadrature points.</div><div class="ttdef"><b>Definition:</b> <a href="fe__update__flags_8h_source.html#l00122">fe_update_flags.h:122</a></div></div>
</div><!-- fragment --><p class="interli">接下来我们需要一个向量，它将包含正交点上一个时间层的温度解的值，以组装动量方程右边的源项。我们把这个向量称为 <code>old_solution_values</code> 。 <br  />
</p>
<p class="interli">我们接下来创建的一组向量包含了基函数的评估以及它们的梯度和对称梯度，这些都将用于创建矩阵。将这些放到自己的数组中，而不是每次需要时都向FEValues对象询问这些信息，这是一种优化，可以加速装配过程，详见 <a class="el" href="step_22.html">step-22</a> 。 <br  />
</p>
<p class="interli">最后两个声明是用来从整个FE系统中提取单个块（速度、压力、温度）的。</p>
<div class="fragment"><div class="line">std::vector&lt;double&gt; old_temperature_values(n_q_points);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt;          phi_u(dofs_per_cell);</div>
<div class="line">std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; grads_phi_u(dofs_per_cell);</div>
<div class="line">std::vector&lt;double&gt;                  div_phi_u(dofs_per_cell);</div>
<div class="line">std::vector&lt;double&gt;                  phi_p(dofs_per_cell);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div>
</div><!-- fragment --><p class="interli">现在开始对问题中的所有单元进行循环。我们在这个装配例程中使用了两个不同的DoFHandlers，所以我们必须为使用中的两个对象设置两个不同的单元格迭代器。这可能看起来有点奇怪，因为斯托克斯系统和温度系统都使用相同的网格，但这是保持自由度同步的唯一方法。循环中的第一条语句也是非常熟悉的，按照更新标志的规定对有限元数据进行更新，将局部数组清零，并在正交点上获得旧解的值。然后我们就可以在单元格上的正交点上进行循环。</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span>       cell             = stokes_dof_handler.begin_active();</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> endc             = stokes_dof_handler.end();</div>
<div class="line"><span class="keyword">auto</span>       temperature_cell = temperature_dof_handler.begin_active();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (; cell != endc; ++cell, ++temperature_cell)</div>
<div class="line">  {</div>
<div class="line">    stokes_fe_values.reinit(cell);</div>
<div class="line">    temperature_fe_values.reinit(temperature_cell);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    local_matrix = 0;</div>
<div class="line">    local_rhs    = 0;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    temperature_fe_values.get_function_values(old_temperature_solution,</div>
<div class="line">                                              old_temperature_values);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div>
<div class="line">      {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> old_temperature = old_temperature_values[q];</div>
</div><!-- fragment --><p class="interli">接下来，我们提取与内积条款相关的基函数的值和梯度。如 <a class="el" href="step_22.html">step-22</a> 所示，这有助于加速装配。 <br  />
</p>
<p class="interli">一旦完成，我们开始在局部矩阵的行和列上进行循环，并将相关的乘积送入矩阵。右手边是由温度驱动的重力方向（在我们的例子中是垂直方向）的强迫项。 请注意，右边的项总是生成的，而矩阵的贡献只有在 <code>rebuild_matrices</code> 标志要求时才更新。</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div>
<div class="line">    {</div>
<div class="line">      phi_u[k] = stokes_fe_values[velocities].value(k, q);</div>
<div class="line">      <span class="keywordflow">if</span> (rebuild_stokes_matrix)</div>
<div class="line">        {</div>
<div class="line">          grads_phi_u[k] =</div>
<div class="line">            stokes_fe_values[velocities].symmetric_gradient(k, q);</div>
<div class="line">          div_phi_u[k] =</div>
<div class="line">            stokes_fe_values[velocities].divergence(k, q);</div>
<div class="line">          phi_p[k] = stokes_fe_values[pressure].value(k, q);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (rebuild_stokes_matrix)</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div>
<div class="line">        local_matrix(i, j) +=</div>
<div class="line">          (EquationData::eta * 2 * (grads_phi_u[i] * grads_phi_u[j]) -</div>
<div class="line">           div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j]) *</div>
<div class="line">          stokes_fe_values.JxW(q);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> gravity =</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    -((dim == 2) ? (<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0, 1)) : (<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0, 0, 1)));</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div>
<div class="line">    local_rhs(i) += (-EquationData::density * EquationData::beta *</div>
<div class="line">                     gravity * phi_u[i] * old_temperature) *</div>
<div class="line">                    stokes_fe_values.JxW(q);</div>
<div class="line">}</div>
</div><!-- fragment --><p class="interli">在所有单元的循环中，最后一步是将局部贡献输入到全局矩阵和向量结构中，以达到 <code>local_dof_indices</code> 中指定的位置。 同样，我们让AffineConstraints类来做单元格矩阵元素插入全局矩阵的工作，这已经浓缩了悬挂节点的约束。</p>
<div class="fragment"><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">if</span> (rebuild_stokes_matrix == <span class="keyword">true</span>)</div>
<div class="line">        stokes_constraints.distribute_local_to_global(local_matrix,</div>
<div class="line">                                                      local_rhs,</div>
<div class="line">                                                      local_dof_indices,</div>
<div class="line">                                                      stokes_matrix,</div>
<div class="line">                                                      stokes_rhs);</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">        stokes_constraints.distribute_local_to_global(local_rhs,</div>
<div class="line">                                                      local_dof_indices,</div>
<div class="line">                                                      stokes_rhs);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  rebuild_stokes_matrix = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p class="interli"><a class="anchor" id="BoussinesqFlowProblemassemble_temperature_matrix"></a></p><h4>BoussinesqFlowProblem::assemble_temperature_matrix</h4>
<p class="interli"><br  />
</p>
<p class="interli">该函数组装温度方程中的矩阵。温度矩阵由两部分组成，质量矩阵和时间步长乘以刚度矩阵，由拉普拉斯项乘以扩散量给出。由于该矩阵取决于时间步长（从一个步长到另一个步长），温度矩阵需要在每个时间步长进行更新。我们可以简单地在每个时间步长中重新生成矩阵，但这并不真正有效，因为质量和拉普拉斯矩阵只有在我们改变网格时才会改变。因此，我们通过在这个函数中生成两个单独的矩阵，一个是质量矩阵，一个是刚度（扩散）矩阵，这样做更有效率。一旦我们知道了实际的时间步长，我们将把这个矩阵加上刚度矩阵乘以时间步长的总和。 <br  />
</p>
<p class="interli">所以这第一步的细节非常简单。为了防止我们需要重建矩阵（即网格发生了变化），我们将数据结构归零，得到一个正交公式和一个FEValues对象，并为基函数创建局部矩阵、局部dof指数和评估结构。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_temperature_matrix()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (rebuild_temperature_matrices == <span class="keyword">false</span>)</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  temperature_mass_matrix      = 0;</div>
<div class="line">  temperature_stiffness_matrix = 0;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>   quadrature_formula(temperature_degree + 2);</div>
<div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> temperature_fe_values(temperature_fe,</div>
<div class="line">                                      quadrature_formula,</div>
<div class="line">                                      <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div>
<div class="line">                                        <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = temperature_fe.n_dofs_per_cell();</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.size();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_mass_matrix(dofs_per_cell, dofs_per_cell);</div>
<div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_stiffness_matrix(dofs_per_cell, dofs_per_cell);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  std::vector&lt;double&gt;         phi_T(dofs_per_cell);</div>
<div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; grad_phi_T(dofs_per_cell);</div>
</div><!-- fragment --><p class="interli">现在，让我们开始对三角形中的所有单元进行循环。我们需要将局部矩阵清零，更新有限元评价，然后在每个正交点上循环矩阵的行和列，然后我们创建质量矩阵和刚度矩阵（拉普拉斯项乘以扩散 <code>EquationData::kappa</code> 。最后，我们让约束对象将这些值插入全局矩阵中，并直接将约束条件浓缩到矩阵中。</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : temperature_dof_handler.active_cell_iterators())</div>
<div class="line">    {</div>
<div class="line">      local_mass_matrix      = 0;</div>
<div class="line">      local_stiffness_matrix = 0;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">      temperature_fe_values.reinit(cell);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div>
<div class="line">        {</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div>
<div class="line">            {</div>
<div class="line">              grad_phi_T[k] = temperature_fe_values.shape_grad(k, q);</div>
<div class="line">              phi_T[k]      = temperature_fe_values.shape_value(k, q);</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div>
<div class="line">              {</div>
<div class="line">                local_mass_matrix(i, j) +=</div>
<div class="line">                  (phi_T[i] * phi_T[j] * temperature_fe_values.JxW(q));</div>
<div class="line">                local_stiffness_matrix(i, j) +=</div>
<div class="line">                  (EquationData::kappa * grad_phi_T[i] * grad_phi_T[j] *</div>
<div class="line">                   temperature_fe_values.JxW(q));</div>
<div class="line">              }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">      temperature_constraints.distribute_local_to_global(</div>
<div class="line">        local_mass_matrix, local_dof_indices, temperature_mass_matrix);</div>
<div class="line">      temperature_constraints.distribute_local_to_global(</div>
<div class="line">        local_stiffness_matrix,</div>
<div class="line">        local_dof_indices,</div>
<div class="line">        temperature_stiffness_matrix);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  rebuild_temperature_matrices = <span class="keyword">false</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p class="interli"><a class="anchor" id="BoussinesqFlowProblemassemble_temperature_system"></a> </p><h4>BoussinesqFlowProblem::assemble_temperature_system</h4>
<p class="interli"><br  />
</p>
<p class="interli">这个函数对温度矩阵进行第二部分的装配工作，实际添加压力质量和刚度矩阵（时间步长在这里起作用），以及创建依赖于速度的右手边。这个函数中的右侧装配的声明与其他装配例程中使用的声明基本相同，只是这次我们把自己限制在矢量上。我们将计算温度系统的残差，这意味着我们必须评估二阶导数，由更新标志 <code>update_hessians</code> 指定。 <br  />
</p>
<p class="interli">温度方程是通过流体速度与斯托克斯系统耦合的。解决方案的这两部分与不同的DoFHandlers相关联，因此我们需要再次创建第二个FEValues对象来评估正交点的速度。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_temperature_system(</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> maximal_velocity)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> use_bdf2_scheme = (timestep_number != 0);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (use_bdf2_scheme == <span class="keyword">true</span>)</div>
<div class="line">    {</div>
<div class="line">      temperature_matrix.copy_from(temperature_mass_matrix);</div>
<div class="line">      temperature_matrix *=</div>
<div class="line">        (2 * time_step + old_time_step) / (time_step + old_time_step);</div>
<div class="line">      temperature_matrix.add(time_step, temperature_stiffness_matrix);</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">      temperature_matrix.copy_from(temperature_mass_matrix);</div>
<div class="line">      temperature_matrix.add(time_step, temperature_stiffness_matrix);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  temperature_rhs = 0;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(temperature_degree + 2);</div>
<div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     temperature_fe_values(temperature_fe,</div>
<div class="line">                                      quadrature_formula,</div>
<div class="line">                                      <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div>
<div class="line">                                        <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a> |</div>
<div class="line">                                        <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div>
<div class="line">                                        <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     stokes_fe_values(stokes_fe,</div>
<div class="line">                                 quadrature_formula,</div>
<div class="line">                                 <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = temperature_fe.n_dofs_per_cell();</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.size();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> local_rhs(dofs_per_cell);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div>
<div class="ttc" id="afe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719"><div class="ttname"><a href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a></div><div class="ttdeci">@ update_hessians</div><div class="ttdoc">Second derivatives of shape functions.</div><div class="ttdef"><b>Definition:</b> <a href="fe__update__flags_8h_source.html#l00090">fe_update_flags.h:90</a></div></div>
</div><!-- fragment --><p class="interli">接下来是向量的声明，用来保存旧的和较早的解值（分别作为时间级别 \(n-1\) 和 \(n-2\) 的符号）以及当前单元的正交点的梯度。我们还声明了一个对象来保存温度的右侧值（ <code>gamma_values</code> ），并且我们再次使用温度基函数的快捷方式。最终，我们需要找到温度极值和计算域的直径，这将用于稳定参数的定义（我们得到了最大速度作为该函数的输入）。</p>
<div class="fragment"><div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_velocity_values(n_q_points);</div>
<div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_old_velocity_values(n_q_points);</div>
<div class="line">std::vector&lt;double&gt;         old_temperature_values(n_q_points);</div>
<div class="line">std::vector&lt;double&gt;         old_old_temperature_values(n_q_points);</div>
<div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_temperature_grads(n_q_points);</div>
<div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_old_temperature_grads(n_q_points);</div>
<div class="line">std::vector&lt;double&gt;         old_temperature_laplacians(n_q_points);</div>
<div class="line">std::vector&lt;double&gt;         old_old_temperature_laplacians(n_q_points);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">EquationData::TemperatureRightHandSide&lt;dim&gt; temperature_right_hand_side;</div>
<div class="line">std::vector&lt;double&gt;                         gamma_values(n_q_points);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">std::vector&lt;double&gt;         phi_T(dofs_per_cell);</div>
<div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt; grad_phi_T(dofs_per_cell);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> std::pair&lt;double, double&gt; global_T_range =</div>
<div class="line">  get_extrapolated_temperature_range();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div>
</div><!-- fragment --><p class="interli">现在，让我们开始对三角形中的所有单元进行循环。同样，我们需要两个单元格迭代器，平行走过斯托克斯和温度部分的两个相关DoFHandler对象的单元格。在这个循环中，我们首先将局部rhs设置为零，然后在正交点上获得旧的解函数的值和导数，因为它们将被用于稳定参数的定义和作为方程的系数。请注意，由于温度有自己的DoFHandler和FEValues对象，我们在正交点得到整个解（反正只有标量温度场），而对于斯托克斯部分，我们只限于通过使用 <code>stokes_fe_values[velocities].get_function_values</code> 提取速度部分（而忽略压力部分）。</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span>       cell        = temperature_dof_handler.begin_active();</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> endc        = temperature_dof_handler.end();</div>
<div class="line"><span class="keyword">auto</span>       stokes_cell = stokes_dof_handler.begin_active();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (; cell != endc; ++cell, ++stokes_cell)</div>
<div class="line">  {</div>
<div class="line">    local_rhs = 0;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    temperature_fe_values.reinit(cell);</div>
<div class="line">    stokes_fe_values.reinit(stokes_cell);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    temperature_fe_values.get_function_values(old_temperature_solution,</div>
<div class="line">                                              old_temperature_values);</div>
<div class="line">    temperature_fe_values.get_function_values(old_old_temperature_solution,</div>
<div class="line">                                              old_old_temperature_values);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    temperature_fe_values.get_function_gradients(old_temperature_solution,</div>
<div class="line">                                                 old_temperature_grads);</div>
<div class="line">    temperature_fe_values.get_function_gradients(</div>
<div class="line">      old_old_temperature_solution, old_old_temperature_grads);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    temperature_fe_values.get_function_laplacians(</div>
<div class="line">      old_temperature_solution, old_temperature_laplacians);</div>
<div class="line">    temperature_fe_values.get_function_laplacians(</div>
<div class="line">      old_old_temperature_solution, old_old_temperature_laplacians);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    temperature_right_hand_side.value_list(</div>
<div class="line">      temperature_fe_values.get_quadrature_points(), gamma_values);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    stokes_fe_values[velocities].get_function_values(stokes_solution,</div>
<div class="line">                                                     old_velocity_values);</div>
<div class="line">    stokes_fe_values[velocities].get_function_values(</div>
<div class="line">      old_stokes_solution, old_old_velocity_values);</div>
</div><!-- fragment --><p class="interli">接下来，我们根据引言中的讨论，使用专用函数计算用于稳定的人工黏度。有了这个，我们就可以进入正交点和局部rhs矢量分量的循环。这里的术语相当冗长，但其定义遵循本方案介绍中开发的时间-离散系统。BDF-2方案比用于第一时间步的后向欧拉方案多需要一个旧时间步的术语（并且涉及更复杂的因素）。当所有这些都完成后，我们将局部向量分配到全局向量中（包括悬挂节点约束）。</p>
<div class="fragment"><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> nu =</div>
<div class="line">        compute_viscosity(old_temperature_values,</div>
<div class="line">                          old_old_temperature_values,</div>
<div class="line">                          old_temperature_grads,</div>
<div class="line">                          old_old_temperature_grads,</div>
<div class="line">                          old_temperature_laplacians,</div>
<div class="line">                          old_old_temperature_laplacians,</div>
<div class="line">                          old_velocity_values,</div>
<div class="line">                          old_old_velocity_values,</div>
<div class="line">                          gamma_values,</div>
<div class="line">                          maximal_velocity,</div>
<div class="line">                          global_T_range.second - global_T_range.first,</div>
<div class="line">                          cell-&gt;diameter());</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div>
<div class="line">        {</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div>
<div class="line">            {</div>
<div class="line">              grad_phi_T[k] = temperature_fe_values.shape_grad(k, q);</div>
<div class="line">              phi_T[k]      = temperature_fe_values.shape_value(k, q);</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> T_term_for_rhs =</div>
<div class="line">            (use_bdf2_scheme ?</div>
<div class="line">               (old_temperature_values[q] * (1 + time_step / old_time_step) -</div>
<div class="line">                old_old_temperature_values[q] * (time_step * time_step) /</div>
<div class="line">                  (old_time_step * (time_step + old_time_step))) :</div>
<div class="line">               old_temperature_values[q]);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> ext_grad_T =</div>
<div class="line">            (use_bdf2_scheme ?</div>
<div class="line">               (old_temperature_grads[q] * (1 + time_step / old_time_step) -</div>
<div class="line">                old_old_temperature_grads[q] * time_step / old_time_step) :</div>
<div class="line">               old_temperature_grads[q]);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> extrapolated_u =</div>
<div class="line">            (use_bdf2_scheme ?</div>
<div class="line">               (old_velocity_values[q] * (1 + time_step / old_time_step) -</div>
<div class="line">                old_old_velocity_values[q] * time_step / old_time_step) :</div>
<div class="line">               old_velocity_values[q]);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div>
<div class="line">            local_rhs(i) +=</div>
<div class="line">              (T_term_for_rhs * phi_T[i] -</div>
<div class="line">               time_step * extrapolated_u * ext_grad_T * phi_T[i] -</div>
<div class="line">               time_step * nu * ext_grad_T * grad_phi_T[i] +</div>
<div class="line">               time_step * gamma_values[q] * phi_T[i]) *</div>
<div class="line">              temperature_fe_values.JxW(q);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div>
<div class="line">      temperature_constraints.distribute_local_to_global(local_rhs,</div>
<div class="line">                                                         local_dof_indices,</div>
<div class="line">                                                         temperature_rhs);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p class="interli"><a class="anchor" id="BoussinesqFlowProblemsolve"></a></p><h4>BoussinesqFlowProblem::solve</h4>
<p class="interli"><br  />
</p>
<p class="interli">这个函数解决了线性方程组的问题。在介绍之后，我们从斯托克斯系统开始，在这里我们需要生成我们的块舒尔预处理。由于所有相关的动作都在类 <code>BlockSchurPreconditioner</code> 中实现，我们所要做的就是适当地初始化这个类。我们需要传递的是压力质量矩阵的 <code>InverseMatrix</code> 对象，我们使用相应的类和我们已经生成的IC预处理程序以及速度-速度矩阵的AMG预处理程序来设置它。注意， <code>Mp_preconditioner</code> 和 <code>Amg_preconditioner</code> 都只是指针，所以我们用 <code>*</code> 来传递实际的预处理对象。 <br  />
</p>
<p class="interli">一旦预处理程序准备就绪，我们就为该块系统创建一个GMRES求解器。由于我们使用的是Trilinos数据结构，我们必须在求解器中设置相应的模板参数。GMRES需要在内部存储每次迭代的临时向量（见 <a class="el" href="step_22.html">step-22</a> 结果部分的讨论）&amp;ndash；它可以使用的向量越多，通常表现越好。为了控制内存需求，我们将向量的数量设置为100。这意味着在求解器的100次迭代中，每个临时向量都可以被存储。如果求解器需要更频繁地迭代以获得指定的容忍度，它将通过每100次迭代重新开始，在一个减少的向量集上工作。 <br  />
</p>
<p class="interli">有了这一切的设置，我们求解系统并在斯托克斯系统中分配约束条件，即悬挂节点和无流边界条件，以便即使在受约束的道夫也有适当的解值。最后，我们把迭代次数写到屏幕上。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::solve()</div>
<div class="line">{</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">const</span> LinearSolvers::InverseMatrix&lt;<a class="code" href="namespaceLinearAlgebraDealII.html#a912abe2208022aec6753876bcc72f6bf">TrilinosWrappers::SparseMatrix</a>,</div>
<div class="line">                                       <a class="code" href="classTrilinosWrappers_1_1PreconditionIC.html">TrilinosWrappers::PreconditionIC</a>&gt;</div>
<div class="line">      mp_inverse(stokes_preconditioner_matrix.block(1, 1),</div>
<div class="line">                 *Mp_preconditioner);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> LinearSolvers::BlockSchurPreconditioner&lt;</div>
<div class="line">      <a class="code" href="namespaceLinearAlgebraPETSc_1_1MPI.html#a41f11f7a1992c6d6aa9367b12c68f791">TrilinosWrappers::PreconditionAMG</a>,</div>
<div class="line">      <a class="code" href="classTrilinosWrappers_1_1PreconditionIC.html">TrilinosWrappers::PreconditionIC</a>&gt;</div>
<div class="line">      preconditioner(stokes_matrix, mp_inverse, *Amg_preconditioner);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(stokes_matrix.m(),</div>
<div class="line">                                 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-6 * stokes_rhs.l2_norm());</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classSolverGMRES.html">SolverGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;</a> gmres(</div>
<div class="line">      solver_control,</div>
<div class="line">      <a class="code" href="structSolverGMRES_1_1AdditionalData.html">SolverGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;::AdditionalData</a>(100));</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; stokes_solution.size(); ++i)</div>
<div class="line">      <span class="keywordflow">if</span> (stokes_constraints.is_constrained(i))</div>
<div class="line">        stokes_solution(i) = 0;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    gmres.solve(stokes_matrix, stokes_solution, stokes_rhs, preconditioner);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    stokes_constraints.distribute(stokes_solution);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; solver_control.last_step()</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot; GMRES iterations for Stokes subsystem.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="ttc" id="aclassSolverGMRES_html"><div class="ttname"><a href="classSolverGMRES.html">SolverGMRES</a></div><div class="ttdef"><b>Definition:</b> <a href="solver__gmres_8h_source.html#l00175">solver_gmres.h:176</a></div></div>
<div class="ttc" id="aclassTrilinosWrappers_1_1PreconditionIC_html"><div class="ttname"><a href="classTrilinosWrappers_1_1PreconditionIC.html">TrilinosWrappers::PreconditionIC</a></div><div class="ttdef"><b>Definition:</b> <a href="trilinos__precondition_8h_source.html#l00865">trilinos_precondition.h:866</a></div></div>
<div class="ttc" id="anamespaceLinearAlgebraPETSc_1_1MPI_html_a41f11f7a1992c6d6aa9367b12c68f791"><div class="ttname"><a href="namespaceLinearAlgebraPETSc_1_1MPI.html#a41f11f7a1992c6d6aa9367b12c68f791">LinearAlgebraPETSc::MPI::PreconditionAMG</a></div><div class="ttdeci">PETScWrappers::PreconditionBoomerAMG PreconditionAMG</div><div class="ttdef"><b>Definition:</b> <a href="generic__linear__algebra_8h_source.html#l00133">generic_linear_algebra.h:133</a></div></div>
<div class="ttc" id="astructSolverGMRES_1_1AdditionalData_html"><div class="ttname"><a href="structSolverGMRES_1_1AdditionalData.html">SolverGMRES::AdditionalData</a></div><div class="ttdef"><b>Definition:</b> <a href="solver__gmres_8h_source.html#l00181">solver_gmres.h:182</a></div></div>
</div><!-- fragment --><p class="interli">一旦我们知道了斯托克斯解，我们就可以从最大速度中确定新的时间步长。我们必须这样做以满足CFL条件，因为对流项在温度方程中得到了明确的处理，正如在介绍中所讨论的。这里用于时间步长的公式的确切形式将在本程序的结果部分讨论。 <br  />
</p>
<p class="interli">这里有一个小插曲。该公式包含一个除以速度的最大值。然而，在计算开始时，我们有一个恒定的温度场（我们以恒定的温度开始，只有在源作用的第一个时间步长后，它才是非恒定的）。恒定温度意味着没有浮力作用，所以速度为零。除以它不可能导致任何好的结果。 <br  />
</p>
<p class="interli">为了避免由此产生的无限时间步长，我们要问最大速度是否非常小（特别是小于我们在接下来的任何时间步长中遇到的值），如果是，我们就不除以零，而是除以一个小值，从而产生一个大而有限的时间步长。</p>
<div class="fragment"><div class="line">old_time_step                 = time_step;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> maximal_velocity = get_maximal_velocity();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (maximal_velocity &gt;= 0.01)</div>
<div class="line">  time_step = 1. / (1.7 * dim * <a class="code" href="numbers_8h.html#ac4a2ed1890a931d0b6a55933310eadca">std::sqrt</a>(1. * dim)) / temperature_degree *</div>
<div class="line">              <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>) /</div>
<div class="line">              maximal_velocity;</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">  time_step = 1. / (1.7 * dim * <a class="code" href="numbers_8h.html#ac4a2ed1890a931d0b6a55933310eadca">std::sqrt</a>(1. * dim)) / temperature_degree *</div>
<div class="line">              <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>) / .01;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span></div>
<div class="line">          &lt;&lt; <span class="stringliteral">&quot;Time step: &quot;</span> &lt;&lt; time_step &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">temperature_solution = old_temperature_solution;</div>
<div class="ttc" id="anamespaceGridTools_html_a47c293eff2ec7ce4b90ba08b35d1f2e2"><div class="ttname"><a href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a></div><div class="ttdeci">double minimal_cell_diameter(const Triangulation&lt; dim, spacedim &gt; &amp;triangulation, const Mapping&lt; dim, spacedim &gt; &amp;mapping=(ReferenceCells::get_hypercube&lt; dim &gt;() .template get_default_linear_mapping&lt; dim, spacedim &gt;()))</div><div class="ttdef"><b>Definition:</b> <a href="grid__tools_8cc_source.html#l04274">grid_tools.cc:4274</a></div></div>
<div class="ttc" id="anumbers_8h_html_ac4a2ed1890a931d0b6a55933310eadca"><div class="ttname"><a href="numbers_8h.html#ac4a2ed1890a931d0b6a55933310eadca">std::sqrt</a></div><div class="ttdeci">::VectorizedArray&lt; Number, width &gt; sqrt(const ::VectorizedArray&lt; Number, width &gt; &amp;)</div><div class="ttdef"><b>Definition:</b> <a href="vectorization_8h_source.html#l05406">vectorization.h:5406</a></div></div>
</div><!-- fragment --><p class="interli">接下来我们用函数 <code>assemble_temperature_system()</code> 设置温度系统和右手边。 知道了温度方程的矩阵和右手边，我们设置了一个预处理程序和一个求解器。温度矩阵是一个质量矩阵（特征值在1左右）加上一个拉普拉斯矩阵（特征值在0和 \(ch^{-2}\) 之间）乘以一个与时间步长成比例的小数 \(k_n\) 。因此，产生的对称和正定矩阵的特征值在 \([1,1+k_nh^{-2}]\) 范围内（直到常数）。这个矩阵即使对于小的网格尺寸也只是适度的条件不良，我们通过简单的方法得到一个相当好的预处理，例如用一个不完全的Cholesky分解预处理（IC），因为我们也用于预处理压力质量矩阵求解器。作为一个求解器，我们选择共轭梯度法CG。和以前一样，我们通过模板参数告诉求解器使用特里诺斯向量 <code><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a></code> 。最后，我们求解，分配悬空节点约束并写出迭代次数。</p>
<div class="fragment"><div class="line">assemble_temperature_system(maximal_velocity);</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(temperature_matrix.m(),</div>
<div class="line">                               1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8 * temperature_rhs.l2_norm());</div>
<div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;TrilinosWrappers::MPI::Vector&gt;</a> cg(solver_control);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classTrilinosWrappers_1_1PreconditionIC.html">TrilinosWrappers::PreconditionIC</a> preconditioner;</div>
<div class="line">  preconditioner.<a class="code" href="group__TrilinosWrappers.html#ga95eff1f8abcf2ba67815b6a96a66d375">initialize</a>(temperature_matrix);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  cg.solve(temperature_matrix,</div>
<div class="line">           temperature_solution,</div>
<div class="line">           temperature_rhs,</div>
<div class="line">           preconditioner);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  temperature_constraints.distribute(temperature_solution);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; solver_control.last_step()</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot; CG iterations for temperature.&quot;</span> &lt;&lt; std::endl;</div>
<div class="ttc" id="agroup__TrilinosWrappers_html_ga95eff1f8abcf2ba67815b6a96a66d375"><div class="ttname"><a href="group__TrilinosWrappers.html#ga95eff1f8abcf2ba67815b6a96a66d375">TrilinosWrappers::PreconditionIC::initialize</a></div><div class="ttdeci">void initialize(const SparseMatrix &amp;matrix, const AdditionalData &amp;additional_data=AdditionalData())</div><div class="ttdef"><b>Definition:</b> <a href="trilinos__precondition_8cc_source.html#l00477">trilinos_precondition.cc:477</a></div></div>
</div><!-- fragment --><p class="interli">在这个函数的最后，我们通过向量步进，读出最大和最小的温度值，我们也想输出这个值。在确定本程序结果部分所讨论的选择时间步长的正确常数时，这将非常有用。</p>
<div class="fragment"><div class="line">    <span class="keywordtype">double</span> min_temperature = temperature_solution(0),</div>
<div class="line">           max_temperature = temperature_solution(0);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; temperature_solution.size(); ++i)</div>
<div class="line">      {</div>
<div class="line">        min_temperature =</div>
<div class="line">          std::min&lt;double&gt;(min_temperature, temperature_solution(i));</div>
<div class="line">        max_temperature =</div>
<div class="line">          std::max&lt;double&gt;(max_temperature, temperature_solution(i));</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Temperature range: &quot;</span> &lt;&lt; min_temperature &lt;&lt; <span class="charliteral">&#39; &#39;</span></div>
<div class="line">              &lt;&lt; max_temperature &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p class="interli"><a class="anchor" id="BoussinesqFlowProblemoutput_results"></a> </p><h4>BoussinesqFlowProblem::output_results</h4>
<p class="interli"><br  />
</p>
<p class="interli">该函数将解决方案写入VTK输出文件，以便进行可视化，每隔10个时间步长进行一次。这通常是一个相当简单的任务，因为deal.II库提供的函数几乎为我们完成了所有的工作。与以前的例子相比，有一个新的函数。我们想把斯托克斯解和温度都看作一个数据集，但我们已经根据两个不同的DoFHandler对象完成了所有的计算。幸运的是，DataOut类已经准备好处理这个问题。我们所要做的就是不要在一开始就附加一个单一的DoFHandler，然后将其用于所有添加的向量，而是为每个向量分别指定DoFHandler。剩下的就像 <a class="el" href="step_22.html">step-22</a> 中所做的那样。我们创建解决方案的名称（这些名称将出现在各个组件的可视化程序中）。第一个 <code>dim</code> 分量是矢量速度，然后我们有斯托克斯部分的压力，而温度是标量。这些信息是用DataComponentInterpretation辅助类读出来的。接下来，我们将数据向量与它们的DoFHandler对象连接起来，根据自由度建立补丁，这些补丁是描述可视化程序数据的（子）元素。最后，我们打开一个文件（包括时间步数）并将vtk数据写入其中。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <span class="keywordflow">if</span> (timestep_number % 10 != 0)</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  std::vector&lt;std::string&gt; stokes_names(dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div>
<div class="line">  stokes_names.emplace_back(<span class="stringliteral">&quot;p&quot;</span>);</div>
<div class="line">  std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div>
<div class="line">    stokes_component_interpretation(</div>
<div class="line">      dim + 1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div>
<div class="line">    stokes_component_interpretation[i] =</div>
<div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div>
<div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a>(stokes_dof_handler,</div>
<div class="line">                           stokes_solution,</div>
<div class="line">                           stokes_names,</div>
<div class="line">                           stokes_component_interpretation);</div>
<div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a>(temperature_dof_handler,</div>
<div class="line">                           temperature_solution,</div>
<div class="line">                           <span class="stringliteral">&quot;T&quot;</span>);</div>
<div class="line">  data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(stokes_degree, temperature_degree));</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  std::ofstream output(<span class="stringliteral">&quot;solution-&quot;</span> +</div>
<div class="line">                       <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_number, 4) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div>
<div class="line">  data_out.<a class="code" href="group__Exceptions.html#gacad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div>
<div class="line">}</div>
<div class="ttc" id="aclassDataOut__DoFData_html_ace4b76e565ba0701c4d32c26075ed3b9"><div class="ttname"><a href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">DataOut_DoFData::add_data_vector</a></div><div class="ttdeci">void add_data_vector(const VectorType &amp;data, const std::vector&lt; std::string &gt; &amp;names, const DataVectorType type=type_automatic, const std::vector&lt; DataComponentInterpretation::DataComponentInterpretation &gt; &amp;data_component_interpretation=std::vector&lt; DataComponentInterpretation::DataComponentInterpretation &gt;())</div><div class="ttdef"><b>Definition:</b> <a href="data__out__dof__data_8h_source.html#l01087">data_out_dof_data.h:1087</a></div></div>
<div class="ttc" id="aclassDataOut_html"><div class="ttname"><a href="classDataOut.html">DataOut</a></div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__out_8h_source.html#l00147">data_out.h:150</a></div></div>
<div class="ttc" id="aclassDataOut_html_a5eb51872b8736849bb7e8d2007fae086"><div class="ttname"><a href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">DataOut::build_patches</a></div><div class="ttdeci">virtual void build_patches(const unsigned int n_subdivisions=0)</div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__out_8cc_source.html#l01085">data_out.cc:1085</a></div></div>
<div class="ttc" id="agroup__Exceptions_html_gacad99726038e4fca7f605fdffb3317e4"><div class="ttname"><a href="group__Exceptions.html#gacad99726038e4fca7f605fdffb3317e4">DataOutInterface::write_vtk</a></div><div class="ttdeci">void write_vtk(std::ostream &amp;out) const</div><div class="ttdef"><b>Definition:</b> <a href="data__out__base_8cc_source.html#l07177">data_out_base.cc:7177</a></div></div>
<div class="ttc" id="anamespaceDataComponentInterpretation_html_a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51"><div class="ttname"><a href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a></div><div class="ttdeci">@ component_is_scalar</div><div class="ttdef"><b>Definition:</b> <a href="data__component__interpretation_8h_source.html#l00053">data_component_interpretation.h:53</a></div></div>
<div class="ttc" id="anamespaceDataComponentInterpretation_html_a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0"><div class="ttname"><a href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a></div><div class="ttdeci">@ component_is_part_of_vector</div><div class="ttdef"><b>Definition:</b> <a href="data__component__interpretation_8h_source.html#l00059">data_component_interpretation.h:59</a></div></div>
<div class="ttc" id="anamespaceUtilities_html_a6195c5f009ea8c7c536c6ffdf108c32f"><div class="ttname"><a href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a></div><div class="ttdeci">std::string int_to_string(const unsigned int value, const unsigned int digits=numbers::invalid_unsigned_int)</div><div class="ttdef"><b>Definition:</b> <a href="base_2utilities_8cc_source.html#l00473">utilities.cc:473</a></div></div>
</div><!-- fragment --><p class="interli"><a class="anchor" id="BoussinesqFlowProblemrefine_mesh"></a></p><h4>BoussinesqFlowProblem::refine_mesh</h4>
<p class="interli"><br  />
</p>
<p class="interli">这个函数负责处理自适应网格细化的工作。这个函数执行的三个任务是：首先找出需要细化/粗化的单元，然后实际进行细化，最后在两个不同的网格之间传输解向量。第一个任务是通过对温度使用成熟的凯利误差估计器来实现的（对于这个程序，我们主要关注的是温度，我们需要在高温度梯度的区域保持精确，同时也要避免有太多的数值扩散）。第二项任务是实际进行再塑形。这也只涉及到基本的函数，例如 <code>refine_and_coarsen_fixed_fraction</code> ，它可以细化那些具有最大估计误差的单元，这些误差加起来占到80，并粗化那些具有最小误差的单元，这些误差加起来占到10。 <br  />
</p>
<p class="interli">如果像这样实施，我们会得到一个不会有太大进展的程序。请记住，我们期望的温度场几乎是不连续的（扩散率 \(\kappa\) 毕竟非常小），因此我们可以预期，一个自由适应的网格会越来越细化到大梯度的区域。网格大小的减少将伴随着时间步长的减少，需要大量的时间步长来解决给定的最终时间。这也会导致在几个网格细化周期后，网格的不连续性解决得比开始时好得多。 <br  />
</p>
<p class="interli">特别是为了防止时间步长的减少和相应的大量时间步数，我们限制了网格的最大细化深度。为此，在细化指标应用于单元格后，我们简单地在最细层的所有单元格上循环，如果它们会导致网格层次过高，则取消选择它们进行细化。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">BoussinesqFlowProblem&lt;dim&gt;::refine_mesh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_grid_level)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.n_active_cells());</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classKellyErrorEstimator.html#aa0917e696d4f8ddb983223a68c512357">KellyErrorEstimator&lt;dim&gt;::estimate</a>(temperature_dof_handler,</div>
<div class="line">                                     <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(temperature_degree + 1),</div>
<div class="line">                                     {},</div>
<div class="line">                                     temperature_solution,</div>
<div class="line">                                     estimated_error_per_cell);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <a class="code" href="namespaceGridRefinement.html#ae90dc87c4db158b8d01f6d564ac614e5">GridRefinement::refine_and_coarsen_fixed_fraction</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>,</div>
<div class="line">                                                    estimated_error_per_cell,</div>
<div class="line">                                                    0.8,</div>
<div class="line">                                                    0.1);</div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.n_levels() &gt; max_grid_level)</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell :</div>
<div class="line">         <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.active_cell_iterators_on_level(max_grid_level))</div>
<div class="line">      cell-&gt;clear_refine_flag();</div>
<div class="ttc" id="aclassKellyErrorEstimator_html_aa0917e696d4f8ddb983223a68c512357"><div class="ttname"><a href="classKellyErrorEstimator.html#aa0917e696d4f8ddb983223a68c512357">KellyErrorEstimator::estimate</a></div><div class="ttdeci">static void estimate(const Mapping&lt; dim, spacedim &gt; &amp;mapping, const DoFHandler&lt; dim, spacedim &gt; &amp;dof, const Quadrature&lt; dim - 1 &gt; &amp;quadrature, const std::map&lt; types::boundary_id, const Function&lt; spacedim, typename InputVector::value_type &gt; * &gt; &amp;neumann_bc, const InputVector &amp;solution, Vector&lt; float &gt; &amp;error, const ComponentMask &amp;component_mask=ComponentMask(), const Function&lt; spacedim &gt; *coefficients=nullptr, const unsigned int n_threads=numbers::invalid_unsigned_int, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id, const types::material_id material_id=numbers::invalid_material_id, const Strategy strategy=cell_diameter_over_24)</div></div>
<div class="ttc" id="anamespaceGridRefinement_html_ae90dc87c4db158b8d01f6d564ac614e5"><div class="ttname"><a href="namespaceGridRefinement.html#ae90dc87c4db158b8d01f6d564ac614e5">GridRefinement::refine_and_coarsen_fixed_fraction</a></div><div class="ttdeci">void refine_and_coarsen_fixed_fraction(Triangulation&lt; dim, spacedim &gt; &amp;tria, const Vector&lt; Number &gt; &amp;criteria, const double top_fraction, const double bottom_fraction, const unsigned int max_n_cells=std::numeric_limits&lt; unsigned int &gt;::max(), const VectorTools::NormType norm_type=VectorTools::NormType::L1_norm)</div><div class="ttdef"><b>Definition:</b> <a href="grid_2grid__refinement_8cc_source.html#l00390">grid_refinement.cc:390</a></div></div>
</div><!-- fragment --><p class="interli">作为网格细化的一部分，我们需要将旧网格中的解向量转移到新网格中。为此，我们使用SolutionTransfer类，我们必须准备好需要转移到新网格的解向量（一旦我们完成细化，我们将失去旧的网格，所以转移必须与细化同时进行）。我们肯定需要的是当前温度和旧温度（BDF-2时间步长需要两个旧的解决方案）。由于SolutionTransfer对象只支持在每个dof处理程序中传输一个对象，我们需要在一个数据结构中收集两个温度解决方案。此外，我们也选择转移斯托克斯解，因为我们需要前两个时间步长的速度，其中只有一个是在飞行中计算的。 <br  />
</p>
<p class="interli">因此，我们为斯托克斯和温度的DoFHandler对象初始化了两个SolutionTransfer对象，将它们附加到旧的dof处理程序中。有了这些，我们就可以准备三角测量和数据向量的细化（按这个顺序）。</p>
<div class="fragment"><div class="line">std::vector&lt;TrilinosWrappers::MPI::Vector&gt; x_temperature(2);</div>
<div class="line">x_temperature[0]                            = temperature_solution;</div>
<div class="line">x_temperature[1]                            = old_temperature_solution;</div>
<div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> x_stokes = stokes_solution;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim, TrilinosWrappers::MPI::Vector&gt;</a> temperature_trans(</div>
<div class="line">  temperature_dof_handler);</div>
<div class="line"><a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim, TrilinosWrappers::MPI::BlockVector&gt;</a> stokes_trans(</div>
<div class="line">  stokes_dof_handler);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.prepare_coarsening_and_refinement();</div>
<div class="line">temperature_trans.prepare_for_coarsening_and_refinement(x_temperature);</div>
<div class="line">stokes_trans.prepare_for_coarsening_and_refinement(x_stokes);</div>
<div class="ttc" id="aclassSolutionTransfer_html"><div class="ttname"><a href="classSolutionTransfer.html">SolutionTransfer</a></div><div class="ttdef"><b>Definition:</b> <a href="numerics_2solution__transfer_8h_source.html#l00338">solution_transfer.h:339</a></div></div>
</div><!-- fragment --><p class="interli">现在一切都准备好了，所以进行细化，在新的网格上重新创建dof结构，并在 <code>setup_dofs</code> 函数中初始化矩阵结构和新向量。接下来，我们实际执行网格之间的插值解。我们为温度创建另一份临时向量（现在与新网格相对应），并让插值函数完成这项工作。然后，产生的向量数组被写入各自的向量成员变量中。 <br  />
</p>
<p class="interli">记住，约束集将在setup_dofs()调用中为新的三角结构进行更新。</p>
<div class="fragment"><div class="line"><a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.execute_coarsening_and_refinement();</div>
<div class="line">setup_dofs();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">std::vector&lt;TrilinosWrappers::MPI::Vector&gt; tmp(2);</div>
<div class="line">tmp[0].reinit(temperature_solution);</div>
<div class="line">tmp[1].reinit(temperature_solution);</div>
<div class="line">temperature_trans.interpolate(x_temperature, tmp);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">temperature_solution     = tmp[0];</div>
<div class="line">old_temperature_solution = tmp[1];</div>
</div><!-- fragment --><p class="interli">在解决方案被转移后，我们再对转移的解决方案执行约束。</p>
<div class="fragment"><div class="line">temperature_constraints.distribute(temperature_solution);</div>
<div class="line">temperature_constraints.distribute(old_temperature_solution);</div>
</div><!-- fragment --><p class="interli">对于斯托克斯矢量，一切都一样&amp;ndash；除了我们不需要另一个临时矢量，因为我们只是内插一个矢量。最后，我们必须告诉程序，矩阵和预处理程序需要重新生成，因为网格已经改变。</p>
<div class="fragment"><div class="line">  stokes_trans.interpolate(x_stokes, stokes_solution);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  stokes_constraints.distribute(stokes_solution);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  rebuild_stokes_matrix         = <span class="keyword">true</span>;</div>
<div class="line">  rebuild_temperature_matrices  = <span class="keyword">true</span>;</div>
<div class="line">  rebuild_stokes_preconditioner = <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p class="interli"><a class="anchor" id="BoussinesqFlowProblemrun"></a> </p><h4>BoussinesqFlowProblem::run</h4>
<p class="interli"><br  />
</p>
<p class="interli">这个函数执行 Boussinesq 程序中的所有基本步骤。它首先设置一个网格（根据空间维度，我们选择一些不同的初始细化水平和额外的自适应细化步骤，然后在 <code>dim</code> 维度上创建一个立方体，并首次设置道夫。由于我们想用一个自适应细化的网格开始时间步进，我们执行一些预细化步骤，包括所有的装配、求解和细化，但实际上没有在时间上推进。相反，我们使用被人诟病的 <code>goto</code> 语句，在网格细化后立即跳出时间循环，从 <code>start_time_iteration</code> 标签处的新网格重新开始。( <code>goto</code> 的使用在 <a class="el" href="step_26.html">step-26</a> 中讨论) 。 <br  />
</p>
<p class="interli">在我们开始之前，我们将初始值投影到网格上，并获得 <code>old_temperature_solution</code> 矢量的第一个数据。然后，我们初始化时间步数和时间步长，开始时间循环。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">BoussinesqFlowProblem&lt;dim&gt;::run</a>()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_refinement     = (dim == 2 ? 4 : 2);</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_pre_refinement_steps = (dim == 2 ? 4 : 3);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>);</div>
<div class="line">  global_Omega_diameter = <a class="code" href="namespaceGridTools.html#acd5ccc543d561cfb086b571d1f7818cb">GridTools::diameter</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.refine_global(initial_refinement);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  setup_dofs();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pre_refinement_step = 0;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">start_time_iteration:</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a>(temperature_dof_handler,</div>
<div class="line">                       temperature_constraints,</div>
<div class="line">                       <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(temperature_degree + 2),</div>
<div class="line">                       EquationData::TemperatureInitialValues&lt;dim&gt;(),</div>
<div class="line">                       old_temperature_solution);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  timestep_number = 0;</div>
<div class="line">  time_step = old_time_step = 0;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">double</span> time = 0;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">do</span></div>
<div class="line">    {</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Timestep &quot;</span> &lt;&lt; timestep_number &lt;&lt; <span class="stringliteral">&quot;:  t=&quot;</span> &lt;&lt; time</div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="ttc" id="anamespaceGridGenerator_html_acea0cbcd68e52ce8113d1134b87de403"><div class="ttname"><a href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a></div><div class="ttdeci">void hyper_cube(Triangulation&lt; dim, spacedim &gt; &amp;tria, const double left=0., const double right=1., const bool colorize=false)</div></div>
<div class="ttc" id="anamespaceGridTools_html_acd5ccc543d561cfb086b571d1f7818cb"><div class="ttname"><a href="namespaceGridTools.html#acd5ccc543d561cfb086b571d1f7818cb">GridTools::diameter</a></div><div class="ttdeci">double diameter(const Triangulation&lt; dim, spacedim &gt; &amp;tria)</div><div class="ttdef"><b>Definition:</b> <a href="grid__tools_8cc_source.html#l00081">grid_tools.cc:81</a></div></div>
<div class="ttc" id="anamespaceVectorTools_html_ac6b404bf03cb2a742b290421cc2789fe"><div class="ttname"><a href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a></div><div class="ttdeci">void project(const Mapping&lt; dim, spacedim &gt; &amp;mapping, const DoFHandler&lt; dim, spacedim &gt; &amp;dof, const AffineConstraints&lt; typename VectorType::value_type &gt; &amp;constraints, const Quadrature&lt; dim &gt; &amp;quadrature, const Function&lt; spacedim, typename VectorType::value_type &gt; &amp;function, VectorType &amp;vec, const bool enforce_zero_boundary=false, const Quadrature&lt; dim - 1 &gt; &amp;q_boundary=(dim &gt; 1 ? QGauss&lt; dim - 1 &gt;(2) :Quadrature&lt; dim - 1 &gt;(0)), const bool project_to_boundary_first=false)</div></div>
</div><!-- fragment --><p class="interli">时间循环的第一步都是显而易见的&amp;ndash；我们组装斯托克斯系统、预处理程序、温度矩阵（矩阵和预处理程序实际上只在我们之前重做的情况下发生变化），然后进行求解。在继续下一个时间步骤之前，我们必须检查我们是否应该首先完成预精炼步骤，或者是否应该重新啮合（每五个时间步骤），精炼到一个与初始精炼和预精炼步骤一致的水平。循环的最后一个步骤是推进解，即把解复制到下一个 "老 "时间层。</p>
<div class="fragment"><div class="line">  assemble_stokes_system();</div>
<div class="line">  build_stokes_preconditioner();</div>
<div class="line">  assemble_temperature_matrix();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  solve();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  output_results();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> ((timestep_number == 0) &amp;&amp;</div>
<div class="line">      (pre_refinement_step &lt; n_pre_refinement_steps))</div>
<div class="line">    {</div>
<div class="line">      refine_mesh(initial_refinement + n_pre_refinement_steps);</div>
<div class="line">      ++pre_refinement_step;</div>
<div class="line">      <span class="keywordflow">goto</span> start_time_iteration;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((timestep_number &gt; 0) &amp;&amp; (timestep_number % 5 == 0))</div>
<div class="line">    refine_mesh(initial_refinement + n_pre_refinement_steps);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  time += time_step;</div>
<div class="line">  ++timestep_number;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  old_stokes_solution          = stokes_solution;</div>
<div class="line">  old_old_temperature_solution = old_temperature_solution;</div>
<div class="line">  old_temperature_solution     = temperature_solution;</div>
<div class="line">}</div>
</div><!-- fragment --><p class="interli">做所有上述工作，直到我们到达时间100。</p>
<div class="fragment"><div class="line">    <span class="keywordflow">while</span> (time &lt;= 100);</div>
<div class="line">  }</div>
<div class="line">} <span class="comment">// namespace Step31</span></div>
</div><!-- fragment --><p class="interli"><a class="anchor" id="Thecodemaincodefunction"></a></p><h3>The <code>main</code> function</h3>
<p class="interli"></p>
<p class="interli">主函数看起来与所有其他程序几乎相同。</p>
<p class="interli">有一个区别是我们必须要注意的。这个程序使用了Trilinos，而通常情况下，Trilinos被配置为可以使用MPI以并行方式运行。这并不意味着它<em>has</em>要以并行方式运行，事实上这个程序（与 <a class="el" href="step_32.html">step-32</a> 不同）根本没有尝试使用MPI在并行中做任何事情。然而，Trilinos希望MPI系统被初始化。我们通过创建一个类型为 <a class="el" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> 的对象来做到这一点，该对象使用给main()的参数来初始化MPI（如果可用的话）（即 <code>argc</code> 和 <code>argv</code> ），并在对象超出范围时再次去初始化它。</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
<div class="line">      <span class="keyword">using namespace </span>Step31;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(</div>
<div class="line">        argc, argv, <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>);</div>
<div class="ttc" id="aclassUtilities_1_1MPI_1_1MPI__InitFinalize_html"><div class="ttname"><a href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a></div><div class="ttdef"><b>Definition:</b> <a href="mpi_8h_source.html#l00902">mpi.h:903</a></div></div>
<div class="ttc" id="anamespacenumbers_html_a8ae36952c7e0cc778b47b5371b3aeff1"><div class="ttname"><a href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></div><div class="ttdeci">static const unsigned int invalid_unsigned_int</div><div class="ttdef"><b>Definition:</b> <a href="types_8h_source.html#l00196">types.h:196</a></div></div>
</div><!-- fragment --><p class="interli">这个程序只能以串行方式运行。否则，会抛出一个异常。</p>
<div class="fragment"><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD) == 1,</div>
<div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div>
<div class="line">                    <span class="stringliteral">&quot;This program can only be run in serial, use ./step-31&quot;</span>));</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">      BoussinesqFlowProblem&lt;2&gt; flow_problem;</div>
<div class="line">      flow_problem.run();</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__Exceptions_html_gafc0ca7ad85b3ebd64e8e51689ac85caf"><div class="ttname"><a href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a></div><div class="ttdeci">#define AssertThrow(cond, exc)</div><div class="ttdef"><b>Definition:</b> <a href="include_2deal_8II_2base_2exceptions_8h_source.html#l01583">exceptions.h:1583</a></div></div>
<div class="ttc" id="anamespaceUtilities_1_1MPI_html_ac26de0c059200523177bb1d92cc25d00"><div class="ttname"><a href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a></div><div class="ttdeci">unsigned int n_mpi_processes(const MPI_Comm &amp;mpi_communicator)</div><div class="ttdef"><b>Definition:</b> <a href="mpi_8cc_source.html#l00117">mpi.cc:117</a></div></div>
</div><!-- fragment --><p class="interli"><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p class="interli"></p>
<p class="interli"><a class="anchor" id="Resultsin2d"></a> </p><h3>Results in 2d </h3>
<p class="interli"></p>
<p class="interli">当你在2d中运行程序时，输出结果会是这样的。<code> </p><pre> 活动单元的数量：256（在5层） 自由度的数量：3556（2178+289+1089 

时间步数 0: t=0 正在组装...    重建斯托克斯预调节器...    解算...    斯托克斯子系统的GMRES迭代次数为0。   时间步长：0.919118温度的9次CG迭代。   温度范围：-0.16687 1.30011 

活动单元的数量：280（在6层） 自由度的数量：4062（2490+327+1245 

时间步数 0: t=0 正在组装...    重建斯托克斯预处理程序...    解算...    斯托克斯子系统的GMRES迭代次数为0。   时间步长：0.459559温度的9次CG迭代。   温度范围：-0.0982971 0.598503 

活动单元的数量：520（在7层） 自由度的数量：7432（4562+589+2281) 

时间步数 0: t=0 正在组装...    重建斯托克斯预处理程序...    解算...    斯托克斯子系统的GMRES迭代次数为0。   时间步长：0.229779 温度的9次CG迭代。   温度范围：-0.0551098 0.294493 

活动单元数：1072（8层） 自由度数：15294(9398+1197+4699) 

时间步数 0: t=0 正在组装...    重建斯托克斯预处理程序...    解算...    斯托克斯子系统的GMRES迭代次数为0。   时间步长：0.11489 温度的9次CG迭代。   温度范围：-0.0273524 0.156861 

活动单元数：2116（9层） 自由度数：30114 (18518+2337+9259) 

时间步数 0: t=0 正在组装...    重建斯托克斯预处理程序...    解算...    斯托克斯子系统的GMRES迭代次数为0。   时间步长：0.0574449 温度的9次CG迭代。   温度范围：-0.014993 0.0738328 

时间步数1：t=0.0574449 装配...    解决...    对斯托克斯子系统进行56次GMRES迭代。   时间步长：0.0574449 温度的9次CG迭代。   温度范围：-0.0273934 0.14488 

... </pre><p> </code></p>
<p class="interli">在开始的时候，我们自适应地细化了几次网格，并总是返回到时间步长为零的新细化的网格上重新开始。只有这样，我们才开始实际的时间迭代。</p>
<p class="interli">该程序运行了一段时间。时间步数为0、500、1000、1500、2000、3000、4000和5000的温度场看起来是这样的（注意温度使用的色标并不总是相同）。</p>
<table align="center" class="doxtable">
<tr>
<td><img src="https://www.dealii.org/images/steps/developer/step-31.2d.solution.00.png" alt="" class="inline"/>  </td><td><img src="https://www.dealii.org/images/steps/developer/step-31.2d.solution.01.png" alt="" class="inline"/>  </td><td><img src="https://www.dealii.org/images/steps/developer/step-31.2d.solution.02.png" alt="" class="inline"/>  </td><td><img src="https://www.dealii.org/images/steps/developer/step-31.2d.solution.03.png" alt="" class="inline"/>   </td></tr>
<tr>
<td><img src="https://www.dealii.org/images/steps/developer/step-31.2d.solution.04.png" alt="" class="inline"/>  </td><td><img src="https://www.dealii.org/images/steps/developer/step-31.2d.solution.05.png" alt="" class="inline"/>  </td><td><img src="https://www.dealii.org/images/steps/developer/step-31.2d.solution.06.png" alt="" class="inline"/>  </td><td><img src="https://www.dealii.org/images/steps/developer/step-31.2d.solution.07.png" alt="" class="inline"/>   </td></tr>
</table>
<p><br  />
</p>
<p class="interli">这里显示的视觉效果是使用一个版本的例子生成的，该版本在传输网格后没有强制执行约束。</p>
<p class="interli">可以看出，我们有三个热源加热流体，因此产生了浮力效应，让流体的热袋上升并旋转起来。通过烟囱效应，这三股气流被来自外部并想加入上升气流的流体压在一起。请注意，由于流体最初处于静止状态，那些最初在源头上的流体部分比后来被充分发展的流场拖到源头上的流体获得更长的加热时间。因此，它更热，这一事实可以从三个羽流的红色尖端看出。还要注意流场的相对精细的特征，这是我们选择的温度方程的复杂传输稳定的结果。</p>
<p class="interli">除了上面的图片外，下面的图片显示了自适应网格和同一时间步长的流场。</p>
<table align="center" class="doxtable">
<tr>
<td><img src="https://www.dealii.org/images/steps/developer/step-31.2d.grid.00.png" alt="" class="inline"/>  </td><td><img src="https://www.dealii.org/images/steps/developer/step-31.2d.grid.01.png" alt="" class="inline"/>  </td><td><img src="https://www.dealii.org/images/steps/developer/step-31.2d.grid.02.png" alt="" class="inline"/>  </td><td><img src="https://www.dealii.org/images/steps/developer/step-31.2d.grid.03.png" alt="" class="inline"/>   </td></tr>
<tr>
<td><img src="https://www.dealii.org/images/steps/developer/step-31.2d.grid.04.png" alt="" class="inline"/>  </td><td><img src="https://www.dealii.org/images/steps/developer/step-31.2d.grid.05.png" alt="" class="inline"/>  </td><td><img src="https://www.dealii.org/images/steps/developer/step-31.2d.grid.06.png" alt="" class="inline"/>  </td><td><img src="https://www.dealii.org/images/steps/developer/step-31.2d.grid.07.png" alt="" class="inline"/>   </td></tr>
</table>
<p><br  />
</p>
<p class="interli"><a class="anchor" id="Resultsin3d"></a></p><h3>Results in 3d </h3>
<p class="interli"></p>
<p class="interli">当然，同样的事情也可以在3D中进行，将 <code>main()</code> 中的BoussinesqFlowProblem对象的模板参数从2改为3，这样，现在的输出看起来如下。</p>
<p class="interli"><code> </p><pre> 活动单元的数量：64（在3层） 自由度的数量：3041（2187+125+729 

时间步数 0: t=0 正在组装...    重建斯托克斯预调节器...    解算...    斯托克斯子系统的GMRES迭代次数为0。   时间步长：2.45098 温度的9次CG迭代。   温度范围：-0.675683 4.94725 

活动单元的数量：288（在4层） 自由度的数量：12379（8943+455+2981）。

时间步数 0: t=0 正在组装...    重建斯托克斯预处理程序...    解算...    斯托克斯子系统的GMRES迭代次数为0。   时间步长：1.22549 温度的9次CG迭代。   温度范围：-0.527701 2.25764 

活动单元数：1296（在5层） 自由度数：51497（37305+1757+12435 

时间步数 0: t=0 正在组装...    重建斯托克斯预处理程序...    解算...    斯托克斯子系统的GMRES迭代次数为0。   时间步长：0.612745温度的10次CG迭代。   温度范围：-0.496942 0.847395 

活动单元数：5048（在6层） 自由度数：192425 (139569+6333+46523) 

时间步数 0: t=0 正在组装...    重建斯托克斯预处理程序...    解算...    斯托克斯子系统的GMRES迭代次数为0。   时间步长：0.306373 温度的10次CG迭代。   温度范围：-0.267683 0.497739 

时间步数1：t=0.306373 装配...    解决...    对斯托克斯子系统进行27次GMRES迭代。   时间步长：0.306373 温度的10次CG迭代。   温度范围：-0.461787 0.958679 

... </pre><p> </code></p>
<p class="interli">在时间步长为0、50、100、150、200、300、400、500、600、700和800时，将温度等值线可视化，得到以下图示。</p>
<table align="center" class="doxtable">
<tr>
<td><img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.00.png" alt="" class="inline"/>  </td><td><img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.01.png" alt="" class="inline"/>  </td><td><img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.02.png" alt="" class="inline"/>  </td><td><img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.03.png" alt="" class="inline"/>   </td></tr>
<tr>
<td><img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.04.png" alt="" class="inline"/>  </td><td><img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.05.png" alt="" class="inline"/>  </td><td><img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.06.png" alt="" class="inline"/>  </td><td><img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.07.png" alt="" class="inline"/>   </td></tr>
<tr>
<td><img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.08.png" alt="" class="inline"/>  </td><td><img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.09.png" alt="" class="inline"/>  </td><td><img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.10.png" alt="" class="inline"/>  </td><td></td></tr>
</table>
<p><br  />
</p>
<p class="interli">第一幅图看起来像三只刺猬，这是因为我们的方案基本上是将源乘以第一个时间步长投射到网格上，以获得第一个时间步长的温度场。由于源函数是不连续的，我们需要期待这个项目的过冲和欠冲。这就是事实上发生的情况（在2d中更容易检查），并导致等值面的皱缩外观。 这里显示的视觉效果是使用例子的一个版本生成的，该版本在传输网格后没有强制执行约束。</p>
<p class="interli"><a class="anchor" id="Numericalexperimentstodetermineoptimalparameters"></a></p><h3>Numerical experiments to determine optimal parameters </h3>
<p class="interli"></p>
<p class="endli">这个程序有三个参数，我们在理论上还没有掌握如何以最佳方式选择。这三个参数是。 </p><ul>
<li>
时间步骤必须满足CFL条件 \(k\le \min_K \frac{c_kh_K}{\|\mathbf{u}\|_{L^\infty(K)}}\) 。这里， \(c_k\) 是无量纲的，但什么是正确的值？ </li>
<li>
<p class="startli">在计算人工黏度时， </p><p class="formulaDsp">
\begin{eqnarray*} \nu_\alpha(T)|_K = \beta \|\mathbf{u}\|_{L^\infty(K)} \min\left\{ h_K, h_K^\alpha \frac{\|R_\alpha(T)\|_{L^\infty(K)}}{c(\mathbf{u},T)} \right\}, \end{eqnarray*}
</p>
 <pre class="fragment">  与 @f$c(\mathbf{u},T) =
  c_R\ \|\mathbf{u}\|_{L^\infty(\Omega)} \ \mathrm{var}(T)
  \ |\mathrm{diam}(\Omega)|^{\alpha-2}@f$  。      这里，无量纲%数 @f$\beta,c_R@f$ 的选择是有意义的。  &lt;/ul&gt;  在所有这些情况下，我们将不得不期待每个值的正确选择取决于其他值的正确选择，而且很可能也取决于用于温度的有限元的空间尺寸和多项式程度。下面我们将讨论一些数值实验来选择常数  @f$c_k@f$  和  @f$\beta@f$  。
</pre><p> 下面，我们将不讨论 \(c_R\) 的选择。在程序中，我们将其设置为 \(c_R=2^{\frac{4-2\alpha}{d}}\) 。这个值的原因有点复杂，与程序的历史而不是推理有关：虽然全局缩放参数 \(c(\mathbf{u},T)\) 的正确公式如上所示，但程序（包括与deal.II 6.2一起发货的版本）最初有一个错误，即我们计算的是 \(c(\mathbf{u},T) = \|\mathbf{u}\|_{L^\infty(\Omega)} \ \mathrm{var}(T) \ \frac{1}{|\mathrm{diam}(\Omega)|^{\alpha-2}}\) ，而不是我们将缩放参数设置为1。由于我们只在 \(\mathrm{diam}(\Omega)=2^{1/d}\) 的单位平方/立方体上进行计算，这完全等同于使用 \(c_R=\left(2^{1/d}\right)^{4-2\alpha}=2^{\frac{4-2\alpha}{d}}\) 的正确公式。由于 \(c_R\) 的这个值对目前的程序来说似乎很好用，我们在程序中修正了公式，将 \(c_R\) 设置为一个值，正好再现了我们之前的结果。不过，我们将在 <a class="el" href="step_32.html">step-32</a> 中再次讨论这个问题。</p>
<p class="interli">然而现在，回到讨论 \(c_k\) 和 \(\beta\) 选择什么值。</p>
<p class="interli"><a class="anchor" id="Choosingicsubksubiandbeta"></a></p><h4>Choosing <em>c<sub>k</sub></em><em>c<sub>k</sub></em> and beta </h4>
<p class="interli"></p>
<p class="interli">这两个常数肯定在某种程度上有联系。原因很容易看出来。在纯平流问题的情况下， \(\frac{\partial T}{\partial t} + \mathbf{u}\cdot\nabla T = \gamma\) ，任何显式方案都必须满足形式为 \(k\le \min_K \frac{c_k^a h_K}{\|\mathbf{u}\|_{L^\infty(K)}}\) 的CFL条件。另一方面，对于纯扩散问题， \(\frac{\partial T}{\partial t} + \nu \Delta T = \gamma\) ，显式方案需要满足一个条件 \(k\le \min_K \frac{c_k^d h_K^2}{\nu}\) 。因此，鉴于上述 \(\nu\) 的形式，像我们这里要解决的平流扩散问题将导致一个 \( k\le \min_K \min \left\{ \frac{c_k^a h_K}{\|\mathbf{u}\|_{L^\infty(K)}}, \frac{c_k^d h_K^2}{\beta \|\mathbf{u}\|_{L^\infty(K)} h_K}\right\} = \min_K \left( \min \left\{ c_k^a, \frac{c_k^d}{\beta}\right\} \frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}} \right) \) 的条件。因此，我们必须面对这样一个事实：我们可能希望选择更大的 \(\beta\) 来提高数值方案的稳定性（通过增加人工扩散量），但我们必须以更小的、因而更多的时间步骤为代价。因此，在实践中，人们希望尽可能地选择 \(\beta\) 来保持传输问题的充分稳定，同时尽量选择大的时间步长来减少总的工作量。</p>
<p class="interli">要找到正确的平衡点，唯一的办法就是做一些计算实验。以下是我们所做的。我们稍微修改了程序，允许更少的网格细化（所以我们不一定要等那么久），并选择 \( \nu(T)|_K = \beta \|\mathbf{u}\|_{L^\infty(K)} h_K \) 来消除常数 \(c_R\) 的影响（我们知道通过使用这个版本的 \(\nu(T)\) 作为人工粘度，解决方案是稳定的，但我们可以通过使用这个人工粘度的更复杂的公式来改善情况&ndash;即让解决方案更尖锐）。然后我们对不同的值 \(c_k,\beta\) 运行程序，观察域中的最大和最小温度。我们期望看到的情况是这样的。如果我们选择的时间步长过大（即选择一个比理论上允许的大的 \(c_k\) ），那么我们将得到温度的指数式增长。如果我们选择 \(\beta\) 太小，那么传输稳定就变得不充分，解决方案将显示出明显的振荡，但不是指数增长。</p>
<p class="interli"><a class="anchor" id="ResultsforQsub1subelements"></a></p><h5>Results for Q<sub>1</sub> elements</h5>
<p class="interli"></p>
<p class="interli">下面是我们对 \(\beta=0.01, \beta=0.1\) ，和 \(\beta=0.5\) ， \(c_k\) 的不同选择，以及2d的双线性元素（ <code>temperature_degree=1</code> ）得到的结果。</p>
<table align="center" class="doxtable">
<tr>
<td><img src="https://www.dealii.org/images/steps/developer/step-31.timestep.q1.beta=0.01.png" alt="" class="inline"/>  </td><td><img src="https://www.dealii.org/images/steps/developer/step-31.timestep.q1.beta=0.03.png" alt="" class="inline"/>   </td></tr>
<tr>
<td><img src="https://www.dealii.org/images/steps/developer/step-31.timestep.q1.beta=0.1.png" alt="" class="inline"/>  </td><td><img src="https://www.dealii.org/images/steps/developer/step-31.timestep.q1.beta=0.5.png" alt="" class="inline"/>   </td></tr>
</table>
<p><br  />
</p>
<p class="interli">解释这些图形的方法是这样的：对于 \(\beta=0.01\) 和 \(c_k=\frac 12,\frac 14\) ，我们看到指数增长或至少是大的变化，但如果我们选择 \(k=\frac 18\frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}}\) 或更小，那么这个方案是稳定的，尽管有点摇摆不定。对于更多的人工扩散，我们可以选择 \(k=\frac 14\frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}}\) 或更小的 \(\beta=0.03\) ， \(k=\frac 13\frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}}\) 或更小的 \(\beta=0.1\) ，再次需要 \(k=\frac 1{15}\frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}}\) 的 \(\beta=0.5\) （这次是因为很多扩散需要一个小的时间步长）。</p>
<p class="interli">那么该如何选择呢？如果我们只是对大的时间步长感兴趣，那么我们会选择 \(\beta=0.1\) 和 \(k=\frac 13\frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}}\) 。另一方面，我们也对准确性感兴趣，在这里，实际调查这些曲线所显示的内容可能会有兴趣。为此，请注意，我们从零温度开始，我们的来源是正的&amp;mdash；所以我们会直观地期望温度永远不会降到零以下。但它确实如此，这是使用连续元素来近似不连续的解决方案时，吉布现象的结果。因此，我们可以看到，选择 \(\beta\) 太小是不好的：太少的人工扩散会导致没有被扩散掉的过冲和欠冲。另一方面，对于大的 \(\beta\) ，最低温度在开始时下降到零以下，但随后迅速扩散回零。</p>
<p class="interli">另一方面，我们也来看看最高温度。观察溶液的电影，我们看到最初流体处于静止状态。源头不断加热相同体积的流体，其温度在开始时是线性上升的，直到其浮力能够使其向上移动。因此，流体中最热的部分被带离了溶液，取而代之的流体只被加热了很短的时间就被移出了源区，因此仍然比初始气泡要冷。如果 \(\kappa=0\) （在程序中它是非零的，但非常小），那么流体中最热的部分应该随着流动而平移，其温度不变。这就是我们在最小的 \(\beta\) 图中可以看到的：一旦达到最高温度，它就几乎不再变化。另一方面，人工扩散越大，热点的扩散就越多。请注意，对于这个标准，时间步长并没有发挥重要作用。</p>
<p class="interli">因此，总结起来，可能最好的选择似乎是 \(\beta=0.03\) 和 \(k=\frac 14\frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}}\) 。曲线有点摇摆不定，但总的来说，图片看起来很合理，除了由于吉布现象造成的接近开始时间的一些过冲和欠冲。</p>
<p class="interli"><a class="anchor" id="ResultsforQsub2subelements"></a> </p><h5>Results for Q<sub>2</sub> elements</h5>
<p class="interli"></p>
<p class="interli">我们也可以对高阶元素重复同样的实验序列。这里是温度的双二次方形状函数( <code>temperature_degree=2</code> )的图形，同时我们保留了斯托克斯系统的 \(Q_2/Q_1\) 稳定泰勒-胡德元素。</p>
<table align="center" class="doxtable">
<tr>
<td><img src="https://www.dealii.org/images/steps/developer/step-31.timestep.q2.beta=0.01.png" alt="" class="inline"/>  </td><td><img src="https://www.dealii.org/images/steps/developer/step-31.timestep.q2.beta=0.03.png" alt="" class="inline"/>   </td></tr>
<tr>
<td><img src="https://www.dealii.org/images/steps/developer/step-31.timestep.q2.beta=0.1.png" alt="" class="inline"/>   </td></tr>
</table>
<p><br  />
</p>
<p class="interli">同样， \(\beta\) 的小值会导致较少的扩散，但我们必须选择非常小的时间步长来保持事情的控制。太大的 \(\beta\) 值会导致更多的扩散，但同样需要小的时间步骤。最佳值似乎是 \(\beta=0.03\) ，和 \(Q_1\) 元素一样，然后我们必须选择 \(k=\frac 18\frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}}\) &amp;mdash；正好是 \(Q_1\) 元素的一半大小。 ]元素，如果我们把CFL条件说成是要求时间步长足够小，以便运输在每个时间步长中的移动距离不超过一个<em>grid point</em>的距离（对于 \(Q_1\) 元素是 \(h_K\) ，但对于 \(Q_2\) 元素是 \(h_K/2\) ），这个事实可能并不令人惊讶。事实证明， \(\beta\) 需要稍微大一点，以便在模拟后期获得稳定的结果，时间大于60，所以我们实际上在代码中选择它作为 \(\beta = 0.034\) 。</p>
<p class="interli"><a class="anchor" id="Resultsfor3d"></a></p><h5>Results for 3d</h5>
<p class="interli"></p>
<p class="interli">人们可以在3D中重复这些实验，找到每个 \(\beta\) 值的最佳时间步骤，并找到 \(\beta\) 的最佳值。人们发现，对于2d中已经使用的相同的 \(\beta\) ，时间步长需要小一点，大约是1.2倍左右。这很容易解释：时间步长的限制是 \(k=\min_K \frac{ch_K}{\|\mathbf{u}\|_{L^\infty(K)}}\) ，其中 \(h_K\) 是单元的<em>diameter</em>。然而，真正需要的是网格点之间的距离，它是 \(\frac{h_K}{\sqrt{d}}\) 。所以更合适的形式是 \(k=\min_K \frac{ch_K}{\|\mathbf{u}\|_{L^\infty(K)}\sqrt{d}}\) 。</p>
<p class="interli">第二个发现是，需要选择 \(\beta\) 稍大一些（大约 \(\beta=0.05\) 左右）。这样就再次减少了我们可以采取的时间步骤。</p>
<p class="interli"><a class="anchor" id="Conclusions"></a></p><h5>Conclusions</h5>
<p class="interli"></p>
<p class="interli">总之，从上面的简单计算来看， \(\beta=0.034\) 似乎是2D中稳定参数的好选择，而 \(\beta=0.05\) 则是3D中稳定参数的好选择。以独立于维度的方式，我们可以将其建模为 \(\beta=0.017d\) 。如果在更细的网格上做更长时间的计算（几千个时间步长），就会意识到时间步长还不够小，为了稳定，就必须把上述数值再降低一些（大约是 \(\frac 78\) 的一个系数）。</p>
<p class="interli">因此，一个调和了2D、3D和可变多项式程度并考虑到所有因素的公式如下。 </p><p class="formulaDsp">
\begin{eqnarray*} k = \frac 1{2 \cdot 1.7} \frac 1{\sqrt{d}} \frac 2d \frac 1{q_T} \frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}} = \frac 1{1.7 d\sqrt{d}} \frac 1{q_T} \frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}}. \end{eqnarray*}
</p>
<p class="interli">在第一种形式中（方程中心）， \(\frac 1{2 \cdot 1.7}\) 是一个通用常数， \(\frac 1{\sqrt{d}}\) 是考虑到单元直径和网格点间距的因素， \(\frac 2d\) 考虑到 \(\beta\) 随空间维度的增加， \(\frac 1{q_T}\) 考虑到高阶元素的网格点间距离， \(\frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}}\) 考虑到相对于单元尺寸的局部传输速度。这就是我们在程序中使用的公式。</p>
<p class="interli">至于对温度使用 \(Q_1\) 还是 \(Q_2\) 元素的问题，以下考虑可能是有用的。首先，解决温度方程在整个方案中几乎不是一个因素，因为几乎所有的计算时间都用于解决每个时间步骤中的斯托克斯系统。因此，温度方程的高阶元素并不是一个重要的缺点。另一方面，如果比较一下由于不连续的源描述而产生的过冲和欠冲的大小，就会注意到，对于上述 \(\beta\) 和 \(k\) 的选择， \(Q_1\) 的解会下降到 \(-0.47\) 左右，而 \(Q_2\) 的解只到 \(-0.13\) （记住，精确的解根本不应该变成负数。这意味着 \(Q_2\) 解明显更准确；因此程序使用这些高阶元素，尽管我们在较小的时间步长方面付出了代价。</p>
<p class="interli"><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions </h3>
<p class="interli"></p>
<p class="interli">有各种方法来扩展当前的程序。当然，特别感兴趣的是使其更快和/或提高程序的分辨率，特别是在三维中。这是 <a class="el" href="step_32.html">step-32</a> 教程程序的主题，它将实现在集群上以并行方式解决这个问题的策略。它也是更大的开放源代码ASPECT（见https://aspect.geodynamics.org/）的基础，它可以解决现实问题，并构成了 <a class="el" href="step_32.html">step-32</a> 的进一步发展。</p>
<p class="interli">另一个方向是使流体流动更加逼真。该程序最初是为了模拟各种情况，模拟地幔中的物质对流，即外地核和固体地壳之间的区域：在那里，物质从下面被加热，从上面被冷却，导致热对流。然而，这种流体的物理学要比这个程序中显示的复杂得多。地幔材料的粘度与温度有很大的关系，即 \(\eta=\eta(T)\) ，这种关系经常被模拟为粘度随温度升高而呈指数下降。其次，地幔的大部分动力学是由化学反应决定的，主要是构成地幔的各种晶体的相变；然后，斯托克斯方程右边的浮力项不仅取决于温度，而且还取决于某一特定位置的化学成分，这些化学成分被流场平流，但也作为压力和温度的函数而变化。我们将在以后的教程程序中也研究其中的一些影响。<a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Copyright (C) 2007 - 2020 by the deal.II authors</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div>
<div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div>
<div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div>
<div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div>
<div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div>
<div class="line"><span class="comment"> * the top level directory of deal.II.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Authors: Martin Kronbichler, Uppsala University,</span></div>
<div class="line"><span class="comment"> *          Wolfgang Bangerth, Texas A&amp;M University 2007, 2008</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__gmres_8h.html">deal.II/lac/solver_gmres.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparsity__pattern_8h.html">deal.II/lac/block_sparsity_pattern.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2solution__transfer_8h.html">deal.II/numerics/solution_transfer.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__sparse__matrix_8h.html">deal.II/lac/trilinos_sparse_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__block__sparse__matrix_8h.html">deal.II/lac/trilinos_block_sparse_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__vector_8h.html">deal.II/lac/trilinos_vector.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__parallel__block__vector_8h.html">deal.II/lac/trilinos_parallel_block_vector.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__precondition_8h.html">deal.II/lac/trilinos_precondition.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;limits&gt;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>Step31</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">namespace </span>EquationData</div>
<div class="line">  {</div>
<div class="line">    constexpr <span class="keywordtype">double</span> eta     = 1;</div>
<div class="line">    constexpr <span class="keywordtype">double</span> kappa   = 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-6;</div>
<div class="line">    constexpr <span class="keywordtype">double</span> beta    = 10;</div>
<div class="line">    constexpr <span class="keywordtype">double</span> density = 1;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keyword">class </span>TemperatureInitialValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">      TemperatureInitialValues()</div>
<div class="line">        : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div>
<div class="line">      {}</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="namespaceinternal.html#aa5bef221c94bc6b9c5441c306a72cdbaa2063c1608d6e0baf80249c42e2be5804">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div>
<div class="line">                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword">      </span>{</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div>
<div class="line">                                <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  value)<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword">      </span>{</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div>
<div class="line">          <a class="code" href="namespaceinternal.html#aa5bef221c94bc6b9c5441c306a72cdbaa2063c1608d6e0baf80249c42e2be5804">value</a>(c) = TemperatureInitialValues&lt;dim&gt;::value(p, c);</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">    <span class="keyword">class </span>TemperatureRightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">      TemperatureRightHandSide()</div>
<div class="line">        : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div>
<div class="line">      {}</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="namespaceinternal.html#aa5bef221c94bc6b9c5441c306a72cdbaa2063c1608d6e0baf80249c42e2be5804">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div>
<div class="line">                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword">      </span>{</div>
<div class="line">        (void)component;</div>
<div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0,</div>
<div class="line">               <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Invalid operation for a scalar function.&quot;</span>));</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((dim == 2) || (dim == 3), <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> source_centers[3] = {</div>
<div class="line">          (dim == 2 ? <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(.3, .1) : <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(.3, .5, .1)),</div>
<div class="line">          (dim == 2 ? <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(.45, .1) : <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(.45, .5, .1)),</div>
<div class="line">          (dim == 2 ? <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(.75, .1) : <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(.75, .5, .1))};</div>
<div class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> source_radius = (dim == 2 ? 1. / 32 : 1. / 8);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> ((source_centers[0].distance(p) &lt; source_radius) ||</div>
<div class="line">                    (source_centers[1].<a class="code" href="classPoint.html#a3df8e6ab311dab9337c8d7b039c7b815">distance</a>(p) &lt; source_radius) ||</div>
<div class="line">                    (source_centers[2].distance(p) &lt; source_radius) ?</div>
<div class="line">                  1 :</div>
<div class="line">                  0);</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div>
<div class="line">                                <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  value)<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword">      </span>{</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div>
<div class="line">          <a class="code" href="namespaceinternal.html#aa5bef221c94bc6b9c5441c306a72cdbaa2063c1608d6e0baf80249c42e2be5804">value</a>(c) = TemperatureRightHandSide&lt;dim&gt;::value(p, c);</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line">  } <span class="comment">// namespace EquationData</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">namespace </span>LinearSolvers</div>
<div class="line">  {</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div>
<div class="line">    <span class="keyword">class </span>InverseMatrix : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">      InverseMatrix(<span class="keyword">const</span> MatrixType &amp;        m,</div>
<div class="line">                    <span class="keyword">const</span> PreconditionerType &amp;preconditioner);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">      <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div>
<div class="line">      <span class="keywordtype">void</span> vmult(VectorType &amp;dst, <span class="keyword">const</span> VectorType &amp;src) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const MatrixType&gt;</a> <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>;</div>
<div class="line">      <span class="keyword">const</span> PreconditionerType &amp;           preconditioner;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div>
<div class="line">    InverseMatrix&lt;MatrixType, PreconditionerType&gt;::InverseMatrix(</div>
<div class="line">      <span class="keyword">const</span> MatrixType &amp;        m,</div>
<div class="line">      <span class="keyword">const</span> PreconditionerType &amp;preconditioner)</div>
<div class="line">      : <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>(&amp;m)</div>
<div class="line">      , preconditioner(preconditioner)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div>
<div class="line">    <span class="keywordtype">void</span> InverseMatrix&lt;MatrixType, PreconditionerType&gt;::vmult(</div>
<div class="line">      VectorType &amp;      dst,</div>
<div class="line">      <span class="keyword">const</span> VectorType &amp;src)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a>        solver_control(src.size(), 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-7 * src.l2_norm());</div>
<div class="line">      <a class="code" href="classSolverCG.html">SolverCG&lt;VectorType&gt;</a> cg(solver_control);</div>
<div class="line"> </div>
<div class="line">      dst = 0;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">try</span></div>
<div class="line">        {</div>
<div class="line">          cg.solve(*<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, dst, src, preconditioner);</div>
<div class="line">        }</div>
<div class="line">      <span class="keywordflow">catch</span> (std::exception &amp;<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>)</div>
<div class="line">        {</div>
<div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>.what()));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div>
<div class="line">    <span class="keyword">class </span>BlockSchurPreconditioner : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">      BlockSchurPreconditioner(</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;S,</div>
<div class="line">        <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a>,</div>
<div class="line">                            PreconditionerTypeMp&gt; &amp;Mpinv,</div>
<div class="line">        <span class="keyword">const</span> PreconditionerTypeA &amp;                Apreconditioner);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">void</span> vmult(<a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;      dst,</div>
<div class="line">                 <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;src) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const TrilinosWrappers::BlockSparseMatrix&gt;</a></div>
<div class="line">        stokes_matrix;</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer</a>&lt;<span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="namespaceLinearAlgebraDealII.html#a912abe2208022aec6753876bcc72f6bf">TrilinosWrappers::SparseMatrix</a>,</div>
<div class="line">                                             PreconditionerTypeMp&gt;&gt;</div>
<div class="line">                                 m_inverse;</div>
<div class="line">      <span class="keyword">const</span> PreconditionerTypeA &amp;a_preconditioner;</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">mutable</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> tmp;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div>
<div class="line">    BlockSchurPreconditioner&lt;PreconditionerTypeA, PreconditionerTypeMp&gt;::</div>
<div class="line">      BlockSchurPreconditioner(</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;S,</div>
<div class="line">        <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a>,</div>
<div class="line">                            PreconditionerTypeMp&gt; &amp;Mpinv,</div>
<div class="line">        <span class="keyword">const</span> PreconditionerTypeA &amp;                Apreconditioner)</div>
<div class="line">      : stokes_matrix(&amp;S)</div>
<div class="line">      , m_inverse(&amp;Mpinv)</div>
<div class="line">      , a_preconditioner(Apreconditioner)</div>
<div class="line">      , tmp(<a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(stokes_matrix-&gt;block(1, 1).m()))</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    BlockSchurPreconditioner&lt;PreconditionerTypeA, PreconditionerTypeMp&gt;::vmult(</div>
<div class="line">      <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;      dst,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;src)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      a_preconditioner.vmult(dst.<a class="code" href="group__Exceptions.html#gae05a0e26814f032473ed2ef66da018bd">block</a>(0), src.<a class="code" href="group__Exceptions.html#gae05a0e26814f032473ed2ef66da018bd">block</a>(0));</div>
<div class="line">      stokes_matrix-&gt;block(1, 0).residual(tmp, dst.<a class="code" href="group__Exceptions.html#gae05a0e26814f032473ed2ef66da018bd">block</a>(0), src.<a class="code" href="group__Exceptions.html#gae05a0e26814f032473ed2ef66da018bd">block</a>(1));</div>
<div class="line">      tmp *= -1;</div>
<div class="line">      m_inverse-&gt;vmult(dst.<a class="code" href="group__Exceptions.html#gae05a0e26814f032473ed2ef66da018bd">block</a>(1), tmp);</div>
<div class="line">    }</div>
<div class="line">  } <span class="comment">// namespace LinearSolvers</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keyword">class </span>BoussinesqFlowProblem</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    BoussinesqFlowProblem();</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span>   setup_dofs();</div>
<div class="line">    <span class="keywordtype">void</span>   assemble_stokes_preconditioner();</div>
<div class="line">    <span class="keywordtype">void</span>   build_stokes_preconditioner();</div>
<div class="line">    <span class="keywordtype">void</span>   assemble_stokes_system();</div>
<div class="line">    <span class="keywordtype">void</span>   assemble_temperature_system(<span class="keyword">const</span> <span class="keywordtype">double</span> maximal_velocity);</div>
<div class="line">    <span class="keywordtype">void</span>   assemble_temperature_matrix();</div>
<div class="line">    <span class="keywordtype">double</span> get_maximal_velocity() <span class="keyword">const</span>;</div>
<div class="line">    std::pair&lt;double, double&gt; get_extrapolated_temperature_range() <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">void</span>                      solve();</div>
<div class="line">    <span class="keywordtype">void</span>                      output_results() <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">void</span>                      refine_mesh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_grid_level);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> compute_viscosity(</div>
<div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_temperature,</div>
<div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_temperature,</div>
<div class="line">      <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_temperature_grads,</div>
<div class="line">      <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_temperature_grads,</div>
<div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_temperature_laplacians,</div>
<div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_temperature_laplacians,</div>
<div class="line">      <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_velocity_values,</div>
<div class="line">      <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_velocity_values,</div>
<div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        gamma_values,</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_u_infty,</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_T_variation,</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                       cell_diameter) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div>
<div class="line">    <span class="keywordtype">double</span>             global_Omega_diameter;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        stokes_degree;</div>
<div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>             stokes_fe;</div>
<div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           stokes_dof_handler;</div>
<div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> stokes_constraints;</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;IndexSet&gt;               stokes_partitioning;</div>
<div class="line">    <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> stokes_matrix;</div>
<div class="line">    <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> stokes_preconditioner_matrix;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> stokes_solution;</div>
<div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> old_stokes_solution;</div>
<div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> stokes_rhs;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        temperature_degree;</div>
<div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>                 temperature_fe;</div>
<div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           temperature_dof_handler;</div>
<div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> temperature_constraints;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a> temperature_mass_matrix;</div>
<div class="line">    <a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a> temperature_stiffness_matrix;</div>
<div class="line">    <a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a> temperature_matrix;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> temperature_solution;</div>
<div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_temperature_solution;</div>
<div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_old_temperature_solution;</div>
<div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> temperature_rhs;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span>       time_step;</div>
<div class="line">    <span class="keywordtype">double</span>       old_time_step;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div>
<div class="line"> </div>
<div class="line">    std::shared_ptr&lt;TrilinosWrappers::PreconditionAMG&gt; Amg_preconditioner;</div>
<div class="line">    std::shared_ptr&lt;TrilinosWrappers::PreconditionIC&gt;  Mp_preconditioner;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> rebuild_stokes_matrix;</div>
<div class="line">    <span class="keywordtype">bool</span> rebuild_temperature_matrices;</div>
<div class="line">    <span class="keywordtype">bool</span> rebuild_stokes_preconditioner;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  BoussinesqFlowProblem&lt;dim&gt;::BoussinesqFlowProblem()</div>
<div class="line">    : <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::maximum_smoothing)</div>
<div class="line">    , global_Omega_diameter(std::numeric_limits&lt;<a class="code" href="classdouble.html">double</a>&gt;::quiet_NaN())</div>
<div class="line">    , stokes_degree(1)</div>
<div class="line">    , stokes_fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(stokes_degree + 1), dim, <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(stokes_degree), 1)</div>
<div class="line">    , stokes_dof_handler(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>)</div>
<div class="line">    ,</div>
<div class="line"> </div>
<div class="line">    temperature_degree(2)</div>
<div class="line">    , temperature_fe(temperature_degree)</div>
<div class="line">    , temperature_dof_handler(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>)</div>
<div class="line">    ,</div>
<div class="line"> </div>
<div class="line">    time_step(0)</div>
<div class="line">    , old_time_step(0)</div>
<div class="line">    , timestep_number(0)</div>
<div class="line">    , rebuild_stokes_matrix(true)</div>
<div class="line">    , rebuild_temperature_matrices(true)</div>
<div class="line">    , rebuild_stokes_preconditioner(true)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">double</span> BoussinesqFlowProblem&lt;dim&gt;::get_maximal_velocity()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classQIterated.html">QIterated&lt;dim&gt;</a> quadrature_formula(<a class="code" href="classQTrapezoid.html">QTrapezoid&lt;1&gt;</a>(), stokes_degree + 1);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points = quadrature_formula.size();</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(stokes_fe, quadrature_formula, <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div>
<div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; velocity_values(n_q_points);</div>
<div class="line">    <span class="keywordtype">double</span>                      max_velocity = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : stokes_dof_handler.active_cell_iterators())</div>
<div class="line">      {</div>
<div class="line">        fe_values.reinit(cell);</div>
<div class="line">        fe_values[velocities].get_function_values(stokes_solution,</div>
<div class="line">                                                  velocity_values);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div>
<div class="line">          max_velocity = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_velocity, velocity_values[q].<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>());</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> max_velocity;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  std::pair&lt;double, double&gt;</div>
<div class="line">  BoussinesqFlowProblem&lt;dim&gt;::get_extrapolated_temperature_range()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classQIterated.html">QIterated&lt;dim&gt;</a> quadrature_formula(<a class="code" href="classQTrapezoid.html">QTrapezoid&lt;1&gt;</a>(),</div>
<div class="line">                                            temperature_degree);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points = quadrature_formula.size();</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(temperature_fe, quadrature_formula, <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div>
<div class="line">    std::vector&lt;double&gt; old_temperature_values(n_q_points);</div>
<div class="line">    std::vector&lt;double&gt; old_old_temperature_values(n_q_points);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (timestep_number != 0)</div>
<div class="line">      {</div>
<div class="line">        <span class="keywordtype">double</span> min_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div>
<div class="line">               max_temperature = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : temperature_dof_handler.active_cell_iterators())</div>
<div class="line">          {</div>
<div class="line">            fe_values.reinit(cell);</div>
<div class="line">            fe_values.get_function_values(old_temperature_solution,</div>
<div class="line">                                          old_temperature_values);</div>
<div class="line">            fe_values.get_function_values(old_old_temperature_solution,</div>
<div class="line">                                          old_old_temperature_values);</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div>
<div class="line">              {</div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> temperature =</div>
<div class="line">                  (1. + time_step / old_time_step) * old_temperature_values[q] -</div>
<div class="line">                  time_step / old_time_step * old_old_temperature_values[q];</div>
<div class="line"> </div>
<div class="line">                min_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_temperature, temperature);</div>
<div class="line">                max_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_temperature, temperature);</div>
<div class="line">              }</div>
<div class="line">          }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> std::make_pair(min_temperature, max_temperature);</div>
<div class="line">      }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">      {</div>
<div class="line">        <span class="keywordtype">double</span> min_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div>
<div class="line">               max_temperature = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : temperature_dof_handler.active_cell_iterators())</div>
<div class="line">          {</div>
<div class="line">            fe_values.reinit(cell);</div>
<div class="line">            fe_values.get_function_values(old_temperature_solution,</div>
<div class="line">                                          old_temperature_values);</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div>
<div class="line">              {</div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> temperature = old_temperature_values[q];</div>
<div class="line"> </div>
<div class="line">                min_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_temperature, temperature);</div>
<div class="line">                max_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_temperature, temperature);</div>
<div class="line">              }</div>
<div class="line">          }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> std::make_pair(min_temperature, max_temperature);</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">double</span> BoussinesqFlowProblem&lt;dim&gt;::compute_viscosity(</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_temperature,</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_temperature,</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_temperature_grads,</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_temperature_grads,</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_temperature_laplacians,</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_temperature_laplacians,</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_velocity_values,</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_velocity_values,</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        gamma_values,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_u_infty,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_T_variation,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                       cell_diameter)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    constexpr <span class="keywordtype">double</span> beta  = 0.017 * dim;</div>
<div class="line">    constexpr <span class="keywordtype">double</span> alpha = 1.0;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (global_u_infty == 0)</div>
<div class="line">      <span class="keywordflow">return</span> 5<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-3 * cell_diameter;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = old_temperature.size();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> max_residual = 0;</div>
<div class="line">    <span class="keywordtype">double</span> max_velocity = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div>
<div class="line">      {</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> u =</div>
<div class="line">          (old_velocity_values[q] + old_old_velocity_values[q]) / 2;</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> dT_dt =</div>
<div class="line">          (old_temperature[q] - old_old_temperature[q]) / old_time_step;</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> u_grad_T =</div>
<div class="line">          u * (old_temperature_grads[q] + old_old_temperature_grads[q]) / 2;</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> kappa_Delta_T =</div>
<div class="line">          EquationData::kappa *</div>
<div class="line">          (old_temperature_laplacians[q] + old_old_temperature_laplacians[q]) /</div>
<div class="line">          2;</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> residual =</div>
<div class="line">          <a class="code" href="numbers_8h.html#a0ebae11c64606a73e80a6328b1ab0802">std::abs</a>((dT_dt + u_grad_T - kappa_Delta_T - gamma_values[q]) *</div>
<div class="line">                   std::pow((old_temperature[q] + old_old_temperature[q]) / 2,</div>
<div class="line">                            alpha - 1.));</div>
<div class="line"> </div>
<div class="line">        max_residual = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(residual, max_residual);</div>
<div class="line">        max_velocity = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(std::sqrt(u * u), max_velocity);</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> c_R            = <a class="code" href="numbers_8h.html#af44aee1db5cdcd0bab54e3c011d2be66">std::pow</a>(2., (4. - 2 * alpha) / dim);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> global_scaling = c_R * global_u_infty * global_T_variation *</div>
<div class="line">                                  <a class="code" href="numbers_8h.html#af44aee1db5cdcd0bab54e3c011d2be66">std::pow</a>(global_Omega_diameter, alpha - 2.);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> (</div>
<div class="line">      beta * max_velocity *</div>
<div class="line">      <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(cell_diameter,</div>
<div class="line">               std::pow(cell_diameter, alpha) * max_residual / global_scaling));</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::setup_dofs()</div>
<div class="line">  {</div>
<div class="line">    std::vector&lt;unsigned int&gt; stokes_sub_blocks(dim + 1, 0);</div>
<div class="line">    stokes_sub_blocks[dim] = 1;</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">      stokes_dof_handler.distribute_dofs(stokes_fe);</div>
<div class="line">      <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(stokes_dof_handler, stokes_sub_blocks);</div>
<div class="line"> </div>
<div class="line">      stokes_constraints.clear();</div>
<div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(stokes_dof_handler,</div>
<div class="line">                                              stokes_constraints);</div>
<div class="line">      std::set&lt;types::boundary_id&gt; no_normal_flux_boundaries;</div>
<div class="line">      no_normal_flux_boundaries.insert(0);</div>
<div class="line">      <a class="code" href="group__constraints.html#ga0d16c332aaa652e8905a6f48208e4500">VectorTools::compute_no_normal_flux_constraints</a>(stokes_dof_handler,</div>
<div class="line">                                                      0,</div>
<div class="line">                                                      no_normal_flux_boundaries,</div>
<div class="line">                                                      stokes_constraints);</div>
<div class="line">      stokes_constraints.close();</div>
<div class="line">    }</div>
<div class="line">    {</div>
<div class="line">      temperature_dof_handler.distribute_dofs(temperature_fe);</div>
<div class="line"> </div>
<div class="line">      temperature_constraints.clear();</div>
<div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(temperature_dof_handler,</div>
<div class="line">                                              temperature_constraints);</div>
<div class="line">      temperature_constraints.close();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; stokes_dofs_per_block =</div>
<div class="line">      <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(stokes_dof_handler, stokes_sub_blocks);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = stokes_dofs_per_block[0],</div>
<div class="line">                       n_p = stokes_dofs_per_block[1],</div>
<div class="line">                       n_T = temperature_dof_handler.n_dofs();</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.n_active_cells()</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot; (on &quot;</span> &lt;&lt; <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.n_levels() &lt;&lt; <span class="stringliteral">&quot; levels)&quot;</span> &lt;&lt; std::endl</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; n_u + n_p + n_T &lt;&lt; <span class="stringliteral">&quot; (&quot;</span></div>
<div class="line">              &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_T &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl</div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    stokes_partitioning.resize(2);</div>
<div class="line">    stokes_partitioning[0] = <a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(n_u);</div>
<div class="line">    stokes_partitioning[1] = <a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(n_p);</div>
<div class="line">    {</div>
<div class="line">      stokes_matrix.clear();</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(2, 2);</div>
<div class="line"> </div>
<div class="line">      dsp.block(0, 0).reinit(n_u, n_u);</div>
<div class="line">      dsp.block(0, 1).reinit(n_u, n_p);</div>
<div class="line">      dsp.block(1, 0).reinit(n_p, n_u);</div>
<div class="line">      dsp.block(1, 1).reinit(n_p, n_p);</div>
<div class="line"> </div>
<div class="line">      dsp.collect_sizes();</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div>
<div class="line">          <span class="keywordflow">if</span> (!((c == dim) &amp;&amp; (<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> == dim)))</div>
<div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div>
<div class="line">          <span class="keywordflow">else</span></div>
<div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div>
<div class="line">        stokes_dof_handler, coupling, dsp, stokes_constraints, <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">      stokes_matrix.reinit(dsp);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">      Amg_preconditioner.reset();</div>
<div class="line">      Mp_preconditioner.reset();</div>
<div class="line">      stokes_preconditioner_matrix.clear();</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(2, 2);</div>
<div class="line"> </div>
<div class="line">      dsp.block(0, 0).reinit(n_u, n_u);</div>
<div class="line">      dsp.block(0, 1).reinit(n_u, n_p);</div>
<div class="line">      dsp.block(1, 0).reinit(n_p, n_u);</div>
<div class="line">      dsp.block(1, 1).reinit(n_p, n_p);</div>
<div class="line"> </div>
<div class="line">      dsp.collect_sizes();</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div>
<div class="line">          <span class="keywordflow">if</span> (c == <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div>
<div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div>
<div class="line">          <span class="keywordflow">else</span></div>
<div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div>
<div class="line">        stokes_dof_handler, coupling, dsp, stokes_constraints, <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">      stokes_preconditioner_matrix.reinit(dsp);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">      temperature_mass_matrix.clear();</div>
<div class="line">      temperature_stiffness_matrix.clear();</div>
<div class="line">      temperature_matrix.clear();</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(n_T, n_T);</div>
<div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(temperature_dof_handler,</div>
<div class="line">                                      dsp,</div>
<div class="line">                                      temperature_constraints,</div>
<div class="line">                                      <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">      temperature_matrix.reinit(dsp);</div>
<div class="line">      temperature_mass_matrix.reinit(temperature_matrix);</div>
<div class="line">      temperature_stiffness_matrix.reinit(temperature_matrix);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> temperature_partitioning = <a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(n_T);</div>
<div class="line">    stokes_solution.reinit(stokes_partitioning, MPI_COMM_WORLD);</div>
<div class="line">    old_stokes_solution.reinit(stokes_partitioning, MPI_COMM_WORLD);</div>
<div class="line">    stokes_rhs.reinit(stokes_partitioning, MPI_COMM_WORLD);</div>
<div class="line"> </div>
<div class="line">    temperature_solution.reinit(temperature_partitioning, MPI_COMM_WORLD);</div>
<div class="line">    old_temperature_solution.reinit(temperature_partitioning, MPI_COMM_WORLD);</div>
<div class="line">    old_old_temperature_solution.reinit(temperature_partitioning,</div>
<div class="line">                                        MPI_COMM_WORLD);</div>
<div class="line"> </div>
<div class="line">    temperature_rhs.reinit(temperature_partitioning, MPI_COMM_WORLD);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_stokes_preconditioner()</div>
<div class="line">  {</div>
<div class="line">    stokes_preconditioner_matrix = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(stokes_degree + 2);</div>
<div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     stokes_fe_values(stokes_fe,</div>
<div class="line">                                   quadrature_formula,</div>
<div class="line">                                   <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div>
<div class="line">                                     <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = stokes_fe.n_dofs_per_cell();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.size();</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div>
<div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;Tensor&lt;2, dim&gt;&gt; grad_phi_u(dofs_per_cell);</div>
<div class="line">    std::vector&lt;double&gt;         phi_p(dofs_per_cell);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : stokes_dof_handler.active_cell_iterators())</div>
<div class="line">      {</div>
<div class="line">        stokes_fe_values.reinit(cell);</div>
<div class="line">        local_matrix = 0;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div>
<div class="line">          {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div>
<div class="line">              {</div>
<div class="line">                grad_phi_u[k] = stokes_fe_values[velocities].gradient(k, q);</div>
<div class="line">                phi_p[k]      = stokes_fe_values[pressure].value(k, q);</div>
<div class="line">              }</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div>
<div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div>
<div class="line">                local_matrix(i, j) +=</div>
<div class="line">                  (EquationData::eta *</div>
<div class="line">                     <a class="code" href="classSymmetricTensor.html#ab14ac27fc9ab74d4de531698b492d8de">scalar_product</a>(grad_phi_u[i], grad_phi_u[j]) +</div>
<div class="line">                   (1. / EquationData::eta) * phi_p[i] * phi_p[j]) *</div>
<div class="line">                  stokes_fe_values.JxW(q);</div>
<div class="line">          }</div>
<div class="line"> </div>
<div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div>
<div class="line">        stokes_constraints.distribute_local_to_global(</div>
<div class="line">          local_matrix, local_dof_indices, stokes_preconditioner_matrix);</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::build_stokes_preconditioner()</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> (rebuild_stokes_preconditioner == <span class="keyword">false</span>)</div>
<div class="line">      <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Rebuilding Stokes preconditioner...&quot;</span> &lt;&lt; std::flush;</div>
<div class="line"> </div>
<div class="line">    assemble_stokes_preconditioner();</div>
<div class="line"> </div>
<div class="line">    Amg_preconditioner = std::make_shared&lt;TrilinosWrappers::PreconditionAMG&gt;();</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;std::vector&lt;bool&gt;&gt; constant_modes;</div>
<div class="line">    <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a>     velocity_components(0);</div>
<div class="line">    <a class="code" href="namespaceDoFTools.html#afc96893388fe1a55c6ae5ae19ba52c6d">DoFTools::extract_constant_modes</a>(stokes_dof_handler,</div>
<div class="line">                                     stokes_fe.component_mask(</div>
<div class="line">                                       velocity_components),</div>
<div class="line">                                     constant_modes);</div>
<div class="line">    <a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html">TrilinosWrappers::PreconditionAMG::AdditionalData</a> amg_data;</div>
<div class="line">    amg_data.<a class="code" href="group__TrilinosWrappers.html#ga133c7bf7e618aaab51cd84214b731532">constant_modes</a> = constant_modes;</div>
<div class="line"> </div>
<div class="line">    amg_data.<a class="code" href="group__TrilinosWrappers.html#ga852e93b85f68573cd0eedfe62c0f6bdc">elliptic</a>              = <span class="keyword">true</span>;</div>
<div class="line">    amg_data.<a class="code" href="group__TrilinosWrappers.html#ga8bb24e061826fbdfb49aeb24f80e02fd">higher_order_elements</a> = <span class="keyword">true</span>;</div>
<div class="line">    amg_data.<a class="code" href="group__TrilinosWrappers.html#ga7bcc5fa85afdb96d90416e7bf182edd0">smoother_sweeps</a>       = 2;</div>
<div class="line">    amg_data.<a class="code" href="group__TrilinosWrappers.html#ga36b8fa00a7ce0a5ed1ab0cddd41e4f9f">aggregation_threshold</a> = 0.02;</div>
<div class="line">    Amg_preconditioner-&gt;initialize(stokes_preconditioner_matrix.block(0, 0),</div>
<div class="line">                                   amg_data);</div>
<div class="line"> </div>
<div class="line">    Mp_preconditioner = std::make_shared&lt;TrilinosWrappers::PreconditionIC&gt;();</div>
<div class="line">    Mp_preconditioner-&gt;initialize(stokes_preconditioner_matrix.block(1, 1));</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    rebuild_stokes_preconditioner = <span class="keyword">false</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_stokes_system()</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Assembling...&quot;</span> &lt;&lt; std::flush;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (rebuild_stokes_matrix == <span class="keyword">true</span>)</div>
<div class="line">      stokes_matrix = 0;</div>
<div class="line"> </div>
<div class="line">    stokes_rhs = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(stokes_degree + 2);</div>
<div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     stokes_fe_values(</div>
<div class="line">      stokes_fe,</div>
<div class="line">      quadrature_formula,</div>
<div class="line">      <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div>
<div class="line">        (rebuild_stokes_matrix == <span class="keyword">true</span> ? <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> : <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>(0)));</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> temperature_fe_values(temperature_fe,</div>
<div class="line">                                        quadrature_formula,</div>
<div class="line">                                        <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = stokes_fe.n_dofs_per_cell();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.size();</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div>
<div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     local_rhs(dofs_per_cell);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;double&gt; old_temperature_values(n_q_points);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt;          phi_u(dofs_per_cell);</div>
<div class="line">    std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; grads_phi_u(dofs_per_cell);</div>
<div class="line">    std::vector&lt;double&gt;                  div_phi_u(dofs_per_cell);</div>
<div class="line">    std::vector&lt;double&gt;                  phi_p(dofs_per_cell);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span>       cell             = stokes_dof_handler.begin_active();</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> endc             = stokes_dof_handler.end();</div>
<div class="line">    <span class="keyword">auto</span>       temperature_cell = temperature_dof_handler.begin_active();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (; cell != endc; ++cell, ++temperature_cell)</div>
<div class="line">      {</div>
<div class="line">        stokes_fe_values.reinit(cell);</div>
<div class="line">        temperature_fe_values.reinit(temperature_cell);</div>
<div class="line"> </div>
<div class="line">        local_matrix = 0;</div>
<div class="line">        local_rhs    = 0;</div>
<div class="line"> </div>
<div class="line">        temperature_fe_values.get_function_values(old_temperature_solution,</div>
<div class="line">                                                  old_temperature_values);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div>
<div class="line">          {</div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> old_temperature = old_temperature_values[q];</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div>
<div class="line">              {</div>
<div class="line">                phi_u[k] = stokes_fe_values[velocities].value(k, q);</div>
<div class="line">                <span class="keywordflow">if</span> (rebuild_stokes_matrix)</div>
<div class="line">                  {</div>
<div class="line">                    grads_phi_u[k] =</div>
<div class="line">                      stokes_fe_values[velocities].symmetric_gradient(k, q);</div>
<div class="line">                    div_phi_u[k] =</div>
<div class="line">                      stokes_fe_values[velocities].divergence(k, q);</div>
<div class="line">                    phi_p[k] = stokes_fe_values[pressure].value(k, q);</div>
<div class="line">                  }</div>
<div class="line">              }</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (rebuild_stokes_matrix)</div>
<div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div>
<div class="line">                  local_matrix(i, j) +=</div>
<div class="line">                    (EquationData::eta * 2 * (grads_phi_u[i] * grads_phi_u[j]) -</div>
<div class="line">                     div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j]) *</div>
<div class="line">                    stokes_fe_values.JxW(q);</div>
<div class="line"> </div>
<div class="line">            <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> gravity =</div>
<div class="line">              -((dim == 2) ? (<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0, 1)) : (<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0, 0, 1)));</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div>
<div class="line">              local_rhs(i) += (-EquationData::density * EquationData::beta *</div>
<div class="line">                               gravity * phi_u[i] * old_temperature) *</div>
<div class="line">                              stokes_fe_values.JxW(q);</div>
<div class="line">          }</div>
<div class="line"> </div>
<div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (rebuild_stokes_matrix == <span class="keyword">true</span>)</div>
<div class="line">          stokes_constraints.distribute_local_to_global(local_matrix,</div>
<div class="line">                                                        local_rhs,</div>
<div class="line">                                                        local_dof_indices,</div>
<div class="line">                                                        stokes_matrix,</div>
<div class="line">                                                        stokes_rhs);</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">          stokes_constraints.distribute_local_to_global(local_rhs,</div>
<div class="line">                                                        local_dof_indices,</div>
<div class="line">                                                        stokes_rhs);</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">    rebuild_stokes_matrix = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_temperature_matrix()</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> (rebuild_temperature_matrices == <span class="keyword">false</span>)</div>
<div class="line">      <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">    temperature_mass_matrix      = 0;</div>
<div class="line">    temperature_stiffness_matrix = 0;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>   quadrature_formula(temperature_degree + 2);</div>
<div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> temperature_fe_values(temperature_fe,</div>
<div class="line">                                        quadrature_formula,</div>
<div class="line">                                        <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div>
<div class="line">                                          <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = temperature_fe.n_dofs_per_cell();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.size();</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_mass_matrix(dofs_per_cell, dofs_per_cell);</div>
<div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_stiffness_matrix(dofs_per_cell, dofs_per_cell);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;double&gt;         phi_T(dofs_per_cell);</div>
<div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; grad_phi_T(dofs_per_cell);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : temperature_dof_handler.active_cell_iterators())</div>
<div class="line">      {</div>
<div class="line">        local_mass_matrix      = 0;</div>
<div class="line">        local_stiffness_matrix = 0;</div>
<div class="line"> </div>
<div class="line">        temperature_fe_values.reinit(cell);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div>
<div class="line">          {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div>
<div class="line">              {</div>
<div class="line">                grad_phi_T[k] = temperature_fe_values.shape_grad(k, q);</div>
<div class="line">                phi_T[k]      = temperature_fe_values.shape_value(k, q);</div>
<div class="line">              }</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div>
<div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div>
<div class="line">                {</div>
<div class="line">                  local_mass_matrix(i, j) +=</div>
<div class="line">                    (phi_T[i] * phi_T[j] * temperature_fe_values.JxW(q));</div>
<div class="line">                  local_stiffness_matrix(i, j) +=</div>
<div class="line">                    (EquationData::kappa * grad_phi_T[i] * grad_phi_T[j] *</div>
<div class="line">                     temperature_fe_values.JxW(q));</div>
<div class="line">                }</div>
<div class="line">          }</div>
<div class="line"> </div>
<div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div>
<div class="line"> </div>
<div class="line">        temperature_constraints.distribute_local_to_global(</div>
<div class="line">          local_mass_matrix, local_dof_indices, temperature_mass_matrix);</div>
<div class="line">        temperature_constraints.distribute_local_to_global(</div>
<div class="line">          local_stiffness_matrix,</div>
<div class="line">          local_dof_indices,</div>
<div class="line">          temperature_stiffness_matrix);</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">    rebuild_temperature_matrices = <span class="keyword">false</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_temperature_system(</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> maximal_velocity)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> use_bdf2_scheme = (timestep_number != 0);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (use_bdf2_scheme == <span class="keyword">true</span>)</div>
<div class="line">      {</div>
<div class="line">        temperature_matrix.copy_from(temperature_mass_matrix);</div>
<div class="line">        temperature_matrix *=</div>
<div class="line">          (2 * time_step + old_time_step) / (time_step + old_time_step);</div>
<div class="line">        temperature_matrix.add(time_step, temperature_stiffness_matrix);</div>
<div class="line">      }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">      {</div>
<div class="line">        temperature_matrix.copy_from(temperature_mass_matrix);</div>
<div class="line">        temperature_matrix.add(time_step, temperature_stiffness_matrix);</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">    temperature_rhs = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(temperature_degree + 2);</div>
<div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     temperature_fe_values(temperature_fe,</div>
<div class="line">                                        quadrature_formula,</div>
<div class="line">                                        <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div>
<div class="line">                                          <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a> |</div>
<div class="line">                                          <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div>
<div class="line">                                          <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     stokes_fe_values(stokes_fe,</div>
<div class="line">                                   quadrature_formula,</div>
<div class="line">                                   <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = temperature_fe.n_dofs_per_cell();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.size();</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> local_rhs(dofs_per_cell);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_velocity_values(n_q_points);</div>
<div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_old_velocity_values(n_q_points);</div>
<div class="line">    std::vector&lt;double&gt;         old_temperature_values(n_q_points);</div>
<div class="line">    std::vector&lt;double&gt;         old_old_temperature_values(n_q_points);</div>
<div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_temperature_grads(n_q_points);</div>
<div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_old_temperature_grads(n_q_points);</div>
<div class="line">    std::vector&lt;double&gt;         old_temperature_laplacians(n_q_points);</div>
<div class="line">    std::vector&lt;double&gt;         old_old_temperature_laplacians(n_q_points);</div>
<div class="line"> </div>
<div class="line">    EquationData::TemperatureRightHandSide&lt;dim&gt; temperature_right_hand_side;</div>
<div class="line">    std::vector&lt;double&gt;                         gamma_values(n_q_points);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;double&gt;         phi_T(dofs_per_cell);</div>
<div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; grad_phi_T(dofs_per_cell);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> std::pair&lt;double, double&gt; global_T_range =</div>
<div class="line">      get_extrapolated_temperature_range();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span>       cell        = temperature_dof_handler.begin_active();</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> endc        = temperature_dof_handler.end();</div>
<div class="line">    <span class="keyword">auto</span>       stokes_cell = stokes_dof_handler.begin_active();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (; cell != endc; ++cell, ++stokes_cell)</div>
<div class="line">      {</div>
<div class="line">        local_rhs = 0;</div>
<div class="line"> </div>
<div class="line">        temperature_fe_values.reinit(cell);</div>
<div class="line">        stokes_fe_values.reinit(stokes_cell);</div>
<div class="line"> </div>
<div class="line">        temperature_fe_values.get_function_values(old_temperature_solution,</div>
<div class="line">                                                  old_temperature_values);</div>
<div class="line">        temperature_fe_values.get_function_values(old_old_temperature_solution,</div>
<div class="line">                                                  old_old_temperature_values);</div>
<div class="line"> </div>
<div class="line">        temperature_fe_values.get_function_gradients(old_temperature_solution,</div>
<div class="line">                                                     old_temperature_grads);</div>
<div class="line">        temperature_fe_values.get_function_gradients(</div>
<div class="line">          old_old_temperature_solution, old_old_temperature_grads);</div>
<div class="line"> </div>
<div class="line">        temperature_fe_values.get_function_laplacians(</div>
<div class="line">          old_temperature_solution, old_temperature_laplacians);</div>
<div class="line">        temperature_fe_values.get_function_laplacians(</div>
<div class="line">          old_old_temperature_solution, old_old_temperature_laplacians);</div>
<div class="line"> </div>
<div class="line">        temperature_right_hand_side.value_list(</div>
<div class="line">          temperature_fe_values.get_quadrature_points(), gamma_values);</div>
<div class="line"> </div>
<div class="line">        stokes_fe_values[velocities].get_function_values(stokes_solution,</div>
<div class="line">                                                         old_velocity_values);</div>
<div class="line">        stokes_fe_values[velocities].get_function_values(</div>
<div class="line">          old_stokes_solution, old_old_velocity_values);</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> nu =</div>
<div class="line">          compute_viscosity(old_temperature_values,</div>
<div class="line">                            old_old_temperature_values,</div>
<div class="line">                            old_temperature_grads,</div>
<div class="line">                            old_old_temperature_grads,</div>
<div class="line">                            old_temperature_laplacians,</div>
<div class="line">                            old_old_temperature_laplacians,</div>
<div class="line">                            old_velocity_values,</div>
<div class="line">                            old_old_velocity_values,</div>
<div class="line">                            gamma_values,</div>
<div class="line">                            maximal_velocity,</div>
<div class="line">                            global_T_range.second - global_T_range.first,</div>
<div class="line">                            cell-&gt;diameter());</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div>
<div class="line">          {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div>
<div class="line">              {</div>
<div class="line">                grad_phi_T[k] = temperature_fe_values.shape_grad(k, q);</div>
<div class="line">                phi_T[k]      = temperature_fe_values.shape_value(k, q);</div>
<div class="line">              }</div>
<div class="line"> </div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> T_term_for_rhs =</div>
<div class="line">              (use_bdf2_scheme ?</div>
<div class="line">                 (old_temperature_values[q] * (1 + time_step / old_time_step) -</div>
<div class="line">                  old_old_temperature_values[q] * (time_step * time_step) /</div>
<div class="line">                    (old_time_step * (time_step + old_time_step))) :</div>
<div class="line">                 old_temperature_values[q]);</div>
<div class="line"> </div>
<div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> ext_grad_T =</div>
<div class="line">              (use_bdf2_scheme ?</div>
<div class="line">                 (old_temperature_grads[q] * (1 + time_step / old_time_step) -</div>
<div class="line">                  old_old_temperature_grads[q] * time_step / old_time_step) :</div>
<div class="line">                 old_temperature_grads[q]);</div>
<div class="line"> </div>
<div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> extrapolated_u =</div>
<div class="line">              (use_bdf2_scheme ?</div>
<div class="line">                 (old_velocity_values[q] * (1 + time_step / old_time_step) -</div>
<div class="line">                  old_old_velocity_values[q] * time_step / old_time_step) :</div>
<div class="line">                 old_velocity_values[q]);</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div>
<div class="line">              local_rhs(i) +=</div>
<div class="line">                (T_term_for_rhs * phi_T[i] -</div>
<div class="line">                 time_step * extrapolated_u * ext_grad_T * phi_T[i] -</div>
<div class="line">                 time_step * nu * ext_grad_T * grad_phi_T[i] +</div>
<div class="line">                 time_step * gamma_values[q] * phi_T[i]) *</div>
<div class="line">                temperature_fe_values.JxW(q);</div>
<div class="line">          }</div>
<div class="line"> </div>
<div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div>
<div class="line">        temperature_constraints.distribute_local_to_global(local_rhs,</div>
<div class="line">                                                           local_dof_indices,</div>
<div class="line">                                                           temperature_rhs);</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::solve()</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">const</span> LinearSolvers::InverseMatrix&lt;<a class="code" href="namespaceLinearAlgebraDealII.html#a912abe2208022aec6753876bcc72f6bf">TrilinosWrappers::SparseMatrix</a>,</div>
<div class="line">                                         <a class="code" href="classTrilinosWrappers_1_1PreconditionIC.html">TrilinosWrappers::PreconditionIC</a>&gt;</div>
<div class="line">        mp_inverse(stokes_preconditioner_matrix.block(1, 1),</div>
<div class="line">                   *Mp_preconditioner);</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">const</span> LinearSolvers::BlockSchurPreconditioner&lt;</div>
<div class="line">        <a class="code" href="namespaceLinearAlgebraPETSc_1_1MPI.html#a41f11f7a1992c6d6aa9367b12c68f791">TrilinosWrappers::PreconditionAMG</a>,</div>
<div class="line">        <a class="code" href="classTrilinosWrappers_1_1PreconditionIC.html">TrilinosWrappers::PreconditionIC</a>&gt;</div>
<div class="line">        preconditioner(stokes_matrix, mp_inverse, *Amg_preconditioner);</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(stokes_matrix.m(),</div>
<div class="line">                                   1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-6 * stokes_rhs.l2_norm());</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classSolverGMRES.html">SolverGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;</a> gmres(</div>
<div class="line">        solver_control,</div>
<div class="line">        <a class="code" href="structSolverGMRES_1_1AdditionalData.html">SolverGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;::AdditionalData</a>(100));</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; stokes_solution.size(); ++i)</div>
<div class="line">        <span class="keywordflow">if</span> (stokes_constraints.is_constrained(i))</div>
<div class="line">          stokes_solution(i) = 0;</div>
<div class="line"> </div>
<div class="line">      gmres.solve(stokes_matrix, stokes_solution, stokes_rhs, preconditioner);</div>
<div class="line"> </div>
<div class="line">      stokes_constraints.distribute(stokes_solution);</div>
<div class="line"> </div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; solver_control.last_step()</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot; GMRES iterations for Stokes subsystem.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    old_time_step                 = time_step;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> maximal_velocity = get_maximal_velocity();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (maximal_velocity &gt;= 0.01)</div>
<div class="line">      time_step = 1. / (1.7 * dim * <a class="code" href="numbers_8h.html#ac4a2ed1890a931d0b6a55933310eadca">std::sqrt</a>(1. * dim)) / temperature_degree *</div>
<div class="line">                  <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>) /</div>
<div class="line">                  maximal_velocity;</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">      time_step = 1. / (1.7 * dim * <a class="code" href="numbers_8h.html#ac4a2ed1890a931d0b6a55933310eadca">std::sqrt</a>(1. * dim)) / temperature_degree *</div>
<div class="line">                  <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>) / .01;</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span></div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;Time step: &quot;</span> &lt;&lt; time_step &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    temperature_solution = old_temperature_solution;</div>
<div class="line"> </div>
<div class="line">    assemble_temperature_system(maximal_velocity);</div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(temperature_matrix.m(),</div>
<div class="line">                                   1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8 * temperature_rhs.l2_norm());</div>
<div class="line">      <a class="code" href="classSolverCG.html">SolverCG&lt;TrilinosWrappers::MPI::Vector&gt;</a> cg(solver_control);</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classTrilinosWrappers_1_1PreconditionIC.html">TrilinosWrappers::PreconditionIC</a> preconditioner;</div>
<div class="line">      preconditioner.<a class="code" href="group__TrilinosWrappers.html#ga95eff1f8abcf2ba67815b6a96a66d375">initialize</a>(temperature_matrix);</div>
<div class="line"> </div>
<div class="line">      cg.solve(temperature_matrix,</div>
<div class="line">               temperature_solution,</div>
<div class="line">               temperature_rhs,</div>
<div class="line">               preconditioner);</div>
<div class="line"> </div>
<div class="line">      temperature_constraints.distribute(temperature_solution);</div>
<div class="line"> </div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; solver_control.last_step()</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot; CG iterations for temperature.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">double</span> min_temperature = temperature_solution(0),</div>
<div class="line">             max_temperature = temperature_solution(0);</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; temperature_solution.size(); ++i)</div>
<div class="line">        {</div>
<div class="line">          min_temperature =</div>
<div class="line">            std::min&lt;double&gt;(min_temperature, temperature_solution(i));</div>
<div class="line">          max_temperature =</div>
<div class="line">            std::max&lt;double&gt;(max_temperature, temperature_solution(i));</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   Temperature range: &quot;</span> &lt;&lt; min_temperature &lt;&lt; <span class="charliteral">&#39; &#39;</span></div>
<div class="line">                &lt;&lt; max_temperature &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keywordflow">if</span> (timestep_number % 10 != 0)</div>
<div class="line">      <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;std::string&gt; stokes_names(dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div>
<div class="line">    stokes_names.emplace_back(<span class="stringliteral">&quot;p&quot;</span>);</div>
<div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div>
<div class="line">      stokes_component_interpretation(</div>
<div class="line">        dim + 1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div>
<div class="line">      stokes_component_interpretation[i] =</div>
<div class="line">        <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div>
<div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a>(stokes_dof_handler,</div>
<div class="line">                             stokes_solution,</div>
<div class="line">                             stokes_names,</div>
<div class="line">                             stokes_component_interpretation);</div>
<div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a>(temperature_dof_handler,</div>
<div class="line">                             temperature_solution,</div>
<div class="line">                             <span class="stringliteral">&quot;T&quot;</span>);</div>
<div class="line">    data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(stokes_degree, temperature_degree));</div>
<div class="line"> </div>
<div class="line">    std::ofstream output(<span class="stringliteral">&quot;solution-&quot;</span> +</div>
<div class="line">                         <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_number, 4) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div>
<div class="line">    data_out.<a class="code" href="group__Exceptions.html#gacad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span></div>
<div class="line">  BoussinesqFlowProblem&lt;dim&gt;::refine_mesh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_grid_level)</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.n_active_cells());</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classKellyErrorEstimator.html#aa0917e696d4f8ddb983223a68c512357">KellyErrorEstimator&lt;dim&gt;::estimate</a>(temperature_dof_handler,</div>
<div class="line">                                       <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(temperature_degree + 1),</div>
<div class="line">                                       {},</div>
<div class="line">                                       temperature_solution,</div>
<div class="line">                                       estimated_error_per_cell);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="namespaceGridRefinement.html#ae90dc87c4db158b8d01f6d564ac614e5">GridRefinement::refine_and_coarsen_fixed_fraction</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>,</div>
<div class="line">                                                      estimated_error_per_cell,</div>
<div class="line">                                                      0.8,</div>
<div class="line">                                                      0.1);</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.n_levels() &gt; max_grid_level)</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell :</div>
<div class="line">           <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.active_cell_iterators_on_level(max_grid_level))</div>
<div class="line">        cell-&gt;clear_refine_flag();</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;TrilinosWrappers::MPI::Vector&gt; x_temperature(2);</div>
<div class="line">    x_temperature[0]                            = temperature_solution;</div>
<div class="line">    x_temperature[1]                            = old_temperature_solution;</div>
<div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> x_stokes = stokes_solution;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim, TrilinosWrappers::MPI::Vector&gt;</a> temperature_trans(</div>
<div class="line">      temperature_dof_handler);</div>
<div class="line">    <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim, TrilinosWrappers::MPI::BlockVector&gt;</a> stokes_trans(</div>
<div class="line">      stokes_dof_handler);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.prepare_coarsening_and_refinement();</div>
<div class="line">    temperature_trans.prepare_for_coarsening_and_refinement(x_temperature);</div>
<div class="line">    stokes_trans.prepare_for_coarsening_and_refinement(x_stokes);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.execute_coarsening_and_refinement();</div>
<div class="line">    setup_dofs();</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;TrilinosWrappers::MPI::Vector&gt; tmp(2);</div>
<div class="line">    tmp[0].reinit(temperature_solution);</div>
<div class="line">    tmp[1].reinit(temperature_solution);</div>
<div class="line">    temperature_trans.interpolate(x_temperature, tmp);</div>
<div class="line"> </div>
<div class="line">    temperature_solution     = tmp[0];</div>
<div class="line">    old_temperature_solution = tmp[1];</div>
<div class="line"> </div>
<div class="line">    temperature_constraints.distribute(temperature_solution);</div>
<div class="line">    temperature_constraints.distribute(old_temperature_solution);</div>
<div class="line"> </div>
<div class="line">    stokes_trans.interpolate(x_stokes, stokes_solution);</div>
<div class="line"> </div>
<div class="line">    stokes_constraints.distribute(stokes_solution);</div>
<div class="line"> </div>
<div class="line">    rebuild_stokes_matrix         = <span class="keyword">true</span>;</div>
<div class="line">    rebuild_temperature_matrices  = <span class="keyword">true</span>;</div>
<div class="line">    rebuild_stokes_preconditioner = <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">BoussinesqFlowProblem&lt;dim&gt;::run</a>()</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_refinement     = (dim == 2 ? 4 : 2);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_pre_refinement_steps = (dim == 2 ? 4 : 3);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>);</div>
<div class="line">    global_Omega_diameter = <a class="code" href="namespaceGridTools.html#acd5ccc543d561cfb086b571d1f7818cb">GridTools::diameter</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.refine_global(initial_refinement);</div>
<div class="line"> </div>
<div class="line">    setup_dofs();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pre_refinement_step = 0;</div>
<div class="line"> </div>
<div class="line">  start_time_iteration:</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a>(temperature_dof_handler,</div>
<div class="line">                         temperature_constraints,</div>
<div class="line">                         <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(temperature_degree + 2),</div>
<div class="line">                         EquationData::TemperatureInitialValues&lt;dim&gt;(),</div>
<div class="line">                         old_temperature_solution);</div>
<div class="line"> </div>
<div class="line">    timestep_number = 0;</div>
<div class="line">    time_step = old_time_step = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> time = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">do</span></div>
<div class="line">      {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Timestep &quot;</span> &lt;&lt; timestep_number &lt;&lt; <span class="stringliteral">&quot;:  t=&quot;</span> &lt;&lt; time</div>
<div class="line">                  &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">        assemble_stokes_system();</div>
<div class="line">        build_stokes_preconditioner();</div>
<div class="line">        assemble_temperature_matrix();</div>
<div class="line"> </div>
<div class="line">        solve();</div>
<div class="line"> </div>
<div class="line">        output_results();</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> ((timestep_number == 0) &amp;&amp;</div>
<div class="line">            (pre_refinement_step &lt; n_pre_refinement_steps))</div>
<div class="line">          {</div>
<div class="line">            refine_mesh(initial_refinement + n_pre_refinement_steps);</div>
<div class="line">            ++pre_refinement_step;</div>
<div class="line">            <span class="keywordflow">goto</span> start_time_iteration;</div>
<div class="line">          }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((timestep_number &gt; 0) &amp;&amp; (timestep_number % 5 == 0))</div>
<div class="line">          refine_mesh(initial_refinement + n_pre_refinement_steps);</div>
<div class="line"> </div>
<div class="line">        time += time_step;</div>
<div class="line">        ++timestep_number;</div>
<div class="line"> </div>
<div class="line">        old_stokes_solution          = stokes_solution;</div>
<div class="line">        old_old_temperature_solution = old_temperature_solution;</div>
<div class="line">        old_temperature_solution     = temperature_solution;</div>
<div class="line">      }</div>
<div class="line">    <span class="keywordflow">while</span> (time &lt;= 100);</div>
<div class="line">  }</div>
<div class="line">} <span class="comment">// namespace Step31</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
<div class="line">      <span class="keyword">using namespace </span>Step31;</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(</div>
<div class="line">        argc, argv, <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>);</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD) == 1,</div>
<div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div>
<div class="line">                    <span class="stringliteral">&quot;This program can only be run in serial, use ./step-31&quot;</span>));</div>
<div class="line"> </div>
<div class="line">      BoussinesqFlowProblem&lt;2&gt; flow_problem;</div>
<div class="line">      flow_problem.run();</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> 。 </p>
</li>
</ul>
</li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
