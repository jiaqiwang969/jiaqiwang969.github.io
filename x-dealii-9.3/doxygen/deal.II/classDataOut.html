<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classDataOut.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: DataOut&lt; dim, DoFHandlerType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.3.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.3.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classDataOut-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DataOut&lt; dim, DoFHandlerType &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__IO.html">Input/Output</a> &raquo; <a class="el" href="group__output.html">Graphical output</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="numerics_2data__out_8h_source.html">deal.II/numerics/data_out.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for DataOut&lt; dim, DoFHandlerType &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classDataOut__inherit__graph.svg" width="1508" height="98"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1303b5d99f10f3fae984e7d406cfeb37"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut.html#a1303b5d99f10f3fae984e7d406cfeb37">CurvedCellRegion</a> { <a class="el" href="classDataOut.html#a1303b5d99f10f3fae984e7d406cfeb37a48b3413706d5e705b001ab3874915903">no_curved_cells</a>
, <a class="el" href="classDataOut.html#a1303b5d99f10f3fae984e7d406cfeb37ade19577951156fc5d90fc1ab8685c219">curved_boundary</a>
, <a class="el" href="classDataOut.html#a1303b5d99f10f3fae984e7d406cfeb37a7f310f7608c5724c67300f6e9a8728c1">curved_inner_cells</a>
 }</td></tr>
<tr class="separator:a1303b5d99f10f3fae984e7d406cfeb37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a501c6b6a2ac9210e9f5742898908183c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut.html#a501c6b6a2ac9210e9f5742898908183c">cell_iterator</a> = typename <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; DoFHandlerType, DoFHandlerType::dimension, DoFHandlerType::space_dimension &gt;::<a class="el" href="classDataOut.html#a501c6b6a2ac9210e9f5742898908183c">cell_iterator</a></td></tr>
<tr class="separator:a501c6b6a2ac9210e9f5742898908183c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ecf9a434575409695befe41fe10196"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut.html#a94ecf9a434575409695befe41fe10196">FirstCellFunctionType</a> = typename std::function&lt; <a class="el" href="classDataOut.html#a501c6b6a2ac9210e9f5742898908183c">cell_iterator</a>(const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, <a class="el" href="classDataOut.html#a12aba32b2db70710325e468f6b8cebb7">spacedim</a> &gt; &amp;)&gt;</td></tr>
<tr class="separator:a94ecf9a434575409695befe41fe10196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827d3edc28fcc9dafdc149f2ae111990"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut.html#a827d3edc28fcc9dafdc149f2ae111990">NextCellFunctionType</a> = typename std::function&lt; <a class="el" href="classDataOut.html#a501c6b6a2ac9210e9f5742898908183c">cell_iterator</a>(const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, <a class="el" href="classDataOut.html#a12aba32b2db70710325e468f6b8cebb7">spacedim</a> &gt; &amp;, const <a class="el" href="classDataOut.html#a501c6b6a2ac9210e9f5742898908183c">cell_iterator</a> &amp;)&gt;</td></tr>
<tr class="separator:a827d3edc28fcc9dafdc149f2ae111990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062005bfe37e877e1f44e1c3e8e6cb27"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27">DataVectorType</a> </td></tr>
<tr class="separator:a062005bfe37e877e1f44e1c3e8e6cb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8de208d5d09c52f3438cc853385ee75c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut.html#a8de208d5d09c52f3438cc853385ee75c">DataOut</a> ()</td></tr>
<tr class="separator:a8de208d5d09c52f3438cc853385ee75c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb51872b8736849bb7e8d2007fae086"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a> (const unsigned int n_subdivisions=0)</td></tr>
<tr class="separator:a5eb51872b8736849bb7e8d2007fae086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991c9d3ecb57231c9cd2357c549ff8c3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut.html#a991c9d3ecb57231c9cd2357c549ff8c3">build_patches</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; DoFHandlerType::dimension, DoFHandlerType::space_dimension &gt; &amp;mapping, const unsigned int n_subdivisions=0, const <a class="el" href="classDataOut.html#a1303b5d99f10f3fae984e7d406cfeb37">CurvedCellRegion</a> curved_region=<a class="el" href="classDataOut.html#a1303b5d99f10f3fae984e7d406cfeb37ade19577951156fc5d90fc1ab8685c219">curved_boundary</a>)</td></tr>
<tr class="separator:a991c9d3ecb57231c9cd2357c549ff8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d491be143f2672b076622e7abd32b8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut.html#a04d491be143f2672b076622e7abd32b8">build_patches</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; DoFHandlerType::dimension, DoFHandlerType::space_dimension &gt; &amp;mapping, const unsigned int n_subdivisions=0, const <a class="el" href="classDataOut.html#a1303b5d99f10f3fae984e7d406cfeb37">CurvedCellRegion</a> curved_region=<a class="el" href="classDataOut.html#a1303b5d99f10f3fae984e7d406cfeb37ade19577951156fc5d90fc1ab8685c219">curved_boundary</a>)</td></tr>
<tr class="separator:a04d491be143f2672b076622e7abd32b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d12b73d53d98d9ec35d78ae89a9bd23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut.html#a5d12b73d53d98d9ec35d78ae89a9bd23">set_cell_selection</a> (const std::function&lt; <a class="el" href="classDataOut.html#a501c6b6a2ac9210e9f5742898908183c">cell_iterator</a>(const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, <a class="el" href="classDataOut.html#a12aba32b2db70710325e468f6b8cebb7">spacedim</a> &gt; &amp;)&gt; &amp;<a class="el" href="classDataOut.html#a1af7d4c3409e24acbcc4f8a1da4723e5">first_cell</a>, const std::function&lt; <a class="el" href="classDataOut.html#a501c6b6a2ac9210e9f5742898908183c">cell_iterator</a>(const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, <a class="el" href="classDataOut.html#a12aba32b2db70710325e468f6b8cebb7">spacedim</a> &gt; &amp;, const <a class="el" href="classDataOut.html#a501c6b6a2ac9210e9f5742898908183c">cell_iterator</a> &amp;)&gt; &amp;<a class="el" href="classDataOut.html#afdefbb966f2053f4c4fc52293d2339ce">next_cell</a>)</td></tr>
<tr class="separator:a5d12b73d53d98d9ec35d78ae89a9bd23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f06c6e1c03cbcc5b3090fa8dc41777"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut.html#a66f06c6e1c03cbcc5b3090fa8dc41777">set_cell_selection</a> (const <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classDataOut.html#a501c6b6a2ac9210e9f5742898908183c">cell_iterator</a> &gt; &amp;filtered_iterator)</td></tr>
<tr class="separator:a66f06c6e1c03cbcc5b3090fa8dc41777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c28d7579277c882ee6f6729c04f5803"><td class="memItemLeft" align="right" valign="top">const std::pair&lt; <a class="el" href="classDataOut.html#a94ecf9a434575409695befe41fe10196">FirstCellFunctionType</a>, <a class="el" href="classDataOut.html#a827d3edc28fcc9dafdc149f2ae111990">NextCellFunctionType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut.html#a6c28d7579277c882ee6f6729c04f5803">get_cell_selection</a> () const</td></tr>
<tr class="separator:a6c28d7579277c882ee6f6729c04f5803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af7d4c3409e24acbcc4f8a1da4723e5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classDataOut.html#a501c6b6a2ac9210e9f5742898908183c">cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut.html#a1af7d4c3409e24acbcc4f8a1da4723e5">first_cell</a> ()</td></tr>
<tr class="separator:a1af7d4c3409e24acbcc4f8a1da4723e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdefbb966f2053f4c4fc52293d2339ce"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classDataOut.html#a501c6b6a2ac9210e9f5742898908183c">cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut.html#afdefbb966f2053f4c4fc52293d2339ce">next_cell</a> (const <a class="el" href="classDataOut.html#a501c6b6a2ac9210e9f5742898908183c">cell_iterator</a> &amp;cell)</td></tr>
<tr class="separator:afdefbb966f2053f4c4fc52293d2339ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1eb26168177faa30ffbcf9cbb9c3cd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;)</td></tr>
<tr class="separator:ac1eb26168177faa30ffbcf9cbb9c3cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8d4fbc99c408d956c4685fd4c97b99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a0a8d4fbc99c408d956c4685fd4c97b99">attach_triangulation</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; DoFHandlerType::dimension, DoFHandlerType::space_dimension &gt; &amp;)</td></tr>
<tr class="separator:a0a8d4fbc99c408d956c4685fd4c97b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4b76e565ba0701c4d32c26075ed3b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (const VectorType &amp;data, const std::vector&lt; std::string &gt; &amp;names, const <a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27">DataVectorType</a> type=<a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27ad7189bcb96ade9f785a40b8959ac443e">type_automatic</a>, const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;data_component_interpretation=std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;())</td></tr>
<tr class="separator:ace4b76e565ba0701c4d32c26075ed3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f47f598ad14b15eb519350a2846432"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a65f47f598ad14b15eb519350a2846432">add_data_vector</a> (const VectorType &amp;data, const std::string &amp;name, const <a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27">DataVectorType</a> type=<a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27ad7189bcb96ade9f785a40b8959ac443e">type_automatic</a>, const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;data_component_interpretation=std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;())</td></tr>
<tr class="separator:a65f47f598ad14b15eb519350a2846432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bce7f46c9ad03ecdd71a86d47f8fb11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a4bce7f46c9ad03ecdd71a86d47f8fb11">add_data_vector</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;dof_handler, const VectorType &amp;data, const std::vector&lt; std::string &gt; &amp;names, const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;data_component_interpretation=std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;())</td></tr>
<tr class="separator:a4bce7f46c9ad03ecdd71a86d47f8fb11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ed745ab12b197a57cc5e22af0fcd8a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a5ed745ab12b197a57cc5e22af0fcd8a7">add_data_vector</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;dof_handler, const VectorType &amp;data, const std::string &amp;name, const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;data_component_interpretation=std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;())</td></tr>
<tr class="separator:a5ed745ab12b197a57cc5e22af0fcd8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6aa38d46f054f61211dbc02a16e384"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a4f6aa38d46f054f61211dbc02a16e384">add_data_vector</a> (const VectorType &amp;data, const <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; DoFHandlerType::space_dimension &gt; &amp;data_postprocessor)</td></tr>
<tr class="separator:a4f6aa38d46f054f61211dbc02a16e384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444344dcaaff07df72672b57001e1c27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a444344dcaaff07df72672b57001e1c27">add_data_vector</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;dof_handler, const VectorType &amp;data, const <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; DoFHandlerType::space_dimension &gt; &amp;data_postprocessor)</td></tr>
<tr class="separator:a444344dcaaff07df72672b57001e1c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f52f05c045de7fa390449c1ed339c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#ab1f52f05c045de7fa390449c1ed339c1">add_mg_data_vector</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;dof_handler, const <a class="el" href="classMGLevelObject.html">MGLevelObject</a>&lt; VectorType &gt; &amp;data, const std::vector&lt; std::string &gt; &amp;names, const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;data_component_interpretation=std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;())</td></tr>
<tr class="separator:ab1f52f05c045de7fa390449c1ed339c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c63ba80dac30bc2a18664a154d8e80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a90c63ba80dac30bc2a18664a154d8e80">add_mg_data_vector</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;dof_handler, const <a class="el" href="classMGLevelObject.html">MGLevelObject</a>&lt; VectorType &gt; &amp;data, const std::string &amp;name)</td></tr>
<tr class="separator:a90c63ba80dac30bc2a18664a154d8e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38df03770155948e7f702e14599e28e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a38df03770155948e7f702e14599e28e7">clear_data_vectors</a> ()</td></tr>
<tr class="separator:a38df03770155948e7f702e14599e28e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bda326e895cf4b1489d271cb358cfdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a1bda326e895cf4b1489d271cb358cfdd">clear_input_data_references</a> ()</td></tr>
<tr class="separator:a1bda326e895cf4b1489d271cb358cfdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d51e2c8ddb56ac1306927c502cd5983"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a4d51e2c8ddb56ac1306927c502cd5983">merge_patches</a> (const <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; DoFHandlerType2, patch_dim, patch_space_dim &gt; &amp;source, const <a class="el" href="classPoint.html">Point</a>&lt; patch_space_dim &gt; &amp;shift=<a class="el" href="classPoint.html">Point</a>&lt; patch_space_dim &gt;())</td></tr>
<tr class="separator:a4d51e2c8ddb56ac1306927c502cd5983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4769fe891f8d7f9caa1ba4f854484958"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a4769fe891f8d7f9caa1ba4f854484958">clear</a> ()</td></tr>
<tr class="separator:a4769fe891f8d7f9caa1ba4f854484958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af605c2840093a5f03e873153544da225"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#af605c2840093a5f03e873153544da225">memory_consumption</a> () const</td></tr>
<tr class="separator:af605c2840093a5f03e873153544da225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc05be5cd920b234e68548735852446e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gafc05be5cd920b234e68548735852446e">write_dx</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:gafc05be5cd920b234e68548735852446e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea2031a2a6fe56c9b7d3f9f338f20882"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaea2031a2a6fe56c9b7d3f9f338f20882">write_eps</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:gaea2031a2a6fe56c9b7d3f9f338f20882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7f2c3305058c94333d8aa699286b807"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gae7f2c3305058c94333d8aa699286b807">write_gmv</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:gae7f2c3305058c94333d8aa699286b807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85407e870a68179ebe62410d9efc153f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga85407e870a68179ebe62410d9efc153f">write_gnuplot</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:ga85407e870a68179ebe62410d9efc153f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33a15f01cb0171da2956be68ad496cd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga33a15f01cb0171da2956be68ad496cd0">write_povray</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:ga33a15f01cb0171da2956be68ad496cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga980b995a6f5944a75721097de39069c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga980b995a6f5944a75721097de39069c1">write_tecplot</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:ga980b995a6f5944a75721097de39069c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bf06b8647892769140884b3ab44a08e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga2bf06b8647892769140884b3ab44a08e">write_ucd</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:ga2bf06b8647892769140884b3ab44a08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacad99726038e4fca7f605fdffb3317e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacad99726038e4fca7f605fdffb3317e4">write_vtk</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:gacad99726038e4fca7f605fdffb3317e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93c780f93105e0daaa76c6c43694b4ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga93c780f93105e0daaa76c6c43694b4ae">write_vtu</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:ga93c780f93105e0daaa76c6c43694b4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5df488dad82b811ceb08cb1adf9eafcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5df488dad82b811ceb08cb1adf9eafcd">write_vtu_in_parallel</a> (const std::string &amp;filename, const MPI_Comm &amp;comm) const</td></tr>
<tr class="separator:ga5df488dad82b811ceb08cb1adf9eafcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1eff778443cd0431cd807c45b6ae16d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga1eff778443cd0431cd807c45b6ae16d9">write_pvtu_record</a> (std::ostream &amp;out, const std::vector&lt; std::string &gt; &amp;piece_names) const</td></tr>
<tr class="separator:ga1eff778443cd0431cd807c45b6ae16d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0864e51eb173c87e2a3edc9391ea8009"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga0864e51eb173c87e2a3edc9391ea8009">write_vtu_with_pvtu_record</a> (const std::string &amp;directory, const std::string &amp;filename_without_extension, const unsigned int counter, const MPI_Comm &amp;mpi_communicator, const unsigned int n_digits_for_counter=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>, const unsigned int n_groups=0) const</td></tr>
<tr class="separator:ga0864e51eb173c87e2a3edc9391ea8009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab56595d7d5aebfb2b3abfdaad51df20d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gab56595d7d5aebfb2b3abfdaad51df20d">write_svg</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:gab56595d7d5aebfb2b3abfdaad51df20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffac60e1e3799ae884642113a8e2e723"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaffac60e1e3799ae884642113a8e2e723">write_deal_II_intermediate</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:gaffac60e1e3799ae884642113a8e2e723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45ef5cf2b6515c10ff080729a9901155"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classXDMFEntry.html">XDMFEntry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga45ef5cf2b6515c10ff080729a9901155">create_xdmf_entry</a> (const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;data_filter, const std::string &amp;h5_filename, const <a class="el" href="classdouble.html">double</a> cur_time, const MPI_Comm &amp;comm) const</td></tr>
<tr class="separator:ga45ef5cf2b6515c10ff080729a9901155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f0b3eec5ee65bd7915c4e46272287eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classXDMFEntry.html">XDMFEntry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga0f0b3eec5ee65bd7915c4e46272287eb">create_xdmf_entry</a> (const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;data_filter, const std::string &amp;h5_mesh_filename, const std::string &amp;h5_solution_filename, const <a class="el" href="classdouble.html">double</a> cur_time, const MPI_Comm &amp;comm) const</td></tr>
<tr class="separator:ga0f0b3eec5ee65bd7915c4e46272287eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfab5d02f11dcede67bb61ff3ae105d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gabfab5d02f11dcede67bb61ff3ae105d2">write_xdmf_file</a> (const std::vector&lt; <a class="el" href="classXDMFEntry.html">XDMFEntry</a> &gt; &amp;entries, const std::string &amp;filename, const MPI_Comm &amp;comm) const</td></tr>
<tr class="separator:gabfab5d02f11dcede67bb61ff3ae105d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29468f4e8eca1367d44b1a2431d39e91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga29468f4e8eca1367d44b1a2431d39e91">write_hdf5_parallel</a> (const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;data_filter, const std::string &amp;filename, const MPI_Comm &amp;comm) const</td></tr>
<tr class="separator:ga29468f4e8eca1367d44b1a2431d39e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78fdf1cc5071d85ecb2d707d798bf063"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga78fdf1cc5071d85ecb2d707d798bf063">write_hdf5_parallel</a> (const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;data_filter, const <a class="el" href="classbool.html">bool</a> write_mesh_file, const std::string &amp;mesh_filename, const std::string &amp;solution_filename, const MPI_Comm &amp;comm) const</td></tr>
<tr class="separator:ga78fdf1cc5071d85ecb2d707d798bf063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga154d8192688eef96f052f50c2f669aa8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga154d8192688eef96f052f50c2f669aa8">write_filtered_data</a> (<a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;filtered_data) const</td></tr>
<tr class="separator:ga154d8192688eef96f052f50c2f669aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78e73ad285a8792ff0f9f227b82eb108"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga78e73ad285a8792ff0f9f227b82eb108">write</a> (std::ostream &amp;out, const <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> output_format=<a class="el" href="group__Exceptions.html#gaa3cbced9f1d4ae661f13018f4c980aa1aaca645a9a5b8782ed6dff8ef6b809e07">DataOutBase::default_format</a>) const</td></tr>
<tr class="separator:ga78e73ad285a8792ff0f9f227b82eb108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dab6e0fed8d4ad90d658f71a68eb32c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga6dab6e0fed8d4ad90d658f71a68eb32c">set_default_format</a> (const <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> default_format)</td></tr>
<tr class="separator:ga6dab6e0fed8d4ad90d658f71a68eb32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7280a24690b117454acfb0fa058299c"><td class="memTemplParams" colspan="2">template&lt;typename FlagType &gt; </td></tr>
<tr class="memitem:gac7280a24690b117454acfb0fa058299c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac7280a24690b117454acfb0fa058299c">set_flags</a> (const FlagType &amp;flags)</td></tr>
<tr class="separator:gac7280a24690b117454acfb0fa058299c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36120ca3f536c90709e135161030f16c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga36120ca3f536c90709e135161030f16c">default_suffix</a> (const <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> output_format=<a class="el" href="group__Exceptions.html#gaa3cbced9f1d4ae661f13018f4c980aa1aaca645a9a5b8782ed6dff8ef6b809e07">DataOutBase::default_format</a>) const</td></tr>
<tr class="separator:ga36120ca3f536c90709e135161030f16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a975649e4516ee7c7a67ae2f8dddd97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga0a975649e4516ee7c7a67ae2f8dddd97">parse_parameters</a> (<a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</td></tr>
<tr class="separator:ga0a975649e4516ee7c7a67ae2f8dddd97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ga1f2f1d644d9cb1c4d1714d5173d159f2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga1f2f1d644d9cb1c4d1714d5173d159f2">declare_parameters</a> (<a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</td></tr>
<tr class="separator:ga1f2f1d644d9cb1c4d1714d5173d159f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a12aba32b2db70710325e468f6b8cebb7"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut.html#a12aba32b2db70710325e468f6b8cebb7">spacedim</a> = DoFHandlerType::space_dimension</td></tr>
<tr class="separator:a12aba32b2db70710325e468f6b8cebb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a5d7ef9ef54d930c6cf85e37a1b155e30"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a5d7ef9ef54d930c6cf85e37a1b155e30">Patch</a> = ::<a class="el" href="structDataOutBase_1_1Patch.html">DataOutBase::Patch</a>&lt; patch_dim, patch_space_dim &gt;</td></tr>
<tr class="separator:a5d7ef9ef54d930c6cf85e37a1b155e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a496f2bb31228bec26f4ce73ef4166b3d"><td class="memItemLeft" align="right" valign="top">virtual const std::vector&lt; <a class="el" href="classDataOut__DoFData.html#a5d7ef9ef54d930c6cf85e37a1b155e30">Patch</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a496f2bb31228bec26f4ce73ef4166b3d">get_patches</a> () const override</td></tr>
<tr class="separator:a496f2bb31228bec26f4ce73ef4166b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e60dbfa99a1a31f520893b7145ab321"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a7e60dbfa99a1a31f520893b7145ab321">get_dataset_names</a> () const override</td></tr>
<tr class="separator:a7e60dbfa99a1a31f520893b7145ab321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf6228742921d4f04fafca0bf30e9cc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt;::<a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; DoFHandlerType::dimension, DoFHandlerType::space_dimension &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a5bf6228742921d4f04fafca0bf30e9cc">get_fes</a> () const</td></tr>
<tr class="separator:a5bf6228742921d4f04fafca0bf30e9cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34486ffea504c88c1bc3e121c8809f1e"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::tuple&lt; unsigned int, unsigned int, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a34486ffea504c88c1bc3e121c8809f1e">get_nonscalar_data_ranges</a> () const override</td></tr>
<tr class="separator:a34486ffea504c88c1bc3e121c8809f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3292ed269dfb832d20ae35db4177473"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac3292ed269dfb832d20ae35db4177473">validate_dataset_names</a> () const</td></tr>
<tr class="separator:gac3292ed269dfb832d20ae35db4177473"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:abf58679bb3ce869323a2a997415aa1df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; DoFHandlerType::dimension, DoFHandlerType::space_dimension &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#abf58679bb3ce869323a2a997415aa1df">triangulation</a></td></tr>
<tr class="separator:abf58679bb3ce869323a2a997415aa1df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a282f4d56013f02908e665353fc4b21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a6a282f4d56013f02908e665353fc4b21">dofs</a></td></tr>
<tr class="separator:a6a282f4d56013f02908e665353fc4b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6bc1c5c850d7d5c15362a5fdc936777"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classinternal_1_1DataOutImplementation_1_1DataEntryBase.html">internal::DataOutImplementation::DataEntryBase</a>&lt; DoFHandlerType::dimension, DoFHandlerType::space_dimension &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#ac6bc1c5c850d7d5c15362a5fdc936777">dof_data</a></td></tr>
<tr class="separator:ac6bc1c5c850d7d5c15362a5fdc936777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d58dd18d706e9bc613e3e635538750a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classinternal_1_1DataOutImplementation_1_1DataEntryBase.html">internal::DataOutImplementation::DataEntryBase</a>&lt; DoFHandlerType::dimension, DoFHandlerType::space_dimension &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a7d58dd18d706e9bc613e3e635538750a">cell_data</a></td></tr>
<tr class="separator:a7d58dd18d706e9bc613e3e635538750a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb583ebaa6c26c5d31c0becf5aff5558"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classDataOut__DoFData.html#a5d7ef9ef54d930c6cf85e37a1b155e30">Patch</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#adb583ebaa6c26c5d31c0becf5aff5558">patches</a></td></tr>
<tr class="separator:adb583ebaa6c26c5d31c0becf5aff5558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga072edd6d53d1c5a1e4c71af22a123228"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga072edd6d53d1c5a1e4c71af22a123228">default_subdivisions</a></td></tr>
<tr class="separator:ga072edd6d53d1c5a1e4c71af22a123228"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a7e8586a93600289bb598e61ead8d9b8f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classDataOut.html#a501c6b6a2ac9210e9f5742898908183c">cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut.html#a7e8586a93600289bb598e61ead8d9b8f">first_locally_owned_cell</a> ()</td></tr>
<tr class="separator:a7e8586a93600289bb598e61ead8d9b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18a64bada3fb2f1663ca27a6c14369c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classDataOut.html#a501c6b6a2ac9210e9f5742898908183c">cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut.html#ad18a64bada3fb2f1663ca27a6c14369c">next_locally_owned_cell</a> (const <a class="el" href="classDataOut.html#a501c6b6a2ac9210e9f5742898908183c">cell_iterator</a> &amp;cell)</td></tr>
<tr class="separator:ad18a64bada3fb2f1663ca27a6c14369c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3d7d0b36010a70a12ebc87f3204f69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut.html#aad3d7d0b36010a70a12ebc87f3204f69">build_one_patch</a> (const std::pair&lt; <a class="el" href="classDataOut.html#a501c6b6a2ac9210e9f5742898908183c">cell_iterator</a>, unsigned int &gt; *cell_and_index, <a class="el" href="structinternal_1_1DataOutImplementation_1_1ParallelData.html">internal::DataOutImplementation::ParallelData</a>&lt; DoFHandlerType::dimension, DoFHandlerType::space_dimension &gt; &amp;scratch_data, const unsigned int n_subdivisions, const <a class="el" href="classDataOut.html#a1303b5d99f10f3fae984e7d406cfeb37">CurvedCellRegion</a> curved_cell_region)</td></tr>
<tr class="separator:aad3d7d0b36010a70a12ebc87f3204f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8cca59e1dd63590824828c21f5854a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#aa8cca59e1dd63590824828c21f5854a0">add_data_vector_internal</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; *dof_handler, const VectorType &amp;data, const std::vector&lt; std::string &gt; &amp;names, const <a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27">DataVectorType</a> type, const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;data_component_interpretation, const <a class="el" href="classbool.html">bool</a> deduce_output_names)</td></tr>
<tr class="separator:aa8cca59e1dd63590824828c21f5854a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aaa5530b77acd5aa7c447bd2c6ba538c9"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classDataOut.html#a501c6b6a2ac9210e9f5742898908183c">cell_iterator</a>(const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, <a class="el" href="classDataOut.html#a12aba32b2db70710325e468f6b8cebb7">spacedim</a> &gt; &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut.html#aaa5530b77acd5aa7c447bd2c6ba538c9">first_cell_function</a></td></tr>
<tr class="separator:aaa5530b77acd5aa7c447bd2c6ba538c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae126940becff62ea40cd6a73d2062c"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classDataOut.html#a501c6b6a2ac9210e9f5742898908183c">cell_iterator</a>(const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, <a class="el" href="classDataOut.html#a12aba32b2db70710325e468f6b8cebb7">spacedim</a> &gt; &amp;, const <a class="el" href="classDataOut.html#a501c6b6a2ac9210e9f5742898908183c">cell_iterator</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut.html#a1ae126940becff62ea40cd6a73d2062c">next_cell_function</a></td></tr>
<tr class="separator:a1ae126940becff62ea40cd6a73d2062c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82c974193222c8c3c3950a6b9047328d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga82c974193222c8c3c3950a6b9047328d">default_fmt</a></td></tr>
<tr class="separator:ga82c974193222c8c3c3950a6b9047328d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebcd8f42c70f0b26f34e7e62b8808b35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDataOutBase_1_1DXFlags.html">DataOutBase::DXFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaebcd8f42c70f0b26f34e7e62b8808b35">dx_flags</a></td></tr>
<tr class="separator:gaebcd8f42c70f0b26f34e7e62b8808b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77b3216d3e76e2ed65ad6967d2ca42b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDataOutBase_1_1UcdFlags.html">DataOutBase::UcdFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga77b3216d3e76e2ed65ad6967d2ca42b5">ucd_flags</a></td></tr>
<tr class="separator:ga77b3216d3e76e2ed65ad6967d2ca42b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8466681c18e24c0b3c7af7eae5e0997e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDataOutBase_1_1GnuplotFlags.html">DataOutBase::GnuplotFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga8466681c18e24c0b3c7af7eae5e0997e">gnuplot_flags</a></td></tr>
<tr class="separator:ga8466681c18e24c0b3c7af7eae5e0997e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77a68867f11f41af91470c37b930cac8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDataOutBase_1_1PovrayFlags.html">DataOutBase::PovrayFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga77a68867f11f41af91470c37b930cac8">povray_flags</a></td></tr>
<tr class="separator:ga77a68867f11f41af91470c37b930cac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8b6e70c57dd3994130304d33fc0a0fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDataOutBase_1_1EpsFlags.html">DataOutBase::EpsFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gae8b6e70c57dd3994130304d33fc0a0fd">eps_flags</a></td></tr>
<tr class="separator:gae8b6e70c57dd3994130304d33fc0a0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62aad8dd9acbe017b15757d419d356ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDataOutBase_1_1GmvFlags.html">DataOutBase::GmvFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga62aad8dd9acbe017b15757d419d356ae">gmv_flags</a></td></tr>
<tr class="separator:ga62aad8dd9acbe017b15757d419d356ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga295e120b8f3a3f38f94810e82a5aa90d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDataOutBase_1_1TecplotFlags.html">DataOutBase::TecplotFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga295e120b8f3a3f38f94810e82a5aa90d">tecplot_flags</a></td></tr>
<tr class="separator:ga295e120b8f3a3f38f94810e82a5aa90d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae690412df124f4dcea1b34450535ce83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gae690412df124f4dcea1b34450535ce83">vtk_flags</a></td></tr>
<tr class="separator:gae690412df124f4dcea1b34450535ce83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe7a9711c62ab10adf2e629c4fceafa5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDataOutBase_1_1SvgFlags.html">DataOutBase::SvgFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gabe7a9711c62ab10adf2e629c4fceafa5">svg_flags</a></td></tr>
<tr class="separator:gabe7a9711c62ab10adf2e629c4fceafa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d1bb3d43066b0163db165f79b93a6de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDataOutBase_1_1Deal__II__IntermediateFlags.html">DataOutBase::Deal_II_IntermediateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga0d1bb3d43066b0163db165f79b93a6de">deal_II_intermediate_flags</a></td></tr>
<tr class="separator:ga0d1bb3d43066b0163db165f79b93a6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, typename DoFHandlerType = DoFHandler&lt;dim&gt;&gt;<br />
class DataOut&lt; dim, DoFHandlerType &gt;</h3>

<p>This class is the main class to provide output of data described by finite element fields defined on a collection of cells.</p>
<p>This class is an actual implementation of the functionality proposed by the <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a> class. It offers a function <a class="el" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches()</a> that generates the data to be written in some graphics format. Most of the interface and an example of its use is described in the documentation of this base class.</p>
<p>The only thing this class offers is the function <a class="el" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches()</a> which loops over all cells of the triangulation stored by the <a class="el" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler()</a> function of the base class (with the exception of cells of <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> objects that are not owned by the current processor) and converts the data on these to actual patches which are the objects that are later output by the functions of the base classes. You can give a parameter to the function which determines how many subdivisions in each coordinate direction are to be performed, i.e. of how many subcells each patch shall consist. The default is one, but you may want to choose a higher number for higher order elements, for example two for quadratic elements, three for cubic elements, and so on. (See <a class="el" href="step_11.html">step-11</a> for an example.) The purpose of this parameter is because most graphics programs do not allow to specify higher order polynomial functions in the file formats: only data at vertices can be plotted and is then shown as a bilinear interpolation within the interior of cells. This may be insufficient if you have higher order finite elements, and the only way to achieve better output is to subdivide each cell of the mesh into several cells for graphical output. Of course, what you get to see is still a bilinear interpolation on each cell of the output (where these cells are not subdivisions of the cells of the triangulation in use) due to the same limitations in output formats, but at least a bilinear interpolation of a higher order polynomial on a finer mesh.</p>
<p>Note that after having called <a class="el" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches()</a> once, you can call one or more of the <a class="el" href="group__Exceptions.html#ga78e73ad285a8792ff0f9f227b82eb108">write()</a> functions of <a class="el" href="classDataOutInterface.html">DataOutInterface</a>. You can therefore output the same data in more than one format without having to rebuild the patches.</p>
<h3>User interface information</h3>
<p>The base classes of this class, <a class="el" href="namespaceDataOutBase.html">DataOutBase</a>, <a class="el" href="classDataOutInterface.html">DataOutInterface</a> and <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a> offer several interfaces of their own. Refer to the <a class="el" href="namespaceDataOutBase.html">DataOutBase</a> class's documentation for a discussion of the different output formats presently supported, <a class="el" href="classDataOutInterface.html">DataOutInterface</a> for ways of selecting which format to use upon output at run-time and without the need to adapt your program when new formats become available, as well as for flags to determine aspects of output. The <a class="el" href="classDataOut__DoFData.html#ad4dd3ef4d97b4ab200c15da17734479d">DataOut_DoFData()</a> class's documentation has an example of using nodal data to generate output.</p>
<h3>Extensions</h3>
<p>By default, this class produces patches for all active cells. Sometimes, this is not what you want, maybe because there are simply too many (and too small to be seen individually) or because you only want to see a certain region of the domain (for example only in the fluid part of the domain in <a class="el" href="step_46.html">step-46</a>), or for some other reason.</p>
<p>For this, internally <a class="el" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches()</a> does not generate the sequence of cells to be converted into patches itself, but relies on the two function that we'll call <a class="el" href="classDataOut.html#a1af7d4c3409e24acbcc4f8a1da4723e5">first_cell()</a> and <a class="el" href="classDataOut.html#afdefbb966f2053f4c4fc52293d2339ce">next_cell()</a>. By default, they return the first active cell, and the next active cell, respectively. But this can be changed using the <a class="el" href="classDataOut.html#a5d12b73d53d98d9ec35d78ae89a9bd23">set_cell_selection()</a> function that allows you to replace this behavior. What <a class="el" href="classDataOut.html#a5d12b73d53d98d9ec35d78ae89a9bd23">set_cell_selection()</a> wants to know is how you want to pick out the first cell on which output should be generated, and how given one cell on which output is generated you want to pick the next cell.</p>
<p>This may, for example, include only cells that are in parts of a domain (e.g., if you don't care about the solution elsewhere, think for example a buffer region in which you attenuate outgoing waves in the Perfectly Matched Layer method) or if you don't want output to be generated at all levels of an adaptively refined mesh because this creates too much data (in this case, the set of cells returned by your implementations of the <code>first_cell</code> and <code>next_cell</code> arguments to <a class="el" href="classDataOut.html#a5d12b73d53d98d9ec35d78ae89a9bd23">set_cell_selection()</a> will include non-active cells, and <a class="el" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">DataOut::build_patches()</a> will simply take interpolated values of the solution instead of the exact values on these cells children for output). </p>

<p class="definition">Definition at line <a class="el" href="numerics_2data__out_8h_source.html#l00147">147</a> of file <a class="el" href="numerics_2data__out_8h_source.html">data_out.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a501c6b6a2ac9210e9f5742898908183c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a501c6b6a2ac9210e9f5742898908183c">&#9670;&nbsp;</a></span>cell_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType  = DoFHandler&lt;dim&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDataOut.html">DataOut</a>&lt; dim, DoFHandlerType &gt;::<a class="el" href="classDataOut.html#a501c6b6a2ac9210e9f5742898908183c">cell_iterator</a> =  typename <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt;DoFHandlerType, DoFHandlerType::dimension, DoFHandlerType::space_dimension&gt;::<a class="el" href="classDataOut.html#a501c6b6a2ac9210e9f5742898908183c">cell_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef to the iterator type of the dof handler class under consideration. </p>

<p class="definition">Definition at line <a class="el" href="numerics_2data__out_8h_source.html#l00162">162</a> of file <a class="el" href="numerics_2data__out_8h_source.html">data_out.h</a>.</p>

</div>
</div>
<a id="a94ecf9a434575409695befe41fe10196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94ecf9a434575409695befe41fe10196">&#9670;&nbsp;</a></span>FirstCellFunctionType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType  = DoFHandler&lt;dim&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDataOut.html">DataOut</a>&lt; dim, DoFHandlerType &gt;::<a class="el" href="classDataOut.html#a94ecf9a434575409695befe41fe10196">FirstCellFunctionType</a> =  typename std::function&lt;<a class="el" href="classDataOut.html#a501c6b6a2ac9210e9f5742898908183c">cell_iterator</a>(const <a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, <a class="el" href="classDataOut.html#a12aba32b2db70710325e468f6b8cebb7">spacedim</a>&gt; &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of the function object returning the first cell as used in <a class="el" href="classDataOut.html#a5d12b73d53d98d9ec35d78ae89a9bd23">set_cell_selection()</a>. </p>

<p class="definition">Definition at line <a class="el" href="numerics_2data__out_8h_source.html#l00171">171</a> of file <a class="el" href="numerics_2data__out_8h_source.html">data_out.h</a>.</p>

</div>
</div>
<a id="a827d3edc28fcc9dafdc149f2ae111990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a827d3edc28fcc9dafdc149f2ae111990">&#9670;&nbsp;</a></span>NextCellFunctionType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType  = DoFHandler&lt;dim&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDataOut.html">DataOut</a>&lt; dim, DoFHandlerType &gt;::<a class="el" href="classDataOut.html#a827d3edc28fcc9dafdc149f2ae111990">NextCellFunctionType</a> =  typename std::function&lt;<a class="el" href="classDataOut.html#a501c6b6a2ac9210e9f5742898908183c">cell_iterator</a>(const <a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, <a class="el" href="classDataOut.html#a12aba32b2db70710325e468f6b8cebb7">spacedim</a>&gt; &amp;, const <a class="el" href="classDataOut.html#a501c6b6a2ac9210e9f5742898908183c">cell_iterator</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of the function object returning the next cell as used in <a class="el" href="classDataOut.html#a5d12b73d53d98d9ec35d78ae89a9bd23">set_cell_selection()</a>. </p>

<p class="definition">Definition at line <a class="el" href="numerics_2data__out_8h_source.html#l00178">178</a> of file <a class="el" href="numerics_2data__out_8h_source.html">data_out.h</a>.</p>

</div>
</div>
<a id="a5d7ef9ef54d930c6cf85e37a1b155e30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d7ef9ef54d930c6cf85e37a1b155e30">&#9670;&nbsp;</a></span>Patch</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_space_dim &gt;::<a class="el" href="classDataOut__DoFData.html#a5d7ef9ef54d930c6cf85e37a1b155e30">Patch</a> =  ::<a class="el" href="structDataOutBase_1_1Patch.html">DataOutBase::Patch</a>&lt;patch_dim, patch_space_dim&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Abbreviate the somewhat lengthy name for the Patch class. </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00965">965</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a1303b5d99f10f3fae984e7d406cfeb37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1303b5d99f10f3fae984e7d406cfeb37">&#9670;&nbsp;</a></span>CurvedCellRegion</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType  = DoFHandler&lt;dim&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classDataOut.html#a1303b5d99f10f3fae984e7d406cfeb37">DataOut::CurvedCellRegion</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration describing the part of the domain in which cells should be written with curved boundaries. In reality, no file format we are aware of really supports curved boundaries, but this can be emulated by plotting edges as a sequence of straight lines (and faces in 3d as a collection of bilinear patches) if <a class="el" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">DataOut::build_patches()</a> is called with a number of subdivisions greater than 1.</p>
<p>The elements of this enumeration then describe for which cells <a class="el" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">DataOut::build_patches()</a> will query the manifold or boundary description for curved geometries. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1303b5d99f10f3fae984e7d406cfeb37a48b3413706d5e705b001ab3874915903"></a>no_curved_cells&#160;</td><td class="fielddoc"><p>The geometry or boundary description will never be queried for curved geometries. This means that even if you have more than one subdivision per cell (see <a class="el" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">DataOut::build_patches()</a> for what exactly this means) and even if the geometry really is curved, each cell will still be subdivided as if it was just a bi- or trilinear cell. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1303b5d99f10f3fae984e7d406cfeb37ade19577951156fc5d90fc1ab8685c219"></a>curved_boundary&#160;</td><td class="fielddoc"><p>The geometry or boundary description will be queried for curved geometries for cells located at the boundary, i.e., for cells that have at least one face at the boundary. This is sufficient if you have not attached a manifold description to the interiors of cells but only to faces at the boundary. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1303b5d99f10f3fae984e7d406cfeb37a7f310f7608c5724c67300f6e9a8728c1"></a>curved_inner_cells&#160;</td><td class="fielddoc"><p>The geometry description will be queried for all cells and all faces, whether they are at the boundary or not. This option is appropriate if you have attached a manifold object to cells (not only to boundary faces). </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="numerics_2data__out_8h_source.html#l00195">195</a> of file <a class="el" href="numerics_2data__out_8h_source.html">data_out.h</a>.</p>

</div>
</div>
<a id="a062005bfe37e877e1f44e1c3e8e6cb27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a062005bfe37e877e1f44e1c3e8e6cb27">&#9670;&nbsp;</a></span>DataVectorType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27">DataOut_DoFData::DataVectorType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Type describing what the vector given to <a class="el" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector()</a> is: a vector that has one entry per degree of freedom in a <a class="el" href="classDoFHandler.html">DoFHandler</a> object (such as solution vectors), or one entry per cell in the triangulation underlying the <a class="el" href="classDoFHandler.html">DoFHandler</a> object (such as error per cell data). The value <a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27ad7189bcb96ade9f785a40b8959ac443e">type_automatic</a> tells <a class="el" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector()</a> to find out itself (see the documentation of <a class="el" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector()</a> for the method used). </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00617">617</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8de208d5d09c52f3438cc853385ee75c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8de208d5d09c52f3438cc853385ee75c">&#9670;&nbsp;</a></span>DataOut()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataOut.html">DataOut</a>&lt; dim, DoFHandlerType &gt;::<a class="el" href="classDataOut.html">DataOut</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. </p>

<p class="definition">Definition at line <a class="el" href="numerics_2data__out_8cc_source.html#l00069">69</a> of file <a class="el" href="numerics_2data__out_8cc_source.html">data_out.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5eb51872b8736849bb7e8d2007fae086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eb51872b8736849bb7e8d2007fae086">&#9670;&nbsp;</a></span>build_patches() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut.html">DataOut</a>&lt; dim, DoFHandlerType &gt;::build_patches </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_subdivisions</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the central function of this class since it builds the list of patches to be written by the low-level functions of the base class. A patch is, in essence, some intermediate representation of the data on each cell of a triangulation and <a class="el" href="classDoFHandler.html">DoFHandler</a> object that can then be used to write files in some format that is readable by visualization programs.</p>
<p>You can find an overview of the use of this function in the general documentation of this class. An example is also provided in the documentation of this class's base class <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_subdivisions</td><td>A parameter that determines how many "patches" this function will build out of every cell. If you do not specify this value in calling, or provide the default value zero, then this is interpreted as <a class="el" href="group__Exceptions.html#ga072edd6d53d1c5a1e4c71af22a123228">DataOutInterface::default_subdivisions</a> which most of the time will be equal to one (unless you have set it to something else). The purpose of this parameter is to subdivide each cell of the mesh into \(2\times 2, 3\times 3, \ldots\) "patches" in 2d, and \(2\times 2\times 2, 3\times 3\times 3, \ldots\) (if passed the value 2, 3, etc) where each patch represents the data from a regular subdivision of the cell into equal parts. Most of the times, this is not necessary and outputting one patch per cell is exactly what you want to plot the solution. That said, the data we write into files for visualization can only represent (bi-, tri)linear data on each cell, and most visualization programs can in fact only visualize this kind of data. That's good enough if you work with (bi-, tri)linear finite elements, in which case what you get to see is exactly what has been computed. On the other hand, if you work with (bi-, tri)quadratic elements, then what is written into the output file is just a (bi-, tri)linear interpolation onto the current mesh, i.e., only the values at the vertices. If this is not good enough, you can, for example, specify <code>n_subdivisions</code> equal to 2 to plot the solution on a once- refined mesh, or if set to 3, on a mesh where each cell is represented by 3-by-3 patches. On each of these smaller patches, given the limitations of output formats, the data is still linearly interpolated, but a linear interpolation of quadratic data on a finer mesh is still a better representation of the actual quadratic surface than on the original mesh. In other words, using this parameter can not help you plot the solution exactly, but it can get you closer if you use finite elements of higher polynomial degree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Specifying <code>n_subdivisions&gt;1</code> is useful when using higher order finite elements, but in general it does not actually result in the visualization showing higher order polynomial surfaces &ndash; rather, you just get a (bi-, tri-)linear interpolation of that higher order surface on a finer mesh. However, when outputting the solution in the VTK and VTU file formats via <a class="el" href="group__Exceptions.html#gacad99726038e4fca7f605fdffb3317e4">DataOutInterface::write_vtk()</a> or <a class="el" href="group__Exceptions.html#ga93c780f93105e0daaa76c6c43694b4ae">DataOutInterface::write_vtu()</a> (where <a class="el" href="classDataOutInterface.html">DataOutInterface</a> is a base class of the current class) as we often do in the tutorials, you can provide a set of flags via the <a class="el" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> structure that includes the <a class="el" href="group__Exceptions.html#gaa9dd1830c0ff35a2431704c4d45453eb">DataOutBase::VtkFlags::write_higher_order_cells</a> flag. When set, the subdivisions produced by this function will be interpreted as support points for a higher order polynomial that will then actually be visualized as such. This is shown in <a class="el" href="step_11.html">step-11</a>, for example. It is worth noting, however, that this requires a sufficiently new version of one of the VTK-based visualization programs. </dd></dl>

<p class="definition">Definition at line <a class="el" href="numerics_2data__out_8cc_source.html#l01085">1085</a> of file <a class="el" href="numerics_2data__out_8cc_source.html">data_out.cc</a>.</p>

</div>
</div>
<a id="a991c9d3ecb57231c9cd2357c549ff8c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991c9d3ecb57231c9cd2357c549ff8c3">&#9670;&nbsp;</a></span>build_patches() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut.html">DataOut</a>&lt; dim, DoFHandlerType &gt;::build_patches </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; DoFHandlerType::dimension, DoFHandlerType::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_subdivisions</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataOut.html#a1303b5d99f10f3fae984e7d406cfeb37">CurvedCellRegion</a>&#160;</td>
          <td class="paramname"><em>curved_region</em> = <code><a class="el" href="classDataOut.html#a1303b5d99f10f3fae984e7d406cfeb37ade19577951156fc5d90fc1ab8685c219">curved_boundary</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, except that the additional first parameter defines a mapping that is to be used in the generation of output. If <code>n_subdivisions&gt;1</code>, the points interior of subdivided patches which originate from cells at the boundary of the domain can be computed using the mapping, i.e., a higher order mapping leads to a representation of a curved boundary by using more subdivisions. Some mappings like <a class="el" href="classMappingQEulerian.html">MappingQEulerian</a> result in curved cells in the interior of the domain. The same is true if you have attached a manifold description to the cells of a triangulation (see <a class="el" href="group__manifold.html">Manifolds</a> for more information). However, there is no easy way to query the mapping or manifold whether it really does lead to curved cells. Thus the last argument <code>curved_region</code> takes one of three values resulting in no curved cells at all, curved cells at the boundary (default) or curved cells in the whole domain. For more information about these three options, see the CurvedCellRegion enum's description.</p>
<p>Even for non-curved cells, the mapping argument can be used for Eulerian mappings (see class <a class="el" href="classMappingQ1Eulerian.html">MappingQ1Eulerian</a>) where a mapping is used not only to determine the position of points interior to a cell, but also of the vertices. It offers an opportunity to watch the solution on a deformed triangulation on which the computation was actually carried out, even if the mesh is internally stored in its undeformed configuration and the deformation is only tracked by an additional vector that holds the deformation of each vertex. </p>

<p class="definition">Definition at line <a class="el" href="numerics_2data__out_8cc_source.html#l01101">1101</a> of file <a class="el" href="numerics_2data__out_8cc_source.html">data_out.cc</a>.</p>

</div>
</div>
<a id="a04d491be143f2672b076622e7abd32b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d491be143f2672b076622e7abd32b8">&#9670;&nbsp;</a></span>build_patches() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut.html">DataOut</a>&lt; dim, DoFHandlerType &gt;::build_patches </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; DoFHandlerType::dimension, DoFHandlerType::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_subdivisions</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataOut.html#a1303b5d99f10f3fae984e7d406cfeb37">CurvedCellRegion</a>&#160;</td>
          <td class="paramname"><em>curved_region</em> = <code><a class="el" href="classDataOut.html#a1303b5d99f10f3fae984e7d406cfeb37ade19577951156fc5d90fc1ab8685c219">curved_boundary</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but for <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>. </p>

<p class="definition">Definition at line <a class="el" href="numerics_2data__out_8cc_source.html#l01118">1118</a> of file <a class="el" href="numerics_2data__out_8cc_source.html">data_out.cc</a>.</p>

</div>
</div>
<a id="a5d12b73d53d98d9ec35d78ae89a9bd23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d12b73d53d98d9ec35d78ae89a9bd23">&#9670;&nbsp;</a></span>set_cell_selection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut.html">DataOut</a>&lt; dim, DoFHandlerType &gt;::set_cell_selection </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classDataOut.html#a501c6b6a2ac9210e9f5742898908183c">cell_iterator</a>(const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, <a class="el" href="classDataOut.html#a12aba32b2db70710325e468f6b8cebb7">spacedim</a> &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>first_cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classDataOut.html#a501c6b6a2ac9210e9f5742898908183c">cell_iterator</a>(const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, <a class="el" href="classDataOut.html#a12aba32b2db70710325e468f6b8cebb7">spacedim</a> &gt; &amp;, const <a class="el" href="classDataOut.html#a501c6b6a2ac9210e9f5742898908183c">cell_iterator</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>next_cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A function that allows selecting for which cells output should be generated. This function takes two arguments, both <code>std::function</code> objects that can be used what the first cell on which output is generated is supposed to be, and what given one cell the next function is supposed to be. Through these function objects, it is possible to select a subset of cells on which output should be produced (e.g., only selecting those cells that belong to a part of the domain &ndash; say, the fluid domain in a code such as <a class="el" href="step_46.html">step-46</a>), or to completely change <em>where</em> output is produced (e.g., to produce output on non-active cells of a multigrid hierarchy or if the finest level of a mesh is so fine that generating graphical output would lead to an overwhelming amount of data).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first_cell</td><td>A function object that takes as argument the triangulation this class works on and that should return the first cell on which output should be generated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">next_cell</td><td>A function object that takes as arguments the triangulation as well as the last cell on which output was generated, and that should return the next cell on which output should be generated. If there is no next cell, i.e., if the input argument to the <code>next_cell</code> function object is the last cell on which output is to be generated, then <code>next_cell</code> must return <code><a class="el" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">triangulation.end()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<p>These function objects are not difficult to write, but also not immediately obvious. As a consequence, there is a second variation of this function that takes a IteratorFilter argument and generates the corresponding functions itself.</p>
<dl class="section note"><dt>Note</dt><dd>This function is also called in the constructor of this class, where the default behavior is set. By default, this class will select all <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">locally owned</a> and <a class="el" href="DEALGlossary.html#GlossActive">active</a> cells for output.</dd>
<dd>
If you have cell data (in contrast to nodal, or dof, data) such as error indicators, then you must make sure that the <code>first_cell</code> and <code>next_cell</code> function objects only walk over active cells, since cell data cannot be interpolated to a coarser cell. If you do have cell data and use this pair of functions and they return a non-active cell, then an exception will be thrown. </dd></dl>

<p class="definition">Definition at line <a class="el" href="numerics_2data__out_8cc_source.html#l01309">1309</a> of file <a class="el" href="numerics_2data__out_8cc_source.html">data_out.cc</a>.</p>

</div>
</div>
<a id="a66f06c6e1c03cbcc5b3090fa8dc41777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f06c6e1c03cbcc5b3090fa8dc41777">&#9670;&nbsp;</a></span>set_cell_selection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut.html">DataOut</a>&lt; dim, DoFHandlerType &gt;::set_cell_selection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classDataOut.html#a501c6b6a2ac9210e9f5742898908183c">cell_iterator</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>filtered_iterator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A variation of the previous function that selects a subset of all cells for output based on the filter encoded in the <a class="el" href="classFilteredIterator.html">FilteredIterator</a> object given as argument. A typical way to generate the argument is via the <a class="el" href="classFilteredIterator.html#ab70266a7220e6ff4e3f915e0fb44a4dd">make_filtered_iterator()</a> function.</p>
<p>Alternatively, since <a class="el" href="classFilteredIterator.html">FilteredIterator</a> objects can be created from just a predicate (i.e., a function object that returns a <code>bool</code>), it is possible to call this function with just a lambda function, which will then automatically be converted to a <a class="el" href="classFilteredIterator.html">FilteredIterator</a> object. For example, the following piece of code works: </p><div class="fragment"><div class="line"><a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div>
<div class="line">data_out.<a class="code" href="classDataOut.html#a5d12b73d53d98d9ec35d78ae89a9bd23">set_cell_selection</a>(</div>
<div class="line">       [](<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classTriaIterator.html">Triangulation&lt;dim&gt;::cell_iterator</a> &amp;cell) {</div>
<div class="line">           <span class="keywordflow">return</span> (cell-&gt;is_active() &amp;&amp; cell-&gt;subdomain_id() == 0);</div>
<div class="line">       });</div>
<div class="ttc" id="aclassDataOut_html"><div class="ttname"><a href="classDataOut.html">DataOut</a></div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__out_8h_source.html#l00147">data_out.h:150</a></div></div>
<div class="ttc" id="aclassDataOut_html_a5d12b73d53d98d9ec35d78ae89a9bd23"><div class="ttname"><a href="classDataOut.html#a5d12b73d53d98d9ec35d78ae89a9bd23">DataOut::set_cell_selection</a></div><div class="ttdeci">void set_cell_selection(const std::function&lt; cell_iterator(const Triangulation&lt; dim, spacedim &gt; &amp;)&gt; &amp;first_cell, const std::function&lt; cell_iterator(const Triangulation&lt; dim, spacedim &gt; &amp;, const cell_iterator &amp;)&gt; &amp;next_cell)</div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__out_8cc_source.html#l01309">data_out.cc:1309</a></div></div>
<div class="ttc" id="aclassTriaIterator_html"><div class="ttname"><a href="classTriaIterator.html">TriaIterator</a></div><div class="ttdef"><b>Definition:</b> <a href="tria__iterator_8h_source.html#l00577">tria_iterator.h:578</a></div></div>
</div><!-- fragment --><p> In this case, the lambda function selects all of those cells that are <a class="el" href="DEALGlossary.html#GlossActive">active</a> and whose subdomain id is zero. These will then be the only cells on which output is generated.</p>
<dl class="section note"><dt>Note</dt><dd>Not all filters will result in subsets of cells for which output can actually be generated. For example, if you are working on parallel meshes where data is only available on some cells, then you better make sure that your <code>filtered_iterator</code> only loops over the <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">locally owned</a> cells; likewise, in most cases you will probably only want to work on <a class="el" href="DEALGlossary.html#GlossActive">active</a> cells since this is where the solution actually lives. In particular, if you have added vectors that represent data defined on cells (instead of nodal data), then you can not generate output on non-active cells and your iterator filter should reflect this. </dd></dl>

<p class="definition">Definition at line <a class="el" href="numerics_2data__out_8cc_source.html#l01323">1323</a> of file <a class="el" href="numerics_2data__out_8cc_source.html">data_out.cc</a>.</p>

</div>
</div>
<a id="a6c28d7579277c882ee6f6729c04f5803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c28d7579277c882ee6f6729c04f5803">&#9670;&nbsp;</a></span>get_cell_selection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::pair&lt; typename <a class="el" href="classDataOut.html">DataOut</a>&lt; dim, DoFHandlerType &gt;::<a class="el" href="classDataOut.html#a94ecf9a434575409695befe41fe10196">FirstCellFunctionType</a>, typename <a class="el" href="classDataOut.html">DataOut</a>&lt; dim, DoFHandlerType &gt;::<a class="el" href="classDataOut.html#a827d3edc28fcc9dafdc149f2ae111990">NextCellFunctionType</a> &gt; <a class="el" href="classDataOut.html">DataOut</a>&lt; dim, DoFHandlerType &gt;::get_cell_selection</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the two function objects that are in use for determining the first and the next cell as set by <a class="el" href="classDataOut.html#a5d12b73d53d98d9ec35d78ae89a9bd23">set_cell_selection()</a>. </p>

<p class="definition">Definition at line <a class="el" href="numerics_2data__out_8cc_source.html#l01365">1365</a> of file <a class="el" href="numerics_2data__out_8cc_source.html">data_out.cc</a>.</p>

</div>
</div>
<a id="a1af7d4c3409e24acbcc4f8a1da4723e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1af7d4c3409e24acbcc4f8a1da4723e5">&#9670;&nbsp;</a></span>first_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataOut.html">DataOut</a>&lt; dim, DoFHandlerType &gt;::<a class="el" href="classDataOut.html#a501c6b6a2ac9210e9f5742898908183c">cell_iterator</a> <a class="el" href="classDataOut.html">DataOut</a>&lt; dim, DoFHandlerType &gt;::first_cell</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the first cell which we want output for. The default implementation returns the first active cell, but you might want to return other cells in a derived class.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000129">Deprecated:</a></b></dt><dd>Use the <a class="el" href="classDataOut.html#a5d12b73d53d98d9ec35d78ae89a9bd23">set_cell_selection()</a> function instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="numerics_2data__out_8cc_source.html#l01374">1374</a> of file <a class="el" href="numerics_2data__out_8cc_source.html">data_out.cc</a>.</p>

</div>
</div>
<a id="afdefbb966f2053f4c4fc52293d2339ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdefbb966f2053f4c4fc52293d2339ce">&#9670;&nbsp;</a></span>next_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType  = DoFHandler&lt;dim&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataOut.html">DataOut</a>&lt; dim, DoFHandlerType &gt;::<a class="el" href="classDataOut.html#a501c6b6a2ac9210e9f5742898908183c">cell_iterator</a> <a class="el" href="classDataOut.html">DataOut</a>&lt; dim, DoFHandlerType &gt;::next_cell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataOut.html#a501c6b6a2ac9210e9f5742898908183c">cell_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the next cell after <code>cell</code> which we want output for. If there are no more cells, any implementation of this function should return <code>dof_handler-&gt;<a class="el" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end()</a></code>.</p>
<p>The default implementation returns the next active cell, but you might want to return other cells in a derived class. Note that the default implementation assumes that the given <code>cell</code> is active, which is guaranteed as long as <a class="el" href="classDataOut.html#a1af7d4c3409e24acbcc4f8a1da4723e5">first_cell()</a> is also used from the default implementation. Overloading only one of the two functions might not be a good idea.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000130">Deprecated:</a></b></dt><dd>Use the <a class="el" href="classDataOut.html#a5d12b73d53d98d9ec35d78ae89a9bd23">set_cell_selection()</a> function instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="numerics_2data__out_8cc_source.html#l01383">1383</a> of file <a class="el" href="numerics_2data__out_8cc_source.html">data_out.cc</a>.</p>

</div>
</div>
<a id="a7e8586a93600289bb598e61ead8d9b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e8586a93600289bb598e61ead8d9b8f">&#9670;&nbsp;</a></span>first_locally_owned_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataOut.html">DataOut</a>&lt; dim, DoFHandlerType &gt;::<a class="el" href="classDataOut.html#a501c6b6a2ac9210e9f5742898908183c">cell_iterator</a> <a class="el" href="classDataOut.html">DataOut</a>&lt; dim, DoFHandlerType &gt;::first_locally_owned_cell</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the first cell produced by the <a class="el" href="classDataOut.html#a1af7d4c3409e24acbcc4f8a1da4723e5">first_cell()</a>/next_cell() function pair that is locally owned. If this object operates on a non-distributed triangulation, the result equals what <a class="el" href="classDataOut.html#a1af7d4c3409e24acbcc4f8a1da4723e5">first_cell()</a> returns.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000131">Deprecated:</a></b></dt><dd>Use the <a class="el" href="classDataOut.html#a5d12b73d53d98d9ec35d78ae89a9bd23">set_cell_selection()</a> function instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="numerics_2data__out_8cc_source.html#l01399">1399</a> of file <a class="el" href="numerics_2data__out_8cc_source.html">data_out.cc</a>.</p>

</div>
</div>
<a id="ad18a64bada3fb2f1663ca27a6c14369c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad18a64bada3fb2f1663ca27a6c14369c">&#9670;&nbsp;</a></span>next_locally_owned_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType  = DoFHandler&lt;dim&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataOut.html">DataOut</a>&lt; dim, DoFHandlerType &gt;::<a class="el" href="classDataOut.html#a501c6b6a2ac9210e9f5742898908183c">cell_iterator</a> <a class="el" href="classDataOut.html">DataOut</a>&lt; dim, DoFHandlerType &gt;::next_locally_owned_cell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataOut.html#a501c6b6a2ac9210e9f5742898908183c">cell_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the next cell produced by the <a class="el" href="classDataOut.html#afdefbb966f2053f4c4fc52293d2339ce">next_cell()</a> function that is locally owned. If this object operates on a non-distributed triangulation, the result equals what <a class="el" href="classDataOut.html#a1af7d4c3409e24acbcc4f8a1da4723e5">first_cell()</a> returns.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000132">Deprecated:</a></b></dt><dd>Use the <a class="el" href="classDataOut.html#a5d12b73d53d98d9ec35d78ae89a9bd23">set_cell_selection()</a> function instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="numerics_2data__out_8cc_source.html#l01416">1416</a> of file <a class="el" href="numerics_2data__out_8cc_source.html">data_out.cc</a>.</p>

</div>
</div>
<a id="aad3d7d0b36010a70a12ebc87f3204f69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad3d7d0b36010a70a12ebc87f3204f69">&#9670;&nbsp;</a></span>build_one_patch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut.html">DataOut</a>&lt; dim, DoFHandlerType &gt;::build_one_patch </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; <a class="el" href="classDataOut.html#a501c6b6a2ac9210e9f5742898908183c">cell_iterator</a>, unsigned int &gt; *&#160;</td>
          <td class="paramname"><em>cell_and_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal_1_1DataOutImplementation_1_1ParallelData.html">internal::DataOutImplementation::ParallelData</a>&lt; DoFHandlerType::dimension, DoFHandlerType::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_subdivisions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataOut.html#a1303b5d99f10f3fae984e7d406cfeb37">CurvedCellRegion</a>&#160;</td>
          <td class="paramname"><em>curved_cell_region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Build one patch. This function is called in a <a class="el" href="namespaceWorkStream.html">WorkStream</a> context.</p>
<p>The first argument here is the iterator, the second the scratch data object. All following are tied to particular values when calling <a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run()</a>. The function does not take a CopyData object but rather allocates one on its own stack for memory access efficiency reasons. </p>

<p class="definition">Definition at line <a class="el" href="numerics_2data__out_8cc_source.html#l00088">88</a> of file <a class="el" href="numerics_2data__out_8cc_source.html">data_out.cc</a>.</p>

</div>
</div>
<a id="ac1eb26168177faa30ffbcf9cbb9c3cd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1eb26168177faa30ffbcf9cbb9c3cd5">&#9670;&nbsp;</a></span>attach_dof_handler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_space_dim &gt;::attach_dof_handler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt;  &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Designate a dof handler to be used to extract geometry data and the mapping between nodes and node values. This call is not necessary if all added data vectors are supplemented with a <a class="el" href="classDoFHandler.html">DoFHandler</a> argument.</p>
<p>This call is optional: If you add data vectors with specified <a class="el" href="classDoFHandler.html">DoFHandler</a> object, then that contains all information needed to generate the output. </p>

</div>
</div>
<a id="a0a8d4fbc99c408d956c4685fd4c97b99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a8d4fbc99c408d956c4685fd4c97b99">&#9670;&nbsp;</a></span>attach_triangulation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_space_dim &gt;::attach_triangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; DoFHandlerType::dimension, DoFHandlerType::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Designate a triangulation to be used to extract geometry data and the mapping between nodes and node values.</p>
<p>This call is optional: If you add data vectors with specified <a class="el" href="classDoFHandler.html">DoFHandler</a> object, then that contains all information needed to generate the output. This call is useful when you only output cell vectors and no <a class="el" href="classDoFHandler.html">DoFHandler</a> at all, in which case it provides the geometry. </p>

</div>
</div>
<a id="ace4b76e565ba0701c4d32c26075ed3b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace4b76e565ba0701c4d32c26075ed3b9">&#9670;&nbsp;</a></span>add_data_vector() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_space_dim &gt;::add_data_vector </td>
          <td>(</td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27">DataVectorType</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27ad7189bcb96ade9f785a40b8959ac443e">type_automatic</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_component_interpretation</em> = <code>std::vector&lt;&#160;<a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a data vector together with its name.</p>
<p>A pointer to the vector is stored, so you have to make sure the vector exists at that address at least as long as you call the <code>write_*</code> functions.</p>
<p>It is assumed that the vector has the same number of components as there are degrees of freedom in the dof handler, in which case it is assumed to be a vector storing nodal data; or the size may be the number of active cells on the present grid, in which case it is assumed to be a cell data vector. As the number of degrees of freedom and of cells is usually not equal, the function can determine itself which type of vector it is given. However, there are corner cases where this automatic determination does not work. One example is if you compute with piecewise constant elements and have a scalar solution, then there are as many cells as there are degrees of freedom (though they may be numbered differently). Another possibility is if you have a 1d mesh embedded in 2d space and the mesh consists of a closed curve of cells; in this case, there are as many nodes as there are cells, and when using a Q1 element you will have as many degrees of freedom as there are cells. In these cases, you can change the last argument of the function from its default value <a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27ad7189bcb96ade9f785a40b8959ac443e">type_automatic</a> to either <a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27ab25a70fb259c0f1d7a1a18fd6c772227">type_dof_data</a> or <a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27ad2ce9bc33018440a67440bb15791d751">type_cell_data</a>, depending on what the vector represents. Apart from such corner cases, you can leave the argument at its default value and let the function determine the type of the vector itself.</p>
<p>If it is a vector holding DoF data, the names given shall be one for each component of the underlying finite element. If it is a finite element composed of only one subelement, then there is another function following which takes a single name instead of a vector of names.</p>
<p>The data_component_interpretation argument contains information about how the individual components of output files that consist of more than one data set are to be interpreted.</p>
<p>For example, if one has a finite element for the Stokes equations in 2d, representing components (u,v,p), one would like to indicate that the first two, u and v, represent a logical vector so that later on when we generate graphical output we can hand them off to a visualization program that will automatically know to render them as a vector field, rather than as two separate and independent scalar fields.</p>
<p>The default value of this argument (i.e. an empty vector) corresponds is equivalent to a vector of values <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>, indicating that all output components are independent scalar fields. However, if the given data vector represents logical vectors, you may pass a vector that contains values <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>. In the example above, one would pass in a vector with components (<a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>) for (u,v,p).</p>
<p>The names of a data vector shall only contain characters which are letters, underscore and a few other ones. Refer to the ExcInvalidCharacter exception declared in this class to see which characters are valid and which are not.</p>
<dl class="section note"><dt>Note</dt><dd>The actual type for the vector argument may be any vector type from which <a class="el" href="classFEValues.html">FEValues</a> can extract values on a cell using the <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValuesBase::get_function_values()</a> function.</dd>
<dd>
When working in parallel, the vector to be written needs to be ghosted with read access to all degrees of freedom on the locally owned cells, see the <a class="el" href="step_40.html">step-40</a> or <a class="el" href="step_37.html">step-37</a> tutorial programs for details, i.e., it might be necessary to call data.update_ghost_values(). </dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00739">739</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a65f47f598ad14b15eb519350a2846432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65f47f598ad14b15eb519350a2846432">&#9670;&nbsp;</a></span>add_data_vector() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_space_dim &gt;::add_data_vector </td>
          <td>(</td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27">DataVectorType</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27ad7189bcb96ade9f785a40b8959ac443e">type_automatic</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_component_interpretation</em> = <code>std::vector&lt;&#160;<a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is an abbreviation to the above one (see there for a discussion of the various arguments), intended for use with finite elements that are not composed of subelements. In this case, only one name per data vector needs to be given, which is what this function takes. It simply relays its arguments after a conversion of the <code>name</code> to a vector of strings, to the other <a class="el" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector()</a> function above.</p>
<p>If <code>data</code> is a vector with multiple components this function will generate distinct names for all components by appending an underscore and the number of each component to <code>name</code> </p>
<p>The actual type for the template argument may be any vector type from which <a class="el" href="classFEValues.html">FEValues</a> can extract values on a cell using the <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValuesBase::get_function_values()</a> function. </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00765">765</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a4bce7f46c9ad03ecdd71a86d47f8fb11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bce7f46c9ad03ecdd71a86d47f8fb11">&#9670;&nbsp;</a></span>add_data_vector() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_space_dim &gt;::add_data_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt;  &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_component_interpretation</em> = <code>std::vector&lt;&#160;<a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is an extension of the above one (see there for a discussion of the arguments except the first one) and allows to set a vector with its own <a class="el" href="classDoFHandler.html">DoFHandler</a> object. This <a class="el" href="classDoFHandler.html">DoFHandler</a> needs to be compatible with the other <a class="el" href="classDoFHandler.html">DoFHandler</a> objects assigned with calls to <code>add_data_vector</code> or <code>attach_dof_handler</code>, in the sense that all of the <a class="el" href="classDoFHandler.html">DoFHandler</a> objects need to be based on the same triangulation. This function allows you to export data from multiple <a class="el" href="classDoFHandler.html">DoFHandler</a> objects that describe different solution components. An example of using this function is given in <a class="el" href="step_61.html">step-61</a>.</p>
<p>Since this function takes a <a class="el" href="classDoFHandler.html">DoFHandler</a> object and hence naturally represents dof data, the data vector type argument present in the other methods above is not necessary. </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00790">790</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a5ed745ab12b197a57cc5e22af0fcd8a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ed745ab12b197a57cc5e22af0fcd8a7">&#9670;&nbsp;</a></span>add_data_vector() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_space_dim &gt;::add_data_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt;  &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_component_interpretation</em> = <code>std::vector&lt;&#160;<a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is an abbreviation of the function above with only a scalar <code>dof_handler</code> given and a single data name. </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00805">805</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a4f6aa38d46f054f61211dbc02a16e384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f6aa38d46f054f61211dbc02a16e384">&#9670;&nbsp;</a></span>add_data_vector() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_space_dim &gt;::add_data_vector </td>
          <td>(</td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; DoFHandlerType::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_postprocessor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is an alternative to the above ones, allowing the output of derived quantities instead of the given data. This conversion has to be done in a class derived from <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>. This function is used in <a class="el" href="step_29.html">step-29</a>. Other uses are shown in <a class="el" href="step_32.html">step-32</a> and <a class="el" href="step_33.html">step-33</a>.</p>
<p>The names for these derived quantities are provided by the <code>data_postprocessor</code> argument. Likewise, the data_component_interpretation argument of the other <a class="el" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector()</a> functions is provided by the data_postprocessor argument. As only data of type <code>type_dof_data</code> can be transformed, this type is also known implicitly and does not have to be given.</p>
<dl class="section note"><dt>Note</dt><dd>The actual type for the vector argument may be any vector type from which <a class="el" href="classFEValues.html">FEValues</a> can extract values on a cell using the <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValuesBase::get_function_values()</a> function.</dd>
<dd>
The <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> object (i.e., in reality the object of your derived class) has to live until the <a class="el" href="classDataOut.html">DataOut</a> object is destroyed as the latter keeps a pointer to the former and will complain if the object pointed to is destroyed while the latter still has a pointer to it. If both the data postprocessor and <a class="el" href="classDataOut.html">DataOut</a> objects are local variables of a function (as they are, for example, in <a class="el" href="step_29.html">step-29</a>), then you can avoid this error by declaring the data postprocessor variable before the <a class="el" href="classDataOut.html">DataOut</a> variable as objects are destroyed in reverse order of declaration. </dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00841">841</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a444344dcaaff07df72672b57001e1c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a444344dcaaff07df72672b57001e1c27">&#9670;&nbsp;</a></span>add_data_vector() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_space_dim &gt;::add_data_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt;  &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; DoFHandlerType::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_postprocessor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same function as above, but with a <a class="el" href="classDoFHandler.html">DoFHandler</a> object that does not need to coincide with the <a class="el" href="classDoFHandler.html">DoFHandler</a> initially set. Note that the postprocessor can only read data from the given <a class="el" href="classDoFHandler.html">DoFHandler</a> and solution vector, not other solution vectors or DoFHandlers. </p>

</div>
</div>
<a id="ab1f52f05c045de7fa390449c1ed339c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1f52f05c045de7fa390449c1ed339c1">&#9670;&nbsp;</a></span>add_mg_data_vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_space_dim &gt;::add_mg_data_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt;  &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMGLevelObject.html">MGLevelObject</a>&lt; VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_component_interpretation</em> = <code>std::vector&lt;&#160;<a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a multilevel data vector.</p>
<p>This function adds the vector-valued multilevel vector <code>data</code> in the form of a vector on each level that belongs to the <a class="el" href="classDoFHandler.html">DoFHandler</a> <code>dof_handler</code> to the graphical output. This function is typically used in conjunction with a call to <a class="el" href="classDataOut.html#a5d12b73d53d98d9ec35d78ae89a9bd23">set_cell_selection()</a> that selects cells on a specific level and not the active cells (the default).</p>
<p>A vector <code>data</code> can be obtained in several ways, for example by using <a class="el" href="classMultigrid.html#a2614db3c885e19f89b2df14422634c22">Multigrid::solution</a> or <a class="el" href="classMultigrid.html#adecf4e39189911da5096d1112c91680b">Multigrid::defect</a> during or after a multigrid cycle or by interpolating a solution via <a class="el" href="classMGTransferMatrixFree.html#a90aef560cc3d832589ca13a5f18e1414">MGTransferMatrixFree::interpolate_to_mg()</a>.</p>
<p>The handling of <code>names</code> and <code>data_component_interpretation</code> is identical to the <a class="el" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector()</a> function. </p>

</div>
</div>
<a id="a90c63ba80dac30bc2a18664a154d8e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90c63ba80dac30bc2a18664a154d8e80">&#9670;&nbsp;</a></span>add_mg_data_vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_space_dim &gt;::add_mg_data_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt;  &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMGLevelObject.html">MGLevelObject</a>&lt; VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scalar version of the function above. </p>

</div>
</div>
<a id="a38df03770155948e7f702e14599e28e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38df03770155948e7f702e14599e28e7">&#9670;&nbsp;</a></span>clear_data_vectors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_space_dim &gt;::clear_data_vectors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Release the pointers to the data vectors. This allows output of a new set of vectors without supplying the DoF handler again. Therefore, the <a class="el" href="classDataOut.html">DataOut</a> object can be used in an algebraic context. Note that besides the data vectors also the patches already computed are deleted. </p>

</div>
</div>
<a id="a1bda326e895cf4b1489d271cb358cfdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bda326e895cf4b1489d271cb358cfdd">&#9670;&nbsp;</a></span>clear_input_data_references()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_space_dim &gt;::clear_input_data_references </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Release pointers to all input data elements, i.e. pointers to data vectors and to the DoF handler object. This function may be useful when you have called the <code>build_patches</code> function of derived class, since then the patches are built and the input data is no more needed, nor is there a need to reference it. You can then output the patches detached from the main thread and need not make sure anymore that the DoF handler object and vectors must not be deleted before the output thread is finished. </p>

</div>
</div>
<a id="a4d51e2c8ddb56ac1306927c502cd5983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d51e2c8ddb56ac1306927c502cd5983">&#9670;&nbsp;</a></span>merge_patches()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_space_dim &gt;::merge_patches </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; DoFHandlerType2, patch_dim, patch_space_dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; patch_space_dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em> = <code><a class="el" href="classPoint.html">Point</a>&lt;patch_space_dim&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function can be used to merge the patches that were created using the <code>build_patches</code> function of the object given as argument into the list of patches created by this object. This is sometimes handy if one has, for example, a domain decomposition algorithm where each block is represented by a <a class="el" href="classDoFHandler.html">DoFHandler</a> of its own, but one wants to output the solution on all the blocks at the same time.</p>
<p>For this to work, the given argument and this object need to have the same number of output vectors, and they need to use the same number of subdivisions per patch. The output will probably look rather funny if patches in both objects overlap in space.</p>
<p>If you call <a class="el" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches()</a> for this object after merging in patches, the previous state is overwritten, and the merged-in patches are lost.</p>
<p>The second parameter allows to shift each node of the patches in the object passed in in the first parameter by a certain amount. This is sometimes useful to generate "exploded" views of a collection of blocks.</p>
<p>This function will fail if either this or the other object did not yet set up any patches. </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00941">941</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a4769fe891f8d7f9caa1ba4f854484958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4769fe891f8d7f9caa1ba4f854484958">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_space_dim &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Release the pointers to the data vectors and the DoF handler. You have to set all data entries again using the <a class="el" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector()</a> function. The pointer to the dof handler is cleared as well, along with all other data. In effect, this function resets everything to a virgin state. </p>

</div>
</div>
<a id="af605c2840093a5f03e873153544da225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af605c2840093a5f03e873153544da225">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_space_dim &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. </p>

</div>
</div>
<a id="a496f2bb31228bec26f4ce73ef4166b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a496f2bb31228bec26f4ce73ef4166b3d">&#9670;&nbsp;</a></span>get_patches()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::vector&lt;<a class="el" href="classDataOut__DoFData.html#a5d7ef9ef54d930c6cf85e37a1b155e30">Patch</a>&gt;&amp; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_space_dim &gt;::get_patches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function by which the base class's functions get to know what patches they shall write to a file. </p>

<p>Implements <a class="el" href="group__Exceptions.html#ga7c3eeef4bc56cdb85c31e05dc09dae72">DataOutInterface&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a7e60dbfa99a1a31f520893b7145ab321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e60dbfa99a1a31f520893b7145ab321">&#9670;&nbsp;</a></span>get_dataset_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_space_dim &gt;::get_dataset_names </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Virtual function through which the names of data sets are obtained by the output functions of the base class. </p>

<p>Implements <a class="el" href="group__Exceptions.html#ga128e5dec286cc1a429b94e29dd55ab81">DataOutInterface&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a5bf6228742921d4f04fafca0bf30e9cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bf6228742921d4f04fafca0bf30e9cc">&#9670;&nbsp;</a></span>get_fes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::shared_ptr&lt;::<a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt;DoFHandlerType::dimension, DoFHandlerType::space_dimension&gt; &gt; &gt; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_space_dim &gt;::get_fes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Extracts the finite elements stored in the dof_data object, including a dummy object of FE_DGQ&lt;dim&gt;(0) in case only the triangulation is used. </p>

</div>
</div>
<a id="a34486ffea504c88c1bc3e121c8809f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34486ffea504c88c1bc3e121c8809f1e">&#9670;&nbsp;</a></span>get_nonscalar_data_ranges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; std::tuple&lt;unsigned int, unsigned int, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt; &gt; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_space_dim &gt;::get_nonscalar_data_ranges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of the respective <a class="el" href="group__Exceptions.html#ga05d5d72abcf81f4174e15fd984f1267c">DataOutInterface::get_nonscalar_data_ranges()</a> function. See there for a more extensive documentation. </p>

<p>Reimplemented from <a class="el" href="group__Exceptions.html#ga05d5d72abcf81f4174e15fd984f1267c">DataOutInterface&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="aa8cca59e1dd63590824828c21f5854a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8cca59e1dd63590824828c21f5854a0">&#9670;&nbsp;</a></span>add_data_vector_internal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_space_dim &gt;::add_data_vector_internal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt;  *&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27">DataVectorType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_component_interpretation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>deduce_output_names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Common function called by the four public add_data_vector methods. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a12aba32b2db70710325e468f6b8cebb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12aba32b2db70710325e468f6b8cebb7">&#9670;&nbsp;</a></span>spacedim</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType  = DoFHandler&lt;dim&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned int <a class="el" href="classDataOut.html">DataOut</a>&lt; dim, DoFHandlerType &gt;::spacedim = DoFHandlerType::space_dimension</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="numerics_2data__out_8h_source.html#l00156">156</a> of file <a class="el" href="numerics_2data__out_8h_source.html">data_out.h</a>.</p>

</div>
</div>
<a id="aaa5530b77acd5aa7c447bd2c6ba538c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa5530b77acd5aa7c447bd2c6ba538c9">&#9670;&nbsp;</a></span>first_cell_function</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType  = DoFHandler&lt;dim&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="classDataOut.html#a501c6b6a2ac9210e9f5742898908183c">cell_iterator</a>(const <a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, <a class="el" href="classDataOut.html#a12aba32b2db70710325e468f6b8cebb7">spacedim</a>&gt; &amp;)&gt; <a class="el" href="classDataOut.html">DataOut</a>&lt; dim, DoFHandlerType &gt;::first_cell_function</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A function object that is used to select what the first cell is going to be on which to generate graphical output. See the <a class="el" href="classDataOut.html#a5d12b73d53d98d9ec35d78ae89a9bd23">set_cell_selection()</a> function for more information. </p>

<p class="definition">Definition at line <a class="el" href="numerics_2data__out_8h_source.html#l00468">468</a> of file <a class="el" href="numerics_2data__out_8h_source.html">data_out.h</a>.</p>

</div>
</div>
<a id="a1ae126940becff62ea40cd6a73d2062c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ae126940becff62ea40cd6a73d2062c">&#9670;&nbsp;</a></span>next_cell_function</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType  = DoFHandler&lt;dim&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="classDataOut.html#a501c6b6a2ac9210e9f5742898908183c">cell_iterator</a>(const <a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, <a class="el" href="classDataOut.html#a12aba32b2db70710325e468f6b8cebb7">spacedim</a>&gt; &amp;, const <a class="el" href="classDataOut.html#a501c6b6a2ac9210e9f5742898908183c">cell_iterator</a> &amp;)&gt; <a class="el" href="classDataOut.html">DataOut</a>&lt; dim, DoFHandlerType &gt;::next_cell_function</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A function object that is used to select what the next cell is going to be on which to generate graphical output, given a previous cell. See the <a class="el" href="classDataOut.html#a5d12b73d53d98d9ec35d78ae89a9bd23">set_cell_selection()</a> function for more information. </p>

<p class="definition">Definition at line <a class="el" href="numerics_2data__out_8h_source.html#l00477">477</a> of file <a class="el" href="numerics_2data__out_8h_source.html">data_out.h</a>.</p>

</div>
</div>
<a id="abf58679bb3ce869323a2a997415aa1df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf58679bb3ce869323a2a997415aa1df">&#9670;&nbsp;</a></span>triangulation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="classTriangulation.html">Triangulation</a>&lt;DoFHandlerType::dimension, DoFHandlerType::space_dimension&gt; &gt; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_space_dim &gt;::triangulation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the triangulation object. </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00972">972</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a6a282f4d56013f02908e665353fc4b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a282f4d56013f02908e665353fc4b21">&#9670;&nbsp;</a></span>dofs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &gt; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_space_dim &gt;::dofs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the optional handler object. </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00977">977</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="ac6bc1c5c850d7d5c15362a5fdc936777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6bc1c5c850d7d5c15362a5fdc936777">&#9670;&nbsp;</a></span>dof_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;<a class="el" href="classinternal_1_1DataOutImplementation_1_1DataEntryBase.html">internal::DataOutImplementation::DataEntryBase</a>&lt; DoFHandlerType::dimension, DoFHandlerType::space_dimension&gt; &gt; &gt; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_space_dim &gt;::dof_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List of data elements with vectors of values for each degree of freedom. </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00985">985</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a7d58dd18d706e9bc613e3e635538750a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d58dd18d706e9bc613e3e635538750a">&#9670;&nbsp;</a></span>cell_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;<a class="el" href="classinternal_1_1DataOutImplementation_1_1DataEntryBase.html">internal::DataOutImplementation::DataEntryBase</a>&lt; DoFHandlerType::dimension, DoFHandlerType::space_dimension&gt; &gt; &gt; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_space_dim &gt;::cell_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List of data elements with vectors of values for each cell. </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00993">993</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="adb583ebaa6c26c5d31c0becf5aff5558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb583ebaa6c26c5d31c0becf5aff5558">&#9670;&nbsp;</a></span>patches</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classDataOut__DoFData.html#a5d7ef9ef54d930c6cf85e37a1b155e30">Patch</a>&gt; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; , patch_dim, patch_space_dim &gt;::patches</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is a list of patches that is created each time <a class="el" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches()</a> is called. These patches are used in the output routines of the base classes. </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l01000">1000</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/numerics/<a class="el" href="numerics_2data__out_8h_source.html">data_out.h</a></li>
<li>source/numerics/<a class="el" href="numerics_2data__out_8cc_source.html">data_out.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
