<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_1.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-1 tutorial program  。</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.3.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.3.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">The step-1 tutorial program 。 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Aboutthetutorial"> About the tutorial </a><a href="#Aboutthetutorial"> About the tutorial </a>
        <li><a href="#Videolecturesontutorialprograms"> Video lectures on tutorial programs </a><a href="#Videolecturesontutorialprograms"> Video lectures on tutorial programs </a>
        <li><a href="#Whatthisprogramdoes"> What this program does </a><a href="#Whatthisprogramdoes"> What this program does </a>
        <li><a href="#Aboutscientificcomputingingeneral"> About scientific computing in general </a><a href="#Aboutscientificcomputingingeneral"> About scientific computing in general </a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a><a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a><a href="#Includefiles">Include files</a>
        <li><a href="#Creatingthefirstmesh">Creating the first mesh</a><a href="#Creatingthefirstmesh">Creating the first mesh</a>
        <li><a href="#Creatingthesecondmesh">Creating the second mesh</a><a href="#Creatingthesecondmesh">Creating the second mesh</a>
        <li><a href="#Themainfunction">The main function</a><a href="#Themainfunction">The main function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions"> Possibilities for extensions </a><a href="#Possibilitiesforextensions"> Possibilities for extensions </a>
      <ul>
        <li><a href="#Differentadaptiverefinementstrategies"> Different adaptive refinement strategies </a><a href="#Differentadaptiverefinementstrategies"> Different adaptive refinement strategies </a>
        <li><a href="#Differentgeometries"> Different geometries </a><a href="#Differentgeometries"> Different geometries </a>
        <li><a href="#Commentsaboutprogramminganddebugging"> Comments about programming and debugging </a><a href="#Commentsaboutprogramminganddebugging"> Comments about programming and debugging </a>
        <li><a href="#Moreaboutgraphicaloutput"> More about graphical output </a><a href="#Moreaboutgraphicaloutput"> More about graphical output </a>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a><a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
</p>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a> </p><h1>Introduction</h1>
<p><a class="anchor" id="Aboutthetutorial"></a></p><h3>About the tutorial </h3>
<p>由于这是第一个教程程序，让我们先评论一下这个教程和deal.II的其他文档应该如何工作。deal.II的文档基本上有三个不同的层次。</p>
<ul>
<li>教程。这是一个程序集，展示了deal.II在实践中的应用。它通常不在单个参数的层面上讨论单个功能，而是希望给出事物如何共同工作的大画面。换句话说，它讨论的是 "概念"：什么是deal.II的构件，它们如何在有限元程序中一起使用。</li>
<li>手册。这是deal.II中每个类和每个（成员）函数的文档。例如，如果你点击本页顶部的 "主页 "或 "类 "标签，你就可以看到。在这里你可以查到 <a class="el" href="classTriangulation.html#abbbee6e665998c3e4a745cd7836df364">Triangulation::create_triangulation_compatibility</a> 的第二个参数是什么意思，这只是一个略显晦涩的例子。当你知道你要做什么，但忘记了函数到底是怎么命名的，它的参数是什么，或者它的返回值是什么时，你就需要这种级别的文档。请注意，当你读完教程并点击任何一个类或函数名称时，你也会进入手册，也就是说，当你需要对某个函数或类进行更详细的描述时，教程包含了大量进入手册的链接。另一方面，手册并不是学习deal.II的好地方，因为它给了你一个微观的视角，而没有告诉你一个函数如何融入大局。</li>
<li>模块。这些是一起工作或具有相关功能的类和函数组。如果你点击本页顶部的 "模块 "标签，你就会看到一个页面，其中列出了许多这样的组。每个模块都讨论了这些类的基本原理；例如， <a class="el" href="group__Sparsity.html">Sparsity patterns</a> 模块讨论了与存储矩阵的稀疏模式有关的各种不同问题。这就是中级水平的文档：它们给你一个特定领域的概述。例如，当你想知道存在哪些有限元类时，你会看一下 <a class="el" href="group__fe.html">Finite element space descriptions</a> 模块。当然，这些模块也与手册（有时也与教程）有交叉链接；如果你点击一个类的名字，比如说三角形，在类名的右上方也会有这个类所属模块的链接，如果你想进一步了解它的背景。</li>
</ul>
<p>让我们回到教程中来，因为你正在看它的第一个程序（或 "步骤"）。每个教程程序都被细分为以下几个部分。 </p><ol>
<li>
<b>Introduction:</b> 这是讨论程序的作用，包括数学模型，以及与以前的教程程序相比有哪些新的编程技术。 </li>
<li>
<b>The commented program:</b> 广泛记录的源代码清单。在这里，我们经常记录个别行或代码块，并讨论它们做什么，如何做，以及为什么。评论中经常提到介绍，也就是说，你必须先了解<em>what</em>程序想要达到的目标（介绍中讨论的目标），然后才能了解<em>how</em>它打算达到的目标。 </li>
<li>
<b>Results:</b> 程序的输出，包括注释和解释。这一部分也经常有一个小节，给出如何在不同方向上扩展程序的建议；在早期的程序中，这是为了给你提供小实验的方向，旨在使你熟悉deal.II，而在后来的程序中，更多的是关于如何使用更高级的数值技术。 </li>
<li>
<b>The plain program:</b> 剥去所有注释的源代码。如果你想看到代码的 "全貌"，这很有用，因为程序的注释版本中间有很多文字，往往很难在屏幕上一次看到单个函数的全部代码。 </li>
</ol>
<p><br  />
</p>
<p>教程不仅是为了成为静态文档，而且你应该玩一玩。为此，进入 <code>examples/step-1</code> 目录（或任何你感兴趣的教程的编号）并输入</p>
<div class="fragment"><div class="line">cmake .</div>
<div class="line">make</div>
<div class="line">make <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div>
<div class="ttc" id="anamespaceWorkStream_1_1internal_1_1tbb__no__coloring_html_a8673698a405bf47aa24002aeb6d76d70"><div class="ttname"><a href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">WorkStream::internal::tbb_no_coloring::run</a></div><div class="ttdeci">void run(const Iterator &amp;begin, const typename identity&lt; Iterator &gt;::type &amp;end, Worker worker, Copier copier, const ScratchData &amp;sample_scratch_data, const CopyData &amp;sample_copy_data, const unsigned int queue_length, const unsigned int chunk_size)</div><div class="ttdef"><b>Definition:</b> <a href="work__stream_8h_source.html#l00691">work_stream.h:691</a></div></div>
</div><!-- fragment --><p>第一条命令设置文件，描述本教程程序依赖哪些包含文件，如何编译以及如何运行。这个命令应该也能找到已安装的deal.II库，这些库是在你编译和安装<a href="../../readme.html" target="body">README</a>文件中描述的所有内容时产生的。如果这个命令不能找到deal.II库，那么你需要用命令提供安装的路径</p>
<div class="fragment"><div class="line">cmake -DDEAL_II_DIR=/path/to/installed/deal.II .</div>
</div><!-- fragment --><p>来代替。</p>
<p>上述命令中的第二条将源代码编译成可执行文件，而最后一条则是执行它（严格来说，如果可执行文件还不存在， <code>make run</code> 也会编译代码，所以如果你想的话，你可以跳过第二条命令）。这就是运行代码和产生输出所需的全部内容，在教程程序的 "结果 "部分讨论。这个顺序需要在所有你想玩的教程目录中重复。</p>
<p>在学习库的时候，你需要玩玩它，看看会发生什么。为此，用你喜欢的编辑器打开 <code>examples/step-1/step-1.cc</code> 的源文件，并以某种方式进行修改，保存它并按上述方法运行。在这个程序的结果部分的末尾给出了一些可能的修改建议，在那里我们还提供了一些其他有用信息的链接。</p>
<p><a class="anchor" id="Videolecturesontutorialprograms"></a></p><h3>Video lectures on tutorial programs </h3>
<p>在关于deal.II和计算科学的<a href="http://www.math.colostate.edu/~bangerth/videos.html">Wolfgang Bangerth's video lectures</a>中也讨论和演示了这个和其他几个教程程序。特别是，你可以看到他为运行这个和其他程序所执行的步骤，你会对可以用来处理deal.II的工具有一个更好的了解。特别是，第2和第4讲概述了deal.II和任何有限元代码的构建块。( See also <a href="http://www.math.colostate.edu/~bangerth/videos.676.2.html">video lecture 2</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.4.html">video lecture 4</a>.) <br  />
</p>
<p>如果你还不熟悉使用Linux和在命令行上运行东西，你可能有兴趣看第2.9和2.91讲。( See also <a href="http://www.math.colostate.edu/~bangerth/videos.676.2.9.html">video lecture 2.9</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.2.91.html">video lecture 2.91</a>.) These give overviews over the command 行和关于编译程序时发生的事情，分别。</p>
<p>请注意，deal.II正在积极开发，在开发过程中，我们偶尔会对这些视频讲座中仍然引用的函数或类进行重命名或废弃。 例如，视频讲座5中显示的 <a class="el" href="step_1.html">step-1</a> 代码使用了一个HyperShellBoundary类，后来被SphericalManifold类取代。此外，从deal.II 9.0版本开始， <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell()</a> 现在自动将SphericalManifold附加到Triangulation上。否则，其余的讲座材料都是相关的。</p>
<p><a class="anchor" id="Whatthisprogramdoes"></a></p><h3>What this program does </h3>
<p>让我们回到 <a class="el" href="step_1.html">step-1</a> ，即当前的程序。在这个第一个例子中，我们实际上并没有做很多事情，而是展示了两种技术：生成三角形对象的语法是什么，以及所有单元格上简单循环的一些元素。我们创建了两个网格，一个是有规律地细化的正方形（不是很刺激，但对于一些问题来说是常见的起始网格），还有一个是更多的几何尝试：一个环形域，向内边缘细化。通过这些，你将了解到每一个有限元程序都必须有的三样东西。一个用于网格的Triangulation类型的对象；对GridGenerator函数的调用以生成网格；以及涉及迭代器的所有单元的循环（迭代器是指针的泛化，在C++标准库中经常使用；在deal.II的背景下， <a class="el" href="group__Iterators.html">Iterators on mesh-like containers</a> 模块谈到了它们）。</p>
<p>除此之外，该程序很小，不需要大量的介绍。</p>
<dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.5.html">video lecture 5</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.6.html">video lecture 6</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.) <br  />
</dd></dl>
<p><a class="anchor" id="Aboutscientificcomputingingeneral"></a></p><h3>About scientific computing in general </h3>
<p>如果你正在阅读这个教程程序，很可能你有兴趣继续在你自己的项目中使用 deal.II。因此，你即将开始使用一个大规模科学计算库进行编程练习。除非你已经是大规模编程方法的资深用户，否则这对你来说可能是一个新的领域；伴随着所有的新规则，比如你将不得不处理别人写的代码，你可能不得不考虑记录自己的代码，因为你可能在一年后不记得它到底在做什么（或者因为别人也会使用它），或者想出一些方法来测试你的程序是否在做正确的事情。这些都不是我们通常训练数学家、工程师或科学家的东西，但当你开始编写超过几百行的软件时，这些就很重要了。请记住。制作软件与仅仅写代码是不一样的。</p>
<p>为了使你在这一旅程中生活得更轻松，让我们指出一些资源，这些资源在你开始任何大规模的编程之前是值得浏览的。</p>
<ul>
<li><a href="https://github.com/dealii/dealii/wiki/Frequently-Asked-Questions">deal.II FAQ</a>有很多关于deal.II特定方面问题的答案，但也有一些更普遍的问题，如 "我如何调试科学计算代码？"或 "我能否训练自己写出有更少错误的代码？"。</li>
<li>你将从成为一个更好的程序员中受益。为此，一个很好的资源是Steve McConnell <b>[CodeComplete]</b> 的<a href="https://en.wikipedia.org/wiki/Code_Complete">Code Complete</a>一书。这本书已经有几年的历史了，最后一版是在2004年出版的，但它作为良好的编程实践指南的吸引力丝毫不减，一些主要的开发者把它作为他们研究小组每一代成员的集体阅读项目。</li>
<li><a href="http://software-carpentry.org/">Software Carpentry project</a>，提供了对处理软件的许多重要主题的介绍，如版本控制、make文件、测试等。它是专门为科学家和工程师编写的，而不是为计算机科学家编写的，并且侧重于简短、实用的课程。</li>
<li><a href="https://bssw.io/">Better Scientific Software project</a>有大量的资源（和有趣的博文），涵盖了编写科学软件的许多方面。</li>
<li><a href="https://ideas-productivity.org/">IDEAS project</a>也有关于软件开发的资源，特别是用于并行计算。在该网站的 "活动 "部分有录制的教程和网络研讨会，涉及许多有趣的话题。</li>
<li>在<a href="http://arxiv.org/abs/1210.0530">Best Practices for Scientific Computing</a>上有一篇文章，介绍了许多方法，通过这些方法可以确保你是一个高效的程序员，写出能工作的程序。</li>
</ul>
<p>作为一个一般性的建议。如果你希望将来花几天时间来编写软件，那么请你学习能使你的生活更有效率的工具，特别是调试器和集成开发环境。( See also <a href="http://www.math.colostate.edu/~bangerth/videos.676.7.html">video lecture 7</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.8.html">video lecture 8</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.8.01.html">video lecture 8.01</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.25.html">video lecture 25</a>.) 你会发现，通过提高工作效率，你很快就会把学习这些工具的时间拿回来几倍! 上面提到的几个视频讲座展示了如何使用集成开发环境或调试器等工具。<a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>库中最基本的类是Triangulation类，它在这里声明。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div>
<div class="ttc" id="agrid_2tria_8h_html"><div class="ttname"><a href="grid_2tria_8h.html">tria.h</a></div></div>
</div><!-- fragment --><p>这里有一些生成标准网格的函数。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div>
<div class="ttc" id="agrid__generator_8h_html"><div class="ttname"><a href="grid__generator_8h.html">grid_generator.h</a></div></div>
</div><!-- fragment --><p>以各种图形格式输出网格。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div>
<div class="ttc" id="agrid__out_8h_html"><div class="ttname"><a href="grid__out_8h.html">grid_out.h</a></div></div>
</div><!-- fragment --><p>这是C++输出所需要的。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
</div><!-- fragment --><p>还有这个用于 <code>std::sqrt</code> 和 <code>std::fabs</code> 函数的声明。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div>
</div><!-- fragment --><p>导入deal.II的最后一步是这样的。所有deal.II的函数和类都在一个命名空间 <code>dealii</code> 中，以确保它们不会与你可能想和deal.II一起使用的其他库的符号发生冲突。我们可以在使用这些函数和类时，在每个名字前加上 <code>::</code> ，但这样做很快就会变得很麻烦，很烦人。相反，我们只是简单地导入整个deal.II命名空间，供大家使用。</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
<div class="ttc" id="anamespacedealii_html"><div class="ttname"><a href="namespacedealii.html">dealii</a></div><div class="ttdef"><b>Definition:</b> <a href="namespace__dealii_8h_source.html#l00025">namespace_dealii.h:26</a></div></div>
</div><!-- fragment --><p><a class="anchor" id="Creatingthefirstmesh"></a> </p><h3>Creating the first mesh</h3>
<p>在下面的第一个函数中，我们简单地使用单位方格作为域，并从中产生一个全局细化网格。</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> first_grid()</div>
<div class="line">{</div>
</div><!-- fragment --><p>首先要做的是为一个二维域的三角化定义一个对象。</p>
<div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div>
<div class="ttc" id="aclassTriangulation_html"><div class="ttname"><a href="classTriangulation.html">Triangulation</a></div><div class="ttdef"><b>Definition:</b> <a href="grid_2tria_8h_source.html#l01127">tria.h:1128</a></div></div>
<div class="ttc" id="ap4est__wrappers_8cc_html_ace00f2f80d9780ef9aa1007e1c22c6a4"><div class="ttname"><a href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a></div><div class="ttdeci">const ::parallel::distributed::Triangulation&lt; dim, spacedim &gt; * triangulation</div><div class="ttdef"><b>Definition:</b> <a href="p4est__wrappers_8cc_source.html#l00069">p4est_wrappers.cc:69</a></div></div>
</div><!-- fragment --><p>在这里以及接下来的许多情况下，类名后面的字符串"&lt;2&gt;"表示这是一个在两个空间维度上工作的对象。同样地，也有一些三角形类的版本是在一个（"&lt;1&gt;"）和三个（"&lt;3&gt;"）空间维度上工作的。这种工作方式是通过一些模板魔术，我们将在后面的示例程序中更详细地研究；在那里，我们也将看到如何以一种基本上独立于维度的方式来编写程序。</p>
<p>接下来，我们想用一个正方形领域的单个单元来填充三角结构。三角形被细化了四次，总共得到 \(4^4=256\) 个单元。</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>);</div>
<div class="line"><a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.refine_global(4);</div>
<div class="ttc" id="anamespaceGridGenerator_html_acea0cbcd68e52ce8113d1134b87de403"><div class="ttname"><a href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a></div><div class="ttdeci">void hyper_cube(Triangulation&lt; dim, spacedim &gt; &amp;tria, const double left=0., const double right=1., const bool colorize=false)</div></div>
</div><!-- fragment --><p>现在我们想把网格的图形表示写到一个输出文件中。deal.II的GridOut类可以用多种不同的输出格式来实现；在这里，我们选择可扩展矢量图（SVG）格式，你可以用你选择的网络浏览器来进行可视化。</p>
<div class="fragment"><div class="line">  std::ofstream out(<span class="stringliteral">&quot;grid-1.svg&quot;</span>);</div>
<div class="line">  <a class="code" href="classGridOut.html">GridOut</a>       grid_out;</div>
<div class="line">  grid_out.<a class="code" href="classGridOut.html#a1fa6434f6a8d8cda104d47728d30c657">write_svg</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, out);</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Grid written to grid-1.svg&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="aclassGridOut_html"><div class="ttname"><a href="classGridOut.html">GridOut</a></div><div class="ttdef"><b>Definition:</b> <a href="grid__out_8h_source.html#l00992">grid_out.h:993</a></div></div>
<div class="ttc" id="aclassGridOut_html_a1fa6434f6a8d8cda104d47728d30c657"><div class="ttname"><a href="classGridOut.html#a1fa6434f6a8d8cda104d47728d30c657">GridOut::write_svg</a></div><div class="ttdeci">void write_svg(const Triangulation&lt; 2, 2 &gt; &amp;tria, std::ostream &amp;out) const</div><div class="ttdef"><b>Definition:</b> <a href="grid__out_8cc_source.html#l01739">grid_out.cc:1739</a></div></div>
</div><!-- fragment --><p><a class="anchor" id="Creatingthesecondmesh"></a> </p><h3>Creating the second mesh</h3>
<p>下面第二个函数中的网格稍微复杂一些，我们使用了一个环形域，并对结果进行了一次全局细化。</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> second_grid()</div>
<div class="line">{</div>
</div><!-- fragment --><p>我们再次开始定义一个二维域的三角化的对象。</p>
<div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div>
</div><!-- fragment --><p>然后我们用一个环形域来填充它。环的中心应是点（1,0），内部和外部半径应是0.5和1。圆周单元的数量可以由该函数自动调整，但我们选择将其明确设置为10，作为最后一个参数。</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(1, 0);</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>   inner_radius = 0.5, outer_radius = 1.0;</div>
<div class="line"><a class="code" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a>(</div>
<div class="line">  <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>, inner_radius, outer_radius, 10);</div>
<div class="ttc" id="aclassPoint_html"><div class="ttname"><a href="classPoint.html">Point&lt; 2 &gt;</a></div></div>
<div class="ttc" id="adata__out__base_8cc_html_a8188ef4709fc9a4cc076d37447783ba1"><div class="ttname"><a href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a></div><div class="ttdeci">Point&lt; 3 &gt; center</div><div class="ttdef"><b>Definition:</b> <a href="data__out__base_8cc_source.html#l00170">data_out_base.cc:170</a></div></div>
<div class="ttc" id="anamespaceGridGenerator_html_ad85de345ccd86a53e63746709c8e1dfc"><div class="ttname"><a href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a></div><div class="ttdeci">void hyper_shell(Triangulation&lt; dim &gt; &amp;tria, const Point&lt; dim &gt; &amp;center, const double inner_radius, const double outer_radius, const unsigned int n_cells=0, bool colorize=false)</div></div>
</div><!-- fragment --><p>默认情况下，三角测量假定所有边界都是直线，所有单元都是双线性四边形或三线性六边形，而且是由粗网格（我们刚刚创建的）的单元定义。除非我们做一些特别的事情，否则当需要引入新的点时，域被假定为由粗网格的直线划定，而新的点将简单地位于周围的中间。然而，在这里，我们知道领域是弯曲的，我们想让三角法根据底层的几何形状来放置新的点。幸运的是，一些优秀的灵魂实现了一个描述球状域的对象，而环是球状域的一个部分；它只需要环的中心，并自动计算出如何指示三角计算在哪里放置新的点。这在deal.II中的工作方式是，你用一个通常被称为 "流形指标 "的数字来标记你想要弯曲的三角形部分，然后告诉三角形在所有有这个流形指标的地方使用一个特定的 "流形对象"。具体如何操作在此并不重要（你可以在 <a class="el" href="step_53.html">step-53</a> 和 <a class="el" href="group__manifold.html">Manifold description for triangulations</a> 中阅读）。GridGenerator中的函数在大多数情况下为我们处理这个问题：它们将正确的流形附加到一个域上，这样当三角形被细化时，新的单元就会被放置在正确的位置。在目前的情况下， <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a> 为所有的单元格附加了一个球形流形：这使得单元格被细化为球形坐标的计算（因此新单元格的边缘要么是径向的，要么是位于原点周围的同心圆）。 <br  />
</p>
<p>默认情况下（即对于手工创建的三角图或未调用GridGenerator函数（如 <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a> 或 <a class="el" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>), ），三角图的所有单元格和面都将其manifold_id设置为 <a class="el" href="namespacenumbers.html#a9c39a5de95e4d11173378431dc2131fe">numbers::flat_manifold_id</a>, ，如果您想要一个产生直边的流形，这是默认的，但您可以为个别单元格和面改变这一数字。在这种情况下，因此与数字0相关的曲面流形将不适用于那些流形指标为非零的部分，但其他流形描述对象可以与这些非零指标相关联。如果没有流形描述与特定的流形指标相关联，则暗示产生直角边缘的流形。(流形指标是一个略显复杂的话题；如果你对这里到底发生了什么感到困惑，你可能想看看 <a class="el" href="DEALGlossary.html#GlossManifoldIndicator">关于这个话题的词汇表条目</a>)。由于 <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a> 所选择的默认值是合理的，我们就不去管它。 <br  />
</p>
<p>为了演示如何在所有单元格上写一个循环，我们将分五步向域的内圈细化网格。</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> step = 0; step &lt; 5; ++step)</div>
<div class="line">  {</div>
</div><!-- fragment --><p>接下来，我们需要对三角形的活动单元进行循环。你可以把三角网格看作是一个单元格的集合。如果它是一个数组，你只需要得到一个指针，用操作符<code>++</code>从一个元素递增到下一个元素。三角形的单元不是作为一个简单的数组来存储的，但是一个<em>iterator</em>的概念将指针的工作方式概括为任意的对象集合（更多信息见<a href="http://en.wikipedia.org/wiki/Iterator#C.2B.2B">wikipedia</a>）。通常情况下，C++中的任何容器类型都会返回一个迭代器，指向集合的开始，方法称为<code>begin'，而迭代器则指向集合结束后的1，方法称为</code>end'。我们可以用操作符<code>++it</code>来增加迭代器<code>it</code>，用<code>*it</code>来解除引用以获得底层数据，并通过比较<code>it != <a class="el" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">collection.end()</a></code>来检查我们是否已经完成。 <br  />
</p>
<p>第二个重要的部分是，我们只需要活动单元。活跃单元是那些没有被进一步细化的单元，也是唯一可以被标记为进一步细化的单元。deal.II提供了迭代器类别，允许我们在&lt;i&gt;all单元（包括活跃单元的父单元）或只在活跃单元上迭代。因为我们想要后者，所以我们需要调用 <a class="el" href="group__CPP11.html#ga23e860c5192f6501650dda8bb3e2b497">Triangulation::active_cell_iterators()</a>. 方法。 <br  />
</p>
<p>将所有这些放在一起，我们可以用 </p><div class="CodeFragmentInTutorialComment"></div><div class="CodeFragmentInTutorialComment">[1.x.70]</div><div class="CodeFragmentInTutorialComment"></div><p> 循环遍历一个三角形的所有活动单元。 在这个循环的初始化器中，我们用<code>auto</code>关键字来表示迭代器<code>it</code>的类型。<code>auto</code>关键字意味着被声明的对象的类型将从上下文中推断出来。当实际的类型名称很长，甚至可能是多余的时候，这个关键字很有用。如果你不确定类型是什么，想查一下结果支持什么操作，你可以去看方法的文档 <a class="el" href="group__CPP11.html#ga23e860c5192f6501650dda8bb3e2b497">Triangulation::active_cell_iterators()</a>. 在这个例子中，<code>it</code>的类型是 <code><a class="el" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">Triangulation::active_cell_iterator</a></code>. 。 <br  />
</p>
<p>虽然`auto'关键字可以使我们不必键入长长的数据类型名称，但我们仍然要键入大量多余的关于开始和结束迭代器以及如何递增的声明。与其这样，我们不如使用<a href="http://en.cppreference.com/w/cpp/language/range-for">range- based for loops</a>，它将上面显示的所有语法包成一个更短的形式。</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.active_cell_iterators())</div>
<div class="line">  {</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>关于deal.II中使用的迭代器类的更多信息见 <a class="el" href="group__Iterators.html">Iterators on mesh-like containers</a> ，关于基于范围的for循环和<code>auto</code>关键字的更多信息见 <a class="el" href="group__CPP11.html">deal.II and the C++11 standard</a> 。 <br  />
</dd></dl>
<p>接下来，我们对单元格的所有顶点进行循环。为此，我们查询一个顶点索引的迭代器（在2D中，这是一个包含元素<code>{0,1,2,3}</code>的数组，但由于<code>cell-&gt;<a class="el" href="grid__tools_8cc.html#a9bb17554c06536e62c37d90eb7a28d6a">vertex_indices()</a></code>知道单元格所处的维度，因此返回的数组在所有维度上都是正确的，这使得无论我们在2D还是3D中运行这段代码都是正确的，也就是说，它实现了 "维度无关的编程" - 我们将在［ <a class="el" href="step_4.html">step-4</a> ］中讨论一个重要部分）。</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> v : cell-&gt;vertex_indices())</div>
<div class="line">  {</div>
</div><!-- fragment --><p>如果这个单元是在内部边界，那么它至少有一个顶点必须位于内环上，因此与中心的径向距离正好是0.5，达到浮点精度。所以我们计算这个距离，如果我们发现一个顶点具有这个属性，我们就标记这个单元，以便以后进行细化。然后我们也可以打破所有顶点的循环，转到下一个单元。 <br  />
</p>
<p>因为离中心的距离是以浮点数计算的，所以我们必须预期，无论我们计算的是什么，都只能精确到<a href="https://en.wikipedia.org/wiki/Round-off_error">舍入</a>以内。因此，我们永远不能指望通过平等的方式来比较距离和内半径。诸如 "if (distance_from_center == inner_radius) "这样的语句将会失败，除非我们运气特别好。相反，我们需要在一定的容忍度下进行比较，通常的方法是写成<code>if (std::abs(distance_from_center - inner_radius) &lt;= tolerance)</code>，其中<code>tolerance'是某个比四舍五入大的小数字。问题是如何选择它。我们可以直接选择，比如说，</code>1e-10'，但这只适合于我们比较的对象是大小为1的情况。如果我们创建了一个单元大小为<code>1e+10'的网格，那么</code>1e-10'将远远低于四舍五入，就像以前一样，只有在我们特别幸运的情况下，比较才会成功。相反，使公差*相对于被比较对象的典型 "比例 "几乎总是有用的。在这里，"尺度 "是指内半径，或者是细胞的直径。我们选择前者，并设置公差等于 \(10^{-6}\) 乘以环形的内半径。</p>
<div class="fragment"><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> distance_from_center =</div>
<div class="line">        <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>.<a class="code" href="classPoint.html#a3df8e6ab311dab9337c8d7b039c7b815">distance</a>(cell-&gt;vertex(v));</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(distance_from_center - inner_radius) &lt;=</div>
<div class="line">          1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-6 * inner_radius)</div>
<div class="line">        {</div>
<div class="line">          cell-&gt;set_refine_flag();</div>
<div class="line">          <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclassPoint_html_a3df8e6ab311dab9337c8d7b039c7b815"><div class="ttname"><a href="classPoint.html#a3df8e6ab311dab9337c8d7b039c7b815">Point::distance</a></div><div class="ttdeci">numbers::NumberTraits&lt; Number &gt;::real_type distance(const Point&lt; dim, Number &gt; &amp;p) const</div></div>
<div class="ttc" id="anamespaceDifferentiation_1_1SD_html_a592560ee80355620422a86087f11b9df"><div class="ttname"><a href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">Differentiation::SD::fabs</a></div><div class="ttdeci">Expression fabs(const Expression &amp;x)</div><div class="ttdef"><b>Definition:</b> <a href="symengine__math_8cc_source.html#l00273">symengine_math.cc:273</a></div></div>
<div class="ttc" id="anamespacePhysics_1_1Elasticity_1_1Kinematics_html_a9587d5229555daa5b1fa1ba2f8a40adb"><div class="ttname"><a href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">Physics::Elasticity::Kinematics::e</a></div><div class="ttdeci">SymmetricTensor&lt; 2, dim, Number &gt; e(const Tensor&lt; 2, dim, Number &gt; &amp;F)</div></div>
</div><!-- fragment --><p>现在我们已经标记了所有我们想要细化的单元格，我们让三角计算实际做这个细化。这样做的函数的名字很长，因为我们也可以标记单元进行粗化，而且该函数一次完成粗化和细化。</p>
<div class="fragment"><div class="line">  <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.execute_coarsening_and_refinement();</div>
<div class="line">}</div>
</div><!-- fragment --><p>最后，在这五次细化迭代之后，我们要再次将得到的网格写入文件，同样是SVG格式。这和上面的工作一样。</p>
<div class="fragment"><div class="line">  std::ofstream out(<span class="stringliteral">&quot;grid-2.svg&quot;</span>);</div>
<div class="line">  <a class="code" href="classGridOut.html">GridOut</a>       grid_out;</div>
<div class="line">  grid_out.<a class="code" href="classGridOut.html#a1fa6434f6a8d8cda104d47728d30c657">write_svg</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, out);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Grid written to grid-2.svg&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main function</h3>
<p>最后是主函数。这里没有什么可做的，只是调用两个子函数，产生两个网格。</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  first_grid();</div>
<div class="line">  second_grid();</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>运行该程序产生两个网格的图形（grid-1.svg和grid-2.svg）。你可以用大多数网络浏览器打开这些文件&ndash;在最简单的情况下，只要在文件系统资源管理器中打开当前目录并点击文件即可。如果你喜欢在命令行上工作，你可以用该文件调用你的网络浏览器。<code>firefox grid-1.svg</code>，<code>google-chrome grid-1.svg</code>，或者任何你的浏览器的名字。如果你这样做，这两个网格应该看起来像这样。</p>
<table width="60%" align="center">
<tr>
<td align="center"><img src="https://www.dealii.org/images/steps/developer/step-1.grid-1-r9.2.png" alt="" class="inline"/>  </td><td align="center"><img src="https://www.dealii.org/images/steps/developer/step-1.grid-2-r9.2.png" alt="" class="inline"/>   </td></tr>
</table>
<p><br  />
</p>
<p>左边的那个，嗯，不是很刺激。右边的是&mdash;至少是&mdash;非常规的。这些图片对每个单元的 "细化水平 "进行了颜色编码。一个粗略的网格单元要被细分多少次才能得到给定的单元。在左图中，这是无聊的，因为网格被全局细化了若干次，也就是说，<em>every</em>单元被细化了相同的次数。</p>
<p>(虽然第二个网格完全是人为捏造的，当然在应用中也不是很实用，但令大家惊讶的是它已经进入了文献：见 <b>[Mu05]</b> 。显然，它至少对某些事情是有好处的）。)</p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions </h3>
<p><a class="anchor" id="Differentadaptiverefinementstrategies"></a></p><h4>Different adaptive refinement strategies </h4>
<p>这个程序显然没有太多的功能，但特别是 <code>second_grid</code> 函数有一堆你可以玩弄它的地方。例如，你可以修改我们决定细化哪些单元的标准。一个例子是把条件改成这样。</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell: <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.active_cell_iterators())</div>
<div class="line">  <span class="keywordflow">if</span> (cell-&gt;center()[1] &gt; 0)</div>
<div class="line">    cell-&gt;set_refine_flag ();</div>
</div><!-- fragment --><p>这将细化所有单元格中心的 \(y\) 坐标大于零的单元格（我们通过取消引用 <code>cell</code> 迭代器调用的 <code><a class="el" href="classTriaAccessor.html#a8b045bcae58de112897824f4f08d1713">TriaAccessor::center</a></code> 函数返回一个Point&lt;2&gt;对象；下标 <code>[0]</code> 将得到 \(x\) 坐标，下标 <code>[1]</code> 得到 \(y\) 坐标）。通过查看TriaAccessor提供的函数，你也可以使用更复杂的标准进行细化。</p>
<p>一般来说，你能用<code>cell-&gt;something()</code>形式的操作做什么，在文档中有点难找，因为<code>cell</code>不是一个指针，而是一个迭代器。你可以在单元格上调用的函数可以在<code><a class="el" href="classTriaAccessor.html">TriaAccessor</a>'类（它的函数也可以在单元格的面上调用，或者更普遍的，在三角形中出现的各种几何对象）和</code><a class="el" href="classCellAccessor.html">CellAccessor</a>'（它增加了一些专门针对*单元格的函数）的文档中找到。</p>
<p>对整个迭代器概念的更全面的描述可以在 <a class="el" href="group__Iterators.html">Iterators on mesh-like containers</a> 文档模块中找到。</p>
<p><a class="anchor" id="Differentgeometries"></a></p><h4>Different geometries </h4>
<p>另一种可能性是生成完全不同几何形状的网格。虽然对于复杂的几何体，没有办法使用从网格生成器获得的网格，但有大量的几何体，deal.II可以使用GridGenerator命名空间的函数创建网格。许多这样的几何体（如本例程序中使用的几何体）包含有弯曲面的单元：换句话说，我们希望放置在边界上的新顶点位于一个圆上。deal.II通过Manifold类（以及从它继承的类）处理复杂的几何体；尤其是GridGenerator中对应于非笛卡尔网格的函数（如 <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a> ]或 <a class="el" href="namespaceGridGenerator.html#ae63c93351f77276c20de07c91d3c1e48">GridGenerator::truncated_cone</a>) 将一个Manifold对象附加到三角网格中应该是曲线的部分（分别为SphericalManifold和CylindricalManifold），并在应该是平面的部分使用另一个Manifold（FlatManifold）。关于这些类的设计理念和接口的描述，请参见Manifold的文档或 <a class="el" href="group__manifold.html">manifold模块</a>。看看它们提供了什么，看看如何在这样的程序中使用它们。</p>
<p>我们还在 <a class="el" href="step_49.html">step-49</a> 中讨论了其他各种创建和操作网格的方法（并描述了附加歧管的过程）。</p>
<p><a class="anchor" id="Commentsaboutprogramminganddebugging"></a></p><h4>Comments about programming and debugging </h4>
<p>最后，我们对用deal.II修改或编写程序做一个总体的评论。当你开始使用教程程序或你自己的应用程序时，你会发现错误会发生：你的程序会包含一些代码，这些代码要么立即中止程序，要么就是简单地导致错误的结果。无论哪种情况，你都会发现知道如何使用调试器是非常有帮助的：你可能会通过把调试输出放到你的程序中，编译它，然后运行它来应付一段时间，但最终用调试器来寻找错误要快得多，方便得多，而且更可靠，因为你不必一直重新编译程序，而且你可以检查变量的值和它们的变化。</p>
<p>与其推迟学习如何使用调试器，直到你真的看不到任何其他方法来发现一个错误，这里是我们将在本程序中提供的一个建议：尽快学习如何使用调试器。这将是很好的时间投资。( 从顶层的<a href="http://www.dealii.org/">deal.II webpage</a>链接到的 See also <a href="http://www.math.colostate.edu/~bangerth/videos.676.25.html">video lecture 25</a>.) The deal.II Frequently Asked 问题（FAQ）页面也提供了大量关于调试deal.II程序的提示。</p>
<p><a class="anchor" id="Moreaboutgraphicaloutput"></a></p><h4>More about graphical output </h4>
<p>将网格纳入你的论文或出版物中往往是有用的。为此，按细化水平对单元格进行颜色编码，并在每个单元格上打印单元格号，可能不是很有用。但这并不意味着一定要这样做 &ndash; GridOut类允许为每种可能的输出格式设置标志（参见GridOutFlags命名空间中的类），以控制网格的具体绘制方式。当然，你也可以选择其他的输出文件格式，如VTK或VTU；这对三维网格特别有用，因为二维格式如SVG并不特别有用，因为它固定了三维物体的特定视角。因此，你可能想探索GridOut类中的其他选项。<a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Copyright (C) 1999 - 2019 by the deal.II authors</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div>
<div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div>
<div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div>
<div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div>
<div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div>
<div class="line"><span class="comment"> * the top level directory of deal.II.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> first_grid()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>);</div>
<div class="line">  <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.refine_global(4);</div>
<div class="line"> </div>
<div class="line">  std::ofstream out(<span class="stringliteral">&quot;grid-1.svg&quot;</span>);</div>
<div class="line">  <a class="code" href="classGridOut.html">GridOut</a>       grid_out;</div>
<div class="line">  grid_out.<a class="code" href="classGridOut.html#a1fa6434f6a8d8cda104d47728d30c657">write_svg</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, out);</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Grid written to grid-1.svg&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> second_grid()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(1, 0);</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>   inner_radius = 0.5, outer_radius = 1.0;</div>
<div class="line">  <a class="code" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a>(</div>
<div class="line">    <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>, inner_radius, outer_radius, 10);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> step = 0; step &lt; 5; ++step)</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.active_cell_iterators())</div>
<div class="line">        {</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> v : cell-&gt;vertex_indices())</div>
<div class="line">            {</div>
<div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> distance_from_center =</div>
<div class="line">                <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>.<a class="code" href="classPoint.html#a3df8e6ab311dab9337c8d7b039c7b815">distance</a>(cell-&gt;vertex(v));</div>
<div class="line"> </div>
<div class="line">              <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(distance_from_center - inner_radius) &lt;=</div>
<div class="line">                  1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-6 * inner_radius)</div>
<div class="line">                {</div>
<div class="line">                  cell-&gt;set_refine_flag();</div>
<div class="line">                  <span class="keywordflow">break</span>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.execute_coarsening_and_refinement();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  std::ofstream out(<span class="stringliteral">&quot;grid-2.svg&quot;</span>);</div>
<div class="line">  <a class="code" href="classGridOut.html">GridOut</a>       grid_out;</div>
<div class="line">  grid_out.<a class="code" href="classGridOut.html#a1fa6434f6a8d8cda104d47728d30c657">write_svg</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, out);</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Grid written to grid-2.svg&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  first_grid();</div>
<div class="line">  second_grid();</div>
<div class="line">}</div>
</div><!-- fragment --><p> <br  />
 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
