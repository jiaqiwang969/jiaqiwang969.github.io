<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classparallel_1_1fullydistributed_1_1Triangulation.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.3.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.3.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceparallel.html">parallel</a></li><li class="navelem"><a class="el" href="namespaceparallel_1_1fullydistributed.html">fullydistributed</a></li><li class="navelem"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classparallel_1_1fullydistributed_1_1Triangulation-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="fully__distributed__tria_8h_source.html">deal.II/distributed/fully_distributed_tria.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classparallel_1_1fullydistributed_1_1Triangulation__inherit__graph.svg" width="1662" height="134"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a04043b4c8031c526783448969d01cf53"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a04043b4c8031c526783448969d01cf53">cell_iterator</a> = typename ::<a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a04043b4c8031c526783448969d01cf53">cell_iterator</a></td></tr>
<tr class="separator:a04043b4c8031c526783448969d01cf53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1146b56f8c84da24d1c9a68e61182406"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a1146b56f8c84da24d1c9a68e61182406">active_cell_iterator</a> = typename ::<a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a1146b56f8c84da24d1c9a68e61182406">active_cell_iterator</a></td></tr>
<tr class="separator:a1146b56f8c84da24d1c9a68e61182406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1801a900bd27a74e652f041cc9b20da9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a1801a900bd27a74e652f041cc9b20da9">CellStatus</a> = typename ::<a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a1801a900bd27a74e652f041cc9b20da9">CellStatus</a></td></tr>
<tr class="separator:a1801a900bd27a74e652f041cc9b20da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0633dd17e535a59162b79f338c6ff5ae"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a> </td></tr>
<tr class="separator:a0633dd17e535a59162b79f338c6ff5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12cedb5139eeea73fb2a3eec16636f8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ad12cedb5139eeea73fb2a3eec16636f8">level_cell_iterator</a> = <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a04043b4c8031c526783448969d01cf53">cell_iterator</a></td></tr>
<tr class="separator:ad12cedb5139eeea73fb2a3eec16636f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4015f9d1dc9115fbdf74d74960bec074"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga4015f9d1dc9115fbdf74d74960bec074">face_iterator</a> = <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim - 1, dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:ga4015f9d1dc9115fbdf74d74960bec074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad77aace3a5c6c96b985cbf22a28c83f2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#gad77aace3a5c6c96b985cbf22a28c83f2">active_face_iterator</a> = <a class="el" href="classTriaActiveIterator.html">TriaActiveIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim - 1, dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:gad77aace3a5c6c96b985cbf22a28c83f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac23052ad0b446137324ccf9ea0fd386e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#gac23052ad0b446137324ccf9ea0fd386e">vertex_iterator</a> = <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;::<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 0, dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:gac23052ad0b446137324ccf9ea0fd386e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8738294ebb9d165e6b431589b0bbc7f7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga8738294ebb9d165e6b431589b0bbc7f7">active_vertex_iterator</a> = <a class="el" href="classTriaActiveIterator.html">TriaActiveIterator</a>&lt;::<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 0, dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:ga8738294ebb9d165e6b431589b0bbc7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga863d37379dceb11324e72a44039ac495"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga863d37379dceb11324e72a44039ac495">line_iterator</a> = typename IteratorSelector::line_iterator</td></tr>
<tr class="separator:ga863d37379dceb11324e72a44039ac495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfba44e3df01252843f37ee1f8e6df58"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#gabfba44e3df01252843f37ee1f8e6df58">active_line_iterator</a> = typename IteratorSelector::active_line_iterator</td></tr>
<tr class="separator:gabfba44e3df01252843f37ee1f8e6df58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga672c99b1c8da16227cae6f0cf66cc109"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga672c99b1c8da16227cae6f0cf66cc109">quad_iterator</a> = typename IteratorSelector::quad_iterator</td></tr>
<tr class="separator:ga672c99b1c8da16227cae6f0cf66cc109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31b331baff3d6bfb841950b10845fc5f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga31b331baff3d6bfb841950b10845fc5f">active_quad_iterator</a> = typename IteratorSelector::active_quad_iterator</td></tr>
<tr class="separator:ga31b331baff3d6bfb841950b10845fc5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0500bbdefc5ea6a1306892b933896875"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga0500bbdefc5ea6a1306892b933896875">hex_iterator</a> = typename IteratorSelector::hex_iterator</td></tr>
<tr class="separator:ga0500bbdefc5ea6a1306892b933896875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fed0f1753adab5eb220b1bec03ae571"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga4fed0f1753adab5eb220b1bec03ae571">active_hex_iterator</a> = typename IteratorSelector::active_hex_iterator</td></tr>
<tr class="separator:ga4fed0f1753adab5eb220b1bec03ae571"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a84fc193bcb07330e925514206a7d4239"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a84fc193bcb07330e925514206a7d4239">Triangulation</a> (const MPI_Comm &amp;<a class="el" href="classparallel_1_1TriangulationBase.html#a55959d63f6a4e18cae86f005df8605ec">mpi_communicator</a>)</td></tr>
<tr class="separator:a84fc193bcb07330e925514206a7d4239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c6a72a040aa81c8e1b6300da184dee"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#af4c6a72a040aa81c8e1b6300da184dee">~Triangulation</a> ()=default</td></tr>
<tr class="separator:af4c6a72a040aa81c8e1b6300da184dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae09eb5f25fd81eca041851bd8eedec15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#ae09eb5f25fd81eca041851bd8eedec15">create_triangulation</a> (const <a class="el" href="structTriangulationDescription_1_1Description.html">TriangulationDescription::Description</a>&lt; dim, spacedim &gt; &amp;construction_data) override</td></tr>
<tr class="separator:ae09eb5f25fd81eca041851bd8eedec15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ba25d1a33ff78e802592ff7dbcfe1e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a20ba25d1a33ff78e802592ff7dbcfe1e">create_triangulation</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;<a class="el" href="classTriangulation.html#a51469854babb27752dc9f26ed9d5ee30">vertices</a>, const std::vector&lt;::<a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;cells, const <a class="el" href="structSubCellData.html">SubCellData</a> &amp;subcelldata) override</td></tr>
<tr class="separator:a20ba25d1a33ff78e802592ff7dbcfe1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32dee27541d4a63c275046f6e4bdec3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a32dee27541d4a63c275046f6e4bdec3b">copy_triangulation</a> (const ::<a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;other_tria) override</td></tr>
<tr class="separator:a32dee27541d4a63c275046f6e4bdec3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7565ce706569264ab115ebb061d314"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a6a7565ce706569264ab115ebb061d314">set_partitioner</a> (const std::function&lt; void(::<a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;, const unsigned int)&gt; &amp;<a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#ad5c4b0e43427ab6b6bd00950d7de8863">partitioner</a>, const <a class="el" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0">TriangulationDescription::Settings</a> &amp;<a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a2266801c37cca7d3e04a75a65688580b">settings</a>)</td></tr>
<tr class="separator:a6a7565ce706569264ab115ebb061d314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f5cf8e575cfe98719e9afd968e0e06"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a06f5cf8e575cfe98719e9afd968e0e06">execute_coarsening_and_refinement</a> () override</td></tr>
<tr class="separator:a06f5cf8e575cfe98719e9afd968e0e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913467a6ed90032116a4c1f0ba4416f4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a913467a6ed90032116a4c1f0ba4416f4">prepare_coarsening_and_refinement</a> () override</td></tr>
<tr class="separator:a913467a6ed90032116a4c1f0ba4416f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11677987ca8ad5bcc4ab77e8916dcc62"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a11677987ca8ad5bcc4ab77e8916dcc62">has_hanging_nodes</a> () const override</td></tr>
<tr class="separator:a11677987ca8ad5bcc4ab77e8916dcc62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3462af3709c558b158e3a1abba439ad"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#af3462af3709c558b158e3a1abba439ad">memory_consumption</a> () const override</td></tr>
<tr class="separator:af3462af3709c558b158e3a1abba439ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf502e5250d2fbd03f9681cfd12c355"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#adbf502e5250d2fbd03f9681cfd12c355">is_multilevel_hierarchy_constructed</a> () const override</td></tr>
<tr class="separator:adbf502e5250d2fbd03f9681cfd12c355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac954bc1132f894e7deadb42325d526ae"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#ac954bc1132f894e7deadb42325d526ae">save</a> (const std::string &amp;filename) const override</td></tr>
<tr class="separator:ac954bc1132f894e7deadb42325d526ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26557236abb6607adb16edf5375707f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#aa26557236abb6607adb16edf5375707f">load</a> (const std::string &amp;filename, const <a class="el" href="classbool.html">bool</a> autopartition=false) override</td></tr>
<tr class="separator:aa26557236abb6607adb16edf5375707f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6c7f53d060c63005b005e7638d2219"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a0f6c7f53d060c63005b005e7638d2219">clear</a> () override</td></tr>
<tr class="separator:a0f6c7f53d060c63005b005e7638d2219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1a95528832932bf2fad380f8098367"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach</a> (const std::function&lt; std::vector&lt; char &gt;(const <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a04043b4c8031c526783448969d01cf53">cell_iterator</a> &amp;, const <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a1801a900bd27a74e652f041cc9b20da9">CellStatus</a>)&gt; &amp;pack_callback, const <a class="el" href="classbool.html">bool</a> returns_variable_size_data)</td></tr>
<tr class="separator:acb1a95528832932bf2fad380f8098367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbdf11dcfacd414a8936e6d26fecb76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a6fbdf11dcfacd414a8936e6d26fecb76">notify_ready_to_unpack</a> (const unsigned int handle, const std::function&lt; void(const <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a04043b4c8031c526783448969d01cf53">cell_iterator</a> &amp;, const <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a1801a900bd27a74e652f041cc9b20da9">CellStatus</a>, const boost::iterator_range&lt; std::vector&lt; char &gt;::const_iterator &gt; &amp;)&gt; &amp;unpack_callback)</td></tr>
<tr class="separator:a6fbdf11dcfacd414a8936e6d26fecb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e42ca28e9e64c2f292c7cf5d6cb4e5"><td class="memItemLeft" align="right" valign="top">virtual MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#ad6e42ca28e9e64c2f292c7cf5d6cb4e5">get_communicator</a> () const override</td></tr>
<tr class="separator:ad6e42ca28e9e64c2f292c7cf5d6cb4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bca327fa47f88b58086dacc20028064"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1bca327fa47f88b58086dacc20028064">copy_triangulation</a> (const <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;other_tria)</td></tr>
<tr class="separator:a1bca327fa47f88b58086dacc20028064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e904416671ca175093274144e49439"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a74e904416671ca175093274144e49439">n_locally_owned_active_cells</a> () const</td></tr>
<tr class="separator:a74e904416671ca175093274144e49439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fedf8c5b9488f5f82dfbe3d04c3bc0f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacetypes.html#a88f8129eb3e40ecc8022e92a1e15d70e">types::global_cell_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a0fedf8c5b9488f5f82dfbe3d04c3bc0f">n_global_active_cells</a> () const override</td></tr>
<tr class="separator:a0fedf8c5b9488f5f82dfbe3d04c3bc0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6247bd25858eeed99445f2eb810b9c"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels</a> () const override</td></tr>
<tr class="separator:a5e6247bd25858eeed99445f2eb810b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b129156d89f37482d2095de5751d9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a41b129156d89f37482d2095de5751d9c">locally_owned_subdomain</a> () const override</td></tr>
<tr class="separator:a41b129156d89f37482d2095de5751d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182d26a19ae0d8cf91473a647f381364"><td class="memItemLeft" align="right" valign="top">const std::set&lt; <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a182d26a19ae0d8cf91473a647f381364">ghost_owners</a> () const</td></tr>
<tr class="separator:a182d26a19ae0d8cf91473a647f381364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08420b1432082185edaaf83dbc8b4bee"><td class="memItemLeft" align="right" valign="top">const std::set&lt; <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a08420b1432082185edaaf83dbc8b4bee">level_ghost_owners</a> () const</td></tr>
<tr class="separator:a08420b1432082185edaaf83dbc8b4bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6d84acdf8908f48fb236e2c2d47a17"><td class="memItemLeft" align="right" valign="top">const std::weak_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#abe6d84acdf8908f48fb236e2c2d47a17">global_active_cell_index_partitioner</a> () const</td></tr>
<tr class="separator:abe6d84acdf8908f48fb236e2c2d47a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3160e66fd9d88da46c47ce55524d656f"><td class="memItemLeft" align="right" valign="top">const std::weak_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a3160e66fd9d88da46c47ce55524d656f">global_level_cell_index_partitioner</a> (const unsigned int <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a3160e66fd9d88da46c47ce55524d656f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f0952d4737bd402994bc398cfa64a25"><td class="memItemLeft" align="right" valign="top">virtual std::map&lt; unsigned int, std::set&lt;::<a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a7f0952d4737bd402994bc398cfa64a25">compute_vertices_with_ghost_neighbors</a> () const</td></tr>
<tr class="separator:a7f0952d4737bd402994bc398cfa64a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a668fa9fc088a3986cfaefe328d6d2f25"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a668fa9fc088a3986cfaefe328d6d2f25">get_boundary_ids</a> () const override</td></tr>
<tr class="separator:a668fa9fc088a3986cfaefe328d6d2f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04b7e2c65169692ae8805a085c2f7ca"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#af04b7e2c65169692ae8805a085c2f7ca">get_manifold_ids</a> () const override</td></tr>
<tr class="separator:af04b7e2c65169692ae8805a085c2f7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63df2c11257f1e6fb482e4f9ea4589f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#ad63df2c11257f1e6fb482e4f9ea4589f">communicate_locally_moved_vertices</a> (const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;vertex_locally_moved)</td></tr>
<tr class="separator:ad63df2c11257f1e6fb482e4f9ea4589f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a302f66ccc9bd281cf850fdc4f76e50"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a4a302f66ccc9bd281cf850fdc4f76e50">set_mesh_smoothing</a> (const <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a> mesh_smoothing)</td></tr>
<tr class="separator:a4a302f66ccc9bd281cf850fdc4f76e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06df95bfd43216e389a132786f87474f"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a06df95bfd43216e389a132786f87474f">get_mesh_smoothing</a> () const</td></tr>
<tr class="separator:a06df95bfd43216e389a132786f87474f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f9d720f5fbdcdf3dcbb445feefbdb9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a> (const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> number, const <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &amp;manifold_object)</td></tr>
<tr class="separator:ga9f9d720f5fbdcdf3dcbb445feefbdb9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga644a2152b8f5a6902afdc503d163d950"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga644a2152b8f5a6902afdc503d163d950">reset_manifold</a> (const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> manifold_number)</td></tr>
<tr class="separator:ga644a2152b8f5a6902afdc503d163d950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaacb68636e7fc0b399310e570a4d7dd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gaaacb68636e7fc0b399310e570a4d7dd6">reset_all_manifolds</a> ()</td></tr>
<tr class="separator:gaaacb68636e7fc0b399310e570a4d7dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2acfbef517fd03855c4b371f3e182f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a> (const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> number)</td></tr>
<tr class="separator:gae2acfbef517fd03855c4b371f3e182f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f1ea841946c94c079388ecf9ad2c00c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga1f1ea841946c94c079388ecf9ad2c00c">set_all_manifold_ids_on_boundary</a> (const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> number)</td></tr>
<tr class="separator:ga1f1ea841946c94c079388ecf9ad2c00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4e0af28512cb5f9cc8cb3b95a38c669"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gaa4e0af28512cb5f9cc8cb3b95a38c669">set_all_manifold_ids_on_boundary</a> (const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> b_id, const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> number)</td></tr>
<tr class="separator:gaa4e0af28512cb5f9cc8cb3b95a38c669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5d4bed3d2ac6148e969a331bde49f63"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gaa5d4bed3d2ac6148e969a331bde49f63">get_manifold</a> (const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> number) const</td></tr>
<tr class="separator:gaa5d4bed3d2ac6148e969a331bde49f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b191fa3249c9c3641492b6eedebf456"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1b191fa3249c9c3641492b6eedebf456">create_triangulation</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;<a class="el" href="classTriangulation.html#a51469854babb27752dc9f26ed9d5ee30">vertices</a>, const std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;cells, const <a class="el" href="structSubCellData.html">SubCellData</a> &amp;subcelldata)</td></tr>
<tr class="separator:a1b191fa3249c9c3641492b6eedebf456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbbee6e665998c3e4a745cd7836df364"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abbbee6e665998c3e4a745cd7836df364">create_triangulation_compatibility</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;<a class="el" href="classTriangulation.html#a51469854babb27752dc9f26ed9d5ee30">vertices</a>, const std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;cells, const <a class="el" href="structSubCellData.html">SubCellData</a> &amp;subcelldata)</td></tr>
<tr class="separator:abbbee6e665998c3e4a745cd7836df364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc34248a9ba0c38fd0020256a8def5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#afdc34248a9ba0c38fd0020256a8def5c">flip_all_direction_flags</a> ()</td></tr>
<tr class="separator:afdc34248a9ba0c38fd0020256a8def5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f664cd903c4a7d36cfcf59edf77d23"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a79f664cd903c4a7d36cfcf59edf77d23">n_quads</a> () const</td></tr>
<tr class="separator:a79f664cd903c4a7d36cfcf59edf77d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e9cf2d0847dfc5fac2d9d9c39917ad"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a68e9cf2d0847dfc5fac2d9d9c39917ad">n_quads</a> (const unsigned int) const</td></tr>
<tr class="separator:a68e9cf2d0847dfc5fac2d9d9c39917ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa43cc09475a962c64cf81b66bbc6063"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#afa43cc09475a962c64cf81b66bbc6063">n_quads</a> () const</td></tr>
<tr class="separator:afa43cc09475a962c64cf81b66bbc6063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f759946225da01083c7788aba9a51a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ab5f759946225da01083c7788aba9a51a">n_quads</a> (const unsigned int) const</td></tr>
<tr class="separator:ab5f759946225da01083c7788aba9a51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94898f00b04cdd9f446b2781d7c0dcc8"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a94898f00b04cdd9f446b2781d7c0dcc8">n_quads</a> () const</td></tr>
<tr class="separator:a94898f00b04cdd9f446b2781d7c0dcc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b2538b067fac8ad5c6e5f8bf8fae06"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ae0b2538b067fac8ad5c6e5f8bf8fae06">n_quads</a> (const unsigned int) const</td></tr>
<tr class="separator:ae0b2538b067fac8ad5c6e5f8bf8fae06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05dfabc61a0635b5f0448e645e7944f4"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a05dfabc61a0635b5f0448e645e7944f4">n_active_quads</a> (const unsigned int) const</td></tr>
<tr class="separator:a05dfabc61a0635b5f0448e645e7944f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9bb2a1aef23adff709c2fa112bfe870"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ab9bb2a1aef23adff709c2fa112bfe870">n_active_quads</a> () const</td></tr>
<tr class="separator:ab9bb2a1aef23adff709c2fa112bfe870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a33c09d9402a8425583058d7f9d44ce"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a7a33c09d9402a8425583058d7f9d44ce">n_active_quads</a> (const unsigned int) const</td></tr>
<tr class="separator:a7a33c09d9402a8425583058d7f9d44ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e29455eadbe8231a65da04eb0567d6"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a80e29455eadbe8231a65da04eb0567d6">n_active_quads</a> () const</td></tr>
<tr class="separator:a80e29455eadbe8231a65da04eb0567d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f45d56e9d6679fcd0f8d793a5ecb891"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a2f45d56e9d6679fcd0f8d793a5ecb891">n_active_quads</a> (const unsigned int) const</td></tr>
<tr class="separator:a2f45d56e9d6679fcd0f8d793a5ecb891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ff5c5e5aadf633944e2e6c7c7c7767"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a40ff5c5e5aadf633944e2e6c7c7c7767">n_active_quads</a> () const</td></tr>
<tr class="separator:a40ff5c5e5aadf633944e2e6c7c7c7767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d198aebd80535ad593e5133a8812ee"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac0d198aebd80535ad593e5133a8812ee">n_hexs</a> () const</td></tr>
<tr class="separator:ac0d198aebd80535ad593e5133a8812ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2699445c877451375c6128d44c90c9e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af2699445c877451375c6128d44c90c9e">n_hexs</a> (const unsigned int <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:af2699445c877451375c6128d44c90c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23fef4d5635144af728710f4e2783902"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a23fef4d5635144af728710f4e2783902">n_active_hexs</a> () const</td></tr>
<tr class="separator:a23fef4d5635144af728710f4e2783902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d8b81ff513c945250ddff5c6df54cd"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a04d8b81ff513c945250ddff5c6df54cd">n_active_hexs</a> (const unsigned int <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a04d8b81ff513c945250ddff5c6df54cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6e3826a32b12684e8e4ff94a23a648"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5d6e3826a32b12684e8e4ff94a23a648">max_adjacent_cells</a> () const</td></tr>
<tr class="separator:a5d6e3826a32b12684e8e4ff94a23a648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b710ab15cf74994c3f33e4f4d17e95"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aa4b710ab15cf74994c3f33e4f4d17e95">max_adjacent_cells</a> () const</td></tr>
<tr class="separator:aa4b710ab15cf74994c3f33e4f4d17e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a107913a2a6858ec87704accdff065f"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a3a107913a2a6858ec87704accdff065f">max_adjacent_cells</a> () const</td></tr>
<tr class="separator:a3a107913a2a6858ec87704accdff065f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ade3550e213fc07d713a28b489a9a6e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a7ade3550e213fc07d713a28b489a9a6e">n_raw_quads</a> (const unsigned int) const</td></tr>
<tr class="separator:a7ade3550e213fc07d713a28b489a9a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afacb21a22bf29351cf42cfb335e82760"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#afacb21a22bf29351cf42cfb335e82760">n_raw_quads</a> (const unsigned int) const</td></tr>
<tr class="separator:afacb21a22bf29351cf42cfb335e82760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f495bae2139d10563cf878da49bbb6"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ad9f495bae2139d10563cf878da49bbb6">n_raw_quads</a> (const unsigned int) const</td></tr>
<tr class="separator:ad9f495bae2139d10563cf878da49bbb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1cac92589b83a46980c84338e4d32e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a2f1cac92589b83a46980c84338e4d32e">n_raw_quads</a> (const unsigned int <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a2f1cac92589b83a46980c84338e4d32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e1ddd6af8ce2f148dc2e471262cf8c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a41e1ddd6af8ce2f148dc2e471262cf8c">n_raw_quads</a> (const unsigned int <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a41e1ddd6af8ce2f148dc2e471262cf8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70ff6a8fffd9c8f4074fb6f06f708c5"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ab70ff6a8fffd9c8f4074fb6f06f708c5">n_raw_quads</a> (const unsigned int) const</td></tr>
<tr class="separator:ab70ff6a8fffd9c8f4074fb6f06f708c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49642521d7ce41aea4fd882332f47f82"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a49642521d7ce41aea4fd882332f47f82">n_raw_quads</a> () const</td></tr>
<tr class="separator:a49642521d7ce41aea4fd882332f47f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc73e5f4491b310f3a65441be139513"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a0bc73e5f4491b310f3a65441be139513">n_raw_hexs</a> (const unsigned int) const</td></tr>
<tr class="separator:a0bc73e5f4491b310f3a65441be139513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf5b1fd0f6f9753145821d9ff46101a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5cf5b1fd0f6f9753145821d9ff46101a">n_raw_hexs</a> (const unsigned int) const</td></tr>
<tr class="separator:a5cf5b1fd0f6f9753145821d9ff46101a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaec203ac31c6102d901e205bd774362"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aeaec203ac31c6102d901e205bd774362">n_raw_hexs</a> (const unsigned int) const</td></tr>
<tr class="separator:aeaec203ac31c6102d901e205bd774362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a882c905333d176ffdcb5cd79f2e7a51e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a882c905333d176ffdcb5cd79f2e7a51e">n_raw_hexs</a> (const unsigned int <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a882c905333d176ffdcb5cd79f2e7a51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Internal information about the number of objects</div></td></tr>
<tr class="memitem:a2f0c10f7a8cd32d961e9367173685047"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a2f0c10f7a8cd32d961e9367173685047">save</a> (Archive &amp;ar, const unsigned int version) const</td></tr>
<tr class="separator:a2f0c10f7a8cd32d961e9367173685047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f72d5fbb277ec65dbe0382ae72a929"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ae2f72d5fbb277ec65dbe0382ae72a929">load</a> (Archive &amp;ar, const unsigned int version)</td></tr>
<tr class="separator:ae2f72d5fbb277ec65dbe0382ae72a929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a466c6b1755b353d43ce8827b1518e3"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a4a466c6b1755b353d43ce8827b1518e3">n_raw_lines</a> () const</td></tr>
<tr class="separator:a4a466c6b1755b353d43ce8827b1518e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615e8e8877a420fede76cea831f6ca52"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a615e8e8877a420fede76cea831f6ca52">n_raw_lines</a> (const unsigned int <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a615e8e8877a420fede76cea831f6ca52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbcdcdaea38195ba043370ddc6202224"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abbcdcdaea38195ba043370ddc6202224">n_raw_quads</a> () const</td></tr>
<tr class="separator:abbcdcdaea38195ba043370ddc6202224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f590c6799cf3bb79c3c810f972a117e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a9f590c6799cf3bb79c3c810f972a117e">n_raw_quads</a> (const unsigned int <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a9f590c6799cf3bb79c3c810f972a117e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5a359c972a4679b5ff1be96b68efc1"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aed5a359c972a4679b5ff1be96b68efc1">n_raw_hexs</a> (const unsigned int <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:aed5a359c972a4679b5ff1be96b68efc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947c26f9d04c1b4a4fb190334ebd1542"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a947c26f9d04c1b4a4fb190334ebd1542">n_raw_cells</a> (const unsigned int <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a947c26f9d04c1b4a4fb190334ebd1542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7926c72a24cc478de8217c1f6988e0"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5a7926c72a24cc478de8217c1f6988e0">n_raw_faces</a> () const</td></tr>
<tr class="separator:a5a7926c72a24cc478de8217c1f6988e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7117ea716b516ef11a205a5d0020fe40"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a7117ea716b516ef11a205a5d0020fe40">add_periodicity</a> (const std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">GridTools::PeriodicFacePair</a>&lt; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a04043b4c8031c526783448969d01cf53">cell_iterator</a> &gt;&gt; &amp;)</td></tr>
<tr class="separator:a7117ea716b516ef11a205a5d0020fe40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34318b9fb11fa49f10ba7c5155960c6"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::pair&lt; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a04043b4c8031c526783448969d01cf53">cell_iterator</a>, unsigned int &gt;, std::pair&lt; std::pair&lt; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a04043b4c8031c526783448969d01cf53">cell_iterator</a>, unsigned int &gt;, std::bitset&lt; 3 &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac34318b9fb11fa49f10ba7c5155960c6">get_periodic_face_map</a> () const</td></tr>
<tr class="separator:ac34318b9fb11fa49f10ba7c5155960c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f08d0df83f6455dbdac86c1a0736b8"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classReferenceCell.html">ReferenceCell</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af4f08d0df83f6455dbdac86c1a0736b8">get_reference_cells</a> () const</td></tr>
<tr class="separator:af4f08d0df83f6455dbdac86c1a0736b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c84e9fa932ccd35820fe68abfe1348"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a24c84e9fa932ccd35820fe68abfe1348">all_reference_cells_are_hyper_cube</a> () const</td></tr>
<tr class="separator:a24c84e9fa932ccd35820fe68abfe1348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70afc9a4f52455c18183ab31dd6789f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac70afc9a4f52455c18183ab31dd6789f">serialize</a> (Archive &amp;archive, const unsigned int version)</td></tr>
<tr class="separator:ac70afc9a4f52455c18183ab31dd6789f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mesh refinement</div></td></tr>
<tr class="memitem:aed8e461d4b2b23a0e1730afdef36e694"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aed8e461d4b2b23a0e1730afdef36e694">set_all_refine_flags</a> ()</td></tr>
<tr class="separator:aed8e461d4b2b23a0e1730afdef36e694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad0b3fb24aae17f4668427a433dea19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (const unsigned int times=1)</td></tr>
<tr class="separator:a6ad0b3fb24aae17f4668427a433dea19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6552fa04ee753657bd9f92571d76cf09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a6552fa04ee753657bd9f92571d76cf09">coarsen_global</a> (const unsigned int times=1)</td></tr>
<tr class="separator:a6552fa04ee753657bd9f92571d76cf09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">History of a triangulation</div></td></tr>
<tr class="memitem:aca5cfa9068a5d3ad32dfca87e2901a87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aca5cfa9068a5d3ad32dfca87e2901a87">save_refine_flags</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:aca5cfa9068a5d3ad32dfca87e2901a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affce5fca29acccbb2dc1294ebe404a03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#affce5fca29acccbb2dc1294ebe404a03">save_refine_flags</a> (std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v) const</td></tr>
<tr class="separator:affce5fca29acccbb2dc1294ebe404a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43fc07c3f9e1f02658ca556f41087c85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a43fc07c3f9e1f02658ca556f41087c85">load_refine_flags</a> (std::istream &amp;in)</td></tr>
<tr class="separator:a43fc07c3f9e1f02658ca556f41087c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac924a05e66d5e76458ad088a2b7b5583"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac924a05e66d5e76458ad088a2b7b5583">load_refine_flags</a> (const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v)</td></tr>
<tr class="separator:ac924a05e66d5e76458ad088a2b7b5583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64b6155fd89f8f29d4c02795c1a10d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af64b6155fd89f8f29d4c02795c1a10d9">save_coarsen_flags</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:af64b6155fd89f8f29d4c02795c1a10d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaaecbe89311fdaa8a9b999209ff9155"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abaaecbe89311fdaa8a9b999209ff9155">save_coarsen_flags</a> (std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v) const</td></tr>
<tr class="separator:abaaecbe89311fdaa8a9b999209ff9155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4029122ffe741f843f2f3a7deeceea9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aa4029122ffe741f843f2f3a7deeceea9">load_coarsen_flags</a> (std::istream &amp;out)</td></tr>
<tr class="separator:aa4029122ffe741f843f2f3a7deeceea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a9463dcf9aeb3a69831e5e1a321053"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a48a9463dcf9aeb3a69831e5e1a321053">load_coarsen_flags</a> (const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v)</td></tr>
<tr class="separator:a48a9463dcf9aeb3a69831e5e1a321053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178e9ce017916f190ddf7a734ef15902"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a178e9ce017916f190ddf7a734ef15902">get_anisotropic_refinement_flag</a> () const</td></tr>
<tr class="separator:a178e9ce017916f190ddf7a734ef15902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">User data</div></td></tr>
<tr class="memitem:aaa726b33b52f694cfca48fae8e761661"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aaa726b33b52f694cfca48fae8e761661">clear_user_flags</a> ()</td></tr>
<tr class="separator:aaa726b33b52f694cfca48fae8e761661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a9971ee882f15fe521afc4e079383b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a6a9971ee882f15fe521afc4e079383b5">save_user_flags</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a6a9971ee882f15fe521afc4e079383b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad25280beb6c2607418a0d3e903819a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aad25280beb6c2607418a0d3e903819a3">save_user_flags</a> (std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v) const</td></tr>
<tr class="separator:aad25280beb6c2607418a0d3e903819a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3612ed3c7f7f9cccd3003d85b6f7350"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af3612ed3c7f7f9cccd3003d85b6f7350">load_user_flags</a> (std::istream &amp;in)</td></tr>
<tr class="separator:af3612ed3c7f7f9cccd3003d85b6f7350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17946286639b12a03804ebc400eab51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac17946286639b12a03804ebc400eab51">load_user_flags</a> (const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v)</td></tr>
<tr class="separator:ac17946286639b12a03804ebc400eab51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8896f8e838dd34ed5b7c1aa351f76f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af8896f8e838dd34ed5b7c1aa351f76f5">clear_user_flags_line</a> ()</td></tr>
<tr class="separator:af8896f8e838dd34ed5b7c1aa351f76f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7d8e059d6f8f903879eea858215fb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a2b7d8e059d6f8f903879eea858215fb8">save_user_flags_line</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a2b7d8e059d6f8f903879eea858215fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02adea7b298cd5047ee5a5755f87ae36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a02adea7b298cd5047ee5a5755f87ae36">save_user_flags_line</a> (std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v) const</td></tr>
<tr class="separator:a02adea7b298cd5047ee5a5755f87ae36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25190c31d16cde2a01fa0f2318aa0b74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a25190c31d16cde2a01fa0f2318aa0b74">load_user_flags_line</a> (std::istream &amp;in)</td></tr>
<tr class="separator:a25190c31d16cde2a01fa0f2318aa0b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87294511c2f203a57531aaaf2bd2ce39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a87294511c2f203a57531aaaf2bd2ce39">load_user_flags_line</a> (const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v)</td></tr>
<tr class="separator:a87294511c2f203a57531aaaf2bd2ce39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd263157214206ceb637c402552f0eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1dd263157214206ceb637c402552f0eb">clear_user_flags_quad</a> ()</td></tr>
<tr class="separator:a1dd263157214206ceb637c402552f0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4a2db0492d38971366bfcd159cbbc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#acf4a2db0492d38971366bfcd159cbbc1">save_user_flags_quad</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:acf4a2db0492d38971366bfcd159cbbc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431026974872f49e59f6a799ee0a19d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a431026974872f49e59f6a799ee0a19d6">save_user_flags_quad</a> (std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v) const</td></tr>
<tr class="separator:a431026974872f49e59f6a799ee0a19d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e868cde85c04bcc8cec82ba09f24e7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5e868cde85c04bcc8cec82ba09f24e7b">load_user_flags_quad</a> (std::istream &amp;in)</td></tr>
<tr class="separator:a5e868cde85c04bcc8cec82ba09f24e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8651e0def48d61e3f8f0aa8051ae5985"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a8651e0def48d61e3f8f0aa8051ae5985">load_user_flags_quad</a> (const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v)</td></tr>
<tr class="separator:a8651e0def48d61e3f8f0aa8051ae5985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cbe198bb49c3135378bb680582afd46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a7cbe198bb49c3135378bb680582afd46">clear_user_flags_hex</a> ()</td></tr>
<tr class="separator:a7cbe198bb49c3135378bb680582afd46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5512376f914359303ce7d4666d550b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1d5512376f914359303ce7d4666d550b">save_user_flags_hex</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a1d5512376f914359303ce7d4666d550b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57c92493d66995cf29bef79f0e8e09b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ae57c92493d66995cf29bef79f0e8e09b">save_user_flags_hex</a> (std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v) const</td></tr>
<tr class="separator:ae57c92493d66995cf29bef79f0e8e09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e15f4d848adbe6c8bf1af374e467a31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a6e15f4d848adbe6c8bf1af374e467a31">load_user_flags_hex</a> (std::istream &amp;in)</td></tr>
<tr class="separator:a6e15f4d848adbe6c8bf1af374e467a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e827086d26927d08129c8489fdcd45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a77e827086d26927d08129c8489fdcd45">load_user_flags_hex</a> (const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v)</td></tr>
<tr class="separator:a77e827086d26927d08129c8489fdcd45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26562806fd764afdffb973dce92554e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">clear_user_data</a> ()</td></tr>
<tr class="separator:a26562806fd764afdffb973dce92554e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3794cd2d7f80bd81f69fcb828535412"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ae3794cd2d7f80bd81f69fcb828535412">save_user_indices</a> (std::vector&lt; unsigned int &gt; &amp;v) const</td></tr>
<tr class="separator:ae3794cd2d7f80bd81f69fcb828535412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a2359968a027a8b14ae381c8886d30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a12a2359968a027a8b14ae381c8886d30">load_user_indices</a> (const std::vector&lt; unsigned int &gt; &amp;v)</td></tr>
<tr class="separator:a12a2359968a027a8b14ae381c8886d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc8b79020416280c10e4ccde2ee8454"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abcc8b79020416280c10e4ccde2ee8454">save_user_pointers</a> (std::vector&lt; void * &gt; &amp;v) const</td></tr>
<tr class="separator:abcc8b79020416280c10e4ccde2ee8454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8087e84b3b755bcb31767c574342ac0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a8087e84b3b755bcb31767c574342ac0a">load_user_pointers</a> (const std::vector&lt; void * &gt; &amp;v)</td></tr>
<tr class="separator:a8087e84b3b755bcb31767c574342ac0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451b2af8e62783f4780552088fd9ad88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a451b2af8e62783f4780552088fd9ad88">save_user_indices_line</a> (std::vector&lt; unsigned int &gt; &amp;v) const</td></tr>
<tr class="separator:a451b2af8e62783f4780552088fd9ad88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2160dd04545294d138ca00deb4af42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a7b2160dd04545294d138ca00deb4af42">load_user_indices_line</a> (const std::vector&lt; unsigned int &gt; &amp;v)</td></tr>
<tr class="separator:a7b2160dd04545294d138ca00deb4af42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d65cc99c33ea13361700a58ff9d6686"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a8d65cc99c33ea13361700a58ff9d6686">save_user_indices_quad</a> (std::vector&lt; unsigned int &gt; &amp;v) const</td></tr>
<tr class="separator:a8d65cc99c33ea13361700a58ff9d6686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1020c09b32fbb78156b00b833271e21d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1020c09b32fbb78156b00b833271e21d">load_user_indices_quad</a> (const std::vector&lt; unsigned int &gt; &amp;v)</td></tr>
<tr class="separator:a1020c09b32fbb78156b00b833271e21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a18d1c25ca9c0b7cef07c6e92fdd28f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a8a18d1c25ca9c0b7cef07c6e92fdd28f">save_user_indices_hex</a> (std::vector&lt; unsigned int &gt; &amp;v) const</td></tr>
<tr class="separator:a8a18d1c25ca9c0b7cef07c6e92fdd28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad8869b9c8234d6c81c24c69dd97d39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abad8869b9c8234d6c81c24c69dd97d39">load_user_indices_hex</a> (const std::vector&lt; unsigned int &gt; &amp;v)</td></tr>
<tr class="separator:abad8869b9c8234d6c81c24c69dd97d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e0bbc9eac6e707667dad2fe528c178"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a42e0bbc9eac6e707667dad2fe528c178">save_user_pointers_line</a> (std::vector&lt; void * &gt; &amp;v) const</td></tr>
<tr class="separator:a42e0bbc9eac6e707667dad2fe528c178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab55095dab9f1be46f088d6d29d016ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aab55095dab9f1be46f088d6d29d016ba">load_user_pointers_line</a> (const std::vector&lt; void * &gt; &amp;v)</td></tr>
<tr class="separator:aab55095dab9f1be46f088d6d29d016ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1157e5796770a8997fb722b6621921"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1d1157e5796770a8997fb722b6621921">save_user_pointers_quad</a> (std::vector&lt; void * &gt; &amp;v) const</td></tr>
<tr class="separator:a1d1157e5796770a8997fb722b6621921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fadda245a0bef85ae6b957d6154a884"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a6fadda245a0bef85ae6b957d6154a884">load_user_pointers_quad</a> (const std::vector&lt; void * &gt; &amp;v)</td></tr>
<tr class="separator:a6fadda245a0bef85ae6b957d6154a884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8a16ce49cd4b12a65e5fde012b38e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a7d8a16ce49cd4b12a65e5fde012b38e6">save_user_pointers_hex</a> (std::vector&lt; void * &gt; &amp;v) const</td></tr>
<tr class="separator:a7d8a16ce49cd4b12a65e5fde012b38e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e9198f6d3a8dedb19db011e99903863"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a8e9198f6d3a8dedb19db011e99903863">load_user_pointers_hex</a> (const std::vector&lt; void * &gt; &amp;v)</td></tr>
<tr class="separator:a8e9198f6d3a8dedb19db011e99903863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Cell iterator functions</div></td></tr>
<tr class="memitem:a36fb6b15f119483143c433dd10df9b26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a04043b4c8031c526783448969d01cf53">cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a36fb6b15f119483143c433dd10df9b26">begin</a> (const unsigned int <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>=0) const</td></tr>
<tr class="separator:a36fb6b15f119483143c433dd10df9b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6c58805fe436a94b141c1585606c7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a1146b56f8c84da24d1c9a68e61182406">active_cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#afe6c58805fe436a94b141c1585606c7f">begin_active</a> (const unsigned int <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>=0) const</td></tr>
<tr class="separator:afe6c58805fe436a94b141c1585606c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c41c89a9cf1e020050985822196dff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a04043b4c8031c526783448969d01cf53">cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end</a> () const</td></tr>
<tr class="separator:a92c41c89a9cf1e020050985822196dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9597b118c84fce0addf7f4db3b067659"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a04043b4c8031c526783448969d01cf53">cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a9597b118c84fce0addf7f4db3b067659">end</a> (const unsigned int <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a9597b118c84fce0addf7f4db3b067659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0967cc6653ea9a08e94fe9da4d11793"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a1146b56f8c84da24d1c9a68e61182406">active_cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ab0967cc6653ea9a08e94fe9da4d11793">end_active</a> (const unsigned int <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:ab0967cc6653ea9a08e94fe9da4d11793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab51f6fbd9bcd9e41757039a7b4954d2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a04043b4c8031c526783448969d01cf53">cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ab51f6fbd9bcd9e41757039a7b4954d2a">last</a> () const</td></tr>
<tr class="separator:ab51f6fbd9bcd9e41757039a7b4954d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb00096abe5ef91413440e1e1b66c00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a1146b56f8c84da24d1c9a68e61182406">active_cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a2eb00096abe5ef91413440e1e1b66c00">last_active</a> () const</td></tr>
<tr class="separator:a2eb00096abe5ef91413440e1e1b66c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367c0bd718b0ae9316f3b6f52d0ff4c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a04043b4c8031c526783448969d01cf53">cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a367c0bd718b0ae9316f3b6f52d0ff4c6">create_cell_iterator</a> (const <a class="el" href="classCellId.html">CellId</a> &amp;cell_id) const</td></tr>
<tr class="separator:a367c0bd718b0ae9316f3b6f52d0ff4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Cell iterator functions returning ranges of iterators</div></td></tr>
<tr class="memitem:gae2dc0cda6c74461c0bbc22a41b5525c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a04043b4c8031c526783448969d01cf53">cell_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPP11.html#gae2dc0cda6c74461c0bbc22a41b5525c4">cell_iterators</a> () const</td></tr>
<tr class="separator:gae2dc0cda6c74461c0bbc22a41b5525c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23e860c5192f6501650dda8bb3e2b497"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a1146b56f8c84da24d1c9a68e61182406">active_cell_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPP11.html#ga23e860c5192f6501650dda8bb3e2b497">active_cell_iterators</a> () const</td></tr>
<tr class="separator:ga23e860c5192f6501650dda8bb3e2b497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae69f18aa4845bfe513fd51a39755b9d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a04043b4c8031c526783448969d01cf53">cell_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPP11.html#gae69f18aa4845bfe513fd51a39755b9d6">cell_iterators_on_level</a> (const unsigned int <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:gae69f18aa4845bfe513fd51a39755b9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad45356a49aeb1130d244abb313afdc24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a1146b56f8c84da24d1c9a68e61182406">active_cell_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPP11.html#gad45356a49aeb1130d244abb313afdc24">active_cell_iterators_on_level</a> (const unsigned int <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:gad45356a49aeb1130d244abb313afdc24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Face iterator functions</div></td></tr>
<tr class="memitem:abd8e77917e8512bd1e70bf180929f407"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga4015f9d1dc9115fbdf74d74960bec074">face_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abd8e77917e8512bd1e70bf180929f407">begin_face</a> () const</td></tr>
<tr class="separator:abd8e77917e8512bd1e70bf180929f407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e8d4115aad4a2a5c97a7f7c06d34d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#gad77aace3a5c6c96b985cbf22a28c83f2">active_face_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af7e8d4115aad4a2a5c97a7f7c06d34d5">begin_active_face</a> () const</td></tr>
<tr class="separator:af7e8d4115aad4a2a5c97a7f7c06d34d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359dfdc82f2269b68b1d30c8a2286c6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga4015f9d1dc9115fbdf74d74960bec074">face_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a359dfdc82f2269b68b1d30c8a2286c6f">end_face</a> () const</td></tr>
<tr class="separator:a359dfdc82f2269b68b1d30c8a2286c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95c4ae1d1e8d3e7d179fdd6bcbbae7d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; <a class="el" href="group__Iterators.html#gad77aace3a5c6c96b985cbf22a28c83f2">active_face_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPP11.html#ga95c4ae1d1e8d3e7d179fdd6bcbbae7d6">active_face_iterators</a> () const</td></tr>
<tr class="separator:ga95c4ae1d1e8d3e7d179fdd6bcbbae7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Vertex iterator functions</div></td></tr>
<tr class="memitem:aa76498325599ace7304627cb64e5fcd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#gac23052ad0b446137324ccf9ea0fd386e">vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aa76498325599ace7304627cb64e5fcd2">begin_vertex</a> () const</td></tr>
<tr class="separator:aa76498325599ace7304627cb64e5fcd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8705fe160c08af9a2372c605525ef0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga8738294ebb9d165e6b431589b0bbc7f7">active_vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a0e8705fe160c08af9a2372c605525ef0">begin_active_vertex</a> () const</td></tr>
<tr class="separator:a0e8705fe160c08af9a2372c605525ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad93f466afba9b3f003d09a685a615f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#gac23052ad0b446137324ccf9ea0fd386e">vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aaad93f466afba9b3f003d09a685a615f">end_vertex</a> () const</td></tr>
<tr class="separator:aaad93f466afba9b3f003d09a685a615f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Information about the triangulation</div></td></tr>
<tr class="memitem:a46edbe1027405ca9545e3c2289eb3938"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a46edbe1027405ca9545e3c2289eb3938">n_lines</a> () const</td></tr>
<tr class="separator:a46edbe1027405ca9545e3c2289eb3938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5ba9d51dfdd307da590e31c9262c28"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aee5ba9d51dfdd307da590e31c9262c28">n_lines</a> (const unsigned int <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:aee5ba9d51dfdd307da590e31c9262c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c9d6f7b2068f5afa429020086b6b8c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a76c9d6f7b2068f5afa429020086b6b8c">n_active_lines</a> () const</td></tr>
<tr class="separator:a76c9d6f7b2068f5afa429020086b6b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d30203bdeaa3b9e2b416f24b7e9d6d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a21d30203bdeaa3b9e2b416f24b7e9d6d">n_active_lines</a> (const unsigned int <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a21d30203bdeaa3b9e2b416f24b7e9d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105d0305d8c801076bea2404087f29a7"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a105d0305d8c801076bea2404087f29a7">n_quads</a> () const</td></tr>
<tr class="separator:a105d0305d8c801076bea2404087f29a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0817fceed7429359f89928eec87d381"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af0817fceed7429359f89928eec87d381">n_quads</a> (const unsigned int <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:af0817fceed7429359f89928eec87d381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a0837c6dabdda21930bf3d49e9852d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ab7a0837c6dabdda21930bf3d49e9852d">n_active_quads</a> () const</td></tr>
<tr class="separator:ab7a0837c6dabdda21930bf3d49e9852d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf97ad6187b553b2980043dd1c8d75db"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abf97ad6187b553b2980043dd1c8d75db">n_active_quads</a> (const unsigned int <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:abf97ad6187b553b2980043dd1c8d75db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa75fe811e9d1707ce798f874aa2e117"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aaa75fe811e9d1707ce798f874aa2e117">n_hexs</a> () const</td></tr>
<tr class="separator:aaa75fe811e9d1707ce798f874aa2e117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015bc7a2fecb2cba52050a8f2bfbafe1"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a015bc7a2fecb2cba52050a8f2bfbafe1">n_hexs</a> (const unsigned int <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a015bc7a2fecb2cba52050a8f2bfbafe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee621a8e59e259c252ccc64f19e37301"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aee621a8e59e259c252ccc64f19e37301">n_active_hexs</a> () const</td></tr>
<tr class="separator:aee621a8e59e259c252ccc64f19e37301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade8bbb4c8ffd9f8adb683b39a82a9b1e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ade8bbb4c8ffd9f8adb683b39a82a9b1e">n_active_hexs</a> (const unsigned int <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:ade8bbb4c8ffd9f8adb683b39a82a9b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea687f123f3f5a8b09d7485cf03be72"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a> () const</td></tr>
<tr class="separator:abea687f123f3f5a8b09d7485cf03be72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c5623c62d2e43aa63f1eb4904eeec8"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a40c5623c62d2e43aa63f1eb4904eeec8">n_cells</a> (const unsigned int <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a40c5623c62d2e43aa63f1eb4904eeec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea5c9957dbb566a562bbe2c0f3971e9"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a> () const</td></tr>
<tr class="separator:a5ea5c9957dbb566a562bbe2c0f3971e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d106ed8c9a29d6bb7d2bfb636f8df62"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a3d106ed8c9a29d6bb7d2bfb636f8df62">n_active_cells</a> (const unsigned int <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a3d106ed8c9a29d6bb7d2bfb636f8df62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e297d311818e3a79bcede5804f51065"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1e297d311818e3a79bcede5804f51065">n_faces</a> () const</td></tr>
<tr class="separator:a1e297d311818e3a79bcede5804f51065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae907d55b3b12c5c75e58174c1781ff"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5ae907d55b3b12c5c75e58174c1781ff">n_active_faces</a> () const</td></tr>
<tr class="separator:a5ae907d55b3b12c5c75e58174c1781ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777f035a17e91a4d822971516ca11db5"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a> () const</td></tr>
<tr class="separator:a777f035a17e91a4d822971516ca11db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1aadc2300ef9a6f2368fe7bc5926fe8"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">n_vertices</a> () const</td></tr>
<tr class="separator:ae1aadc2300ef9a6f2368fe7bc5926fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3059d54432e0d739534e5330bb7b3a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#afb3059d54432e0d739534e5330bb7b3a">get_vertices</a> () const</td></tr>
<tr class="separator:afb3059d54432e0d739534e5330bb7b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76937acd9dfc3ade1fb885c7ab1ae776"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a76937acd9dfc3ade1fb885c7ab1ae776">n_used_vertices</a> () const</td></tr>
<tr class="separator:a76937acd9dfc3ade1fb885c7ab1ae776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2295fdb4bfc8ab41f51cdbc34de449"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aab2295fdb4bfc8ab41f51cdbc34de449">vertex_used</a> (const unsigned int index) const</td></tr>
<tr class="separator:aab2295fdb4bfc8ab41f51cdbc34de449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07690a619d2817f4c8ef3bb74c43b80a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a07690a619d2817f4c8ef3bb74c43b80a">get_used_vertices</a> () const</td></tr>
<tr class="separator:a07690a619d2817f4c8ef3bb74c43b80a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6313a19a8cc20e07249978218b5ca6a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aa6313a19a8cc20e07249978218b5ca6a">max_adjacent_cells</a> () const</td></tr>
<tr class="separator:aa6313a19a8cc20e07249978218b5ca6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbcac8668993d582f192d3c85b642dd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#acbcac8668993d582f192d3c85b642dd3">get_triangulation</a> ()</td></tr>
<tr class="separator:acbcac8668993d582f192d3c85b642dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae427477f592d34c1bf3367e408f90c3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aae427477f592d34c1bf3367e408f90c3">get_triangulation</a> () const</td></tr>
<tr class="separator:aae427477f592d34c1bf3367e408f90c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Keeping up with what happens to a triangulation</div></td></tr>
<tr class="memitem:ad136f601f63a6d1bd8e205edd93cbae3"><td class="memItemLeft" align="right" valign="top">Signals&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ad136f601f63a6d1bd8e205edd93cbae3">signals</a></td></tr>
<tr class="separator:ad136f601f63a6d1bd8e205edd93cbae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aefd8ddbf96799abebb6c05dced569329"><td class="memItemLeft" align="right" valign="top">static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aefd8ddbf96799abebb6c05dced569329">dimension</a></td></tr>
<tr class="separator:aefd8ddbf96799abebb6c05dced569329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3414a986e63a95d54e961b9b35d756fb"><td class="memItemLeft" align="right" valign="top">static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a3414a986e63a95d54e961b9b35d756fb">space_dimension</a></td></tr>
<tr class="separator:a3414a986e63a95d54e961b9b35d756fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:ae36be1617767da4972eb996d9325902f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ae36be1617767da4972eb996d9325902f">cell_relation_t</a> = typename std::pair&lt; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a04043b4c8031c526783448969d01cf53">cell_iterator</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a1801a900bd27a74e652f041cc9b20da9">CellStatus</a> &gt;</td></tr>
<tr class="separator:ae36be1617767da4972eb996d9325902f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a53caa007ddc9229fa461a0fd925482ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a53caa007ddc9229fa461a0fd925482ae">save_attached_data</a> (const unsigned int global_first_cell, const unsigned int global_num_cells, const std::string &amp;filename) const</td></tr>
<tr class="separator:a53caa007ddc9229fa461a0fd925482ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef794a63c63ff09e2c1c231998083f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#aeef794a63c63ff09e2c1c231998083f2">load_attached_data</a> (const unsigned int global_first_cell, const unsigned int global_num_cells, const unsigned int local_num_cells, const std::string &amp;filename, const unsigned int n_attached_deserialize_fixed, const unsigned int n_attached_deserialize_variable)</td></tr>
<tr class="separator:aeef794a63c63ff09e2c1c231998083f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e5944f1ce4588d3215ae5b63c503e0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a95e5944f1ce4588d3215ae5b63c503e0">update_number_cache</a> ()</td></tr>
<tr class="separator:a95e5944f1ce4588d3215ae5b63c503e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10cf6c4bfa4a3d00d8c76792d1b9872a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a10cf6c4bfa4a3d00d8c76792d1b9872a">update_reference_cells</a> () override</td></tr>
<tr class="separator:a10cf6c4bfa4a3d00d8c76792d1b9872a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac35d252ab3fcbcdc675d6ac526b24c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#adac35d252ab3fcbcdc675d6ac526b24c">reset_global_cell_indices</a> ()</td></tr>
<tr class="separator:adac35d252ab3fcbcdc675d6ac526b24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a891e1057149129681a27bab8ffc10d19"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ae36be1617767da4972eb996d9325902f">cell_relation_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a891e1057149129681a27bab8ffc10d19">local_cell_relations</a></td></tr>
<tr class="separator:a891e1057149129681a27bab8ffc10d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5979f543c847e88743216cb5986f7107"><td class="memItemLeft" align="right" valign="top">CellAttachedData&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a5979f543c847e88743216cb5986f7107">cell_attached_data</a></td></tr>
<tr class="separator:a5979f543c847e88743216cb5986f7107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd423107278fb82665a4a64f0a6da6d2"><td class="memItemLeft" align="right" valign="top">DataTransfer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#afd423107278fb82665a4a64f0a6da6d2">data_transfer</a></td></tr>
<tr class="separator:afd423107278fb82665a4a64f0a6da6d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55959d63f6a4e18cae86f005df8605ec"><td class="memItemLeft" align="right" valign="top">const MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a55959d63f6a4e18cae86f005df8605ec">mpi_communicator</a></td></tr>
<tr class="separator:a55959d63f6a4e18cae86f005df8605ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf7a809217fa1eb11b8c06c49b1b2cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#addf7a809217fa1eb11b8c06c49b1b2cb">my_subdomain</a></td></tr>
<tr class="separator:addf7a809217fa1eb11b8c06c49b1b2cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25846dd7a465319119e91f44d77ae0b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a25846dd7a465319119e91f44d77ae0b1">n_subdomains</a></td></tr>
<tr class="separator:a25846dd7a465319119e91f44d77ae0b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad29d4b50a16239861deb2bb07bc6089"><td class="memItemLeft" align="right" valign="top">NumberCache&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#aad29d4b50a16239861deb2bb07bc6089">number_cache</a></td></tr>
<tr class="separator:aad29d4b50a16239861deb2bb07bc6089"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:ac6506c3f82279eed1dd2ee7f1ea66dc7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac6506c3f82279eed1dd2ee7f1ea66dc7">IteratorSelector</a> = ::<a class="el" href="structinternal_1_1TriangulationImplementation_1_1Iterators.html">internal::TriangulationImplementation::Iterators</a>&lt; dim, spacedim &gt;</td></tr>
<tr class="separator:ac6506c3f82279eed1dd2ee7f1ea66dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:abc62d3732d28c9b6e3cdbd682a5eb014"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#abc62d3732d28c9b6e3cdbd682a5eb014">coarse_cell_id_to_coarse_cell_index</a> (const <a class="el" href="namespacetypes.html#a36be5a74b99dd3f4ab38a2c183250adf">types::coarse_cell_id</a> coarse_cell_id) const override</td></tr>
<tr class="separator:abc62d3732d28c9b6e3cdbd682a5eb014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3e5307d74d2747acf0846eda3e8984"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacetypes.html#a36be5a74b99dd3f4ab38a2c183250adf">types::coarse_cell_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a2b3e5307d74d2747acf0846eda3e8984">coarse_cell_index_to_coarse_cell_id</a> (const unsigned int coarse_cell_index) const override</td></tr>
<tr class="separator:a2b3e5307d74d2747acf0846eda3e8984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b7d4e89daa45162ec29305483a0234"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a77b7d4e89daa45162ec29305483a0234">update_cell_relations</a> () override</td></tr>
<tr class="separator:a77b7d4e89daa45162ec29305483a0234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Line iterator functions for internal use</div></td></tr>
<tr class="memitem:af97878288a5eca64303abe53572ea159"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriangulation.html#a0e0f7bc0b40113139b244a54591e9d53">raw_line_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af97878288a5eca64303abe53572ea159">begin_raw_line</a> (const unsigned int <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>=0) const</td></tr>
<tr class="separator:af97878288a5eca64303abe53572ea159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50f2b3deed6e5f99e91768266df1d6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga863d37379dceb11324e72a44039ac495">line_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aa50f2b3deed6e5f99e91768266df1d6e">begin_line</a> (const unsigned int <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>=0) const</td></tr>
<tr class="separator:aa50f2b3deed6e5f99e91768266df1d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3efa7416e6b56419ffab72ac227a4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#gabfba44e3df01252843f37ee1f8e6df58">active_line_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a8d3efa7416e6b56419ffab72ac227a4a">begin_active_line</a> (const unsigned int <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>=0) const</td></tr>
<tr class="separator:a8d3efa7416e6b56419ffab72ac227a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf640d5b174cae0f46e415c3fe39db2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga863d37379dceb11324e72a44039ac495">line_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5cf640d5b174cae0f46e415c3fe39db2">end_line</a> () const</td></tr>
<tr class="separator:a5cf640d5b174cae0f46e415c3fe39db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Quad iterator functions for internal use</div></td></tr>
<tr class="memitem:a52db7f90cd64a56e55383bef561aa7d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriangulation.html#a80735fd291dca4e5f958ee5876289aa4">raw_quad_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a52db7f90cd64a56e55383bef561aa7d1">begin_raw_quad</a> (const unsigned int <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>=0) const</td></tr>
<tr class="separator:a52db7f90cd64a56e55383bef561aa7d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ee8cea6762ae96b484436de70b3983"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga672c99b1c8da16227cae6f0cf66cc109">quad_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a09ee8cea6762ae96b484436de70b3983">begin_quad</a> (const unsigned int <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>=0) const</td></tr>
<tr class="separator:a09ee8cea6762ae96b484436de70b3983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169e053e788e4d1b6abf7fb7cee6ba3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga31b331baff3d6bfb841950b10845fc5f">active_quad_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a169e053e788e4d1b6abf7fb7cee6ba3c">begin_active_quad</a> (const unsigned int <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>=0) const</td></tr>
<tr class="separator:a169e053e788e4d1b6abf7fb7cee6ba3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4f723b45ffdd6bfefec560fd333dadf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga672c99b1c8da16227cae6f0cf66cc109">quad_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aa4f723b45ffdd6bfefec560fd333dadf">end_quad</a> () const</td></tr>
<tr class="separator:aa4f723b45ffdd6bfefec560fd333dadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a2266801c37cca7d3e04a75a65688580b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0">TriangulationDescription::Settings</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a2266801c37cca7d3e04a75a65688580b">settings</a></td></tr>
<tr class="separator:a2266801c37cca7d3e04a75a65688580b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c4b0e43427ab6b6bd00950d7de8863"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(::<a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;, const unsigned int)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#ad5c4b0e43427ab6b6bd00950d7de8863">partitioner</a></td></tr>
<tr class="separator:ad5c4b0e43427ab6b6bd00950d7de8863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66125a8ea0570cec3b332797a703d03"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; <a class="el" href="namespacetypes.html#a36be5a74b99dd3f4ab38a2c183250adf">types::coarse_cell_id</a>, unsigned int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#ac66125a8ea0570cec3b332797a703d03">coarse_cell_id_to_coarse_cell_index_vector</a></td></tr>
<tr class="separator:ac66125a8ea0570cec3b332797a703d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27144bf4d79680c0bfea6dbb77299f9c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacetypes.html#a36be5a74b99dd3f4ab38a2c183250adf">types::coarse_cell_id</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a27144bf4d79680c0bfea6dbb77299f9c">coarse_cell_index_to_coarse_cell_id_vector</a></td></tr>
<tr class="separator:a27144bf4d79680c0bfea6dbb77299f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af45e31ed66443fb0f65dad97bf76d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a1af45e31ed66443fb0f65dad97bf76d6">currently_processing_create_triangulation_for_internal_usage</a></td></tr>
<tr class="separator:a1af45e31ed66443fb0f65dad97bf76d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd1c9074f1c12ed5f8f3c042d8807dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a2bd1c9074f1c12ed5f8f3c042d8807dc">currently_processing_prepare_coarsening_and_refinement_for_internal_usage</a></td></tr>
<tr class="separator:a2bd1c9074f1c12ed5f8f3c042d8807dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Exceptions</h2></td></tr>
<tr class="memitem:acae2fa4c23a286d83b8d947a714bba40"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; ::<a class="el" href="classinternal_1_1TriangulationImplementation_1_1Policy.html">internal::TriangulationImplementation::Policy</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#acae2fa4c23a286d83b8d947a714bba40">policy</a></td></tr>
<tr class="separator:acae2fa4c23a286d83b8d947a714bba40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d8df10255e3616c7380a31de4c90a3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">GridTools::PeriodicFacePair</a>&lt; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a04043b4c8031c526783448969d01cf53">cell_iterator</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a93d8df10255e3616c7380a31de4c90a3">periodic_face_pairs_level_0</a></td></tr>
<tr class="separator:a93d8df10255e3616c7380a31de4c90a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a371da19ac0c451181b22f371e83a91a6"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::pair&lt; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a04043b4c8031c526783448969d01cf53">cell_iterator</a>, unsigned int &gt;, std::pair&lt; std::pair&lt; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a04043b4c8031c526783448969d01cf53">cell_iterator</a>, unsigned int &gt;, std::bitset&lt; 3 &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a371da19ac0c451181b22f371e83a91a6">periodic_face_map</a></td></tr>
<tr class="separator:a371da19ac0c451181b22f371e83a91a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9474a14d0e8429412c82450013bde67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac9474a14d0e8429412c82450013bde67">smooth_grid</a></td></tr>
<tr class="separator:ac9474a14d0e8429412c82450013bde67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f47aa64420502db8ebeffd531572779"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classReferenceCell.html">ReferenceCell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5f47aa64420502db8ebeffd531572779">reference_cells</a></td></tr>
<tr class="separator:a5f47aa64420502db8ebeffd531572779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609fee9e79ae50f4c348a39838c7eb0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a609fee9e79ae50f4c348a39838c7eb0c">update_periodic_face_map</a> ()</td></tr>
<tr class="separator:a609fee9e79ae50f4c348a39838c7eb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf7a82dea92795d1e2b7efe1d79dd2c9"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaaf7a82dea92795d1e2b7efe1d79dd2c9">ExcInvalidLevel</a> (int arg1, int arg2)</td></tr>
<tr class="separator:gaaf7a82dea92795d1e2b7efe1d79dd2c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f6e5e8dad753152f01dbafe33a3ca6b"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga3f6e5e8dad753152f01dbafe33a3ca6b">ExcTriangulationNotEmpty</a> (int arg1, int arg2)</td></tr>
<tr class="separator:ga3f6e5e8dad753152f01dbafe33a3ca6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c9d4e57043a635b5b500a0586c1102f"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga1c9d4e57043a635b5b500a0586c1102f">ExcGridReadError</a> ()</td></tr>
<tr class="separator:ga1c9d4e57043a635b5b500a0586c1102f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ef856ab83c8d32ad735d94e91104df2"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga3ef856ab83c8d32ad735d94e91104df2">ExcFacesHaveNoLevel</a> ()</td></tr>
<tr class="separator:ga3ef856ab83c8d32ad735d94e91104df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6990c9212a412c867ec48752d7adaff8"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga6990c9212a412c867ec48752d7adaff8">ExcEmptyLevel</a> (int arg1)</td></tr>
<tr class="separator:ga6990c9212a412c867ec48752d7adaff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20d143ee7457a9a3d795b649478a64bc"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga20d143ee7457a9a3d795b649478a64bc">ExcNonOrientableTriangulation</a> ()</td></tr>
<tr class="separator:ga20d143ee7457a9a3d795b649478a64bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbfbe8e4d3cc626d8cd6d9c131b20401"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gabbfbe8e4d3cc626d8cd6d9c131b20401">ExcBoundaryIdNotFound</a> (<a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> arg1)</td></tr>
<tr class="separator:gabbfbe8e4d3cc626d8cd6d9c131b20401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga373a340f3589390f9a5525218430b3b5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga373a340f3589390f9a5525218430b3b5">ExcInconsistentCoarseningFlags</a> ()</td></tr>
<tr class="separator:ga373a340f3589390f9a5525218430b3b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e3e5c077024f40355432c771ccf541"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af9e3e5c077024f40355432c771ccf541">write_bool_vector</a> (const unsigned int magic_number1, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v, const unsigned int magic_number2, std::ostream &amp;out)</td></tr>
<tr class="separator:af9e3e5c077024f40355432c771ccf541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c92032e652bdafdfd7624a55aa2866"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a20c92032e652bdafdfd7624a55aa2866">read_bool_vector</a> (const unsigned int magic_number1, std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v, const unsigned int magic_number2, std::istream &amp;in)</td></tr>
<tr class="separator:a20c92032e652bdafdfd7624a55aa2866"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Hex iterator functions for internal use</h2></td></tr>
<tr class="memitem:ae8e877e2e60025d306a75bb58e7ad68e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::unique_ptr&lt;::<a class="el" href="classinternal_1_1TriangulationImplementation_1_1TriaLevel.html">internal::TriangulationImplementation::TriaLevel</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ae8e877e2e60025d306a75bb58e7ad68e">levels</a></td></tr>
<tr class="separator:ae8e877e2e60025d306a75bb58e7ad68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a706b242073a65dd1e4fe15c58d272671"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;::<a class="el" href="classinternal_1_1TriangulationImplementation_1_1TriaFaces.html">internal::TriangulationImplementation::TriaFaces</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a706b242073a65dd1e4fe15c58d272671">faces</a></td></tr>
<tr class="separator:a706b242073a65dd1e4fe15c58d272671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51469854babb27752dc9f26ed9d5ee30"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a51469854babb27752dc9f26ed9d5ee30">vertices</a></td></tr>
<tr class="separator:a51469854babb27752dc9f26ed9d5ee30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d0610e5c578ced9903db01a70f466f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a12d0610e5c578ced9903db01a70f466f">vertices_used</a></td></tr>
<tr class="separator:a12d0610e5c578ced9903db01a70f466f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf716af5de623e392f8a9f61cc313f5"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>, std::unique_ptr&lt; const <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abbf716af5de623e392f8a9f61cc313f5">manifold</a></td></tr>
<tr class="separator:abbf716af5de623e392f8a9f61cc313f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12dc6feb50966969856aa359f6fa316a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a12dc6feb50966969856aa359f6fa316a">anisotropic_refinement</a></td></tr>
<tr class="separator:a12dc6feb50966969856aa359f6fa316a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c55287cc4c709190b521fd98a4f5e02"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5c55287cc4c709190b521fd98a4f5e02">check_for_distorted_cells</a></td></tr>
<tr class="separator:a5c55287cc4c709190b521fd98a4f5e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3c27fe127e4b1d7de6bc67bb1eae97"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; std::map&lt; unsigned int, <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5d3c27fe127e4b1d7de6bc67bb1eae97">vertex_to_boundary_id_map_1d</a></td></tr>
<tr class="separator:a5d3c27fe127e4b1d7de6bc67bb1eae97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c156f5743dad8cd571f0c63ce0b39e6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; std::map&lt; unsigned int, <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1c156f5743dad8cd571f0c63ce0b39e6">vertex_to_manifold_id_map_1d</a></td></tr>
<tr class="separator:a1c156f5743dad8cd571f0c63ce0b39e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26795906ff2742c5f2109113b79d6744"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriangulation.html#ac2be382ff40558d007dd767a1288dc1e">raw_hex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a26795906ff2742c5f2109113b79d6744">begin_raw_hex</a> (const unsigned int <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>=0) const</td></tr>
<tr class="separator:a26795906ff2742c5f2109113b79d6744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae764c732cc0de8322257d13912552b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga0500bbdefc5ea6a1306892b933896875">hex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aae764c732cc0de8322257d13912552b8">begin_hex</a> (const unsigned int <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>=0) const</td></tr>
<tr class="separator:aae764c732cc0de8322257d13912552b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e876cdf1cdae06aa793cc5081b4fe31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga4fed0f1753adab5eb220b1bec03ae571">active_hex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1e876cdf1cdae06aa793cc5081b4fe31">begin_active_hex</a> (const unsigned int <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>=0) const</td></tr>
<tr class="separator:a1e876cdf1cdae06aa793cc5081b4fe31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd003c8d0a9d5839488ee2ad1313703"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga0500bbdefc5ea6a1306892b933896875">hex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aadd003c8d0a9d5839488ee2ad1313703">end_hex</a> () const</td></tr>
<tr class="separator:aadd003c8d0a9d5839488ee2ad1313703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d0ea3487d046b34de4ee8f60abf1b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a61d0ea3487d046b34de4ee8f60abf1b2">clear_despite_subscriptions</a> ()</td></tr>
<tr class="separator:a61d0ea3487d046b34de4ee8f60abf1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42c164ad82da9629eab01f90ef2a360"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af42c164ad82da9629eab01f90ef2a360">reset_policy</a> ()</td></tr>
<tr class="separator:af42c164ad82da9629eab01f90ef2a360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365332f11d26e60c46a1f9bbb3e5e1c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a365332f11d26e60c46a1f9bbb3e5e1c1">reset_active_cell_indices</a> ()</td></tr>
<tr class="separator:a365332f11d26e60c46a1f9bbb3e5e1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a73cdc08e502d9a140a625184526b89"><td class="memItemLeft" align="right" valign="top">DistortedCellList&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a8a73cdc08e502d9a140a625184526b89">execute_refinement</a> ()</td></tr>
<tr class="separator:a8a73cdc08e502d9a140a625184526b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeebb271c1406d688a1ffb802a7bb509"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#afeebb271c1406d688a1ffb802a7bb509">execute_coarsening</a> ()</td></tr>
<tr class="separator:afeebb271c1406d688a1ffb802a7bb509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37dc87bf8f3793947ba51f2da20b8442"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a37dc87bf8f3793947ba51f2da20b8442">fix_coarsen_flags</a> ()</td></tr>
<tr class="separator:a37dc87bf8f3793947ba51f2da20b8442"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Subscriptor functionality</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp8d6bc922eebec0b76272099aee4a220d"></a>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</td></tr>
<tr class="memitem:ga20658b60d6ef2d530fafa076efa9f503"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga20658b60d6ef2d530fafa076efa9f503">counter</a></td></tr>
<tr class="separator:ga20658b60d6ef2d530fafa076efa9f503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73f9f8936b61e6e17ab2a82e9516e95b"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga73f9f8936b61e6e17ab2a82e9516e95b">counter_map</a></td></tr>
<tr class="separator:ga73f9f8936b61e6e17ab2a82e9516e95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga094d5932c6c004c2a2b1b966950fb2f7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga094d5932c6c004c2a2b1b966950fb2f7">validity_pointers</a></td></tr>
<tr class="separator:ga094d5932c6c004c2a2b1b966950fb2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44e13f7984b31af8d7c54921175a75ff"><td class="memItemLeft" align="right" valign="top">const std::type_info *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga44e13f7984b31af8d7c54921175a75ff">object_info</a></td></tr>
<tr class="separator:ga44e13f7984b31af8d7c54921175a75ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga300c593ea0f9422dcbce1445903e6c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga300c593ea0f9422dcbce1445903e6c12">check_no_subscribers</a> () const noexcept</td></tr>
<tr class="separator:ga300c593ea0f9422dcbce1445903e6c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaeb9ac67567aa7d837f25debd33cd4ce5">map_value_type</a> = decltype(<a class="el" href="group__Exceptions.html#ga73f9f8936b61e6e17ab2a82e9516e95b">counter_map</a>)::value_type</td></tr>
<tr class="separator:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacebdc2d11f8522e4d9e8b7d73ac3f491">map_iterator</a> = decltype(<a class="el" href="group__Exceptions.html#ga73f9f8936b61e6e17ab2a82e9516e95b">counter_map</a>)::iterator</td></tr>
<tr class="separator:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (int arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e0d86893427a935e46d5bd6dcbc3f78"><td class="memItemLeft" align="right" valign="top">static std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7e0d86893427a935e46d5bd6dcbc3f78">mutex</a></td></tr>
<tr class="separator:ga7e0d86893427a935e46d5bd6dcbc3f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Cell iterator functions for internal use</h2></td></tr>
<tr class="memitem:a45bb19508b89ac6ed237b14bf7a506ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriangulation.html#a5977e64adfde9e63f274be77bb34dddc">raw_cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a45bb19508b89ac6ed237b14bf7a506ef">begin_raw</a> (const unsigned int <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>=0) const</td></tr>
<tr class="separator:a45bb19508b89ac6ed237b14bf7a506ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cbfc1e5187c6ad0a47d1b616f9f5149"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriangulation.html#a5977e64adfde9e63f274be77bb34dddc">raw_cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5cbfc1e5187c6ad0a47d1b616f9f5149">end_raw</a> (const unsigned int <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>) const</td></tr>
<tr class="separator:a5cbfc1e5187c6ad0a47d1b616f9f5149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5977e64adfde9e63f274be77bb34dddc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5977e64adfde9e63f274be77bb34dddc">raw_cell_iterator</a> = <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:a5977e64adfde9e63f274be77bb34dddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39637491c7d7e9f7bc4b7ea40a0d72b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ad39637491c7d7e9f7bc4b7ea40a0d72b">raw_face_iterator</a> = <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim - 1, dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:ad39637491c7d7e9f7bc4b7ea40a0d72b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099dd8d123778fdadd882415d639d1b4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a099dd8d123778fdadd882415d639d1b4">raw_vertex_iterator</a> = <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt;::<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 0, dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:a099dd8d123778fdadd882415d639d1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0f7bc0b40113139b244a54591e9d53"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a0e0f7bc0b40113139b244a54591e9d53">raw_line_iterator</a> = typename IteratorSelector::raw_line_iterator</td></tr>
<tr class="separator:a0e0f7bc0b40113139b244a54591e9d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80735fd291dca4e5f958ee5876289aa4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a80735fd291dca4e5f958ee5876289aa4">raw_quad_iterator</a> = typename IteratorSelector::raw_quad_iterator</td></tr>
<tr class="separator:a80735fd291dca4e5f958ee5876289aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2be382ff40558d007dd767a1288dc1e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac2be382ff40558d007dd767a1288dc1e">raw_hex_iterator</a> = typename IteratorSelector::raw_hex_iterator</td></tr>
<tr class="separator:ac2be382ff40558d007dd767a1288dc1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int spacedim = dim&gt;<br />
class parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</h3>

<p>A distributed triangulation with a distributed coarse grid.</p>
<p>The motivation for <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">parallel::fullydistributed::Triangulation</a> has its origins in the following observations about complex geometries and/or about given meshes created by an external mesh generator. We regard complex geometries as geometries that can be meshed only with a non-negligible number of coarse cells (&gt;10,000):</p><ul>
<li>storing the coarse-grid information on every process is too expensive from a memory point of view (as done by <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>). Normally, a process only needs a small section of the global triangulation, i.e., a small section of the coarse grid such that a partitioning of the coarse grid is indeed essential. The cells stored on each process consist of the <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">locally owned cells</a> and the <a class="el" href="DEALGlossary.html#GlossGhostCell">ghost cells</a>.</li>
<li>the distribution of the active cells - on the finest level - among all processes by simply partitioning a space-filling curve might not lead to an optimal result for triangulations that originate from large coarse grids: e.g. partitions that belong to the same process might be discontinuous, leading to increased communication (within a node and beyond). Graph-based partitioning algorithms might be a sound alternative to the space filling curve used by <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>.</li>
</ul>
<p>To be able to construct a fully partitioned triangulation that distributes the coarse grid and gives flexibility regarding partitioning, the following ingredients are required:</p><ul>
<li>a locally relevant coarse-grid triangulation (vertices, cell definition; including a layer of ghost cells)</li>
<li>a mapping of the locally relevant coarse-grid triangulation into the global coarse-grid triangulation</li>
<li>information about which cell should be refined as well as information regarding the subdomain_id, the level_subdomain_id, manifold_id, and boundary_id of each cell.</li>
</ul>
<p>The ingredients listed above are bundled in the struct <a class="el" href="structTriangulationDescription_1_1Description.html">TriangulationDescription::Description</a>. The user has to fill this data structure - in a pre-processing step - before actually creating the triangulation. Predefined functions to create <a class="el" href="structTriangulationDescription_1_1Description.html">TriangulationDescription::Description</a> can be found in the namespace <a class="el" href="namespaceTriangulationDescription_1_1Utilities.html">TriangulationDescription::Utilities</a>.</p>
<p>Once the <a class="el" href="structTriangulationDescription_1_1Description.html">TriangulationDescription::Description</a> <code>construction_data</code> has been constructed, the triangulation <code>tria</code> can be created by calling <code>tria.create_triangulation(construction_data);</code>.</p>
<dl class="section note"><dt>Note</dt><dd>This triangulation supports: 1D/2D/3D, hanging nodes, geometric multigrid, and periodicity.</dd>
<dd>
You can create a triangulation with hanging nodes and multigrid levels with <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#ae09eb5f25fd81eca041851bd8eedec15">create_triangulation()</a>. However, once it has been created, it cannot be altered anymore, i.e. you cannot coarsen or refine afterwards.</dd>
<dd>
Currently only simple periodicity conditions (i.e. without offsets and rotation matrices - see also the documentation of <a class="el" href="namespaceGridTools.html#aee88c4dce5066a41183b5dd70289b9df">GridTools::collect_periodic_faces()</a>) are supported. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fully__distributed__tria_8h_source.html#l00113">113</a> of file <a class="el" href="fully__distributed__tria_8h_source.html">fully_distributed_tria.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a04043b4c8031c526783448969d01cf53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04043b4c8031c526783448969d01cf53">&#9670;&nbsp;</a></span>cell_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">parallel::fullydistributed::Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a04043b4c8031c526783448969d01cf53">cell_iterator</a> =  typename ::<a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt;dim, spacedim&gt;::<a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a04043b4c8031c526783448969d01cf53">cell_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="fully__distributed__tria_8h_source.html#l00117">117</a> of file <a class="el" href="fully__distributed__tria_8h_source.html">fully_distributed_tria.h</a>.</p>

</div>
</div>
<a id="a1146b56f8c84da24d1c9a68e61182406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1146b56f8c84da24d1c9a68e61182406">&#9670;&nbsp;</a></span>active_cell_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">parallel::fullydistributed::Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a1146b56f8c84da24d1c9a68e61182406">active_cell_iterator</a> =  typename ::<a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt;dim, spacedim&gt;::<a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a1146b56f8c84da24d1c9a68e61182406">active_cell_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="fully__distributed__tria_8h_source.html#l00120">120</a> of file <a class="el" href="fully__distributed__tria_8h_source.html">fully_distributed_tria.h</a>.</p>

</div>
</div>
<a id="a1801a900bd27a74e652f041cc9b20da9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1801a900bd27a74e652f041cc9b20da9">&#9670;&nbsp;</a></span>CellStatus</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">parallel::fullydistributed::Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a1801a900bd27a74e652f041cc9b20da9">CellStatus</a> =  typename ::<a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt;dim, spacedim&gt;::<a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a1801a900bd27a74e652f041cc9b20da9">CellStatus</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="fully__distributed__tria_8h_source.html#l00123">123</a> of file <a class="el" href="fully__distributed__tria_8h_source.html">fully_distributed_tria.h</a>.</p>

</div>
</div>
<a id="ae36be1617767da4972eb996d9325902f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae36be1617767da4972eb996d9325902f">&#9670;&nbsp;</a></span>cell_relation_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::<a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ae36be1617767da4972eb996d9325902f">cell_relation_t</a> =  typename std::pair&lt;<a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a04043b4c8031c526783448969d01cf53">cell_iterator</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a1801a900bd27a74e652f041cc9b20da9">CellStatus</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Auxiliary data structure for assigning a CellStatus to a deal.II cell iterator. For an extensive description of the former, see the documentation for the member function <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a>. </p>

<p class="definition">Definition at line <a class="el" href="tria__base_8h_source.html#l00708">708</a> of file <a class="el" href="tria__base_8h_source.html">tria_base.h</a>.</p>

</div>
</div>
<a id="ac6506c3f82279eed1dd2ee7f1ea66dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6506c3f82279eed1dd2ee7f1ea66dc7">&#9670;&nbsp;</a></span>IteratorSelector</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#ac6506c3f82279eed1dd2ee7f1ea66dc7">IteratorSelector</a> =  ::<a class="el" href="structinternal_1_1TriangulationImplementation_1_1Iterators.html">internal::TriangulationImplementation::Iterators</a>&lt;dim, spacedim&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An internal alias to make the definition of the iterator classes simpler. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l01134">1134</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="ad12cedb5139eeea73fb2a3eec16636f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12cedb5139eeea73fb2a3eec16636f8">&#9670;&nbsp;</a></span>level_cell_iterator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#ad12cedb5139eeea73fb2a3eec16636f8">level_cell_iterator</a> =  <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a04043b4c8031c526783448969d01cf53">cell_iterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The same as above to allow the usage of the "MeshType concept" also on the refinement levels. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l01367">1367</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="ga4015f9d1dc9115fbdf74d74960bec074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4015f9d1dc9115fbdf74d74960bec074">&#9670;&nbsp;</a></span>face_iterator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="group__Iterators.html#ga4015f9d1dc9115fbdf74d74960bec074">face_iterator</a> =  <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt;dim - 1, dim, spacedim&gt; &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An alias that is used to identify iterators that point to faces. The concept of iterators is discussed at length in the <a class="el" href="group__Iterators.html">iterators documentation module</a>.</p>
<p>The current alias identifies faces in a triangulation. The <a class="el" href="classTriaIterator.html">TriaIterator</a> class works like a pointer to objects that when you dereference it yields an object of type <a class="el" href="classTriaAccessor.html">TriaAccessor</a>, i.e., class that can be used to query geometric properties of faces such as their vertices, their area, etc. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l01400">1400</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="gad77aace3a5c6c96b985cbf22a28c83f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad77aace3a5c6c96b985cbf22a28c83f2">&#9670;&nbsp;</a></span>active_face_iterator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="group__Iterators.html#gad77aace3a5c6c96b985cbf22a28c83f2">active_face_iterator</a> =  <a class="el" href="classTriaActiveIterator.html">TriaActiveIterator</a>&lt;<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt;dim - 1, dim, spacedim&gt; &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An alias that is used to identify iterators that point to active faces, i.e., to faces that have no children. Active faces must be faces of at least one active cell.</p>
<p>Other than the "active" qualification, this alias is identical to the <code>face_iterator</code> alias. In particular, dereferencing either yields the same kind of object. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l01413">1413</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="gac23052ad0b446137324ccf9ea0fd386e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac23052ad0b446137324ccf9ea0fd386e">&#9670;&nbsp;</a></span>vertex_iterator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="group__Iterators.html#gac23052ad0b446137324ccf9ea0fd386e">vertex_iterator</a> =  <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;::<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt;0, dim, spacedim&gt; &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An alias that defines an iterator type to iterate over vertices of a mesh. The concept of iterators is discussed at length in the <a class="el" href="group__Iterators.html">iterators documentation module</a>. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l01424">1424</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="ga8738294ebb9d165e6b431589b0bbc7f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8738294ebb9d165e6b431589b0bbc7f7">&#9670;&nbsp;</a></span>active_vertex_iterator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="group__Iterators.html#ga8738294ebb9d165e6b431589b0bbc7f7">active_vertex_iterator</a> =  <a class="el" href="classTriaActiveIterator.html">TriaActiveIterator</a>&lt;::<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt;0, dim, spacedim&gt; &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An alias that defines an iterator type to iterate over vertices of a mesh. The concept of iterators is discussed at length in the <a class="el" href="group__Iterators.html">iterators documentation module</a>.</p>
<p>This alias is in fact identical to the <code>vertex_iterator</code> alias above since all vertices in a mesh are active (i.e., are a vertex of an active cell). </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l01438">1438</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="ga863d37379dceb11324e72a44039ac495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga863d37379dceb11324e72a44039ac495">&#9670;&nbsp;</a></span>line_iterator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="group__Iterators.html#ga863d37379dceb11324e72a44039ac495">line_iterator</a> =  typename IteratorSelector::line_iterator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An alias that defines an iterator over the (one-dimensional) lines of a mesh. In one-dimensional meshes, these are the cells of the mesh, whereas in two-dimensional meshes the lines are the faces of cells. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l01448">1448</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="gabfba44e3df01252843f37ee1f8e6df58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfba44e3df01252843f37ee1f8e6df58">&#9670;&nbsp;</a></span>active_line_iterator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="group__Iterators.html#gabfba44e3df01252843f37ee1f8e6df58">active_line_iterator</a> =  typename IteratorSelector::active_line_iterator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An alias that allows iterating over the <em>active</em> lines, i.e., that subset of lines that have no children. In one-dimensional meshes, these are the cells of the mesh, whereas in two-dimensional meshes the lines are the faces of cells.</p>
<p>In two- or three-dimensional meshes, lines without children (i.e., the active lines) are part of at least one active cell. Each such line may additionally be a child of a line of a coarser cell adjacent to a cell that is active. (This coarser neighbor would then also be active.) </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l01463">1463</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="ga672c99b1c8da16227cae6f0cf66cc109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga672c99b1c8da16227cae6f0cf66cc109">&#9670;&nbsp;</a></span>quad_iterator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="group__Iterators.html#ga672c99b1c8da16227cae6f0cf66cc109">quad_iterator</a> =  typename IteratorSelector::quad_iterator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An alias that defines an iterator over the (two-dimensional) quads of a mesh. In two-dimensional meshes, these are the cells of the mesh, whereas in three-dimensional meshes the quads are the faces of cells. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l01472">1472</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="ga31b331baff3d6bfb841950b10845fc5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31b331baff3d6bfb841950b10845fc5f">&#9670;&nbsp;</a></span>active_quad_iterator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="group__Iterators.html#ga31b331baff3d6bfb841950b10845fc5f">active_quad_iterator</a> =  typename IteratorSelector::active_quad_iterator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An alias that allows iterating over the <em>active</em> quads, i.e., that subset of quads that have no children. In two-dimensional meshes, these are the cells of the mesh, whereas in three-dimensional meshes the quads are the faces of cells.</p>
<p>In three-dimensional meshes, quads without children (i.e., the active quads) are faces of at least one active cell. Each such quad may additionally be a child of a quad face of a coarser cell adjacent to a cell that is active. (This coarser neighbor would then also be active.) </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l01487">1487</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="ga0500bbdefc5ea6a1306892b933896875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0500bbdefc5ea6a1306892b933896875">&#9670;&nbsp;</a></span>hex_iterator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="group__Iterators.html#ga0500bbdefc5ea6a1306892b933896875">hex_iterator</a> =  typename IteratorSelector::hex_iterator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An alias that defines an iterator over the (three-dimensional) hexes of a mesh. This iterator only makes sense in three-dimensional meshes, where hexes are the cells of the mesh. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l01496">1496</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="ga4fed0f1753adab5eb220b1bec03ae571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fed0f1753adab5eb220b1bec03ae571">&#9670;&nbsp;</a></span>active_hex_iterator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="group__Iterators.html#ga4fed0f1753adab5eb220b1bec03ae571">active_hex_iterator</a> =  typename IteratorSelector::active_hex_iterator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An alias that allows iterating over the <em>active</em> hexes of a mesh. This iterator only makes sense in three-dimensional meshes, where hexes are the cells of the mesh. Consequently, in these three-dimensional meshes, this iterator is equivalent to the <code>active_cell_iterator</code> alias. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l01507">1507</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a5977e64adfde9e63f274be77bb34dddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5977e64adfde9e63f274be77bb34dddc">&#9670;&nbsp;</a></span>raw_cell_iterator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a5977e64adfde9e63f274be77bb34dddc">raw_cell_iterator</a> =  <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt;<a class="el" href="classCellAccessor.html">CellAccessor</a>&lt;dim, spacedim&gt; &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Declare a number of iterator types for raw iterators, i.e., iterators that also iterate over holes in the list of cells left by cells that have been coarsened away in previous mesh refinement cycles.</p>
<p>Since users should never have to access these internal properties of how we store data, these iterator types are made private. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03615">3615</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="ad39637491c7d7e9f7bc4b7ea40a0d72b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39637491c7d7e9f7bc4b7ea40a0d72b">&#9670;&nbsp;</a></span>raw_face_iterator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#ad39637491c7d7e9f7bc4b7ea40a0d72b">raw_face_iterator</a> =  <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt;<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt;dim - 1, dim, spacedim&gt; &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03616">3616</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a099dd8d123778fdadd882415d639d1b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a099dd8d123778fdadd882415d639d1b4">&#9670;&nbsp;</a></span>raw_vertex_iterator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a099dd8d123778fdadd882415d639d1b4">raw_vertex_iterator</a> =  <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt;::<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt;0, dim, spacedim&gt; &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03618">3618</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a0e0f7bc0b40113139b244a54591e9d53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e0f7bc0b40113139b244a54591e9d53">&#9670;&nbsp;</a></span>raw_line_iterator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a0e0f7bc0b40113139b244a54591e9d53">raw_line_iterator</a> =  typename IteratorSelector::raw_line_iterator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03620">3620</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a80735fd291dca4e5f958ee5876289aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80735fd291dca4e5f958ee5876289aa4">&#9670;&nbsp;</a></span>raw_quad_iterator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a80735fd291dca4e5f958ee5876289aa4">raw_quad_iterator</a> =  typename IteratorSelector::raw_quad_iterator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03621">3621</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="ac2be382ff40558d007dd767a1288dc1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2be382ff40558d007dd767a1288dc1e">&#9670;&nbsp;</a></span>raw_hex_iterator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#ac2be382ff40558d007dd767a1288dc1e">raw_hex_iterator</a> =  typename IteratorSelector::raw_hex_iterator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03622">3622</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a0633dd17e535a59162b79f338c6ff5ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0633dd17e535a59162b79f338c6ff5ae">&#9670;&nbsp;</a></span>MeshSmoothing</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">Triangulation::MeshSmoothing</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Declare some symbolic names for mesh smoothing algorithms. The meaning of these flags is documented in the <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a> class. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l01142">1142</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a84fc193bcb07330e925514206a7d4239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84fc193bcb07330e925514206a7d4239">&#9670;&nbsp;</a></span>Triangulation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a> </td>
          <td>(</td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>mpi_communicator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mpi_communicator</td><td>The MPI communicator to be used for the triangulation. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fully__distributed__tria_8cc_source.html#l00045">45</a> of file <a class="el" href="fully__distributed__tria_8cc_source.html">fully_distributed_tria.cc</a>.</p>

</div>
</div>
<a id="af4c6a72a040aa81c8e1b6300da184dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4c6a72a040aa81c8e1b6300da184dee">&#9670;&nbsp;</a></span>~Triangulation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">parallel::fullydistributed::Triangulation</a>&lt; dim, spacedim &gt;::~<a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

<p>Reimplemented from <a class="el" href="classTriangulation.html#ad9931013dff6e9094c5b525359b6e1c5">Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae09eb5f25fd81eca041851bd8eedec15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae09eb5f25fd81eca041851bd8eedec15">&#9670;&nbsp;</a></span>create_triangulation() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::create_triangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTriangulationDescription_1_1Description.html">TriangulationDescription::Description</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>construction_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Create a triangulation from a list of vertices and a list of cells, each of the latter being a list of <code>1&lt;&lt;dim</code> vertex indices. The triangulation must be empty upon calling this function and the cell list should be useful (connected domain, etc.). The result of calling this function is a <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse mesh</a>.</p>
<p>Material data for the cells is given within the <code>cells</code> array, while boundary information is given in the <code>subcelldata</code> field.</p>
<p>The numbering of vertices within the <code>cells</code> array is subject to some constraints; see the general class documentation for this.</p>
<p>For conditions when this function can generate a valid triangulation, see the documentation of this class, and the <a class="el" href="classGridIn.html">GridIn</a> and <a class="el" href="classGridReordering.html">GridReordering</a> class.</p>
<p>If the <code>check_for_distorted_cells</code> flag was specified upon creation of this object, at the very end of its operation, the current function walks over all cells and verifies that none of the cells is deformed (see the entry on <a class="el" href="DEALGlossary.html#GlossDistorted">distorted cells</a> in the glossary), where we call a cell deformed if the determinant of the Jacobian of the mapping from reference cell to real cell is negative at least at one of the vertices (this computation is done using the GeometryInfo::jacobian_determinants_at_vertices function). If there are deformed cells, this function throws an exception of kind DistortedCellList. Since this happens after all data structures have been set up, you can catch and ignore this exception if you know what you do &ndash; for example, it may be that the determinant is zero (indicating that you have collapsed edges in a cell) but that this is ok because you didn't intend to integrate on this cell anyway. On the other hand, deformed cells are often a sign of a mesh that is too coarse to resolve the geometry of the domain, and in this case ignoring the exception is probably unwise.</p>
<dl class="section note"><dt>Note</dt><dd>This function is used in <a class="el" href="step_14.html">step-14</a> and <a class="el" href="step_19.html">step-19</a>.</dd>
<dd>
This function triggers the "create" signal after doing its work. See the section on signals in the general documentation of this class. For example as a consequence of this, all <a class="el" href="classDoFHandler.html">DoFHandler</a> objects connected to this triangulation will be reinitialized via <a class="el" href="classDoFHandler.html#a84b803d7c74ab87a3eb2e1367611246b">DoFHandler::reinit()</a>.</dd>
<dd>
The check for distorted cells is only done if dim==spacedim, as otherwise cells can legitimately be twisted if the manifold they describe is twisted.</dd>
<dd>
This is the function to be used instead of <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#ae09eb5f25fd81eca041851bd8eedec15">Triangulation::create_triangulation()</a> for some of the other triangulations of deal.II. </dd></dl>

<p>Reimplemented from <a class="el" href="classTriangulation.html#aa80c37d5d647831736e40e4ffb0e0ee2">Triangulation&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fully__distributed__tria_8cc_source.html#l00062">62</a> of file <a class="el" href="fully__distributed__tria_8cc_source.html">fully_distributed_tria.cc</a>.</p>

</div>
</div>
<a id="a20ba25d1a33ff78e802592ff7dbcfe1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20ba25d1a33ff78e802592ff7dbcfe1e">&#9670;&nbsp;</a></span>create_triangulation() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::create_triangulation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt;::<a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSubCellData.html">SubCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>subcelldata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This function is not implemented for this class and throws an assertion. Instead, use the other <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#ae09eb5f25fd81eca041851bd8eedec15">create_triangulation()</a> function to create the triangulation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fully__distributed__tria_8cc_source.html#l00217">217</a> of file <a class="el" href="fully__distributed__tria_8cc_source.html">fully_distributed_tria.cc</a>.</p>

</div>
</div>
<a id="a32dee27541d4a63c275046f6e4bdec3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32dee27541d4a63c275046f6e4bdec3b">&#9670;&nbsp;</a></span>copy_triangulation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::copy_triangulation </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other_tria</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implementation of the same function as in the base class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other_tria</td><td>The triangulation to be copied. It can be a serial <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a> or a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>. Both can have been refined already.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function uses the partitioner registered with <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a6a7565ce706569264ab115ebb061d314">set_partitioner()</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classparallel_1_1TriangulationBase.html#afcc11d84b1e73511844762ad8c111053">parallel::TriangulationBase&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fully__distributed__tria_8cc_source.html#l00246">246</a> of file <a class="el" href="fully__distributed__tria_8cc_source.html">fully_distributed_tria.cc</a>.</p>

</div>
</div>
<a id="a6a7565ce706569264ab115ebb061d314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a7565ce706569264ab115ebb061d314">&#9670;&nbsp;</a></span>set_partitioner()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::set_partitioner </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(::<a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;, const unsigned int)&gt; &amp;&#160;</td>
          <td class="paramname"><em>partitioner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0">TriangulationDescription::Settings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a partitioner, which is used within the method copy_triangulation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">partitioner</td><td>A partitioning function, which takes as input argument a reference to the triangulation to be partitioned and the number of partitions to be created. The function needs to set subdomain ids for each active cell of the given triangulation, with values between zero (inclusive) and the second argument to the function (exclusive). </td></tr>
    <tr><td class="paramname">settings</td><td>See the description of the Settings enumerator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>As a default, <a class="el" href="namespaceGridTools.html#a1951822ebc7a80fb21aea5d4cd6dac6c">GridTools::partition_triangulation_zorder()</a> is used as partitioner and data structures on multigrid levels are not set up. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fully__distributed__tria_8cc_source.html#l00300">300</a> of file <a class="el" href="fully__distributed__tria_8cc_source.html">fully_distributed_tria.cc</a>.</p>

</div>
</div>
<a id="a06f5cf8e575cfe98719e9afd968e0e06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06f5cf8e575cfe98719e9afd968e0e06">&#9670;&nbsp;</a></span>execute_coarsening_and_refinement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::execute_coarsening_and_refinement</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Coarsen and refine the mesh according to refinement and coarsening flags set.</p>
<dl class="section note"><dt>Note</dt><dd>Not implemented yet. </dd></dl>

<p>Reimplemented from <a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">Triangulation&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fully__distributed__tria_8cc_source.html#l00313">313</a> of file <a class="el" href="fully__distributed__tria_8cc_source.html">fully_distributed_tria.cc</a>.</p>

</div>
</div>
<a id="a913467a6ed90032116a4c1f0ba4416f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a913467a6ed90032116a4c1f0ba4416f4">&#9670;&nbsp;</a></span>prepare_coarsening_and_refinement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::prepare_coarsening_and_refinement</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Override the implementation of prepare_coarsening_and_refinement from the base class.</p>
<dl class="section note"><dt>Note</dt><dd>Not implemented yet. </dd></dl>

<p>Reimplemented from <a class="el" href="classTriangulation.html#abf55199c30b0330cf9bf98e2582078e1">Triangulation&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fully__distributed__tria_8cc_source.html#l00322">322</a> of file <a class="el" href="fully__distributed__tria_8cc_source.html">fully_distributed_tria.cc</a>.</p>

</div>
</div>
<a id="a11677987ca8ad5bcc4ab77e8916dcc62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11677987ca8ad5bcc4ab77e8916dcc62">&#9670;&nbsp;</a></span>has_hanging_nodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::has_hanging_nodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if the triangulation has hanging nodes.</p>
<dl class="section note"><dt>Note</dt><dd>Not implemented yet. </dd></dl>

<p>Reimplemented from <a class="el" href="classTriangulation.html#a935cc3b953d71fe4081fa8f88820f034">Triangulation&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fully__distributed__tria_8cc_source.html#l00336">336</a> of file <a class="el" href="fully__distributed__tria_8cc_source.html">fully_distributed_tria.cc</a>.</p>

</div>
</div>
<a id="af3462af3709c558b158e3a1abba439ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3462af3709c558b158e3a1abba439ad">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::memory_consumption</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the local memory consumption in bytes. </p>

<p>Reimplemented from <a class="el" href="classparallel_1_1TriangulationBase.html#a0ad3703ebbac4468e07b74c3ca595747">parallel::TriangulationBase&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fully__distributed__tria_8cc_source.html#l00346">346</a> of file <a class="el" href="fully__distributed__tria_8cc_source.html">fully_distributed_tria.cc</a>.</p>

</div>
</div>
<a id="adbf502e5250d2fbd03f9681cfd12c355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf502e5250d2fbd03f9681cfd12c355">&#9670;&nbsp;</a></span>is_multilevel_hierarchy_constructed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::is_multilevel_hierarchy_constructed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return if multilevel hierarchy is supported and has been constructed. </p>

<p>Implements <a class="el" href="classparallel_1_1TriangulationBase.html#a8f9bfda5524458e6fb8ebe54e9c491fc">parallel::TriangulationBase&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fully__distributed__tria_8cc_source.html#l00362">362</a> of file <a class="el" href="fully__distributed__tria_8cc_source.html">fully_distributed_tria.cc</a>.</p>

</div>
</div>
<a id="ac954bc1132f894e7deadb42325d526ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac954bc1132f894e7deadb42325d526ae">&#9670;&nbsp;</a></span>save() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the triangulation into the given file. This file needs to be reachable from all nodes in the computation on a shared network file system. See the <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a> class on how to store solution vectors into this file. Additional cell-based data can be saved using <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a>. </p>

<p>Implements <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ac958319402a5301d2dde94f1c6e8c78a">parallel::DistributedTriangulationBase&lt; dim, dim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fully__distributed__tria_8cc_source.html#l00424">424</a> of file <a class="el" href="fully__distributed__tria_8cc_source.html">fully_distributed_tria.cc</a>.</p>

</div>
</div>
<a id="aa26557236abb6607adb16edf5375707f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa26557236abb6607adb16edf5375707f">&#9670;&nbsp;</a></span>load() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>autopartition</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the triangulation saved with <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#ac954bc1132f894e7deadb42325d526ae">save()</a> back in. The mesh must be empty before calling this function.</p>
<p>You need to load with the same number of MPI processes that you saved with, hence autopartition is disabled.</p>
<p>Cell-based data that was saved with <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a> can be read in with <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a6fbdf11dcfacd414a8936e6d26fecb76">notify_ready_to_unpack()</a> after calling <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#aa26557236abb6607adb16edf5375707f">load()</a>. </p>

<p>Implements <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ad5a7ad9fd72720414a8c983acee58142">parallel::DistributedTriangulationBase&lt; dim, dim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fully__distributed__tria_8cc_source.html#l00559">559</a> of file <a class="el" href="fully__distributed__tria_8cc_source.html">fully_distributed_tria.cc</a>.</p>

</div>
</div>
<a id="abc62d3732d28c9b6e3cdbd682a5eb014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc62d3732d28c9b6e3cdbd682a5eb014">&#9670;&nbsp;</a></span>coarse_cell_id_to_coarse_cell_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::coarse_cell_id_to_coarse_cell_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a36be5a74b99dd3f4ab38a2c183250adf">types::coarse_cell_id</a>&#160;</td>
          <td class="paramname"><em>coarse_cell_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Translate the unique id of a coarse cell to its index. See the glossary entry on <a class="el" href="DEALGlossary.html#GlossCoarseCellId">coarse cell IDs</a> for more information.</p>
<dl class="section note"><dt>Note</dt><dd>For serial and shared triangulation both id and index are the same. For distributed triangulations setting both might differ, since the id might correspond to a global id and the index to a local id.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coarse_cell_id</td><td>Unique id of the coarse cell. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the coarse cell within the current triangulation. </dd></dl>

<p>Reimplemented from <a class="el" href="classTriangulation.html#af01ec1d50a410f7cc29c543b212edefc">Triangulation&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fully__distributed__tria_8cc_source.html#l00373">373</a> of file <a class="el" href="fully__distributed__tria_8cc_source.html">fully_distributed_tria.cc</a>.</p>

</div>
</div>
<a id="a2b3e5307d74d2747acf0846eda3e8984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3e5307d74d2747acf0846eda3e8984">&#9670;&nbsp;</a></span>coarse_cell_index_to_coarse_cell_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a36be5a74b99dd3f4ab38a2c183250adf">types::coarse_cell_id</a> <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::coarse_cell_index_to_coarse_cell_id </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>coarse_cell_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Translate the index of coarse cell to its unique id. See the glossary entry on <a class="el" href="DEALGlossary.html#GlossCoarseCellId">coarse cell IDs</a> for more information.</p>
<dl class="section note"><dt>Note</dt><dd>See the note of the method <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#abc62d3732d28c9b6e3cdbd682a5eb014">coarse_cell_id_to_coarse_cell_index()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coarse_cell_index</td><td>Index of the coarse cell. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Id of the coarse cell. </dd></dl>

<p>Reimplemented from <a class="el" href="classTriangulation.html#a9ef633762716a14deb9a4dcda02a26f0">Triangulation&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fully__distributed__tria_8cc_source.html#l00392">392</a> of file <a class="el" href="fully__distributed__tria_8cc_source.html">fully_distributed_tria.cc</a>.</p>

</div>
</div>
<a id="a77b7d4e89daa45162ec29305483a0234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77b7d4e89daa45162ec29305483a0234">&#9670;&nbsp;</a></span>update_cell_relations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::update_cell_relations</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Go through all active cells that are locally owned and record how they will change in the private member vector local_cell_relations.</p>
<p>As no adaptive mesh refinement is supported at the moment for this class, all cells will be flagged with the CellStatus CELL_PERSIST. These relations will currently only be used for serialization.</p>
<p>The stored vector will have a size equal to the number of locally owned active cells and will be ordered by the occurrence of those cells. </p>

<p>Implements <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a74fe86d32d73e4c12d1e505739b3662a">parallel::DistributedTriangulationBase&lt; dim, dim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fully__distributed__tria_8cc_source.html#l00408">408</a> of file <a class="el" href="fully__distributed__tria_8cc_source.html">fully_distributed_tria.cc</a>.</p>

</div>
</div>
<a id="a0f6c7f53d060c63005b005e7638d2219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f6c7f53d060c63005b005e7638d2219">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::clear</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset this triangulation into a virgin state by deleting all data.</p>
<p>Note that this operation is only allowed if no subscriptions to this object exist any more, such as <a class="el" href="classDoFHandler.html">DoFHandler</a> objects using it. </p>

<p>Reimplemented from <a class="el" href="classTriangulation.html#a12d54b7dae635d867bf8d2c4b3605817">Triangulation&lt; dim, spacedim &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#acd318718e6553731139718aa7f30307a">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00466">466</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="a2f0c10f7a8cd32d961e9367173685047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f0c10f7a8cd32d961e9367173685047">&#9670;&nbsp;</a></span>save() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write the data of this object to a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function does not save <em>all</em> member variables of the current triangulation. Rather, only certain kinds of information are stored. For more information see the general documentation of this class. </dd></dl>

</div>
</div>
<a id="ae2f72d5fbb277ec65dbe0382ae72a929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f72d5fbb277ec65dbe0382ae72a929">&#9670;&nbsp;</a></span>load() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the data of this object from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. Throw away the previous content.</p>
<dl class="section note"><dt>Note</dt><dd>This function does not reset <em>all</em> member variables of the current triangulation to the ones of the triangulation that was previously stored to an archive. Rather, only certain kinds of information are loaded. For more information see the general documentation of this class.</dd>
<dd>
This function calls the <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a0f6c7f53d060c63005b005e7638d2219">Triangulation::clear()</a> function and consequently triggers the "clear" signal. After loading all data from the archive, it then triggers the "create" signal. For more information on signals, see the general documentation of this class. </dd></dl>

</div>
</div>
<a id="acb1a95528832932bf2fad380f8098367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb1a95528832932bf2fad380f8098367">&#9670;&nbsp;</a></span>register_data_attach()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::register_data_attach </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; std::vector&lt; char &gt;(const <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a> &amp;, const <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a7c98433e1e221ee65731e81345a72546">CellStatus</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>pack_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>returns_variable_size_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register a function that can be used to attach data of fixed size to cells. This is useful for two purposes: (i) Upon refinement and coarsening of a triangulation (<em>e.g</em>. in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a06f5cf8e575cfe98719e9afd968e0e06">parallel::distributed::Triangulation::execute_coarsening_and_refinement()</a>), one needs to be able to store one or more data vectors per cell that characterizes the solution values on the cell so that this data can then be transferred to the new owning processor of the cell (or its parent/children) when the mesh is re-partitioned; (ii) when serializing a computation to a file, it is necessary to attach data to cells so that it can be saved (<em>e.g</em>. in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#ac954bc1132f894e7deadb42325d526ae">parallel::distributed::Triangulation::save()</a>) along with the cell's other information and, if necessary, later be reloaded from disk with a different subdivision of cells among the processors.</p>
<p>The way this function works is that it allows any number of interest parties to register their intent to attach data to cells. One example of classes that do this is <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a> where each <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a> object that works on the current <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a> object then needs to register its intent. Each of these parties registers a callback function (the first argument here, <code>pack_callback</code>) that will be called whenever the triangulation's <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a06f5cf8e575cfe98719e9afd968e0e06">execute_coarsening_and_refinement()</a> or <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#ac954bc1132f894e7deadb42325d526ae">save()</a> functions are called.</p>
<p>The current function then returns an integer handle that corresponds to the number of data set that the callback provided here will attach. While this number could be given a precise meaning, this is not important: You will never actually have to do anything with this number except return it to the <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a6fbdf11dcfacd414a8936e6d26fecb76">notify_ready_to_unpack()</a> function. In other words, each interested party (i.e., the caller of the current function) needs to store their respective returned handle for later use when unpacking data in the callback provided to <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a6fbdf11dcfacd414a8936e6d26fecb76">notify_ready_to_unpack()</a>.</p>
<p>Whenever <code>pack_callback</code> is then called by <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a06f5cf8e575cfe98719e9afd968e0e06">execute_coarsening_and_refinement()</a> or <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#aa26557236abb6607adb16edf5375707f">load()</a> on a given cell, it receives a number of arguments. In particular, the first argument passed to the callback indicates the cell for which it is supposed to attach data. This is always an active cell.</p>
<p>The second, CellStatus, argument provided to the callback function will tell you if the given cell will be coarsened, refined, or will persist as is. (This status may be different than the refinement or coarsening flags set on that cell, to accommodate things such as the "one hanging node per edge" rule.). These flags need to be read in context with the p4est quadrant they belong to, as their relations are gathered in local_cell_relations.</p>
<p>Specifically, the values for this argument mean the following:</p>
<ul>
<li><code>CELL_PERSIST</code>: The cell won't be refined/coarsened, but might be moved to a different processor. If this is the case, the callback will want to pack up the data on this cell into an array and store it at the provided address for later unpacking wherever this cell may land.</li>
<li><code>CELL_REFINE</code>: This cell will be refined into 4 or 8 cells (in 2d and 3d, respectively). However, because these children don't exist yet, you cannot access them at the time when the callback is called. Thus, in local_cell_relations, the corresponding p4est quadrants of the children cells are linked to the deal.II cell which is going to be refined. To be specific, only the very first child is marked with <code>CELL_REFINE</code>, whereas the others will be marked with <code>CELL_INVALID</code>, which indicates that these cells will be ignored by default during the packing or unpacking process. This ensures that data is only transferred once onto or from the parent cell. If the callback is called with <code>CELL_REFINE</code>, the callback will want to pack up the data on this cell into an array and store it at the provided address for later unpacking in a way so that it can then be transferred to the children of the cell that will then be available. In other words, if the data the callback will want to pack up corresponds to a finite element field, then the prolongation from parent to (new) children will have to happen during unpacking.</li>
<li><code>CELL_COARSEN</code>: The children of this cell will be coarsened into the given cell. These children still exist, so if this is the value given to the callback as second argument, the callback will want to transfer data from the children to the current parent cell and pack it up so that it can later be unpacked again on a cell that then no longer has any children (and may also be located on a different processor). In other words, if the data the callback will want to pack up corresponds to a finite element field, then it will need to do the restriction from children to parent at this point.</li>
<li><code>CELL_INVALID</code>: See <code>CELL_REFINE</code>.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>If this function is used for serialization of data using <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#ac954bc1132f894e7deadb42325d526ae">save()</a> and <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#aa26557236abb6607adb16edf5375707f">load()</a>, then the cell status argument with which the callback is called will always be <code>CELL_PERSIST</code>.</dd></dl>
<p>The callback function is expected to return a memory chunk of the format <code>std::vector&lt;char&gt;</code>, representing the packed data on a certain cell.</p>
<p>The second parameter <code>returns_variable_size_data</code> indicates whether the returned size of the memory region from the callback function varies by cell (<code>=true</code>) or stays constant on each one throughout the whole domain (<code>=false</code>).</p>
<dl class="section note"><dt>Note</dt><dd>The purpose of this function is to register intent to attach data for a single, subsequent call to <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a06f5cf8e575cfe98719e9afd968e0e06">execute_coarsening_and_refinement()</a> and <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a6fbdf11dcfacd414a8936e6d26fecb76">notify_ready_to_unpack()</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#ac954bc1132f894e7deadb42325d526ae">save()</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#aa26557236abb6607adb16edf5375707f">load()</a>. Consequently, <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a6fbdf11dcfacd414a8936e6d26fecb76">notify_ready_to_unpack()</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#ac954bc1132f894e7deadb42325d526ae">save()</a>, and <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#aa26557236abb6607adb16edf5375707f">load()</a> all forget the registered callbacks once these callbacks have been called, and you will have to re-register them with a triangulation if you want them to be active for another call to these functions. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00601">601</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="a6fbdf11dcfacd414a8936e6d26fecb76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fbdf11dcfacd414a8936e6d26fecb76">&#9670;&nbsp;</a></span>notify_ready_to_unpack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::notify_ready_to_unpack </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a> &amp;, const <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a7c98433e1e221ee65731e81345a72546">CellStatus</a>, const boost::iterator_range&lt; std::vector&lt; char &gt;::const_iterator &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>unpack_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is the opposite of <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a>. It is called <em>after</em> the <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a06f5cf8e575cfe98719e9afd968e0e06">execute_coarsening_and_refinement()</a> or <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#ac954bc1132f894e7deadb42325d526ae">save()</a>/load() functions are done when classes and functions that have previously attached data to a triangulation for either transfer to other processors, across mesh refinement, or serialization of data to a file are ready to receive that data back. The important part about this process is that the triangulation cannot do this right away from the end of <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a06f5cf8e575cfe98719e9afd968e0e06">execute_coarsening_and_refinement()</a> or <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#aa26557236abb6607adb16edf5375707f">load()</a> via a previously attached callback function (as the <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a> function does) because the classes that eventually want the data back may need to do some setup between the point in time where the mesh has been recreated and when the data can actually be received. An example is the <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a> class that can really only receive the data once not only the mesh is completely available again on the current processor, but only after a <a class="el" href="classDoFHandler.html">DoFHandler</a> has been reinitialized and distributed degrees of freedom. In other words, there is typically a significant amount of set up that needs to happen in user space before the classes that can receive data attached to cell are ready to actually do so. When they are, they use the current function to tell the triangulation object that now is the time when they are ready by calling the current function.</p>
<p>The supplied callback function is then called for each newly locally owned cell. The first argument to the callback is an iterator that designates the cell; the second argument indicates the status of the cell in question; and the third argument localizes a memory area by two iterators that contains the data that was previously saved from the callback provided to <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a>.</p>
<p>The CellStatus will indicate if the cell was refined, coarsened, or persisted unchanged. The <code>cell_iterator</code> argument to the callback will then either be an active, locally owned cell (if the cell was not refined), or the immediate parent if it was refined during <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a06f5cf8e575cfe98719e9afd968e0e06">execute_coarsening_and_refinement()</a>. Therefore, contrary to during <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a>, you can now access the children if the status is <code>CELL_REFINE</code> but no longer for callbacks with status <code>CELL_COARSEN</code>.</p>
<p>The first argument to this function, <code>handle</code>, corresponds to the return value of <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a>. (The precise meaning of what the numeric value of this handle is supposed to represent is neither important, nor should you try to use it for anything other than transmit information between a call to <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a> to the corresponding call to <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a6fbdf11dcfacd414a8936e6d26fecb76">notify_ready_to_unpack()</a>.) </p>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00655">655</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="a53caa007ddc9229fa461a0fd925482ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53caa007ddc9229fa461a0fd925482ae">&#9670;&nbsp;</a></span>save_attached_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::save_attached_data </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>global_first_cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>global_num_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save additional cell-attached data into the given file. The first arguments are used to determine the offsets where to write buffers to.</p>
<p>Called by <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#ac954bc1132f894e7deadb42325d526ae">save</a>. </p>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00671">671</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="aeef794a63c63ff09e2c1c231998083f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeef794a63c63ff09e2c1c231998083f2">&#9670;&nbsp;</a></span>load_attached_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::load_attached_data </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>global_first_cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>global_num_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>local_num_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_attached_deserialize_fixed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_attached_deserialize_variable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load additional cell-attached data from the given file, if any was saved. The first arguments are used to determine the offsets where to read buffers from.</p>
<p>Called by <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#aa26557236abb6607adb16edf5375707f">load</a>. </p>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00683">683</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="ad6e42ca28e9e64c2f292c7cf5d6cb4e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6e42ca28e9e64c2f292c7cf5d6cb4e5">&#9670;&nbsp;</a></span>get_communicator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MPI_Comm <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::get_communicator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return MPI communicator used by this triangulation. </p>

<p>Reimplemented from <a class="el" href="classTriangulation.html#a1005ad6002b51c5bc4592da7246b6a49">Triangulation&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00099">99</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="a1bca327fa47f88b58086dacc20028064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bca327fa47f88b58086dacc20028064">&#9670;&nbsp;</a></span>copy_triangulation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::copy_triangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other_tria</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy <code>other_tria</code> to this triangulation. This operation is not cheap, so you should be careful with using this. We do not implement this function as a copy constructor, since it makes it easier to maintain collections of triangulations if you can assign them values later on.</p>
<p>Keep in mind that this function also copies the pointer to the boundary descriptor previously set by the <code>set_manifold</code> function. You must therefore also guarantee that the <a class="el" href="classManifold.html">Manifold</a> objects describing the boundary have a lifetime at least as long as the copied triangulation.</p>
<p>This triangulation must be empty beforehand.</p>
<p>The function is made <code>virtual</code> since some derived classes might want to disable or extend the functionality of this function.</p>
<dl class="section note"><dt>Note</dt><dd>Calling this function triggers the 'copy' signal on other_tria, i.e. the triangulation being copied <em>from</em>. It also triggers the 'create' signal of the current triangulation. See the section on signals in the general documentation for more information.</dd>
<dd>
The list of connections to signals is not copied from the old to the new triangulation since these connections were established to monitor how the old triangulation changes, not how any triangulation it may be copied to changes. </dd></dl>

</div>
</div>
<a id="a74e904416671ca175093274144e49439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74e904416671ca175093274144e49439">&#9670;&nbsp;</a></span>n_locally_owned_active_cells()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::n_locally_owned_active_cells</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of active cells in the triangulation that are locally owned, i.e. that have a subdomain_id equal to <a class="el" href="classparallel_1_1TriangulationBase.html#a41b129156d89f37482d2095de5751d9c">locally_owned_subdomain()</a>. Note that there may be more active cells in the triangulation stored on the present processor, such as for example ghost cells, or cells further away from the locally owned block of cells but that are needed to ensure that the triangulation that stores this processor's set of active cells still remains balanced with respect to the 2:1 size ratio of adjacent cells.</p>
<p>As a consequence of the remark above, the result of this function is always smaller or equal to the result of the function with the same name in the <a class="el" href="classTriangulation.html">Triangulation</a> base class, which includes the active ghost and artificial cells (see also <a class="el" href="DEALGlossary.html#GlossArtificialCell">GlossArtificialCell</a> and <a class="el" href="DEALGlossary.html#GlossGhostCell">GlossGhostCell</a>). </p>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00138">138</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="a0fedf8c5b9488f5f82dfbe3d04c3bc0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fedf8c5b9488f5f82dfbe3d04c3bc0f">&#9670;&nbsp;</a></span>n_global_active_cells()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a88f8129eb3e40ecc8022e92a1e15d70e">types::global_cell_index</a> <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::n_global_active_cells</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the sum over all processors of the number of active cells owned by each processor. This equals the overall number of active cells in the triangulation. </p>

<p>Reimplemented from <a class="el" href="classTriangulation.html#a05502400e5b4bdd3bb7e0fd410fdf0fb">Triangulation&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00146">146</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="a5e6247bd25858eeed99445f2eb810b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e6247bd25858eeed99445f2eb810b9c">&#9670;&nbsp;</a></span>n_global_levels()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::n_global_levels</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the global maximum level. This may be bigger than the number <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">Triangulation::n_levels()</a> (a function in this class's base class) returns if the current processor only stores cells in parts of the domain that are not very refined, but if other processors store cells in more deeply refined parts of the domain. </p>

<p>Reimplemented from <a class="el" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">Triangulation&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00163">163</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="a41b129156d89f37482d2095de5751d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b129156d89f37482d2095de5751d9c">&#9670;&nbsp;</a></span>locally_owned_subdomain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::locally_owned_subdomain</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the subdomain id of those cells that are owned by the current processor. All cells in the triangulation that do not have this subdomain id are either owned by another processor or have children that only exist on other processors. </p>

<p>Reimplemented from <a class="el" href="classTriangulation.html#a5827cdfafd5fef99803cde97b70e86bc">Triangulation&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00172">172</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="a182d26a19ae0d8cf91473a647f381364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a182d26a19ae0d8cf91473a647f381364">&#9670;&nbsp;</a></span>ghost_owners()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::set&lt; <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> &gt; &amp; <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::ghost_owners</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a set of MPI ranks of the processors that have at least one ghost cell adjacent to the cells of the local processor. In other words, this is the set of <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">subdomain_id()</a> for all ghost cells.</p>
<p>The returned sets are symmetric, that is if <code>i</code> is contained in the list of processor <code>j</code>, then <code>j</code> will also be contained in the list of processor <code>i</code>. </p>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00184">184</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="a08420b1432082185edaaf83dbc8b4bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08420b1432082185edaaf83dbc8b4bee">&#9670;&nbsp;</a></span>level_ghost_owners()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::set&lt; <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> &gt; &amp; <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::level_ghost_owners</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a set of MPI ranks of the processors that have at least one level ghost cell adjacent to our cells used in geometric multigrid. In other words, this is the set of level_subdomain_id() for all level ghost cells.</p>
<p>The returned sets are symmetric, that is if <code>i</code> is contained in the list of processor <code>j</code>, then <code>j</code> will also be contained in the list of processor <code>i</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The level ghost owners can only be determined if the multigrid ownership has been assigned (by setting the construct_multigrid_hierarchy flag at construction time), otherwise the returned set will be empty. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00202">202</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="abe6d84acdf8908f48fb236e2c2d47a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe6d84acdf8908f48fb236e2c2d47a17">&#9670;&nbsp;</a></span>global_active_cell_index_partitioner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::weak_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &gt; <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::global_active_cell_index_partitioner</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return partitioner for the global indices of the cells on the active level of the triangulation. </p>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00209">209</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="a3160e66fd9d88da46c47ce55524d656f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3160e66fd9d88da46c47ce55524d656f">&#9670;&nbsp;</a></span>global_level_cell_index_partitioner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::weak_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &gt; <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::global_level_cell_index_partitioner </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return partitioner for the global indices of the cells on the given <code>level</code> of the triangulation. </p>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00216">216</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="a7f0952d4737bd402994bc398cfa64a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f0952d4737bd402994bc398cfa64a25">&#9670;&nbsp;</a></span>compute_vertices_with_ghost_neighbors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; unsigned int, std::set&lt;::<a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> &gt; &gt; <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::compute_vertices_with_ghost_neighbors</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a map that, for each vertex, lists all the processors whose subdomains are adjacent to that vertex.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000020">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__manifold.html#ga7f6d5b53684824212c789514167fd326">GridTools::compute_vertices_with_ghost_neighbors()</a> instead of <a class="el" href="classparallel_1_1TriangulationBase.html#a7f0952d4737bd402994bc398cfa64a25">parallel::TriangulationBase::compute_vertices_with_ghost_neighbors()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00228">228</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="a668fa9fc088a3986cfaefe328d6d2f25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a668fa9fc088a3986cfaefe328d6d2f25">&#9670;&nbsp;</a></span>get_boundary_ids()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::get_boundary_ids</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Return a vector containing all boundary indicators assigned to boundary faces of active cells of this <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a> object. Note, that each boundary indicator is reported only once. The size of the return vector will represent the number of different indicators (which is greater or equal one).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function involves a global communication gathering all current IDs from all processes. </dd></dl>

<p>Reimplemented from <a class="el" href="classTriangulation.html#a05662a55166596efb520479b495275f8">Triangulation&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00237">237</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="af04b7e2c65169692ae8805a085c2f7ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af04b7e2c65169692ae8805a085c2f7ca">&#9670;&nbsp;</a></span>get_manifold_ids()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> &gt; <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::get_manifold_ids</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Return a vector containing all manifold indicators assigned to the objects of the active cells of this <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>. Note, that each manifold indicator is reported only once. The size of the return vector will represent the number of different indicators (which is greater or equal one).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function involves a global communication gathering all current IDs from all processes. </dd></dl>

<p>Reimplemented from <a class="el" href="group__manifold.html#ga0ee729ae049af6f1495d0059d6086e52">Triangulation&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00246">246</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="ad63df2c11257f1e6fb482e4f9ea4589f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad63df2c11257f1e6fb482e4f9ea4589f">&#9670;&nbsp;</a></span>communicate_locally_moved_vertices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::communicate_locally_moved_vertices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_locally_moved</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When vertices have been moved locally, for example using code like </p><div class="fragment"><div class="line">cell-&gt;vertex(0) = new_location;</div>
</div><!-- fragment --><p> then this function can be used to update the location of vertices between MPI processes.</p>
<p>All the vertices that have been moved and might be in the ghost layer of a process have to be reported in the <code>vertex_locally_moved</code> argument. This ensures that that part of the information that has to be send between processes is actually sent. Additionally, it is quite important that vertices on the boundary between processes are reported on exactly one process (e.g. the one with the highest id). Otherwise we could expect undesirable results if multiple processes move a vertex differently. A typical strategy is to let processor \(i\) move those vertices that are adjacent to cells whose owners include processor \(i\) but no other processor \(j\) with \(j&lt;i\); in other words, for vertices at the boundary of a subdomain, the processor with the lowest subdomain id "owns" a vertex.</p>
<dl class="section note"><dt>Note</dt><dd>It only makes sense to move vertices that are either located on locally owned cells or on cells in the ghost layer. This is because you can be sure that these vertices indeed exist on the finest mesh aggregated over all processors, whereas vertices on artificial cells but not at least in the ghost layer may or may not exist on the globally finest mesh. Consequently, the <code>vertex_locally_moved</code> argument may not contain vertices that aren't at least on ghost cells.</dd>
<dd>
This function moves vertices in such a way that on every processor, the vertices of every locally owned and ghost cell is consistent with the corresponding location of these cells on other processors. On the other hand, the locations of artificial cells will in general be wrong since artificial cells may or may not exist on other processors and consequently it is not possible to determine their location in any way. This is not usually a problem since one never does anything on artificial cells. However, it may lead to problems if the mesh with moved vertices is refined in a later step. If that's what you want to do, the right way to do it is to save the offset applied to every vertex, call this function, and before refining or coarsening the mesh apply the opposite offset and call this function again.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex_locally_moved</td><td>A bitmap indicating which vertices have been moved. The size of this array must be equal to <a class="el" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">Triangulation::n_vertices()</a> and must be a subset of those vertices flagged by <a class="el" href="namespaceGridTools.html#a33b3f1dcc53c868171f1bb0a3793a96e">GridTools::get_locally_owned_vertices()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>This function is used, for example, in <a class="el" href="namespaceGridTools.html#ac4e8aecd2cf74d3476e0daa11a00248b">GridTools::distort_random()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00301">301</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="a95e5944f1ce4588d3215ae5b63c503e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e5944f1ce4588d3215ae5b63c503e0">&#9670;&nbsp;</a></span>update_number_cache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::update_number_cache</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update the number_cache variable after mesh creation or refinement. </p>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00376">376</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="a10cf6c4bfa4a3d00d8c76792d1b9872a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10cf6c4bfa4a3d00d8c76792d1b9872a">&#9670;&nbsp;</a></span>update_reference_cells()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::update_reference_cells</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Update the internal reference_cells vector. </p>

<p>Reimplemented from <a class="el" href="classTriangulation.html#a5ecff6fdc386de47c156781fb4217bcc">Triangulation&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00382">382</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="adac35d252ab3fcbcdc675d6ac526b24c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac35d252ab3fcbcdc675d6ac526b24c">&#9670;&nbsp;</a></span>reset_global_cell_indices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::reset_global_cell_indices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset global active cell indices and global level cell indices. </p>

<p class="definition">Definition at line <a class="el" href="tria__base_8cc_source.html#l00388">388</a> of file <a class="el" href="tria__base_8cc_source.html">tria_base.cc</a>.</p>

</div>
</div>
<a id="a4a302f66ccc9bd281cf850fdc4f76e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a302f66ccc9bd281cf850fdc4f76e50">&#9670;&nbsp;</a></span>set_mesh_smoothing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::set_mesh_smoothing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a>&#160;</td>
          <td class="paramname"><em>mesh_smoothing</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the mesh smoothing to <code>mesh_smoothing</code>. This overrides the MeshSmoothing given to the constructor. It is allowed to call this function only if the triangulation is empty. </p>

</div>
</div>
<a id="a06df95bfd43216e389a132786f87474f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06df95bfd43216e389a132786f87474f">&#9670;&nbsp;</a></span>get_mesh_smoothing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a>&amp; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_mesh_smoothing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the mesh smoothing requirements that are obeyed. </p>

</div>
</div>
<a id="ga9f9d720f5fbdcdf3dcbb445feefbdb9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">&#9670;&nbsp;</a></span>set_manifold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::set_manifold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>manifold_object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assign a manifold object to a certain part of the triangulation. If an object with manifold number <code>number</code> is refined, this object is used to find the location of new vertices (see the results section of <a class="el" href="step_49.html">step-49</a> for a more in-depth discussion of this, with examples). It is also used for non-linear (i.e.: non-Q1) transformations of cells to the unit cell in shape function calculations.</p>
<p>A copy of <code>manifold_object</code> is created using <a class="el" href="classManifold.html#a140e1b7c7334d16f99aa7ad0dbabb44a">Manifold&lt;dim, spacedim&gt;::clone()</a> and stored internally.</p>
<p>It is possible to remove or replace a <a class="el" href="classManifold.html">Manifold</a> object during the lifetime of a non-empty triangulation. Usually, this is done before the first refinement and is dangerous afterwards. Removal of a manifold object is done by <a class="el" href="group__manifold.html#ga644a2152b8f5a6902afdc503d163d950">reset_manifold()</a>. This operation then replaces the manifold object given before by a straight manifold approximation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a> </dd></dl>

</div>
</div>
<a id="ga644a2152b8f5a6902afdc503d163d950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga644a2152b8f5a6902afdc503d163d950">&#9670;&nbsp;</a></span>reset_manifold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::reset_manifold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>&#160;</td>
          <td class="paramname"><em>manifold_number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset those parts of the triangulation with the given <code>manifold_number</code> to use a <a class="el" href="classFlatManifold.html">FlatManifold</a> object. This is the default state of a non-curved triangulation, and undoes assignment of a different <a class="el" href="classManifold.html">Manifold</a> object by the function <a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">Triangulation::set_manifold()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a> </dd></dl>

</div>
</div>
<a id="gaaacb68636e7fc0b399310e570a4d7dd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaacb68636e7fc0b399310e570a4d7dd6">&#9670;&nbsp;</a></span>reset_all_manifolds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::reset_all_manifolds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset all parts of the triangulation, regardless of their manifold_id, to use a <a class="el" href="classFlatManifold.html">FlatManifold</a> object. This undoes assignment of all <a class="el" href="classManifold.html">Manifold</a> objects by the function <a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">Triangulation::set_manifold()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a> </dd></dl>

</div>
</div>
<a id="gae2acfbef517fd03855c4b371f3e182f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2acfbef517fd03855c4b371f3e182f7">&#9670;&nbsp;</a></span>set_all_manifold_ids()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::set_all_manifold_ids </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the manifold_id of all cells and faces to the given argument.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a> </dd></dl>

</div>
</div>
<a id="ga1f1ea841946c94c079388ecf9ad2c00c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f1ea841946c94c079388ecf9ad2c00c">&#9670;&nbsp;</a></span>set_all_manifold_ids_on_boundary() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::set_all_manifold_ids_on_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the manifold_id of all boundary faces to the given argument.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a> </dd></dl>

</div>
</div>
<a id="gaa4e0af28512cb5f9cc8cb3b95a38c669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4e0af28512cb5f9cc8cb3b95a38c669">&#9670;&nbsp;</a></span>set_all_manifold_ids_on_boundary() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::set_all_manifold_ids_on_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>b_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the manifold_id of all boundary faces and edges with given boundary_id <code>b_id</code> to the given manifold_id <code>number</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a> </dd></dl>

</div>
</div>
<a id="gaa5d4bed3d2ac6148e969a331bde49f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5d4bed3d2ac6148e969a331bde49f63">&#9670;&nbsp;</a></span>get_manifold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classManifold.html">Manifold</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_manifold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a constant reference to a <a class="el" href="classManifold.html">Manifold</a> object used for this triangulation. <code>number</code> is the same as in <a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>If no manifold could be found, the default flat manifold is returned.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a> </dd></dl>

</div>
</div>
<a id="a1b191fa3249c9c3641492b6eedebf456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b191fa3249c9c3641492b6eedebf456">&#9670;&nbsp;</a></span>create_triangulation() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::create_triangulation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSubCellData.html">SubCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>subcelldata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a triangulation from a list of vertices and a list of cells, each of the latter being a list of <code>1&lt;&lt;dim</code> vertex indices. The triangulation must be empty upon calling this function and the cell list should be useful (connected domain, etc.). The result of calling this function is a <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse mesh</a>.</p>
<p>Material data for the cells is given within the <code>cells</code> array, while boundary information is given in the <code>subcelldata</code> field.</p>
<p>The numbering of vertices within the <code>cells</code> array is subject to some constraints; see the general class documentation for this.</p>
<p>For conditions when this function can generate a valid triangulation, see the documentation of this class, and the <a class="el" href="classGridIn.html">GridIn</a> and <a class="el" href="classGridReordering.html">GridReordering</a> class.</p>
<p>If the <code>check_for_distorted_cells</code> flag was specified upon creation of this object, at the very end of its operation, the current function walks over all cells and verifies that none of the cells is deformed (see the entry on <a class="el" href="DEALGlossary.html#GlossDistorted">distorted cells</a> in the glossary), where we call a cell deformed if the determinant of the Jacobian of the mapping from reference cell to real cell is negative at least at one of the vertices (this computation is done using the GeometryInfo::jacobian_determinants_at_vertices function). If there are deformed cells, this function throws an exception of kind DistortedCellList. Since this happens after all data structures have been set up, you can catch and ignore this exception if you know what you do &ndash; for example, it may be that the determinant is zero (indicating that you have collapsed edges in a cell) but that this is ok because you didn't intend to integrate on this cell anyway. On the other hand, deformed cells are often a sign of a mesh that is too coarse to resolve the geometry of the domain, and in this case ignoring the exception is probably unwise.</p>
<dl class="section note"><dt>Note</dt><dd>This function is used in <a class="el" href="step_14.html">step-14</a> and <a class="el" href="step_19.html">step-19</a>.</dd>
<dd>
This function triggers the "create" signal after doing its work. See the section on signals in the general documentation of this class. For example as a consequence of this, all <a class="el" href="classDoFHandler.html">DoFHandler</a> objects connected to this triangulation will be reinitialized via <a class="el" href="classDoFHandler.html#a84b803d7c74ab87a3eb2e1367611246b">DoFHandler::reinit()</a>.</dd>
<dd>
The check for distorted cells is only done if dim==spacedim, as otherwise cells can legitimately be twisted if the manifold they describe is twisted. </dd></dl>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#aca8c5c2358bb3630840c8e3ed590a33d">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, and <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#aca8c5c2358bb3630840c8e3ed590a33d">parallel::shared::Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="abbbee6e665998c3e4a745cd7836df364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbbee6e665998c3e4a745cd7836df364">&#9670;&nbsp;</a></span>create_triangulation_compatibility()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::create_triangulation_compatibility </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSubCellData.html">SubCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>subcelldata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For backward compatibility, only. This function takes the cell data in the ordering as requested by deal.II versions up to 5.2, converts it to the new (lexicographic) ordering and calls <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#ae09eb5f25fd81eca041851bd8eedec15">create_triangulation()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function internally calls create_triangulation and therefore can throw the same exception as the other function. </dd></dl>

</div>
</div>
<a id="afdc34248a9ba0c38fd0020256a8def5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc34248a9ba0c38fd0020256a8def5c">&#9670;&nbsp;</a></span>flip_all_direction_flags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::flip_all_direction_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Revert or flip the direction_flags of a dim&lt;spacedim triangulation, see <a class="el" href="DEALGlossary.html#GlossDirectionFlag">GlossDirectionFlag</a>.</p>
<p>This function throws an exception if dim equals spacedim. </p>

</div>
</div>
<a id="aed8e461d4b2b23a0e1730afdef36e694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8e461d4b2b23a0e1730afdef36e694">&#9670;&nbsp;</a></span>set_all_refine_flags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::set_all_refine_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flag all active cells for refinement. This will refine all cells of all levels which are not already refined (i.e. only cells are refined which do not yet have children). The cells are only flagged, not refined, thus you have the chance to save the refinement flags. </p>

</div>
</div>
<a id="a6ad0b3fb24aae17f4668427a433dea19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ad0b3fb24aae17f4668427a433dea19">&#9670;&nbsp;</a></span>refine_global()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::refine_global </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>times</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Refine all cells <code>times</code> times. In other words, in each one of the <code>times</code> iterations, loop over all cells and refine each cell uniformly into \(2^\text{dim}\) children. In practice, this function repeats the following operations <code>times</code> times: call <a class="el" href="classTriangulation.html#aed8e461d4b2b23a0e1730afdef36e694">set_all_refine_flags()</a> followed by <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a06f5cf8e575cfe98719e9afd968e0e06">execute_coarsening_and_refinement()</a>. The end result is that the number of cells increases by a factor of \((2^\text{dim})^\text{times}=2^{\text{dim} \times \text{times}}\).</p>
<p>The <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a06f5cf8e575cfe98719e9afd968e0e06">execute_coarsening_and_refinement()</a> function called in this loop may throw an exception if it creates cells that are distorted (see its documentation for an explanation). This exception will be propagated through this function if that happens, and you may not get the actual number of refinement steps in that case.</p>
<dl class="section note"><dt>Note</dt><dd>This function triggers the pre- and post-refinement signals before and after doing each individual refinement cycle (i.e. more than once if <code>times &gt; 1</code>) . See the section on signals in the general documentation of this class. </dd></dl>

</div>
</div>
<a id="a6552fa04ee753657bd9f92571d76cf09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6552fa04ee753657bd9f92571d76cf09">&#9670;&nbsp;</a></span>coarsen_global()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::coarsen_global </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>times</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Coarsen all cells the given number of times.</p>
<p>In each of one of the <code>times</code> iterations, all cells will be marked for coarsening. If an active cell is already on the coarsest level, it will be ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function triggers the pre- and post-refinement signals before and after doing each individual coarsening cycle (i.e. more than once if <code>times &gt; 1</code>) . See the section on signals in the general documentation of this class. </dd></dl>

</div>
</div>
<a id="aca5cfa9068a5d3ad32dfca87e2901a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca5cfa9068a5d3ad32dfca87e2901a87">&#9670;&nbsp;</a></span>save_refine_flags() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_refine_flags </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the addresses of the cells which are flagged for refinement to <code>out</code>. For usage, read the general documentation for this class. </p>

</div>
</div>
<a id="affce5fca29acccbb2dc1294ebe404a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affce5fca29acccbb2dc1294ebe404a03">&#9670;&nbsp;</a></span>save_refine_flags() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_refine_flags </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. </p>

</div>
</div>
<a id="a43fc07c3f9e1f02658ca556f41087c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43fc07c3f9e1f02658ca556f41087c85">&#9670;&nbsp;</a></span>load_refine_flags() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_refine_flags </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the information stored by <code>save_refine_flags</code>. </p>

</div>
</div>
<a id="ac924a05e66d5e76458ad088a2b7b5583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac924a05e66d5e76458ad088a2b7b5583">&#9670;&nbsp;</a></span>load_refine_flags() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_refine_flags </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the information stored by <code>save_refine_flags</code>. </p>

</div>
</div>
<a id="af64b6155fd89f8f29d4c02795c1a10d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af64b6155fd89f8f29d4c02795c1a10d9">&#9670;&nbsp;</a></span>save_coarsen_flags() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_coarsen_flags </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Analogue to <code>save_refine_flags</code>. </p>

</div>
</div>
<a id="abaaecbe89311fdaa8a9b999209ff9155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaaecbe89311fdaa8a9b999209ff9155">&#9670;&nbsp;</a></span>save_coarsen_flags() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_coarsen_flags </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. </p>

</div>
</div>
<a id="aa4029122ffe741f843f2f3a7deeceea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4029122ffe741f843f2f3a7deeceea9">&#9670;&nbsp;</a></span>load_coarsen_flags() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_coarsen_flags </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Analogue to <code>load_refine_flags</code>. </p>

</div>
</div>
<a id="a48a9463dcf9aeb3a69831e5e1a321053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a9463dcf9aeb3a69831e5e1a321053">&#9670;&nbsp;</a></span>load_coarsen_flags() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_coarsen_flags </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Analogue to <code>load_refine_flags</code>. </p>

</div>
</div>
<a id="a178e9ce017916f190ddf7a734ef15902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a178e9ce017916f190ddf7a734ef15902">&#9670;&nbsp;</a></span>get_anisotropic_refinement_flag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_anisotropic_refinement_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether this triangulation has ever undergone anisotropic (as opposed to only isotropic) refinement. </p>

</div>
</div>
<a id="aaa726b33b52f694cfca48fae8e761661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa726b33b52f694cfca48fae8e761661">&#9670;&nbsp;</a></span>clear_user_flags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_user_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear all user flags. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a6a9971ee882f15fe521afc4e079383b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a9971ee882f15fe521afc4e079383b5">&#9670;&nbsp;</a></span>save_user_flags() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save all user flags. See the general documentation for this class and the documentation for the <code>save_refine_flags</code> for more details. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="aad25280beb6c2607418a0d3e903819a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad25280beb6c2607418a0d3e903819a3">&#9670;&nbsp;</a></span>save_user_flags() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="af3612ed3c7f7f9cccd3003d85b6f7350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3612ed3c7f7f9cccd3003d85b6f7350">&#9670;&nbsp;</a></span>load_user_flags() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the information stored by <code>save_user_flags</code>. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="ac17946286639b12a03804ebc400eab51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17946286639b12a03804ebc400eab51">&#9670;&nbsp;</a></span>load_user_flags() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the information stored by <code>save_user_flags</code>. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="af8896f8e838dd34ed5b7c1aa351f76f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8896f8e838dd34ed5b7c1aa351f76f5">&#9670;&nbsp;</a></span>clear_user_flags_line()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_user_flags_line </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear all user flags on lines. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a2b7d8e059d6f8f903879eea858215fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b7d8e059d6f8f903879eea858215fb8">&#9670;&nbsp;</a></span>save_user_flags_line() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_line </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user flags on lines. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a02adea7b298cd5047ee5a5755f87ae36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02adea7b298cd5047ee5a5755f87ae36">&#9670;&nbsp;</a></span>save_user_flags_line() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_line </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a25190c31d16cde2a01fa0f2318aa0b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25190c31d16cde2a01fa0f2318aa0b74">&#9670;&nbsp;</a></span>load_user_flags_line() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_line </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user flags located on lines. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a87294511c2f203a57531aaaf2bd2ce39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87294511c2f203a57531aaaf2bd2ce39">&#9670;&nbsp;</a></span>load_user_flags_line() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_line </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user flags located on lines. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a1dd263157214206ceb637c402552f0eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dd263157214206ceb637c402552f0eb">&#9670;&nbsp;</a></span>clear_user_flags_quad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_user_flags_quad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear all user flags on quads. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="acf4a2db0492d38971366bfcd159cbbc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4a2db0492d38971366bfcd159cbbc1">&#9670;&nbsp;</a></span>save_user_flags_quad() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_quad </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user flags on quads. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a431026974872f49e59f6a799ee0a19d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431026974872f49e59f6a799ee0a19d6">&#9670;&nbsp;</a></span>save_user_flags_quad() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_quad </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a5e868cde85c04bcc8cec82ba09f24e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e868cde85c04bcc8cec82ba09f24e7b">&#9670;&nbsp;</a></span>load_user_flags_quad() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_quad </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user flags located on quads. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a8651e0def48d61e3f8f0aa8051ae5985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8651e0def48d61e3f8f0aa8051ae5985">&#9670;&nbsp;</a></span>load_user_flags_quad() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_quad </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user flags located on quads. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a7cbe198bb49c3135378bb680582afd46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cbe198bb49c3135378bb680582afd46">&#9670;&nbsp;</a></span>clear_user_flags_hex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_user_flags_hex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear all user flags on quads. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a1d5512376f914359303ce7d4666d550b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d5512376f914359303ce7d4666d550b">&#9670;&nbsp;</a></span>save_user_flags_hex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_hex </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user flags on hexs. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="ae57c92493d66995cf29bef79f0e8e09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae57c92493d66995cf29bef79f0e8e09b">&#9670;&nbsp;</a></span>save_user_flags_hex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_hex </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a6e15f4d848adbe6c8bf1af374e467a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e15f4d848adbe6c8bf1af374e467a31">&#9670;&nbsp;</a></span>load_user_flags_hex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_hex </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user flags located on hexs. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a77e827086d26927d08129c8489fdcd45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77e827086d26927d08129c8489fdcd45">&#9670;&nbsp;</a></span>load_user_flags_hex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_hex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user flags located on hexs. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a26562806fd764afdffb973dce92554e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26562806fd764afdffb973dce92554e8">&#9670;&nbsp;</a></span>clear_user_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_user_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear all user pointers and indices and allow the use of both for next access. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="ae3794cd2d7f80bd81f69fcb828535412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3794cd2d7f80bd81f69fcb828535412">&#9670;&nbsp;</a></span>save_user_indices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_indices </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save all user indices. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a12a2359968a027a8b14ae381c8886d30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12a2359968a027a8b14ae381c8886d30">&#9670;&nbsp;</a></span>load_user_indices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_indices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the information stored by <a class="el" href="classTriangulation.html#ae3794cd2d7f80bd81f69fcb828535412">save_user_indices()</a>. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="abcc8b79020416280c10e4ccde2ee8454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcc8b79020416280c10e4ccde2ee8454">&#9670;&nbsp;</a></span>save_user_pointers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_pointers </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save all user pointers. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a8087e84b3b755bcb31767c574342ac0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8087e84b3b755bcb31767c574342ac0a">&#9670;&nbsp;</a></span>load_user_pointers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_pointers </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the information stored by <a class="el" href="classTriangulation.html#abcc8b79020416280c10e4ccde2ee8454">save_user_pointers()</a>. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a451b2af8e62783f4780552088fd9ad88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a451b2af8e62783f4780552088fd9ad88">&#9670;&nbsp;</a></span>save_user_indices_line()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_indices_line </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user indices on lines. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a7b2160dd04545294d138ca00deb4af42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b2160dd04545294d138ca00deb4af42">&#9670;&nbsp;</a></span>load_user_indices_line()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_indices_line </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user indices located on lines. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a8d65cc99c33ea13361700a58ff9d6686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d65cc99c33ea13361700a58ff9d6686">&#9670;&nbsp;</a></span>save_user_indices_quad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_indices_quad </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user indices on quads. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a1020c09b32fbb78156b00b833271e21d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1020c09b32fbb78156b00b833271e21d">&#9670;&nbsp;</a></span>load_user_indices_quad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_indices_quad </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user indices located on quads. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a8a18d1c25ca9c0b7cef07c6e92fdd28f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a18d1c25ca9c0b7cef07c6e92fdd28f">&#9670;&nbsp;</a></span>save_user_indices_hex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_indices_hex </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user indices on hexes. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="abad8869b9c8234d6c81c24c69dd97d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad8869b9c8234d6c81c24c69dd97d39">&#9670;&nbsp;</a></span>load_user_indices_hex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_indices_hex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user indices located on hexs. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a42e0bbc9eac6e707667dad2fe528c178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e0bbc9eac6e707667dad2fe528c178">&#9670;&nbsp;</a></span>save_user_pointers_line()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_pointers_line </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user indices on lines. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="aab55095dab9f1be46f088d6d29d016ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab55095dab9f1be46f088d6d29d016ba">&#9670;&nbsp;</a></span>load_user_pointers_line()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_pointers_line </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user pointers located on lines. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a1d1157e5796770a8997fb722b6621921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d1157e5796770a8997fb722b6621921">&#9670;&nbsp;</a></span>save_user_pointers_quad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_pointers_quad </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user pointers on quads. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a6fadda245a0bef85ae6b957d6154a884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fadda245a0bef85ae6b957d6154a884">&#9670;&nbsp;</a></span>load_user_pointers_quad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_pointers_quad </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user pointers located on quads. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a7d8a16ce49cd4b12a65e5fde012b38e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8a16ce49cd4b12a65e5fde012b38e6">&#9670;&nbsp;</a></span>save_user_pointers_hex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_pointers_hex </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user pointers on hexes. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a8e9198f6d3a8dedb19db011e99903863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e9198f6d3a8dedb19db011e99903863">&#9670;&nbsp;</a></span>load_user_pointers_hex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_pointers_hex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user pointers located on hexs. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a36fb6b15f119483143c433dd10df9b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36fb6b15f119483143c433dd10df9b26">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a04043b4c8031c526783448969d01cf53">cell_iterator</a> <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first used cell on level <code>level</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a> would return. </dd></dl>

</div>
</div>
<a id="afe6c58805fe436a94b141c1585606c7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6c58805fe436a94b141c1585606c7f">&#9670;&nbsp;</a></span>begin_active()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a1146b56f8c84da24d1c9a68e61182406">active_cell_iterator</a> <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_active </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first active cell on level <code>level</code>. If the given level does not contain any active cells (i.e., all cells on this level are further refined, then this function returns <code>end_active(level)</code> so that loops of the kind </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> cell=tria.begin_active(<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>);</div>
<div class="line">     cell!=tria.end_active(<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>);</div>
<div class="line">     ++cell)</div>
<div class="line">  {</div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="ttc" id="agrid__out_8cc_html_a9082f945c1d289684d0bcd51ee08e11e"><div class="ttname"><a href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a></div><div class="ttdeci">unsigned int level</div><div class="ttdef"><b>Definition:</b> <a href="grid__out_8cc_source.html#l04590">grid_out.cc:4590</a></div></div>
</div><!-- fragment --><p> have zero iterations, as may be expected if there are no active cells on this level.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a> would return. </dd></dl>

</div>
</div>
<a id="a92c41c89a9cf1e020050985822196dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c41c89a9cf1e020050985822196dff">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a04043b4c8031c526783448969d01cf53">cell_iterator</a> <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator past the end; this iterator serves for comparisons of iterators with past-the-end or before-the-beginning states. </p>

</div>
</div>
<a id="a9597b118c84fce0addf7f4db3b067659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9597b118c84fce0addf7f4db3b067659">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a04043b4c8031c526783448969d01cf53">cell_iterator</a> <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator which is the first iterator not on level. If <code>level</code> is the last level, then this returns <code><a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a></code>.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a> would return. </dd></dl>

</div>
</div>
<a id="ab0967cc6653ea9a08e94fe9da4d11793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0967cc6653ea9a08e94fe9da4d11793">&#9670;&nbsp;</a></span>end_active()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a1146b56f8c84da24d1c9a68e61182406">active_cell_iterator</a> <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_active </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an active iterator which is the first active iterator not on the given level. If <code>level</code> is the last level, then this returns <code><a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a></code>.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a> would return. </dd></dl>

</div>
</div>
<a id="ab51f6fbd9bcd9e41757039a7b4954d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab51f6fbd9bcd9e41757039a7b4954d2a">&#9670;&nbsp;</a></span>last()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a04043b4c8031c526783448969d01cf53">cell_iterator</a> <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::last </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator pointing to the last used cell. </p>

</div>
</div>
<a id="a2eb00096abe5ef91413440e1e1b66c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb00096abe5ef91413440e1e1b66c00">&#9670;&nbsp;</a></span>last_active()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a1146b56f8c84da24d1c9a68e61182406">active_cell_iterator</a> <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::last_active </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator pointing to the last active cell. </p>

</div>
</div>
<a id="a367c0bd718b0ae9316f3b6f52d0ff4c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a367c0bd718b0ae9316f3b6f52d0ff4c6">&#9670;&nbsp;</a></span>create_cell_iterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a04043b4c8031c526783448969d01cf53">cell_iterator</a> <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::create_cell_iterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCellId.html">CellId</a> &amp;&#160;</td>
          <td class="paramname"><em>cell_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator to a cell of this <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a> object constructed from an independent <a class="el" href="classCellId.html">CellId</a> object.</p>
<p>If the given argument corresponds to a valid cell in this triangulation, this operation will always succeed for sequential triangulations where the current processor stores all cells that are part of the triangulation. On the other hand, if this is a parallel triangulation, then the current processor may not actually know about this cell. In this case, this operation will succeed for locally relevant cells, but may not for artificial cells that are less refined on the current processor. </p>

</div>
</div>
<a id="gae2dc0cda6c74461c0bbc22a41b5525c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2dc0cda6c74461c0bbc22a41b5525c4">&#9670;&nbsp;</a></span>cell_iterators()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt;<a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a04043b4c8031c526783448969d01cf53">cell_iterator</a>&gt; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator range that contains all cells (active or not) that make up this triangulation. Such a range is useful to initialize range- based for loops as supported by C++11. See the example in the documentation of <a class="el" href="group__CPP11.html#ga23e860c5192f6501650dda8bb3e2b497">active_cell_iterators()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The half open range <code>[this-&gt;<a class="el" href="classTriangulation.html#a36fb6b15f119483143c433dd10df9b26">begin()</a>, this-&gt;<a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a>)</code> </dd></dl>

</div>
</div>
<a id="ga23e860c5192f6501650dda8bb3e2b497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23e860c5192f6501650dda8bb3e2b497">&#9670;&nbsp;</a></span>active_cell_iterators()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt;<a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a1146b56f8c84da24d1c9a68e61182406">active_cell_iterator</a>&gt; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator range that contains all active cells that make up this triangulation. Such a range is useful to initialize range-based for loops as supported by C++11, see also <a class="el" href="group__CPP11.html">C++11 standard</a>.</p>
<p>Range-based for loops are useful in that they require much less code than traditional loops (see <a href="http://en.wikipedia.org/wiki/C%2B%2B11
#Range-based_for_loop">here</a> for a discussion of how they work). An example is that without range-based for loops, one often writes code such as the following (assuming for a moment that our goal is setting the user flag on every active cell): </p><div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div>
<div class="line">...</div>
<div class="line">typename <a class="code" href="classTriaActiveIterator.html">Triangulation&lt;dim&gt;::active_cell_iterator</a></div>
<div class="line">  cell = <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.begin_active(),</div>
<div class="line">  endc = <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.end();</div>
<div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell)</div>
<div class="line">  cell-&gt;set_user_flag();</div>
<div class="ttc" id="aclassTriaActiveIterator_html"><div class="ttname"><a href="classTriaActiveIterator.html">TriaActiveIterator</a></div><div class="ttdef"><b>Definition:</b> <a href="tria__iterator_8h_source.html#l00758">tria_iterator.h:759</a></div></div>
<div class="ttc" id="aclassTriangulation_html"><div class="ttname"><a href="classTriangulation.html">Triangulation</a></div><div class="ttdef"><b>Definition:</b> <a href="grid_2tria_8h_source.html#l01127">tria.h:1128</a></div></div>
<div class="ttc" id="ap4est__wrappers_8cc_html_ace00f2f80d9780ef9aa1007e1c22c6a4"><div class="ttname"><a href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a></div><div class="ttdeci">const ::parallel::distributed::Triangulation&lt; dim, spacedim &gt; * triangulation</div><div class="ttdef"><b>Definition:</b> <a href="p4est__wrappers_8cc_source.html#l00069">p4est_wrappers.cc:69</a></div></div>
</div><!-- fragment --><p> Using C++11's range-based for loops, this is now entirely equivalent to the following: </p><div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div>
<div class="line">...</div>
<div class="line">for (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.active_cell_iterators())</div>
<div class="line">  cell-&gt;set_user_flag();</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>The half open range <code>[this-&gt;<a class="el" href="classTriangulation.html#afe6c58805fe436a94b141c1585606c7f">begin_active()</a>, this-&gt;<a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a>)</code> </dd></dl>

</div>
</div>
<a id="gae69f18aa4845bfe513fd51a39755b9d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae69f18aa4845bfe513fd51a39755b9d6">&#9670;&nbsp;</a></span>cell_iterators_on_level()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt;<a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a04043b4c8031c526783448969d01cf53">cell_iterator</a>&gt; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterators_on_level </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator range that contains all cells (active or not) that make up the given level of this triangulation. Such a range is useful to initialize range-based for loops as supported by C++11. See the example in the documentation of <a class="el" href="group__CPP11.html#ga23e860c5192f6501650dda8bb3e2b497">active_cell_iterators()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>A given level in the refinement hierarchy of this triangulation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The half open range <code>[this-&gt;begin(level), this-&gt;end(level))</code></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>level must be less than this-&gt;<a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. </dd></dl>

</div>
</div>
<a id="gad45356a49aeb1130d244abb313afdc24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad45356a49aeb1130d244abb313afdc24">&#9670;&nbsp;</a></span>active_cell_iterators_on_level()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt;<a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a1146b56f8c84da24d1c9a68e61182406">active_cell_iterator</a>&gt; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterators_on_level </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator range that contains all active cells that make up the given level of this triangulation. Such a range is useful to initialize range-based for loops as supported by C++11. See the example in the documentation of <a class="el" href="group__CPP11.html#ga23e860c5192f6501650dda8bb3e2b497">active_cell_iterators()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>A given level in the refinement hierarchy of this triangulation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The half open range <code>[this-&gt;begin_active(level), this-&gt;end(level))</code></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>level must be less than this-&gt;<a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. </dd></dl>

</div>
</div>
<a id="abd8e77917e8512bd1e70bf180929f407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd8e77917e8512bd1e70bf180929f407">&#9670;&nbsp;</a></span>begin_face()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga4015f9d1dc9115fbdf74d74960bec074">face_iterator</a> <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_face </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first used face. </p>

</div>
</div>
<a id="af7e8d4115aad4a2a5c97a7f7c06d34d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e8d4115aad4a2a5c97a7f7c06d34d5">&#9670;&nbsp;</a></span>begin_active_face()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#gad77aace3a5c6c96b985cbf22a28c83f2">active_face_iterator</a> <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_active_face </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first active face. </p>

</div>
</div>
<a id="a359dfdc82f2269b68b1d30c8a2286c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359dfdc82f2269b68b1d30c8a2286c6f">&#9670;&nbsp;</a></span>end_face()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga4015f9d1dc9115fbdf74d74960bec074">face_iterator</a> <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_face </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator past the end; this iterator serves for comparisons of iterators with past-the-end or before-the-beginning states. </p>

</div>
</div>
<a id="ga95c4ae1d1e8d3e7d179fdd6bcbbae7d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95c4ae1d1e8d3e7d179fdd6bcbbae7d6">&#9670;&nbsp;</a></span>active_face_iterators()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt;<a class="el" href="group__Iterators.html#gad77aace3a5c6c96b985cbf22a28c83f2">active_face_iterator</a>&gt; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_face_iterators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator range that contains all active faces that make up this triangulation. This function is the face version of <a class="el" href="group__CPP11.html#ga23e860c5192f6501650dda8bb3e2b497">Triangulation::active_cell_iterators()</a>, and allows one to write code like, e.g.,</p>
<div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div>
<div class="line">...</div>
<div class="line">for (<span class="keyword">auto</span> &amp;face : <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.active_face_iterators())</div>
<div class="line">  face-&gt;set_manifold_id(42);</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>The half open range <code>[this-&gt;<a class="el" href="classTriangulation.html#af7e8d4115aad4a2a5c97a7f7c06d34d5">begin_active_face()</a>, this-&gt;<a class="el" href="classTriangulation.html#a359dfdc82f2269b68b1d30c8a2286c6f">end_face()</a>)</code> </dd></dl>

</div>
</div>
<a id="aa76498325599ace7304627cb64e5fcd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa76498325599ace7304627cb64e5fcd2">&#9670;&nbsp;</a></span>begin_vertex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#gac23052ad0b446137324ccf9ea0fd386e">vertex_iterator</a> <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_vertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first used vertex. This function can only be used if dim is not one. </p>

</div>
</div>
<a id="a0e8705fe160c08af9a2372c605525ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e8705fe160c08af9a2372c605525ef0">&#9670;&nbsp;</a></span>begin_active_vertex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga8738294ebb9d165e6b431589b0bbc7f7">active_vertex_iterator</a> <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_active_vertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first active vertex. Because all vertices are active, <a class="el" href="classTriangulation.html#aa76498325599ace7304627cb64e5fcd2">begin_vertex()</a> and <a class="el" href="classTriangulation.html#a0e8705fe160c08af9a2372c605525ef0">begin_active_vertex()</a> return the same vertex. This function can only be used if dim is not one. </p>

</div>
</div>
<a id="aaad93f466afba9b3f003d09a685a615f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad93f466afba9b3f003d09a685a615f">&#9670;&nbsp;</a></span>end_vertex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#gac23052ad0b446137324ccf9ea0fd386e">vertex_iterator</a> <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_vertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator past the end; this iterator serves for comparisons of iterators with past-the-end or before-the-beginning states. This function can only be used if dim is not one. </p>

</div>
</div>
<a id="a46edbe1027405ca9545e3c2289eb3938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46edbe1027405ca9545e3c2289eb3938">&#9670;&nbsp;</a></span>n_lines() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_lines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>In the following, most functions are provided in two versions, with and without an argument describing the level. The versions with this argument are only applicable for objects describing the cells of the present triangulation. For example: in 2D <code>n_lines(level)</code> cannot be called, only <code><a class="el" href="classTriangulation.html#a46edbe1027405ca9545e3c2289eb3938">n_lines()</a></code>, as lines are faces in 2D and therefore have no level. Return the total number of used lines, active or not. </p>

</div>
</div>
<a id="aee5ba9d51dfdd307da590e31c9262c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee5ba9d51dfdd307da590e31c9262c28">&#9670;&nbsp;</a></span>n_lines() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_lines </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used lines, active or not on level <code>level</code>. </p>

</div>
</div>
<a id="a76c9d6f7b2068f5afa429020086b6b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c9d6f7b2068f5afa429020086b6b8c">&#9670;&nbsp;</a></span>n_active_lines() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_lines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active lines. </p>

</div>
</div>
<a id="a21d30203bdeaa3b9e2b416f24b7e9d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d30203bdeaa3b9e2b416f24b7e9d6d">&#9670;&nbsp;</a></span>n_active_lines() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_lines </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active lines, on level <code>level</code>. </p>

</div>
</div>
<a id="a105d0305d8c801076bea2404087f29a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105d0305d8c801076bea2404087f29a7">&#9670;&nbsp;</a></span>n_quads() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_quads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used quads, active or not. </p>

</div>
</div>
<a id="af0817fceed7429359f89928eec87d381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0817fceed7429359f89928eec87d381">&#9670;&nbsp;</a></span>n_quads() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used quads, active or not on level <code>level</code>. </p>

</div>
</div>
<a id="a79f664cd903c4a7d36cfcf59edf77d23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f664cd903c4a7d36cfcf59edf77d23">&#9670;&nbsp;</a></span>n_quads() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; 1, 1 &gt;::n_quads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12919">12919</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a68e9cf2d0847dfc5fac2d9d9c39917ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68e9cf2d0847dfc5fac2d9d9c39917ad">&#9670;&nbsp;</a></span>n_quads() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; 1, 1 &gt;::n_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12927">12927</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="afa43cc09475a962c64cf81b66bbc6063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa43cc09475a962c64cf81b66bbc6063">&#9670;&nbsp;</a></span>n_quads() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; 1, 2 &gt;::n_quads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12968">12968</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="ab5f759946225da01083c7788aba9a51a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f759946225da01083c7788aba9a51a">&#9670;&nbsp;</a></span>n_quads() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; 1, 2 &gt;::n_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12976">12976</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a94898f00b04cdd9f446b2781d7c0dcc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94898f00b04cdd9f446b2781d7c0dcc8">&#9670;&nbsp;</a></span>n_quads() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; 1, 3 &gt;::n_quads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13016">13016</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="ae0b2538b067fac8ad5c6e5f8bf8fae06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b2538b067fac8ad5c6e5f8bf8fae06">&#9670;&nbsp;</a></span>n_quads() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; 1, 3 &gt;::n_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13024">13024</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="ab7a0837c6dabdda21930bf3d49e9852d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7a0837c6dabdda21930bf3d49e9852d">&#9670;&nbsp;</a></span>n_active_quads() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_quads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active quads, active or not. </p>

</div>
</div>
<a id="abf97ad6187b553b2980043dd1c8d75db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf97ad6187b553b2980043dd1c8d75db">&#9670;&nbsp;</a></span>n_active_quads() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active quads, active or not on level <code>level</code>. </p>

</div>
</div>
<a id="a05dfabc61a0635b5f0448e645e7944f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05dfabc61a0635b5f0448e645e7944f4">&#9670;&nbsp;</a></span>n_active_quads() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; 1, 1 &gt;::n_active_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12951">12951</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="ab9bb2a1aef23adff709c2fa112bfe870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9bb2a1aef23adff709c2fa112bfe870">&#9670;&nbsp;</a></span>n_active_quads() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; 1, 1 &gt;::n_active_quads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12959">12959</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a7a33c09d9402a8425583058d7f9d44ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a33c09d9402a8425583058d7f9d44ce">&#9670;&nbsp;</a></span>n_active_quads() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; 1, 2 &gt;::n_active_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13000">13000</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a80e29455eadbe8231a65da04eb0567d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80e29455eadbe8231a65da04eb0567d6">&#9670;&nbsp;</a></span>n_active_quads() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; 1, 2 &gt;::n_active_quads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13008">13008</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a2f45d56e9d6679fcd0f8d793a5ecb891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f45d56e9d6679fcd0f8d793a5ecb891">&#9670;&nbsp;</a></span>n_active_quads() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; 1, 3 &gt;::n_active_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13048">13048</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a40ff5c5e5aadf633944e2e6c7c7c7767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ff5c5e5aadf633944e2e6c7c7c7767">&#9670;&nbsp;</a></span>n_active_quads() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; 1, 3 &gt;::n_active_quads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13056">13056</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="aaa75fe811e9d1707ce798f874aa2e117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa75fe811e9d1707ce798f874aa2e117">&#9670;&nbsp;</a></span>n_hexs() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_hexs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used hexahedra, active or not. </p>

</div>
</div>
<a id="a015bc7a2fecb2cba52050a8f2bfbafe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a015bc7a2fecb2cba52050a8f2bfbafe1">&#9670;&nbsp;</a></span>n_hexs() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_hexs </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used hexahedra, active or not on level <code>level</code>. </p>

</div>
</div>
<a id="ac0d198aebd80535ad593e5133a8812ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0d198aebd80535ad593e5133a8812ee">&#9670;&nbsp;</a></span>n_hexs() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; 3, 3 &gt;::n_hexs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13194">13194</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="af2699445c877451375c6128d44c90c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2699445c877451375c6128d44c90c9e">&#9670;&nbsp;</a></span>n_hexs() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; 3, 3 &gt;::n_hexs </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13203">13203</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="aee621a8e59e259c252ccc64f19e37301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee621a8e59e259c252ccc64f19e37301">&#9670;&nbsp;</a></span>n_active_hexs() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_hexs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active hexahedra, active or not. </p>

</div>
</div>
<a id="ade8bbb4c8ffd9f8adb683b39a82a9b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade8bbb4c8ffd9f8adb683b39a82a9b1e">&#9670;&nbsp;</a></span>n_active_hexs() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_hexs </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active hexahedra, active or not on level <code>level</code>. </p>

</div>
</div>
<a id="a23fef4d5635144af728710f4e2783902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23fef4d5635144af728710f4e2783902">&#9670;&nbsp;</a></span>n_active_hexs() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; 3, 3 &gt;::n_active_hexs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13223">13223</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a04d8b81ff513c945250ddff5c6df54cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d8b81ff513c945250ddff5c6df54cd">&#9670;&nbsp;</a></span>n_active_hexs() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; 3, 3 &gt;::n_active_hexs </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13232">13232</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="abea687f123f3f5a8b09d7485cf03be72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea687f123f3f5a8b09d7485cf03be72">&#9670;&nbsp;</a></span>n_cells() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used cells, active or not. Maps to <code><a class="el" href="classTriangulation.html#a46edbe1027405ca9545e3c2289eb3938">n_lines()</a></code> in one space dimension and so on. </p>

</div>
</div>
<a id="a40c5623c62d2e43aa63f1eb4904eeec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c5623c62d2e43aa63f1eb4904eeec8">&#9670;&nbsp;</a></span>n_cells() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_cells </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used cells, active or not, on level <code>level</code>. Maps to <code>n_lines(level)</code> in one space dimension and so on. </p>

</div>
</div>
<a id="a5ea5c9957dbb566a562bbe2c0f3971e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ea5c9957dbb566a562bbe2c0f3971e9">&#9670;&nbsp;</a></span>n_active_cells() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active cells. Maps to <code><a class="el" href="classTriangulation.html#a76c9d6f7b2068f5afa429020086b6b8c">n_active_lines()</a></code> in one space dimension and so on. </p>

</div>
</div>
<a id="a3d106ed8c9a29d6bb7d2bfb636f8df62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d106ed8c9a29d6bb7d2bfb636f8df62">&#9670;&nbsp;</a></span>n_active_cells() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_cells </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active cells on level <code>level</code>. Maps to <code>n_active_lines(level)</code> in one space dimension and so on. </p>

</div>
</div>
<a id="a1e297d311818e3a79bcede5804f51065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e297d311818e3a79bcede5804f51065">&#9670;&nbsp;</a></span>n_faces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used faces, active or not. In 2D, the result equals <a class="el" href="classTriangulation.html#a46edbe1027405ca9545e3c2289eb3938">n_lines()</a>, in 3D it equals <a class="el" href="classTriangulation.html#a105d0305d8c801076bea2404087f29a7">n_quads()</a>, while in 1D it equals the number of used vertices. </p>

</div>
</div>
<a id="a5ae907d55b3b12c5c75e58174c1781ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae907d55b3b12c5c75e58174c1781ff">&#9670;&nbsp;</a></span>n_active_faces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active faces. In 2D, the result equals <a class="el" href="classTriangulation.html#a76c9d6f7b2068f5afa429020086b6b8c">n_active_lines()</a>, in 3D it equals <a class="el" href="classTriangulation.html#ab7a0837c6dabdda21930bf3d49e9852d">n_active_quads()</a>, while in 1D it equals the number of used vertices. </p>

</div>
</div>
<a id="a777f035a17e91a4d822971516ca11db5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a777f035a17e91a4d822971516ca11db5">&#9670;&nbsp;</a></span>n_levels()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_levels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of levels in this triangulation.</p>
<dl class="section note"><dt>Note</dt><dd>Internally, triangulations store data in levels, and there may be more levels in this data structure than one may think &ndash; for example, imagine a triangulation that we just got by coarsening the highest level so that it was completely depopulated. That level is not removed, since it will most likely be repopulated soon by the next refinement process. As a consequence, if you happened to run through raw cell iterators (which you can't do as a user of this class, but can internally), then the number of objects in the levels hierarchy is larger than the level of the most refined cell plus one. On the other hand, since this is rarely what a user of this class cares about, the function really just returns the level of the most refined active cell plus one. (The plus one is because in a coarse, unrefined mesh, all cells have level zero &ndash; making the number of levels equal to one.) </dd></dl>

</div>
</div>
<a id="ae1aadc2300ef9a6f2368fe7bc5926fe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1aadc2300ef9a6f2368fe7bc5926fe8">&#9670;&nbsp;</a></span>n_vertices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of vertices. Some of them may not be used, which usually happens upon coarsening of a triangulation when some vertices are discarded, but we do not want to renumber the remaining ones, leading to holes in the numbers of used vertices. You can get the number of used vertices using <code>n_used_vertices</code> function. </p>

</div>
</div>
<a id="afb3059d54432e0d739534e5330bb7b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb3059d54432e0d739534e5330bb7b3a">&#9670;&nbsp;</a></span>get_vertices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; &gt;&amp; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a constant reference to all the vertices present in this triangulation. Note that not necessarily all vertices in this array are actually used; for example, if you coarsen a mesh, then some vertices are deleted, but their positions in this array are unchanged as the indices of vertices are only allocated once. You can find out about which vertices are actually used by the function <a class="el" href="classTriangulation.html#a07690a619d2817f4c8ef3bb74c43b80a">get_used_vertices()</a>. </p>

</div>
</div>
<a id="a76937acd9dfc3ade1fb885c7ab1ae776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76937acd9dfc3ade1fb885c7ab1ae776">&#9670;&nbsp;</a></span>n_used_vertices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_used_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of vertices that are presently in use, i.e. belong to at least one used element. </p>

</div>
</div>
<a id="aab2295fdb4bfc8ab41f51cdbc34de449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab2295fdb4bfc8ab41f51cdbc34de449">&#9670;&nbsp;</a></span>vertex_used()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::vertex_used </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return <code>true</code> if the vertex with this <code>index</code> is used. </p>

</div>
</div>
<a id="a07690a619d2817f4c8ef3bb74c43b80a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07690a619d2817f4c8ef3bb74c43b80a">&#9670;&nbsp;</a></span>get_used_vertices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classbool.html">bool</a>&gt;&amp; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_used_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a constant reference to the array of <code>bools</code> indicating whether an entry in the vertex array is used or not. </p>

</div>
</div>
<a id="aa6313a19a8cc20e07249978218b5ca6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6313a19a8cc20e07249978218b5ca6a">&#9670;&nbsp;</a></span>max_adjacent_cells() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::max_adjacent_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the maximum number of cells meeting at a common vertex. Since this number is an invariant under refinement, only the cells on the coarsest level are considered. The operation is thus reasonably fast. The invariance is only true for sufficiently many cells in the coarsest triangulation (e.g. for a single cell one would be returned), so a minimum of four is returned in two dimensions, 8 in three dimensions, etc, which is how many cells meet if the triangulation is refined.</p>
<p>In one space dimension, two is returned. </p>

</div>
</div>
<a id="a5d6e3826a32b12684e8e4ff94a23a648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d6e3826a32b12684e8e4ff94a23a648">&#9670;&nbsp;</a></span>max_adjacent_cells() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; 1, 1 &gt;::max_adjacent_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13261">13261</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="aa4b710ab15cf74994c3f33e4f4d17e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b710ab15cf74994c3f33e4f4d17e95">&#9670;&nbsp;</a></span>max_adjacent_cells() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; 1, 2 &gt;::max_adjacent_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13270">13270</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a3a107913a2a6858ec87704accdff065f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a107913a2a6858ec87704accdff065f">&#9670;&nbsp;</a></span>max_adjacent_cells() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; 1, 3 &gt;::max_adjacent_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13278">13278</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="acbcac8668993d582f192d3c85b642dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbcac8668993d582f192d3c85b642dd3">&#9670;&nbsp;</a></span>get_triangulation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_triangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference to the current object.</p>
<p>This doesn't seem to be very useful but allows to write code that can access the underlying triangulation for anything that satisfies the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a> (which may not only be a triangulation, but also a <a class="el" href="classDoFHandler.html">DoFHandler</a>, for example). </p>

</div>
</div>
<a id="aae427477f592d34c1bf3367e408f90c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae427477f592d34c1bf3367e408f90c3">&#9670;&nbsp;</a></span>get_triangulation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_triangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference to the current object. This is the const-version of the previous function. </p>

</div>
</div>
<a id="a4a466c6b1755b353d43ce8827b1518e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a466c6b1755b353d43ce8827b1518e3">&#9670;&nbsp;</a></span>n_raw_lines() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_lines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Total number of lines, used or unused.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="a615e8e8877a420fede76cea831f6ca52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a615e8e8877a420fede76cea831f6ca52">&#9670;&nbsp;</a></span>n_raw_lines() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_lines </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of lines, used or unused, on the given level.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="abbcdcdaea38195ba043370ddc6202224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbcdcdaea38195ba043370ddc6202224">&#9670;&nbsp;</a></span>n_raw_quads() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_quads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Total number of quads, used or unused.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="a9f590c6799cf3bb79c3c810f972a117e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f590c6799cf3bb79c3c810f972a117e">&#9670;&nbsp;</a></span>n_raw_quads() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of quads, used or unused, on the given level.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="a7ade3550e213fc07d713a28b489a9a6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ade3550e213fc07d713a28b489a9a6e">&#9670;&nbsp;</a></span>n_raw_quads() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; 1, 1 &gt;::n_raw_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12935">12935</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="afacb21a22bf29351cf42cfb335e82760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afacb21a22bf29351cf42cfb335e82760">&#9670;&nbsp;</a></span>n_raw_quads() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; 1, 2 &gt;::n_raw_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12984">12984</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="ad9f495bae2139d10563cf878da49bbb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f495bae2139d10563cf878da49bbb6">&#9670;&nbsp;</a></span>n_raw_quads() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; 1, 3 &gt;::n_raw_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13032">13032</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a2f1cac92589b83a46980c84338e4d32e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f1cac92589b83a46980c84338e4d32e">&#9670;&nbsp;</a></span>n_raw_quads() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; 2, 2 &gt;::n_raw_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13084">13084</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a41e1ddd6af8ce2f148dc2e471262cf8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41e1ddd6af8ce2f148dc2e471262cf8c">&#9670;&nbsp;</a></span>n_raw_quads() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; 2, 3 &gt;::n_raw_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13094">13094</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="ab70ff6a8fffd9c8f4074fb6f06f708c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab70ff6a8fffd9c8f4074fb6f06f708c5">&#9670;&nbsp;</a></span>n_raw_quads() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; 3, 3 &gt;::n_raw_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13103">13103</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a49642521d7ce41aea4fd882332f47f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49642521d7ce41aea4fd882332f47f82">&#9670;&nbsp;</a></span>n_raw_quads() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; 3, 3 &gt;::n_raw_quads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13123">13123</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="aed5a359c972a4679b5ff1be96b68efc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5a359c972a4679b5ff1be96b68efc1">&#9670;&nbsp;</a></span>n_raw_hexs() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_hexs </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of hexs, used or unused, on the given level.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="a0bc73e5f4491b310f3a65441be139513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bc73e5f4491b310f3a65441be139513">&#9670;&nbsp;</a></span>n_raw_hexs() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; 1, 1 &gt;::n_raw_hexs </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12943">12943</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a5cf5b1fd0f6f9753145821d9ff46101a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf5b1fd0f6f9753145821d9ff46101a">&#9670;&nbsp;</a></span>n_raw_hexs() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; 1, 2 &gt;::n_raw_hexs </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l12992">12992</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="aeaec203ac31c6102d901e205bd774362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaec203ac31c6102d901e205bd774362">&#9670;&nbsp;</a></span>n_raw_hexs() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; 1, 3 &gt;::n_raw_hexs </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13040">13040</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a882c905333d176ffdcb5cd79f2e7a51e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a882c905333d176ffdcb5cd79f2e7a51e">&#9670;&nbsp;</a></span>n_raw_hexs() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; 3, 3 &gt;::n_raw_hexs </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l13214">13214</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a947c26f9d04c1b4a4fb190334ebd1542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947c26f9d04c1b4a4fb190334ebd1542">&#9670;&nbsp;</a></span>n_raw_cells()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_cells </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of cells, used or unused, on the given level.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="a5a7926c72a24cc478de8217c1f6988e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a7926c72a24cc478de8217c1f6988e0">&#9670;&nbsp;</a></span>n_raw_faces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of faces, used or not. In 2d, the result equals <a class="el" href="classTriangulation.html#a4a466c6b1755b353d43ce8827b1518e3">n_raw_lines()</a>, in 3d it equals <a class="el" href="classTriangulation.html#abbcdcdaea38195ba043370ddc6202224">n_raw_quads()</a>, while in 1D it equals the number of vertices.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="a7117ea716b516ef11a205a5d0020fe40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7117ea716b516ef11a205a5d0020fe40">&#9670;&nbsp;</a></span>add_periodicity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::add_periodicity </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">GridTools::PeriodicFacePair</a>&lt; <a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Declare the (coarse) face pairs given in the argument of this function as periodic. This way it is possible to obtain neighbors across periodic boundaries.</p>
<p>The vector can be filled by the function <a class="el" href="namespaceGridTools.html#aee88c4dce5066a41183b5dd70289b9df">GridTools::collect_periodic_faces</a>.</p>
<p>For more information on periodic boundary conditions see <a class="el" href="namespaceGridTools.html#aee88c4dce5066a41183b5dd70289b9df">GridTools::collect_periodic_faces</a>, <a class="el" href="namespaceDoFTools.html#a929249499b1e5624728d212e90a8e037">DoFTools::make_periodicity_constraints</a> and <a class="el" href="step_45.html">step-45</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Before this function can be used the <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a> has to be initialized and must not be refined. </dd></dl>

</div>
</div>
<a id="ac34318b9fb11fa49f10ba7c5155960c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac34318b9fb11fa49f10ba7c5155960c6">&#9670;&nbsp;</a></span>get_periodic_face_map()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt; std::pair&lt;<a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a04043b4c8031c526783448969d01cf53">cell_iterator</a>, unsigned int&gt;, std::pair&lt;std::pair&lt;<a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a04043b4c8031c526783448969d01cf53">cell_iterator</a>, unsigned int&gt;, std::bitset&lt;3&gt; &gt; &gt;&amp; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_periodic_face_map </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the periodic_face_map. </p>

</div>
</div>
<a id="af4f08d0df83f6455dbdac86c1a0736b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f08d0df83f6455dbdac86c1a0736b8">&#9670;&nbsp;</a></span>get_reference_cells()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classReferenceCell.html">ReferenceCell</a>&gt;&amp; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_reference_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return vector filled with the used reference-cell types of this triangulation. </p>

</div>
</div>
<a id="a24c84e9fa932ccd35820fe68abfe1348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c84e9fa932ccd35820fe68abfe1348">&#9670;&nbsp;</a></span>all_reference_cells_are_hyper_cube()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::all_reference_cells_are_hyper_cube </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Indicate if the triangulation only consists of hypercube-like cells, i.e., lines, quadrilaterals, or hexahedra. </p>

</div>
</div>
<a id="ac70afc9a4f52455c18183ab31dd6789f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac70afc9a4f52455c18183ab31dd6789f">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>archive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write and read the data of this object from a stream for the purpose of serialization. using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. </p>

</div>
</div>
<a id="gaaf7a82dea92795d1e2b7efe1d79dd2c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf7a82dea92795d1e2b7efe1d79dd2c9">&#9670;&nbsp;</a></span>ExcInvalidLevel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a>&amp; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::ExcInvalidLevel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exception </p><dl class="section note"><dt>Note</dt><dd>The message that will be printed by this exception reads: <div class="doxygen-generated-exception-message"> &lt;&lt; "You are requesting information from refinement level " &lt;&lt; arg1 &lt;&lt; " of a triangulation, but this triangulation only has " &lt;&lt; arg2 &lt;&lt; " refinement levels. The given level " &lt;&lt; arg1 &lt;&lt; " must be *less* than " &lt;&lt; arg2 &lt;&lt; "." </div> </dd></dl>

</div>
</div>
<a id="ga3f6e5e8dad753152f01dbafe33a3ca6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f6e5e8dad753152f01dbafe33a3ca6b">&#9670;&nbsp;</a></span>ExcTriangulationNotEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a>&amp; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::ExcTriangulationNotEmpty </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function raising this exception can only operate on an empty <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>, i.e., a <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a> without grid cells. </p><dl class="section note"><dt>Note</dt><dd>The message that will be printed by this exception reads: <div class="doxygen-generated-exception-message"> &lt;&lt; "You are trying to perform an operation on a triangulation " &lt;&lt; "that is only allowed if the triangulation is currently empty. " &lt;&lt; "However, it currently stores " &lt;&lt; arg1 &lt;&lt; " vertices and has " &lt;&lt; "cells on " &lt;&lt; arg2 &lt;&lt; " levels." </div> </dd></dl>

</div>
</div>
<a id="ga1c9d4e57043a635b5b500a0586c1102f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c9d4e57043a635b5b500a0586c1102f">&#9670;&nbsp;</a></span>ExcGridReadError()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a>&amp; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::ExcGridReadError </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Trying to re-read a grid, an error occurred. </p>

</div>
</div>
<a id="ga3ef856ab83c8d32ad735d94e91104df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ef856ab83c8d32ad735d94e91104df2">&#9670;&nbsp;</a></span>ExcFacesHaveNoLevel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a>&amp; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::ExcFacesHaveNoLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="ga6990c9212a412c867ec48752d7adaff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6990c9212a412c867ec48752d7adaff8">&#9670;&nbsp;</a></span>ExcEmptyLevel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a>&amp; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::ExcEmptyLevel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The triangulation level you accessed is empty. </p><dl class="section note"><dt>Note</dt><dd>The message that will be printed by this exception reads: <div class="doxygen-generated-exception-message"> &lt;&lt; "You tried to do something on level " &lt;&lt; arg1 &lt;&lt; ", but this level is empty." </div> </dd></dl>

</div>
</div>
<a id="ga20d143ee7457a9a3d795b649478a64bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20d143ee7457a9a3d795b649478a64bc">&#9670;&nbsp;</a></span>ExcNonOrientableTriangulation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a>&amp; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::ExcNonOrientableTriangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="gabbfbe8e4d3cc626d8cd6d9c131b20401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbfbe8e4d3cc626d8cd6d9c131b20401">&#9670;&nbsp;</a></span>ExcBoundaryIdNotFound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a>&amp; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::ExcBoundaryIdNotFound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>arg1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exception</p>
<p>Requested boundary_id not found </p><dl class="section note"><dt>Note</dt><dd>The message that will be printed by this exception reads: <div class="doxygen-generated-exception-message"> &lt;&lt; "The given boundary_id " &lt;&lt; arg1 &lt;&lt; " is not defined in this Triangulation!" </div> </dd></dl>

</div>
</div>
<a id="ga373a340f3589390f9a5525218430b3b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga373a340f3589390f9a5525218430b3b5">&#9670;&nbsp;</a></span>ExcInconsistentCoarseningFlags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a>&amp; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::ExcInconsistentCoarseningFlags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exception </p><dl class="section note"><dt>Note</dt><dd>The message that will be printed by this exception reads: <div class="doxygen-generated-exception-message"> "A cell is flagged for coarsening, but either not all of its siblings " "are active or flagged for coarsening as well. Please clean up all " "coarsen flags on your triangulation via " "Triangulation::prepare_coarsening_and_refinement() beforehand!" </div> </dd></dl>

</div>
</div>
<a id="af9e3e5c077024f40355432c771ccf541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9e3e5c077024f40355432c771ccf541">&#9670;&nbsp;</a></span>write_bool_vector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::write_bool_vector </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>magic_number1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>magic_number2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write a bool vector to the given stream, writing a pre- and a postfix magic number. The vector is written in an almost binary format, i.e. the bool flags are packed but the data is written as ASCII text.</p>
<p>The flags are stored in a binary format: for each <code>true</code>, a <code>1</code> bit is stored, a <code>0</code> bit otherwise. The bits are stored as <code>unsigned char</code>, thus avoiding endianness. They are written to <code>out</code> in plain text, thus amounting to 3.6 bits in the output per bits in the input on the average. Other information (magic numbers and number of elements of the input vector) is stored as plain text as well. The format should therefore be interplatform compatible. </p>

</div>
</div>
<a id="a20c92032e652bdafdfd7624a55aa2866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20c92032e652bdafdfd7624a55aa2866">&#9670;&nbsp;</a></span>read_bool_vector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::read_bool_vector </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>magic_number1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>magic_number2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Re-read a vector of bools previously written by <code>write_bool_vector</code> and compare with the magic numbers. </p>

</div>
</div>
<a id="a609fee9e79ae50f4c348a39838c7eb0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a609fee9e79ae50f4c348a39838c7eb0c">&#9670;&nbsp;</a></span>update_periodic_face_map()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::update_periodic_face_map </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Recreate information about periodic neighbors from periodic_face_pairs_level_0. </p>

</div>
</div>
<a id="a45bb19508b89ac6ed237b14bf7a506ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45bb19508b89ac6ed237b14bf7a506ef">&#9670;&nbsp;</a></span>begin_raw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html#a5977e64adfde9e63f274be77bb34dddc">raw_cell_iterator</a> <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_raw </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first cell, used or not, on level <code>level</code>. If a level has no cells, a past-the-end iterator is returned. </p>

</div>
</div>
<a id="a5cbfc1e5187c6ad0a47d1b616f9f5149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cbfc1e5187c6ad0a47d1b616f9f5149">&#9670;&nbsp;</a></span>end_raw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html#a5977e64adfde9e63f274be77bb34dddc">raw_cell_iterator</a> <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_raw </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a raw iterator which is the first iterator not on level. If <code>level</code> is the last level, then this returns <code><a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a></code>. </p>

</div>
</div>
<a id="af97878288a5eca64303abe53572ea159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af97878288a5eca64303abe53572ea159">&#9670;&nbsp;</a></span>begin_raw_line()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html#a0e0f7bc0b40113139b244a54591e9d53">raw_line_iterator</a> <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_raw_line </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first line, used or not, on level <code>level</code>. If a level has no lines, a past-the-end iterator is returned. If lines are no cells, i.e. for <code>dim&gt;1</code> no <code>level</code> argument must be given. The same applies for all the other functions above, of course. </p>

</div>
</div>
<a id="aa50f2b3deed6e5f99e91768266df1d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa50f2b3deed6e5f99e91768266df1d6e">&#9670;&nbsp;</a></span>begin_line()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga863d37379dceb11324e72a44039ac495">line_iterator</a> <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_line </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first used line on level <code>level</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a> would return. </dd></dl>

</div>
</div>
<a id="a8d3efa7416e6b56419ffab72ac227a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d3efa7416e6b56419ffab72ac227a4a">&#9670;&nbsp;</a></span>begin_active_line()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#gabfba44e3df01252843f37ee1f8e6df58">active_line_iterator</a> <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_active_line </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first active line on level <code>level</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a> would return. </dd></dl>

</div>
</div>
<a id="a5cf640d5b174cae0f46e415c3fe39db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf640d5b174cae0f46e415c3fe39db2">&#9670;&nbsp;</a></span>end_line()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga863d37379dceb11324e72a44039ac495">line_iterator</a> <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_line </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator past the end; this iterator serves for comparisons of iterators with past-the-end or before-the-beginning states. </p>

</div>
</div>
<a id="a52db7f90cd64a56e55383bef561aa7d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52db7f90cd64a56e55383bef561aa7d1">&#9670;&nbsp;</a></span>begin_raw_quad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html#a80735fd291dca4e5f958ee5876289aa4">raw_quad_iterator</a> <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_raw_quad </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first quad, used or not, on the given level. If a level has no quads, a past-the-end iterator is returned. If quads are no cells, i.e. for \(dim&gt;2\) no level argument must be given.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a> would return. </dd></dl>

</div>
</div>
<a id="a09ee8cea6762ae96b484436de70b3983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ee8cea6762ae96b484436de70b3983">&#9670;&nbsp;</a></span>begin_quad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga672c99b1c8da16227cae6f0cf66cc109">quad_iterator</a> <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_quad </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first used quad on level <code>level</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a> would return. </dd></dl>

</div>
</div>
<a id="a169e053e788e4d1b6abf7fb7cee6ba3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a169e053e788e4d1b6abf7fb7cee6ba3c">&#9670;&nbsp;</a></span>begin_active_quad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga31b331baff3d6bfb841950b10845fc5f">active_quad_iterator</a> <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_active_quad </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first active quad on level <code>level</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a> would return. </dd></dl>

</div>
</div>
<a id="aa4f723b45ffdd6bfefec560fd333dadf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4f723b45ffdd6bfefec560fd333dadf">&#9670;&nbsp;</a></span>end_quad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga672c99b1c8da16227cae6f0cf66cc109">quad_iterator</a> <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_quad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator past the end; this iterator serves for comparisons of iterators with past-the-end or before-the-beginning states. </p>

</div>
</div>
<a id="a26795906ff2742c5f2109113b79d6744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26795906ff2742c5f2109113b79d6744">&#9670;&nbsp;</a></span>begin_raw_hex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html#ac2be382ff40558d007dd767a1288dc1e">raw_hex_iterator</a> <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_raw_hex </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first hex, used or not, on level <code>level</code>. If a level has no hexes, a past-the-end iterator is returned.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a> would return. </dd></dl>

</div>
</div>
<a id="aae764c732cc0de8322257d13912552b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae764c732cc0de8322257d13912552b8">&#9670;&nbsp;</a></span>begin_hex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga0500bbdefc5ea6a1306892b933896875">hex_iterator</a> <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_hex </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first used hex on level <code>level</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a> would return. </dd></dl>

</div>
</div>
<a id="a1e876cdf1cdae06aa793cc5081b4fe31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e876cdf1cdae06aa793cc5081b4fe31">&#9670;&nbsp;</a></span>begin_active_hex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga4fed0f1753adab5eb220b1bec03ae571">active_hex_iterator</a> <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_active_hex </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first active hex on level <code>level</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#a5e6247bd25858eeed99445f2eb810b9c">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a> would return. </dd></dl>

</div>
</div>
<a id="aadd003c8d0a9d5839488ee2ad1313703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadd003c8d0a9d5839488ee2ad1313703">&#9670;&nbsp;</a></span>end_hex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga0500bbdefc5ea6a1306892b933896875">hex_iterator</a> <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_hex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator past the end; this iterator serves for comparisons of iterators with past-the-end or before-the-beginning states. </p>

</div>
</div>
<a id="a61d0ea3487d046b34de4ee8f60abf1b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61d0ea3487d046b34de4ee8f60abf1b2">&#9670;&nbsp;</a></span>clear_despite_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_despite_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The (public) function <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a0f6c7f53d060c63005b005e7638d2219">clear()</a> will only work when the triangulation is not subscribed to by other users. The <a class="el" href="classTriangulation.html#a61d0ea3487d046b34de4ee8f60abf1b2">clear_despite_subscriptions()</a> function now allows the triangulation being cleared even when there are subscriptions.</p>
<p>Make sure, you know what you do, when calling this function, as its use is reasonable in very rare cases, only. For example, when the subscriptions were for the initially empty <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a> and the <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a> object wants to release its memory before throwing an assertion due to input errors (e.g. in the <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#ae09eb5f25fd81eca041851bd8eedec15">create_triangulation()</a> function). </p>

</div>
</div>
<a id="af42c164ad82da9629eab01f90ef2a360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af42c164ad82da9629eab01f90ef2a360">&#9670;&nbsp;</a></span>reset_policy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::reset_policy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset triangulation policy. </p>

</div>
</div>
<a id="a365332f11d26e60c46a1f9bbb3e5e1c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365332f11d26e60c46a1f9bbb3e5e1c1">&#9670;&nbsp;</a></span>reset_active_cell_indices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::reset_active_cell_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For all cells, set the active cell indices so that active cells know the how many-th active cell they are, and all other cells have an invalid value. This function is called after mesh creation, refinement, and serialization. </p>

</div>
</div>
<a id="a8a73cdc08e502d9a140a625184526b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a73cdc08e502d9a140a625184526b89">&#9670;&nbsp;</a></span>execute_refinement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DistortedCellList <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::execute_refinement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Refine all cells on all levels which were previously flagged for refinement.</p>
<p>Note, that this function uses the <code>line-&gt;user_flags</code> for <code>dim=2,3</code> and the <code>quad-&gt;user_flags</code> for <code>dim=3</code>.</p>
<p>The function returns a list of cells that have produced children that satisfy the criteria of <a class="el" href="DEALGlossary.html#GlossDistorted">distorted cells</a> if the <code>check_for_distorted_cells</code> flag was specified upon creation of this object, at </p>

</div>
</div>
<a id="afeebb271c1406d688a1ffb802a7bb509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeebb271c1406d688a1ffb802a7bb509">&#9670;&nbsp;</a></span>execute_coarsening()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::execute_coarsening </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Coarsen all cells which were flagged for coarsening, or rather: delete all children of those cells of which all child cells are flagged for coarsening and several other constraints hold (see the general doc of this class). </p>

</div>
</div>
<a id="a37dc87bf8f3793947ba51f2da20b8442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37dc87bf8f3793947ba51f2da20b8442">&#9670;&nbsp;</a></span>fix_coarsen_flags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::fix_coarsen_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make sure that either all or none of the children of a cell are tagged for coarsening. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a2266801c37cca7d3e04a75a65688580b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2266801c37cca7d3e04a75a65688580b">&#9670;&nbsp;</a></span>settings</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0">TriangulationDescription::Settings</a> <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">parallel::fullydistributed::Triangulation</a>&lt; dim, spacedim &gt;::settings</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>store the Settings. </p>

<p class="definition">Definition at line <a class="el" href="fully__distributed__tria_8h_source.html#l00284">284</a> of file <a class="el" href="fully__distributed__tria_8h_source.html">fully_distributed_tria.h</a>.</p>

</div>
</div>
<a id="ad5c4b0e43427ab6b6bd00950d7de8863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5c4b0e43427ab6b6bd00950d7de8863">&#9670;&nbsp;</a></span>partitioner</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(::<a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt;dim, spacedim&gt; &amp;, const unsigned int)&gt; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">parallel::fullydistributed::Triangulation</a>&lt; dim, spacedim &gt;::partitioner</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Partitioner used in <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a32dee27541d4a63c275046f6e4bdec3b">copy_triangulation()</a>. </p>

<p class="definition">Definition at line <a class="el" href="fully__distributed__tria_8h_source.html#l00291">291</a> of file <a class="el" href="fully__distributed__tria_8h_source.html">fully_distributed_tria.h</a>.</p>

</div>
</div>
<a id="ac66125a8ea0570cec3b332797a703d03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac66125a8ea0570cec3b332797a703d03">&#9670;&nbsp;</a></span>coarse_cell_id_to_coarse_cell_index_vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;<a class="el" href="namespacetypes.html#a36be5a74b99dd3f4ab38a2c183250adf">types::coarse_cell_id</a>, unsigned int&gt; &gt; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">parallel::fullydistributed::Triangulation</a>&lt; dim, spacedim &gt;::coarse_cell_id_to_coarse_cell_index_vector</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sorted list of pairs of coarse-cell ids and their indices. </p>

<p class="definition">Definition at line <a class="el" href="fully__distributed__tria_8h_source.html#l00297">297</a> of file <a class="el" href="fully__distributed__tria_8h_source.html">fully_distributed_tria.h</a>.</p>

</div>
</div>
<a id="a27144bf4d79680c0bfea6dbb77299f9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27144bf4d79680c0bfea6dbb77299f9c">&#9670;&nbsp;</a></span>coarse_cell_index_to_coarse_cell_id_vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespacetypes.html#a36be5a74b99dd3f4ab38a2c183250adf">types::coarse_cell_id</a>&gt; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">parallel::fullydistributed::Triangulation</a>&lt; dim, spacedim &gt;::coarse_cell_index_to_coarse_cell_id_vector</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List of the coarse-cell id for each coarse cell (stored at cell-&gt;index()). </p>

<p class="definition">Definition at line <a class="el" href="fully__distributed__tria_8h_source.html#l00304">304</a> of file <a class="el" href="fully__distributed__tria_8h_source.html">fully_distributed_tria.h</a>.</p>

</div>
</div>
<a id="a1af45e31ed66443fb0f65dad97bf76d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1af45e31ed66443fb0f65dad97bf76d6">&#9670;&nbsp;</a></span>currently_processing_create_triangulation_for_internal_usage</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">parallel::fullydistributed::Triangulation</a>&lt; dim, spacedim &gt;::currently_processing_create_triangulation_for_internal_usage</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Boolean indicating that the function <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#ae09eb5f25fd81eca041851bd8eedec15">create_triangulation()</a> was called for internal usage. </p>

<p class="definition">Definition at line <a class="el" href="fully__distributed__tria_8h_source.html#l00310">310</a> of file <a class="el" href="fully__distributed__tria_8h_source.html">fully_distributed_tria.h</a>.</p>

</div>
</div>
<a id="a2bd1c9074f1c12ed5f8f3c042d8807dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd1c9074f1c12ed5f8f3c042d8807dc">&#9670;&nbsp;</a></span>currently_processing_prepare_coarsening_and_refinement_for_internal_usage</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">parallel::fullydistributed::Triangulation</a>&lt; dim, spacedim &gt;::currently_processing_prepare_coarsening_and_refinement_for_internal_usage</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Boolean indicating that the function <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a913467a6ed90032116a4c1f0ba4416f4">prepare_coarsening_and_refinement()</a> was called for internal usage. </p>

<p class="definition">Definition at line <a class="el" href="fully__distributed__tria_8h_source.html#l00317">317</a> of file <a class="el" href="fully__distributed__tria_8h_source.html">fully_distributed_tria.h</a>.</p>

</div>
</div>
<a id="a891e1057149129681a27bab8ffc10d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a891e1057149129681a27bab8ffc10d19">&#9670;&nbsp;</a></span>local_cell_relations</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ae36be1617767da4972eb996d9325902f">cell_relation_t</a>&gt; <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::local_cell_relations</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classVector.html">Vector</a> of pairs, each containing a deal.II cell iterator and its respective CellStatus. To update its contents, use the <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a77b7d4e89daa45162ec29305483a0234">update_cell_relations()</a> member function. </p>

<p class="definition">Definition at line <a class="el" href="tria__base_8h_source.html#l00715">715</a> of file <a class="el" href="tria__base_8h_source.html">tria_base.h</a>.</p>

</div>
</div>
<a id="a5979f543c847e88743216cb5986f7107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5979f543c847e88743216cb5986f7107">&#9670;&nbsp;</a></span>cell_attached_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CellAttachedData <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::cell_attached_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tria__base_8h_source.html#l00748">748</a> of file <a class="el" href="tria__base_8h_source.html">tria_base.h</a>.</p>

</div>
</div>
<a id="afd423107278fb82665a4a64f0a6da6d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd423107278fb82665a4a64f0a6da6d2">&#9670;&nbsp;</a></span>data_transfer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DataTransfer <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::data_transfer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tria__base_8h_source.html#l00903">903</a> of file <a class="el" href="tria__base_8h_source.html">tria_base.h</a>.</p>

</div>
</div>
<a id="a55959d63f6a4e18cae86f005df8605ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55959d63f6a4e18cae86f005df8605ec">&#9670;&nbsp;</a></span>mpi_communicator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const MPI_Comm <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::mpi_communicator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>MPI communicator to be used for the triangulation. We create a unique communicator for this class, which is a duplicate of the one passed to the constructor. </p>

<p class="definition">Definition at line <a class="el" href="tria__base_8h_source.html#l00310">310</a> of file <a class="el" href="tria__base_8h_source.html">tria_base.h</a>.</p>

</div>
</div>
<a id="addf7a809217fa1eb11b8c06c49b1b2cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addf7a809217fa1eb11b8c06c49b1b2cb">&#9670;&nbsp;</a></span>my_subdomain</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::my_subdomain</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The subdomain id to be used for the current processor. This is the MPI rank. </p>

<p class="definition">Definition at line <a class="el" href="tria__base_8h_source.html#l00316">316</a> of file <a class="el" href="tria__base_8h_source.html">tria_base.h</a>.</p>

</div>
</div>
<a id="a25846dd7a465319119e91f44d77ae0b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25846dd7a465319119e91f44d77ae0b1">&#9670;&nbsp;</a></span>n_subdomains</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::n_subdomains</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The total number of subdomains (or the size of the MPI communicator). </p>

<p class="definition">Definition at line <a class="el" href="tria__base_8h_source.html#l00321">321</a> of file <a class="el" href="tria__base_8h_source.html">tria_base.h</a>.</p>

</div>
</div>
<a id="aad29d4b50a16239861deb2bb07bc6089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad29d4b50a16239861deb2bb07bc6089">&#9670;&nbsp;</a></span>number_cache</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NumberCache <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::number_cache</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tria__base_8h_source.html#l00370">370</a> of file <a class="el" href="tria__base_8h_source.html">tria_base.h</a>.</p>

</div>
</div>
<a id="aefd8ddbf96799abebb6c05dced569329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefd8ddbf96799abebb6c05dced569329">&#9670;&nbsp;</a></span>dimension</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::dimension</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make the dimension available in function templates. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l01548">1548</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a3414a986e63a95d54e961b9b35d756fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3414a986e63a95d54e961b9b35d756fb">&#9670;&nbsp;</a></span>space_dimension</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::space_dimension</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make the space-dimension available in function templates. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l01553">1553</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="ad136f601f63a6d1bd8e205edd93cbae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad136f601f63a6d1bd8e205edd93cbae3">&#9670;&nbsp;</a></span>signals</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Signals <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::signals</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Signals for the various actions that a triangulation can do to itself. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l02295">2295</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="ac9474a14d0e8429412c82450013bde67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9474a14d0e8429412c82450013bde67">&#9670;&nbsp;</a></span>smooth_grid</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a> <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::smooth_grid</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Do some smoothing in the process of refining the triangulation. See the general doc of this class for more information about this. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03525">3525</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a5f47aa64420502db8ebeffd531572779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f47aa64420502db8ebeffd531572779">&#9670;&nbsp;</a></span>reference_cells</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classReferenceCell.html">ReferenceCell</a>&gt; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::reference_cells</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classVector.html">Vector</a> caching all reference-cell types of the given triangulation (also in the distributed case). </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03531">3531</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="acae2fa4c23a286d83b8d947a714bba40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae2fa4c23a286d83b8d947a714bba40">&#9670;&nbsp;</a></span>policy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; ::<a class="el" href="classinternal_1_1TriangulationImplementation_1_1Policy.html">internal::TriangulationImplementation::Policy</a>&lt;dim, spacedim&gt; &gt; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::policy</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Policy with the Triangulation-specific tasks related to creation, refinement, and coarsening. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03583">3583</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a93d8df10255e3616c7380a31de4c90a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d8df10255e3616c7380a31de4c90a3">&#9670;&nbsp;</a></span>periodic_face_pairs_level_0</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structGridTools_1_1PeriodicFacePair.html">GridTools::PeriodicFacePair</a>&lt;<a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a04043b4c8031c526783448969d01cf53">cell_iterator</a>&gt; &gt; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::periodic_face_pairs_level_0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If <a class="el" href="classTriangulation.html#a7117ea716b516ef11a205a5d0020fe40">add_periodicity()</a> is called, this variable stores the given periodic face pairs on level 0 for later access during the identification of ghost cells for the multigrid hierarchy and for setting up the periodic_face_map. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03592">3592</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a371da19ac0c451181b22f371e83a91a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a371da19ac0c451181b22f371e83a91a6">&#9670;&nbsp;</a></span>periodic_face_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::pair&lt;<a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a04043b4c8031c526783448969d01cf53">cell_iterator</a>, unsigned int&gt;, std::pair&lt;std::pair&lt;<a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a04043b4c8031c526783448969d01cf53">cell_iterator</a>, unsigned int&gt;, std::bitset&lt;3&gt; &gt; &gt; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::periodic_face_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If <a class="el" href="classTriangulation.html#a7117ea716b516ef11a205a5d0020fe40">add_periodicity()</a> is called, this variable stores the active periodic face pairs. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03600">3600</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="ae8e877e2e60025d306a75bb58e7ad68e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8e877e2e60025d306a75bb58e7ad68e">&#9670;&nbsp;</a></span>levels</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::unique_ptr&lt;::<a class="el" href="classinternal_1_1TriangulationImplementation_1_1TriaLevel.html">internal::TriangulationImplementation::TriaLevel</a>&gt; &gt; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::levels</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Array of pointers pointing to the objects storing the cell data on the different levels. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03972">3972</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a706b242073a65dd1e4fe15c58d272671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a706b242073a65dd1e4fe15c58d272671">&#9670;&nbsp;</a></span>faces</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;::<a class="el" href="classinternal_1_1TriangulationImplementation_1_1TriaFaces.html">internal::TriangulationImplementation::TriaFaces</a>&gt; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::faces</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the faces of the triangulation. In 1d this contains nothing, in 2D it contains data concerning lines and in 3D quads and lines. All of these have no level and are therefore treated separately. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03980">3980</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a51469854babb27752dc9f26ed9d5ee30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51469854babb27752dc9f26ed9d5ee30">&#9670;&nbsp;</a></span>vertices</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; &gt; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::vertices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Array of the vertices of this triangulation. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03986">3986</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a12d0610e5c578ced9903db01a70f466f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12d0610e5c578ced9903db01a70f466f">&#9670;&nbsp;</a></span>vertices_used</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classbool.html">bool</a>&gt; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::vertices_used</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Array storing a bit-pattern which vertices are used. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03991">3991</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="abbf716af5de623e392f8a9f61cc313f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf716af5de623e392f8a9f61cc313f5">&#9670;&nbsp;</a></span>manifold</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>, std::unique_ptr&lt;const <a class="el" href="classManifold.html">Manifold</a>&lt;dim, spacedim&gt; &gt; &gt; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::manifold</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Collection of manifold objects. We store only objects, which are not of type <a class="el" href="classFlatManifold.html">FlatManifold</a>. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03998">3998</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a12dc6feb50966969856aa359f6fa316a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12dc6feb50966969856aa359f6fa316a">&#9670;&nbsp;</a></span>anisotropic_refinement</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::anisotropic_refinement</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flag indicating whether anisotropic refinement took place. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l04003">4003</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a5c55287cc4c709190b521fd98a4f5e02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c55287cc4c709190b521fd98a4f5e02">&#9670;&nbsp;</a></span>check_for_distorted_cells</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbool.html">bool</a> <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::check_for_distorted_cells</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A flag that determines whether we are to check for distorted cells upon creation and refinement of a mesh. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l04010">4010</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a5d3c27fe127e4b1d7de6bc67bb1eae97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d3c27fe127e4b1d7de6bc67bb1eae97">&#9670;&nbsp;</a></span>vertex_to_boundary_id_map_1d</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;std::map&lt;unsigned int, <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&gt; &gt; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::vertex_to_boundary_id_map_1d</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A map that relates the number of a boundary vertex to the boundary indicator. This field is only used in 1d. We have this field because we store boundary indicator information with faces in 2d and higher where we have space in the structures that store data for faces, but in 1d there is no such space for faces.</p>
<p>The field is declared as a pointer for a rather mundane reason: all other fields of this class that can be modified by the <a class="el" href="classTriaAccessor.html">TriaAccessor</a> hierarchy are pointers, and so these accessor classes store a const pointer to the triangulation. We could no longer do so for <a class="el" href="classTriaAccessor_3_010_00_011_00_01spacedim_01_4.html">TriaAccessor&lt;0,1,spacedim&gt;</a> if this field (that can be modified by <a class="el" href="classTriaAccessor.html#a654de9ccd776b524a27cd64bded48e14">TriaAccessor::set_boundary_id</a>) were not a pointer. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l04038">4038</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a1c156f5743dad8cd571f0c63ce0b39e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c156f5743dad8cd571f0c63ce0b39e6">&#9670;&nbsp;</a></span>vertex_to_manifold_id_map_1d</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;std::map&lt;unsigned int, <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>&gt; &gt; <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::vertex_to_manifold_id_map_1d</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A map that relates the number of a boundary vertex to the manifold indicator. This field is only used in 1d. We have this field because we store manifold indicator information with faces in 2d and higher where we have space in the structures that store data for faces, but in 1d there is no such space for faces.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classManifold.html">Manifold</a> objects are pretty useless for points since they are neither refined nor are their interiors mapped. We nevertheless allow storing manifold ids for points to be consistent in dimension-independent programs.</dd></dl>
<p>The field is declared as a pointer for a rather mundane reason: all other fields of this class that can be modified by the <a class="el" href="classTriaAccessor.html">TriaAccessor</a> hierarchy are pointers, and so these accessor classes store a const pointer to the triangulation. We could no longer do so for <a class="el" href="classTriaAccessor_3_010_00_011_00_01spacedim_01_4.html">TriaAccessor&lt;0,1,spacedim&gt;</a> if this field (that can be modified by <a class="el" href="group__manifold.html#gafbeb21da36433dc2ec117b9694ca2557">TriaAccessor::set_manifold_id</a>) were not a pointer. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l04061">4061</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/distributed/<a class="el" href="fully__distributed__tria_8h_source.html">fully_distributed_tria.h</a></li>
<li>source/distributed/<a class="el" href="fully__distributed__tria_8cc_source.html">fully_distributed_tria.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
