<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classSolverBase.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: SolverBase&lt; VectorType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.3.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.3.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classSolverBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SolverBase&lt; VectorType &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__Solvers.html">Linear solver classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="solver_8h_source.html">deal.II/lac/solver.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SolverBase&lt; VectorType &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classSolverBase__inherit__graph.svg" width="1279" height="959"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSolverBase_1_1StateCombiner.html">StateCombiner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abe117f08879bcffbbcd348c4bb547b9b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolverBase.html#abe117f08879bcffbbcd348c4bb547b9b">vector_type</a> = VectorType</td></tr>
<tr class="separator:abe117f08879bcffbbcd348c4bb547b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4a143bf73d81bbeca24fae7cabfb4681"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolverBase.html#a4a143bf73d81bbeca24fae7cabfb4681">SolverBase</a> (<a class="el" href="classSolverControl.html">SolverControl</a> &amp;solver_control, <a class="el" href="classVectorMemory.html">VectorMemory</a>&lt; VectorType &gt; &amp;vector_memory)</td></tr>
<tr class="separator:a4a143bf73d81bbeca24fae7cabfb4681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4d18a7f1c760114f85dd246de8379d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolverBase.html#afb4d18a7f1c760114f85dd246de8379d">SolverBase</a> (<a class="el" href="classSolverControl.html">SolverControl</a> &amp;solver_control)</td></tr>
<tr class="separator:afb4d18a7f1c760114f85dd246de8379d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9721e9769d3ee8b603a1622f33fe8a"><td class="memItemLeft" align="right" valign="top">boost::signals2::connection&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolverBase.html#a9f9721e9769d3ee8b603a1622f33fe8a">connect</a> (const std::function&lt; <a class="el" href="classSolverControl.html#afcdeab4b55513dbd766b56e35efecbaa">SolverControl::State</a>(const unsigned int iteration, const <a class="el" href="classdouble.html">double</a> check_value, const VectorType &amp;current_iterate)&gt; &amp;slot)</td></tr>
<tr class="separator:a9f9721e9769d3ee8b603a1622f33fe8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:acc03248bb340e9204a2429aa78dd3218"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGrowingVectorMemory.html">GrowingVectorMemory</a>&lt; VectorType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolverBase.html#acc03248bb340e9204a2429aa78dd3218">static_vector_memory</a></td></tr>
<tr class="separator:acc03248bb340e9204a2429aa78dd3218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb6cb40edde189c1a8efe4e7815ef86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVectorMemory.html">VectorMemory</a>&lt; VectorType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolverBase.html#acdb6cb40edde189c1a8efe4e7815ef86">memory</a></td></tr>
<tr class="separator:acdb6cb40edde189c1a8efe4e7815ef86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62a92a9cbd7c3003fe5ffb3e4fe06c7"><td class="memItemLeft" align="right" valign="top">boost::signals2::signal&lt; <a class="el" href="classSolverControl.html#afcdeab4b55513dbd766b56e35efecbaa">SolverControl::State</a>(const unsigned int iteration, const <a class="el" href="classdouble.html">double</a> check_value, const VectorType &amp;current_iterate), <a class="el" href="structSolverBase_1_1StateCombiner.html">StateCombiner</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolverBase.html#ab62a92a9cbd7c3003fe5ffb3e4fe06c7">iteration_status</a></td></tr>
<tr class="separator:ab62a92a9cbd7c3003fe5ffb3e4fe06c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Subscriptor functionality</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp8d6bc922eebec0b76272099aee4a220d"></a>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</td></tr>
<tr class="memitem:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned int version)</td></tr>
<tr class="separator:ga68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaeb9ac67567aa7d837f25debd33cd4ce5">map_value_type</a> = decltype(<a class="el" href="group__Exceptions.html#ga73f9f8936b61e6e17ab2a82e9516e95b">counter_map</a>)::value_type</td></tr>
<tr class="separator:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacebdc2d11f8522e4d9e8b7d73ac3f491">map_iterator</a> = decltype(<a class="el" href="group__Exceptions.html#ga73f9f8936b61e6e17ab2a82e9516e95b">counter_map</a>)::iterator</td></tr>
<tr class="separator:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20658b60d6ef2d530fafa076efa9f503"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga20658b60d6ef2d530fafa076efa9f503">counter</a></td></tr>
<tr class="separator:ga20658b60d6ef2d530fafa076efa9f503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73f9f8936b61e6e17ab2a82e9516e95b"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga73f9f8936b61e6e17ab2a82e9516e95b">counter_map</a></td></tr>
<tr class="separator:ga73f9f8936b61e6e17ab2a82e9516e95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga094d5932c6c004c2a2b1b966950fb2f7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga094d5932c6c004c2a2b1b966950fb2f7">validity_pointers</a></td></tr>
<tr class="separator:ga094d5932c6c004c2a2b1b966950fb2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44e13f7984b31af8d7c54921175a75ff"><td class="memItemLeft" align="right" valign="top">const std::type_info *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga44e13f7984b31af8d7c54921175a75ff">object_info</a></td></tr>
<tr class="separator:ga44e13f7984b31af8d7c54921175a75ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e0d86893427a935e46d5bd6dcbc3f78"><td class="memItemLeft" align="right" valign="top">static std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7e0d86893427a935e46d5bd6dcbc3f78">mutex</a></td></tr>
<tr class="separator:ga7e0d86893427a935e46d5bd6dcbc3f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (int arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga300c593ea0f9422dcbce1445903e6c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga300c593ea0f9422dcbce1445903e6c12">check_no_subscribers</a> () const noexcept</td></tr>
<tr class="separator:ga300c593ea0f9422dcbce1445903e6c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class VectorType = Vector&lt;double&gt;&gt;<br />
class SolverBase&lt; VectorType &gt;</h3>

<p>A base class for iterative linear solvers. This class provides interfaces to a memory pool and the objects that determine whether a solver has converged.</p>
<h3>Requirements common to derived solver classes</h3>
<p>In general, iterative solvers do not rely on any special structure of matrices or the format of storage. Rather, they only require that matrices and vectors define certain operations such as matrix-vector products, or scalar products between vectors. Consequently, this class as well as the derived classes and their member functions implementing concrete linear solvers are templated on the types of matrices and vectors. However, there are some common requirements a matrix or vector type must fulfill to qualify as an acceptable type for the solvers in this hierarchy. These requirements are listed below.</p>
<p>The classes we show below are not any concrete class. Rather, they are intended to form a "signature" which a concrete class has to conform to. Note that the matrix and vector classes within this library of course conform to this interface; therefore, <a class="el" href="classSparseMatrix.html">SparseMatrix</a> and <a class="el" href="classVector.html">Vector</a> are good examples for these classes as they provide the necessary signatures of member functions (although they also provide many more interfaces that solvers do not in fact need &ndash; for example, element access). In addition, you may want to take a look at <a class="el" href="step_20.html">step-20</a>, <a class="el" href="step_22.html">step-22</a>, or a number of classes in the LinearSolvers namespace for examples of how one can define matrix-like classes that can serve as linear operators for linear solvers.</p>
<p>Concretely, matrix and vector classes that can be passed to a linear solver need to provide the following interfaces: </p><div class="fragment"><div class="line"><span class="keyword">class </span>Matrix</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Application of matrix to vector src. Write result into dst.</span></div>
<div class="line">    <span class="keywordtype">void</span> vmult (VectorType       &amp;dst,</div>
<div class="line">                <span class="keyword">const</span> VectorType &amp;src) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Application of transpose to a vector. This function is,</span></div>
<div class="line">    <span class="comment">// however, only used by some iterative methods.</span></div>
<div class="line">    <span class="keywordtype">void</span> Tvmult (VectorType       &amp;dst,</div>
<div class="line">                 <span class="keyword">const</span> VectorType &amp;src) <span class="keyword">const</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span><a class="code" href="classVector.html">Vector</a></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Define value type of the entries</span></div>
<div class="line">    <span class="keyword">using</span> value_type = <a class="code" href="classdouble.html">double</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Resize the current object to have the same size and layout as</span></div>
<div class="line">    <span class="comment">// the model_vector argument provided. The second argument</span></div>
<div class="line">    <span class="comment">// indicates whether to clear the current object after resizing.</span></div>
<div class="line">    <span class="comment">// The second argument must have a default value equal to false.</span></div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit</a> (<span class="keyword">const</span> <a class="code" href="classVector.html">Vector</a> &amp;model_vector,</div>
<div class="line">                 <span class="keyword">const</span> <span class="keywordtype">bool</span>  leave_elements_uninitialized = <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Inner product between the current object and the argument.</span></div>
<div class="line">    <span class="keywordtype">double</span> <a class="code" href="complex__overloads_8h.html#a285c79b547d28de482e34d02cee71bb2">operator * </a>(<span class="keyword">const</span> <a class="code" href="classVector.html">Vector</a> &amp;v) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Set all the vector entries to a constant scalar.</span></div>
<div class="line">    <a class="code" href="classVector.html">Vector</a> &amp; <a class="code" href="classSubscriptor.html#a5099175b75089cdc5cf4e7e64829f739">operator = </a>(<span class="keyword">const</span> <span class="keywordtype">double</span> a);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Deep copy of the vector.</span></div>
<div class="line">    <span class="comment">// Important if Vector contains pointers to data to duplicate data.</span></div>
<div class="line">    <a class="code" href="classVector.html">Vector</a> &amp; <a class="code" href="classSubscriptor.html#a5099175b75089cdc5cf4e7e64829f739">operator = </a>(<span class="keyword">const</span> <a class="code" href="classVector.html">Vector</a> &amp;x);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Addition of vectors</span></div>
<div class="line">    <span class="keywordtype">void</span> add (<span class="keyword">const</span> <a class="code" href="classVector.html">Vector</a> &amp;x);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Scaled addition of vectors</span></div>
<div class="line">    <span class="keywordtype">void</span> add (<span class="keyword">const</span> <span class="keywordtype">double</span>  a,</div>
<div class="line">              <span class="keyword">const</span> <a class="code" href="classVector.html">Vector</a> &amp;x);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Scaled addition of vectors</span></div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="group__CUDAWrappers.html#gadd2ad651a84773cd69851f66dea04831">sadd</a> (<span class="keyword">const</span> <span class="keywordtype">double</span>  a,</div>
<div class="line">               <span class="keyword">const</span> <span class="keywordtype">double</span>  <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#ae880749870e5b45fbb6a441fd96c1a07">b</a>,</div>
<div class="line">               <span class="keyword">const</span> <a class="code" href="classVector.html">Vector</a> &amp;x);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Scaled assignment of a vector</span></div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="group__CUDAWrappers.html#ga3cd8b561b058955d0c2b3115570ca1c5">equ</a> (<span class="keyword">const</span> <span class="keywordtype">double</span>  a,</div>
<div class="line">              <span class="keyword">const</span> <a class="code" href="classVector.html">Vector</a> &amp;x);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Combined scaled addition of vector x into the current object and</span></div>
<div class="line">    <span class="comment">// subsequent inner product of the current object with v.</span></div>
<div class="line">    <span class="keywordtype">double</span> <a class="code" href="group__CUDAWrappers.html#ga6cb0dd94d13594d1ba8b90a1b31f38d0">add_and_dot</a> (<span class="keyword">const</span> <span class="keywordtype">double</span>  a,</div>
<div class="line">                        <span class="keyword">const</span> <a class="code" href="classVector.html">Vector</a> &amp;x,</div>
<div class="line">                        <span class="keyword">const</span> <a class="code" href="classVector.html">Vector</a> &amp;v);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Multiply the elements of the current object by a fixed value.</span></div>
<div class="line">    <a class="code" href="classVector.html">Vector</a> &amp; operator *= (<span class="keyword">const</span> <span class="keywordtype">double</span> a);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Return the l2 norm of the vector.</span></div>
<div class="line">    <span class="keywordtype">double</span> <a class="code" href="namespaceAdaptationStrategies_1_1Refinement.html#a629b528b2c9777d26eb9048d50d6c13a">l2_norm</a> () <span class="keyword">const</span>;</div>
<div class="line">};</div>
<div class="ttc" id="aclassSubscriptor_html_a5099175b75089cdc5cf4e7e64829f739"><div class="ttname"><a href="classSubscriptor.html#a5099175b75089cdc5cf4e7e64829f739">Subscriptor::operator=</a></div><div class="ttdeci">Subscriptor &amp; operator=(const Subscriptor &amp;)</div><div class="ttdef"><b>Definition:</b> <a href="subscriptor_8h_source.html#l00292">subscriptor.h:292</a></div></div>
<div class="ttc" id="aclassVector_html"><div class="ttname"><a href="classVector.html">Vector</a></div><div class="ttdef"><b>Definition:</b> <a href="vector_8h_source.html#l00109">vector.h:110</a></div></div>
<div class="ttc" id="aclassdouble_html"><div class="ttname"><a href="classdouble.html">double</a></div></div>
<div class="ttc" id="acomplex__overloads_8h_html_a285c79b547d28de482e34d02cee71bb2"><div class="ttname"><a href="complex__overloads_8h.html#a285c79b547d28de482e34d02cee71bb2">operator*</a></div><div class="ttdeci">std::enable_if&lt; std::is_floating_point&lt; T &gt;::value &amp;&amp;std::is_floating_point&lt; U &gt;::value, typename ProductType&lt; std::complex&lt; T &gt;, std::complex&lt; U &gt; &gt;::type &gt;::type operator*(const std::complex&lt; T &gt; &amp;left, const std::complex&lt; U &gt; &amp;right)</div><div class="ttdef"><b>Definition:</b> <a href="complex__overloads_8h_source.html#l00043">complex_overloads.h:43</a></div></div>
<div class="ttc" id="agroup__CUDAWrappers_html_ga3cd8b561b058955d0c2b3115570ca1c5"><div class="ttname"><a href="group__CUDAWrappers.html#ga3cd8b561b058955d0c2b3115570ca1c5">LinearAlgebra::CUDAWrappers::kernel::equ</a></div><div class="ttdeci">__global__ void equ(Number *val, const Number a, const Number *V_val, const size_type N)</div></div>
<div class="ttc" id="agroup__CUDAWrappers_html_ga6cb0dd94d13594d1ba8b90a1b31f38d0"><div class="ttname"><a href="group__CUDAWrappers.html#ga6cb0dd94d13594d1ba8b90a1b31f38d0">LinearAlgebra::CUDAWrappers::kernel::add_and_dot</a></div><div class="ttdeci">__global__ void add_and_dot(Number *res, Number *v1, const Number *v2, const Number *v3, const Number a, const size_type N)</div></div>
<div class="ttc" id="agroup__CUDAWrappers_html_gadd2ad651a84773cd69851f66dea04831"><div class="ttname"><a href="group__CUDAWrappers.html#gadd2ad651a84773cd69851f66dea04831">LinearAlgebra::CUDAWrappers::kernel::sadd</a></div><div class="ttdeci">__global__ void sadd(const Number s, Number *val, const Number a, const Number *V_val, const size_type N)</div></div>
<div class="ttc" id="anamespaceAdaptationStrategies_1_1Refinement_html_a629b528b2c9777d26eb9048d50d6c13a"><div class="ttname"><a href="namespaceAdaptationStrategies_1_1Refinement.html#a629b528b2c9777d26eb9048d50d6c13a">AdaptationStrategies::Refinement::l2_norm</a></div><div class="ttdeci">std::vector&lt; value_type &gt; l2_norm(const typename ::Triangulation&lt; dim, spacedim &gt;::cell_iterator &amp;parent, const value_type parent_value)</div></div>
<div class="ttc" id="anamespacePhysics_1_1Elasticity_1_1Kinematics_html_ae880749870e5b45fbb6a441fd96c1a07"><div class="ttname"><a href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#ae880749870e5b45fbb6a441fd96c1a07">Physics::Elasticity::Kinematics::b</a></div><div class="ttdeci">SymmetricTensor&lt; 2, dim, Number &gt; b(const Tensor&lt; 2, dim, Number &gt; &amp;F)</div></div>
<div class="ttc" id="anamespaceinternal_html_a38181f4582ff69679bda7d8e31c37291"><div class="ttname"><a href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">internal::reinit</a></div><div class="ttdeci">void reinit(MatrixBlock&lt; MatrixType &gt; &amp;v, const BlockSparsityPattern &amp;p)</div><div class="ttdef"><b>Definition:</b> <a href="matrix__block_8h_source.html#l00618">matrix_block.h:618</a></div></div>
</div><!-- fragment --><p>In addition, for some solvers there has to be a global function <code>swap(VectorType &amp;a, VectorType &amp;b)</code> that exchanges the values of the two vectors.</p>
<p>Finally, the solvers also expect an instantiation of <a class="el" href="classGrowingVectorMemory.html">GrowingVectorMemory</a>&lt;VectorType&gt;. These instantiations are provided by the deal.II library for the built-in vector types, but must be explicitly added for user-provided vector classes. Otherwise, the linker will complain that it cannot find the constructors and destructors of <a class="el" href="classGrowingVectorMemory.html">GrowingVectorMemory</a> that happen in the <code><a class="el" href="classSolverBase.html">SolverBase</a></code> class.</p>
<div class="fragment"><div class="line"><span class="comment">// Definition and implementation of vector class</span></div>
<div class="line"><span class="keyword">class </span>UserVector { ... };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create explicit instantiation for the vector class. If your project</span></div>
<div class="line"><span class="comment">// consists of multiple files, including header files, this instantiation</span></div>
<div class="line"><span class="comment">// must be put in a &lt;code&gt;.cc&lt;/code&gt; file in order to instantiate only</span></div>
<div class="line"><span class="comment">// once.</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector_memory.templates.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> <span class="keyword">class </span><a class="code" href="classVectorMemory.html">VectorMemory&lt;UserVector&gt;</a>;</div>
<div class="line"><span class="keyword">template</span> <span class="keyword">class </span><a class="code" href="classGrowingVectorMemory.html">GrowingVectorMemory&lt;UserVector&gt;</a>;</div>
<div class="ttc" id="aclassGrowingVectorMemory_html"><div class="ttname"><a href="classGrowingVectorMemory.html">GrowingVectorMemory</a></div><div class="ttdef"><b>Definition:</b> <a href="include_2deal_8II_2lac_2vector__memory_8h_source.html#l00313">vector_memory.h:314</a></div></div>
<div class="ttc" id="aclassVectorMemory_html"><div class="ttname"><a href="classVectorMemory.html">VectorMemory</a></div><div class="ttdef"><b>Definition:</b> <a href="include_2deal_8II_2lac_2vector__memory_8h_source.html#l00104">vector_memory.h:105</a></div></div>
</div><!-- fragment --><p>The preconditioners used must have the same interface as matrices, i.e. in particular they have to provide a member function <code>vmult</code> which denotes the application of the preconditioner.</p>
<h3>AdditionalData</h3>
<p>Several solvers need additional data, like the damping parameter <code>omega</code> of the <code><a class="el" href="classSolverRichardson.html">SolverRichardson</a></code> class or the maximum number of temporary vectors of <code><a class="el" href="classSolverGMRES.html">SolverGMRES</a></code>. To have a standardized way of constructing solvers, each solver class has a <code>struct AdditionalData</code> as a member, and constructors of all solver classes take such an argument. Some solvers need no additional data, or may not at the current time. For these solvers the struct <code>AdditionalData</code> is empty and calling the constructor may be done without giving the additional structure as an argument as a default <code>AdditionalData</code> is set by default.</p>
<p>With this, creating a solver looks like one of the following blocks: </p><div class="fragment"><div class="line"><span class="comment">// GMRES with restart every 50 iterations</span></div>
<div class="line"><a class="code" href="classSolverGMRES.html">SolverGMRES</a> solver_gmres (solver_control, vector_memory,</div>
<div class="line">                          <a class="code" href="structSolverGMRES_1_1AdditionalData.html">SolverGMRES::AdditionalData</a>(50));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Richardson with omega=0.8</span></div>
<div class="line"><a class="code" href="classSolverRichardson.html">SolverRichardson</a> solver_richardson (solver_control, vector_memory,</div>
<div class="line">                                    <a class="code" href="structSolverGMRES_1_1AdditionalData.html">SolverGMRES::AdditionalData</a>(0.8));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// CG with default AdditionalData</span></div>
<div class="line"><a class="code" href="classSolverCG.html">SolverCG</a> solver_cg (solver_control, vector_memory);</div>
<div class="ttc" id="aclassSolverCG_html"><div class="ttname"><a href="classSolverCG.html">SolverCG</a></div><div class="ttdef"><b>Definition:</b> <a href="solver__cg_8h_source.html#l00095">solver_cg.h:96</a></div></div>
<div class="ttc" id="aclassSolverGMRES_html"><div class="ttname"><a href="classSolverGMRES.html">SolverGMRES</a></div><div class="ttdef"><b>Definition:</b> <a href="solver__gmres_8h_source.html#l00175">solver_gmres.h:176</a></div></div>
<div class="ttc" id="aclassSolverRichardson_html"><div class="ttname"><a href="classSolverRichardson.html">SolverRichardson</a></div><div class="ttdef"><b>Definition:</b> <a href="solver__richardson_8h_source.html#l00060">solver_richardson.h:61</a></div></div>
<div class="ttc" id="astructSolverGMRES_1_1AdditionalData_html"><div class="ttname"><a href="structSolverGMRES_1_1AdditionalData.html">SolverGMRES::AdditionalData</a></div><div class="ttdef"><b>Definition:</b> <a href="solver__gmres_8h_source.html#l00181">solver_gmres.h:182</a></div></div>
</div><!-- fragment --><p>Using a unified constructor parameter list for all solvers supports the <code><a class="el" href="classSolverSelector.html">SolverSelector</a></code> class; the unified interface enables us to use this class unchanged even if the number of types of parameters to a certain solver changes and it is still possible in a simple way to give these additional data to the <code><a class="el" href="classSolverSelector.html">SolverSelector</a></code> object for each solver which it may use.</p>
<h3>Observing the progress of linear solver iterations</h3>
<p>The <a class="el" href="classSolverBase.html">SolverBase</a> class, being the base class for all of the iterative solvers such as <a class="el" href="classSolverCG.html">SolverCG</a>, <a class="el" href="classSolverGMRES.html">SolverGMRES</a>, etc, provides the facilities by which actual solver implementations determine whether the iteration is converged, not yet converged, or has failed. Typically, this is done using an object of type <a class="el" href="classSolverControl.html">SolverControl</a> that is passed to the solver classes's constructors and from them down to the constructor of this base class. Every one of the tutorial programs that solves a linear problem (starting with <a class="el" href="step_3.html">step-3</a>) uses this method and it is described in detail there. However, the underlying mechanism is more general and allows for many other uses to observe how the linear solver iterations progress.</p>
<p>The basic approach is that the iterative solvers invoke a <em>signal</em> at the end of each iteration to determine whether the solution is converged. A signal is a class that has, conceptually, a list of pointers to functions and every time the signal is invoked, each of these functions are called. In the language of signals, the functions called are called <em>slots</em> and one can attach any number of slots to a signal. (The implementation of signals and slots we use here is the one from the BOOST.signals2 library.) A number of details may clarify what is happening underneath:</p><ul>
<li>In reality, the signal object does not store pointers to functions, but function objects as slots. Each slot must conform to a particular signature: here, it is an object that can be called with three arguments (the number of the current linear iteration, the current residual, and the current iterate; more specifics are discussed in the documentation of the <a class="el" href="classSolverBase.html#a9f9721e9769d3ee8b603a1622f33fe8a">connect()</a> function). A pointer to a function with this argument list satisfies the requirements, but you can also pass a member function whose <code>this</code> argument has been bound using a lambda function (see the example below).</li>
<li>Each of the slots will return a value that indicates whether the iteration should continue, should stop because it has succeeded, or stop because it has failed. The return type of slots is therefore of type <a class="el" href="classSolverControl.html#afcdeab4b55513dbd766b56e35efecbaa">SolverControl::State</a>. The returned values from all of the slots will then have to be combined before they are returned to the iterative solver that invoked the signal. The way this works is that if at least one slot returned <a class="el" href="classSolverControl.html#afcdeab4b55513dbd766b56e35efecbaaae98cb11d1886dd019bcc1edf24c98bb2" title="Stop iteration, goal not reached.">SolverControl::failure</a>, then the combined value is <a class="el" href="classSolverControl.html#afcdeab4b55513dbd766b56e35efecbaaae98cb11d1886dd019bcc1edf24c98bb2" title="Stop iteration, goal not reached.">SolverControl::failure</a>; otherwise, if at least one slot returned <a class="el" href="classSolverControl.html#afcdeab4b55513dbd766b56e35efecbaaa0df2bbb86c9c456f02c3d69739be394c" title="Continue iteration.">SolverControl::iterate</a>, then this is going to be the return value of the signal; finally, only if all slots return <a class="el" href="classSolverControl.html#afcdeab4b55513dbd766b56e35efecbaaacd4d23200472d1c9d24e447c8ad04d87" title="Stop iteration, goal reached.">SolverControl::success</a> will the signal's return value be <a class="el" href="classSolverControl.html#afcdeab4b55513dbd766b56e35efecbaaacd4d23200472d1c9d24e447c8ad04d87" title="Stop iteration, goal reached.">SolverControl::success</a>.</li>
<li>It may of course be that a particular slot has been connected to the signal only to observe how the solution or a specific part of it converges, but has no particular opinion on whether the iteration should continue or not. In such cases, the slot should just return <a class="el" href="classSolverControl.html#afcdeab4b55513dbd766b56e35efecbaaacd4d23200472d1c9d24e447c8ad04d87" title="Stop iteration, goal reached.">SolverControl::success</a>, which is the weakest of all return values according to the rules laid out above.</li>
</ul>
<p>Given all this, it should now be obvious how the <a class="el" href="classSolverControl.html">SolverControl</a> object fits into this scheme: when a <a class="el" href="classSolverControl.html">SolverControl</a> object is passed to the constructor of the current class, we simply connect the <a class="el" href="classSolverControl.html#a56fdf4c8d099edaca6fad443d7c76649">SolverControl::check()</a> function of that object as a slot to the signal we maintain here. In other words, since a <a class="el" href="classSolverBase.html">SolverBase</a> object is always constructed using a <a class="el" href="classSolverControl.html">SolverControl</a> object, there is always at least one slot associated with the signal, namely the one that determines convergence.</p>
<p>On the other hand, using the <a class="el" href="classSolverBase.html#a9f9721e9769d3ee8b603a1622f33fe8a">connect()</a> member function, it is possible to connect any number of other slots to the signal to observe whatever it is you want to observe. The <a class="el" href="classSolverBase.html#a9f9721e9769d3ee8b603a1622f33fe8a">connect()</a> function also returns an object that describes the connection from the signal to the slot, and the corresponding BOOST functions then allow you to disconnect the slot if you want.</p>
<p>An example may illuminate these issues. In the <a class="el" href="step_3.html">step-3</a> tutorial program, let us add a member function as follows to the main class: </p><div class="fragment"><div class="line"><a class="code" href="classSolverControl.html#afcdeab4b55513dbd766b56e35efecbaa">SolverControl::State</a></div>
<div class="line">Step3::write_intermediate_solution (</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    iteration,</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>          , <span class="comment">//check_value</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;current_iterate)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;2&gt;</a> data_out;</div>
<div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (dof_handler);</div>
<div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (current_iterate, <span class="stringliteral">&quot;solution&quot;</span>);</div>
<div class="line">  data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a> ();</div>
<div class="line"> </div>
<div class="line">  std::ofstream output (<span class="stringliteral">&quot;solution-&quot;</span></div>
<div class="line">                        + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(iteration,4)</div>
<div class="line">                        + <span class="stringliteral">&quot;.vtu&quot;</span>);</div>
<div class="line">  data_out.<a class="code" href="group__Exceptions.html#ga93c780f93105e0daaa76c6c43694b4ae">write_vtu</a> (output);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="classSolverControl.html#afcdeab4b55513dbd766b56e35efecbaaacd4d23200472d1c9d24e447c8ad04d87">SolverControl::success</a>;</div>
<div class="line">}</div>
<div class="ttc" id="aclassDataOut__DoFData_html_ac1eb26168177faa30ffbcf9cbb9c3cd5"><div class="ttname"><a href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">DataOut_DoFData::attach_dof_handler</a></div><div class="ttdeci">void attach_dof_handler(const DoFHandlerType &amp;)</div></div>
<div class="ttc" id="aclassDataOut__DoFData_html_ace4b76e565ba0701c4d32c26075ed3b9"><div class="ttname"><a href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">DataOut_DoFData::add_data_vector</a></div><div class="ttdeci">void add_data_vector(const VectorType &amp;data, const std::vector&lt; std::string &gt; &amp;names, const DataVectorType type=type_automatic, const std::vector&lt; DataComponentInterpretation::DataComponentInterpretation &gt; &amp;data_component_interpretation=std::vector&lt; DataComponentInterpretation::DataComponentInterpretation &gt;())</div><div class="ttdef"><b>Definition:</b> <a href="data__out__dof__data_8h_source.html#l01087">data_out_dof_data.h:1087</a></div></div>
<div class="ttc" id="aclassDataOut_html"><div class="ttname"><a href="classDataOut.html">DataOut</a></div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__out_8h_source.html#l00147">data_out.h:150</a></div></div>
<div class="ttc" id="aclassDataOut_html_a5eb51872b8736849bb7e8d2007fae086"><div class="ttname"><a href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">DataOut::build_patches</a></div><div class="ttdeci">virtual void build_patches(const unsigned int n_subdivisions=0)</div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__out_8cc_source.html#l01085">data_out.cc:1085</a></div></div>
<div class="ttc" id="aclassSolverControl_html_afcdeab4b55513dbd766b56e35efecbaa"><div class="ttname"><a href="classSolverControl.html#afcdeab4b55513dbd766b56e35efecbaa">SolverControl::State</a></div><div class="ttdeci">State</div><div class="ttdef"><b>Definition:</b> <a href="solver__control_8h_source.html#l00072">solver_control.h:73</a></div></div>
<div class="ttc" id="aclassSolverControl_html_afcdeab4b55513dbd766b56e35efecbaaacd4d23200472d1c9d24e447c8ad04d87"><div class="ttname"><a href="classSolverControl.html#afcdeab4b55513dbd766b56e35efecbaaacd4d23200472d1c9d24e447c8ad04d87">SolverControl::success</a></div><div class="ttdeci">@ success</div><div class="ttdoc">Stop iteration, goal reached.</div><div class="ttdef"><b>Definition:</b> <a href="solver__control_8h_source.html#l00077">solver_control.h:77</a></div></div>
<div class="ttc" id="agroup__Exceptions_html_ga93c780f93105e0daaa76c6c43694b4ae"><div class="ttname"><a href="group__Exceptions.html#ga93c780f93105e0daaa76c6c43694b4ae">DataOutInterface::write_vtu</a></div><div class="ttdeci">void write_vtu(std::ostream &amp;out) const</div><div class="ttdef"><b>Definition:</b> <a href="data__out__base_8cc_source.html#l07188">data_out_base.cc:7188</a></div></div>
<div class="ttc" id="anamespaceUtilities_html_a6195c5f009ea8c7c536c6ffdf108c32f"><div class="ttname"><a href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a></div><div class="ttdeci">std::string int_to_string(const unsigned int value, const unsigned int digits=numbers::invalid_unsigned_int)</div><div class="ttdef"><b>Definition:</b> <a href="base_2utilities_8cc_source.html#l00473">utilities.cc:473</a></div></div>
</div><!-- fragment --><p> The function satisfies the signature necessary to be a slot for the signal discussed above, with the exception that it is a member function and consequently requires a <code>this</code> pointer. What the function does is to take the vector given as last argument and write it into a file in VTU format with a file name derived from the number of the iteration.</p>
<p>This function can then be hooked into the CG solver by modifying the <code>Step3::solve()</code> function as follows: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> Step3::solve ()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>           solver_control (1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12);</div>
<div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a>              solver (solver_control);</div>
<div class="line"> </div>
<div class="line">  solver.connect ([<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iteration,</div>
<div class="line">                         <span class="keyword">const</span> <span class="keywordtype">double</span> check_value,</div>
<div class="line">                         <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> *current_iterate){</div>
<div class="line">                    this-&gt;write_intermediate_solution(</div>
<div class="line">                      iteration, check_value, current_iterate);</div>
<div class="line">                  });</div>
<div class="line">  solver.solve (system_matrix, solution, system_rhs,</div>
<div class="line">                <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div>
<div class="line">}</div>
<div class="ttc" id="aclassPreconditionIdentity_html"><div class="ttname"><a href="classPreconditionIdentity.html">PreconditionIdentity</a></div><div class="ttdef"><b>Definition:</b> <a href="precondition_8h_source.html#l00079">precondition.h:80</a></div></div>
<div class="ttc" id="aclassSolverControl_html"><div class="ttname"><a href="classSolverControl.html">SolverControl</a></div><div class="ttdef"><b>Definition:</b> <a href="solver__control_8h_source.html#l00065">solver_control.h:66</a></div></div>
<div class="ttc" id="anamespacePhysics_1_1Elasticity_1_1Kinematics_html_a9587d5229555daa5b1fa1ba2f8a40adb"><div class="ttname"><a href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">Physics::Elasticity::Kinematics::e</a></div><div class="ttdeci">SymmetricTensor&lt; 2, dim, Number &gt; e(const Tensor&lt; 2, dim, Number &gt; &amp;F)</div></div>
</div><!-- fragment --><p> The use of a lambda function here ensures that we convert the member function with its three arguments plus the <code>this</code> pointer, to a function that only takes three arguments, by fixing the implicit <code>this</code> argument of the function to the <code>this</code> pointer in the current function.</p>
<p>It is well understood that the CG method is a smoothing iteration (in the same way as the more commonly used Jacobi or SSOR iterations are smoothers). The code above therefore allows to observe how the solution becomes smoother and smoother in every iteration. This is best observed by initializing the solution vector with randomly distributed numbers in \([-1,1]\), using code such as </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;solution.size(); ++i)</div>
<div class="line">  solution(i) = 2.*rand()/RAND_MAX-1;</div>
</div><!-- fragment --><p> Using this, the slot will then generate files that when visualized look like this over the course of iterations zero to five: </p><table class="doxtable">
<tr>
<td><div class="image">
<img src="cg-monitor-smoothing-0.png" alt=""/>
</div>
  </td><td><div class="image">
<img src="cg-monitor-smoothing-1.png" alt=""/>
</div>
  </td><td><div class="image">
<img src="cg-monitor-smoothing-2.png" alt=""/>
</div>
   </td></tr>
<tr>
<td><div class="image">
<img src="cg-monitor-smoothing-3.png" alt=""/>
</div>
  </td><td><div class="image">
<img src="cg-monitor-smoothing-4.png" alt=""/>
</div>
  </td><td><div class="image">
<img src="cg-monitor-smoothing-5.png" alt=""/>
</div>
   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="solver_8h_source.html#l00341">341</a> of file <a class="el" href="solver_8h_source.html">solver.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="abe117f08879bcffbbcd348c4bb547b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe117f08879bcffbbcd348c4bb547b9b">&#9670;&nbsp;</a></span>vector_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType  = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classSolverBase.html">SolverBase</a>&lt; VectorType &gt;::<a class="el" href="classSolverBase.html#abe117f08879bcffbbcd348c4bb547b9b">vector_type</a> =  VectorType</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An alias for the underlying vector type </p>

<p class="definition">Definition at line <a class="el" href="solver_8h_source.html#l00347">347</a> of file <a class="el" href="solver_8h_source.html">solver.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4a143bf73d81bbeca24fae7cabfb4681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a143bf73d81bbeca24fae7cabfb4681">&#9670;&nbsp;</a></span>SolverBase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType  = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSolverBase.html">SolverBase</a>&lt; VectorType &gt;::<a class="el" href="classSolverBase.html">SolverBase</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSolverControl.html">SolverControl</a> &amp;&#160;</td>
          <td class="paramname"><em>solver_control</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorMemory.html">VectorMemory</a>&lt; VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Takes a control object which evaluates the conditions for convergence, and an object that allows solvers to allocate memory for temporary objects.</p>
<p>Of both objects, a reference is stored, so it is the user's responsibility to guarantee that the lifetime of the two arguments is at least as long as that of the solver object. </p>

</div>
</div>
<a id="afb4d18a7f1c760114f85dd246de8379d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb4d18a7f1c760114f85dd246de8379d">&#9670;&nbsp;</a></span>SolverBase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType  = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSolverBase.html">SolverBase</a>&lt; VectorType &gt;::<a class="el" href="classSolverBase.html">SolverBase</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSolverControl.html">SolverControl</a> &amp;&#160;</td>
          <td class="paramname"><em>solver_control</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Takes a control object which evaluates the conditions for convergence. In contrast to the other constructor, this constructor designates an internal object of type <a class="el" href="classGrowingVectorMemory.html">GrowingVectorMemory</a> to allocate memory.</p>
<p>A reference to the control object is stored, so it is the user's responsibility to guarantee that the lifetime of the argument is at least as long as that of the solver object. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9f9721e9769d3ee8b603a1622f33fe8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f9721e9769d3ee8b603a1622f33fe8a">&#9670;&nbsp;</a></span>connect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType  = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::connection <a class="el" href="classSolverBase.html">SolverBase</a>&lt; VectorType &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classSolverControl.html#afcdeab4b55513dbd766b56e35efecbaa">SolverControl::State</a>(const unsigned int iteration, const <a class="el" href="classdouble.html">double</a> check_value, const VectorType &amp;current_iterate)&gt; &amp;&#160;</td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connect a function object that will be called periodically within iterative solvers. This function is used to attach monitors to iterative solvers, either to determine when convergence has happened, or simply to observe the progress of an iteration. See the documentation of this class for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A function object specified here will, with each call, receive the number of the current iteration, the value that is used to check for convergence (typically the residual of the current iterate with respect to the linear system to be solved) and the currently best available guess for the current iterate. Note that some solvers do not update the approximate solution in every iteration but only after convergence or failure has been determined (GMRES is an example); in such cases, the vector passed as the last argument to the signal is simply the best approximate at the time the signal is called, but not the vector that will be returned if the signal's return value indicates that the iteration should be terminated. The function object must return a <a class="el" href="classSolverControl.html#afcdeab4b55513dbd766b56e35efecbaa">SolverControl::State</a> value that indicates whether the iteration should continue, has failed, or has succeeded. The results of all connected functions will then be combined to determine what should happen with the iteration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A connection object that represents the connection from the signal to the function object. It can be used to disconnect the function object again from the signal. See the documentation of the BOOST Signals2 library for more information on connection management. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="acc03248bb340e9204a2429aa78dd3218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc03248bb340e9204a2429aa78dd3218">&#9670;&nbsp;</a></span>static_vector_memory</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType  = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGrowingVectorMemory.html">GrowingVectorMemory</a>&lt;VectorType&gt; <a class="el" href="classSolverBase.html">SolverBase</a>&lt; VectorType &gt;::static_vector_memory</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A static vector memory object to be used whenever no such object has been given to the constructor. </p>

<p class="definition">Definition at line <a class="el" href="solver_8h_source.html#l00415">415</a> of file <a class="el" href="solver_8h_source.html">solver.h</a>.</p>

</div>
</div>
<a id="acdb6cb40edde189c1a8efe4e7815ef86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb6cb40edde189c1a8efe4e7815ef86">&#9670;&nbsp;</a></span>memory</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType  = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorMemory.html">VectorMemory</a>&lt;VectorType&gt;&amp; <a class="el" href="classSolverBase.html">SolverBase</a>&lt; VectorType &gt;::memory</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A reference to an object that provides memory for auxiliary vectors. </p>

<p class="definition">Definition at line <a class="el" href="solver_8h_source.html#l00420">420</a> of file <a class="el" href="solver_8h_source.html">solver.h</a>.</p>

</div>
</div>
<a id="ab62a92a9cbd7c3003fe5ffb3e4fe06c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab62a92a9cbd7c3003fe5ffb3e4fe06c7">&#9670;&nbsp;</a></span>iteration_status</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType  = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::signal&lt; <a class="el" href="classSolverControl.html#afcdeab4b55513dbd766b56e35efecbaa">SolverControl::State</a>(const unsigned int iteration, const <a class="el" href="classdouble.html">double</a> check_value, const VectorType &amp; current_iterate), <a class="el" href="structSolverBase_1_1StateCombiner.html">StateCombiner</a>&gt; <a class="el" href="classSolverBase.html">SolverBase</a>&lt; VectorType &gt;::iteration_status</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A signal that iterative solvers can execute at the end of every iteration (or in an otherwise periodic fashion) to find out whether we should continue iterating or not. The signal may call one or more slots that each will make this determination by themselves, and the result over all slots (function calls) will be determined by the <a class="el" href="structSolverBase_1_1StateCombiner.html">StateCombiner</a> object.</p>
<p>The arguments passed to the signal are (i) the number of the current iteration; (ii) the value that is used to determine convergence (oftentimes the residual, but in other cases other quantities may be used as long as they converge to zero as the iterate approaches the solution of the linear system); and (iii) a vector that corresponds to the current best guess for the solution at the point where the signal is called. Note that some solvers do not update the approximate solution in every iteration but only after convergence or failure has been determined (GMRES is an example); in such cases, the vector passed as the last argument to the signal is simply the best approximate at the time the signal is called, but not the vector that will be returned if the signal's return value indicates that the iteration should be terminated. </p>

<p class="definition">Definition at line <a class="el" href="solver_8h_source.html#l00471">471</a> of file <a class="el" href="solver_8h_source.html">solver.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/lac/<a class="el" href="solver_8h_source.html">solver.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
