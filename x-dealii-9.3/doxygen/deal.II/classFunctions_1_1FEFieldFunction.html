<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classFunctions_1_1FEFieldFunction.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Functions::FEFieldFunction&lt; dim, DoFHandlerType, VectorType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.3.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.3.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceFunctions.html">Functions</a></li><li class="navelem"><a class="el" href="classFunctions_1_1FEFieldFunction.html">FEFieldFunction</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classFunctions_1_1FEFieldFunction-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Functions::FEFieldFunction&lt; dim, DoFHandlerType, VectorType &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__functions.html">Functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="fe__field__function_8h_source.html">deal.II/numerics/fe_field_function.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Functions::FEFieldFunction&lt; dim, DoFHandlerType, VectorType &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classFunctions_1_1FEFieldFunction__inherit__graph.svg" width="390" height="471"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a385ed76410d75f5f15304ccebaac220d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a385ed76410d75f5f15304ccebaac220d">time_type</a> = typename <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; VectorType::value_type &gt;::real_type &gt;::<a class="el" href="classFunctionTime.html#a08db01814f31c975752a5ace5515718c">time_type</a></td></tr>
<tr class="separator:a385ed76410d75f5f15304ccebaac220d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6cea91369868d379fbd92beb0d368c99"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a6cea91369868d379fbd92beb0d368c99">FEFieldFunction</a> (const DoFHandlerType &amp;<a class="el" href="classFunctions_1_1FEFieldFunction.html#af8e6d4d5f831501d3b2067694dcc4142">dh</a>, const VectorType &amp;<a class="el" href="classFunctions_1_1FEFieldFunction.html#ac16c620c58be395b9c2a79484667ebd6">data_vector</a>, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;<a class="el" href="classFunctions_1_1FEFieldFunction.html#af1fe1814b55cbea129b17972634a02c4">mapping</a>=<a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt; dim &gt;::<a class="el" href="classFunctions_1_1FEFieldFunction.html#af1fe1814b55cbea129b17972634a02c4">mapping</a>)</td></tr>
<tr class="separator:a6cea91369868d379fbd92beb0d368c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0206a45c90d523792eea8bd725d14788"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a0206a45c90d523792eea8bd725d14788">set_active_cell</a> (const typename DoFHandlerType::active_cell_iterator &amp;newcell)</td></tr>
<tr class="separator:a0206a45c90d523792eea8bd725d14788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d35f2610d0206df87f7288c9e05a43e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a0d35f2610d0206df87f7288c9e05a43e">vector_value</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, <a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;values) const override</td></tr>
<tr class="separator:a0d35f2610d0206df87f7288c9e05a43e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc602fce9e594832f34f687652c5c8e"><td class="memItemLeft" align="right" valign="top">virtual VectorType::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#aebc602fce9e594832f34f687652c5c8e">value</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned int component=0) const override</td></tr>
<tr class="separator:aebc602fce9e594832f34f687652c5c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedce7554c62c46b23f1ea7324ad3c57f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#aedce7554c62c46b23f1ea7324ad3c57f">value_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; typename VectorType::value_type &gt; &amp;values, const unsigned int component=0) const override</td></tr>
<tr class="separator:aedce7554c62c46b23f1ea7324ad3c57f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59a2e4a5bd27b2b6b56c82bd2f924ae"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#af59a2e4a5bd27b2b6b56c82bd2f924ae">vector_value_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt;&gt; &amp;values) const override</td></tr>
<tr class="separator:af59a2e4a5bd27b2b6b56c82bd2f924ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26fbc6dbe05ce5bbd7f1d0651ee0c3f8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a26fbc6dbe05ce5bbd7f1d0651ee0c3f8">vector_gradient</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, typename VectorType::value_type &gt;&gt; &amp;gradients) const override</td></tr>
<tr class="separator:a26fbc6dbe05ce5bbd7f1d0651ee0c3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ecd2b357e099a9e828e51da7cf86a7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, typename VectorType::value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a71ecd2b357e099a9e828e51da7cf86a7">gradient</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned int component=0) const override</td></tr>
<tr class="separator:a71ecd2b357e099a9e828e51da7cf86a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee53c98b2e7f8b308ac8a834c747305"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a9ee53c98b2e7f8b308ac8a834c747305">vector_gradient_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;p, std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, typename VectorType::value_type &gt;&gt;&gt; &amp;gradients) const override</td></tr>
<tr class="separator:a9ee53c98b2e7f8b308ac8a834c747305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a0171b1d056283371bb0a3d75520d0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#aa6a0171b1d056283371bb0a3d75520d0">gradient_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;p, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, typename VectorType::value_type &gt;&gt; &amp;gradients, const unsigned int component=0) const override</td></tr>
<tr class="separator:aa6a0171b1d056283371bb0a3d75520d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e1c8c360549d87c3cbb5ecffe56795"><td class="memItemLeft" align="right" valign="top">virtual VectorType::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a09e1c8c360549d87c3cbb5ecffe56795">laplacian</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned int component=0) const override</td></tr>
<tr class="separator:a09e1c8c360549d87c3cbb5ecffe56795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717128e21bdb96c3a7651178c6266c0f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a717128e21bdb96c3a7651178c6266c0f">vector_laplacian</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, <a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;values) const override</td></tr>
<tr class="separator:a717128e21bdb96c3a7651178c6266c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab345ab75df955b8edf5cc8a58e3a9de4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#ab345ab75df955b8edf5cc8a58e3a9de4">laplacian_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; typename VectorType::value_type &gt; &amp;values, const unsigned int component=0) const override</td></tr>
<tr class="separator:ab345ab75df955b8edf5cc8a58e3a9de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9f3e529440ee0848829301109d12bc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a8b9f3e529440ee0848829301109d12bc">vector_laplacian_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt;&gt; &amp;values) const override</td></tr>
<tr class="separator:a8b9f3e529440ee0848829301109d12bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b170f82e34cc8a12347cd0528071a9"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#ad3b170f82e34cc8a12347cd0528071a9">compute_point_locations</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; typename DoFHandlerType::active_cell_iterator &gt; &amp;cells, std::vector&lt; std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt;&gt; &amp;qpoints, std::vector&lt; std::vector&lt; unsigned int &gt;&gt; &amp;maps) const</td></tr>
<tr class="separator:ad3b170f82e34cc8a12347cd0528071a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b4f548be005a1ffeeca7a450b028d8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#ad1b4f548be005a1ffeeca7a450b028d8">vector_values</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; std::vector&lt; VectorType::value_type &gt;&gt; &amp;values) const</td></tr>
<tr class="separator:ad1b4f548be005a1ffeeca7a450b028d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ddbeb5adda74140a00dfc8db3687b4a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a4ddbeb5adda74140a00dfc8db3687b4a">vector_gradients</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, VectorType::value_type &gt;&gt;&gt; &amp;gradients) const</td></tr>
<tr class="separator:a4ddbeb5adda74140a00dfc8db3687b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa2ec8f2270bdee842413805c4d7442"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, VectorType::value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a8aa2ec8f2270bdee842413805c4d7442">hessian</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned int component=0) const</td></tr>
<tr class="separator:a8aa2ec8f2270bdee842413805c4d7442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94960fba14557566fa5df8745a721939"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a94960fba14557566fa5df8745a721939">vector_hessian</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, VectorType::value_type &gt;&gt; &amp;values) const</td></tr>
<tr class="separator:a94960fba14557566fa5df8745a721939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e69625d9daf07615270d65d97dfebde"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a2e69625d9daf07615270d65d97dfebde">hessian_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, VectorType::value_type &gt;&gt; &amp;values, const unsigned int component=0) const</td></tr>
<tr class="separator:a2e69625d9daf07615270d65d97dfebde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1b732264fb498528453312e24d2f49"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#abc1b732264fb498528453312e24d2f49">vector_hessian_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, VectorType::value_type &gt;&gt;&gt; &amp;values) const</td></tr>
<tr class="separator:abc1b732264fb498528453312e24d2f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e07b63ee34bd7e7ab2492be5213377"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a45e07b63ee34bd7e7ab2492be5213377">memory_consumption</a> () const</td></tr>
<tr class="separator:a45e07b63ee34bd7e7ab2492be5213377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d37ddb04314b38cf67c6cba22923f6"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#ae7d37ddb04314b38cf67c6cba22923f6">get_time</a> () const</td></tr>
<tr class="separator:ae7d37ddb04314b38cf67c6cba22923f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a583fd8f30db3549dbaa43b2592e2bc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#a3a583fd8f30db3549dbaa43b2592e2bc">set_time</a> (const Number new_time)</td></tr>
<tr class="separator:a3a583fd8f30db3549dbaa43b2592e2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb592482f587dc3f0ee6e2267215a772"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#aeb592482f587dc3f0ee6e2267215a772">advance_time</a> (const Number delta_t)</td></tr>
<tr class="separator:aeb592482f587dc3f0ee6e2267215a772"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a7248c7e11dc434fb7d16cdc5e41e3770"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a7248c7e11dc434fb7d16cdc5e41e3770">n_components</a></td></tr>
<tr class="separator:a7248c7e11dc434fb7d16cdc5e41e3770"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ad8063ed9dcbe58753504d9173475befe"><td class="memItemLeft" align="right" valign="top">static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#ad8063ed9dcbe58753504d9173475befe">dimension</a></td></tr>
<tr class="separator:ad8063ed9dcbe58753504d9173475befe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:acd3baa8c298baae043c96dc5a2a81ec2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#acd3baa8c298baae043c96dc5a2a81ec2">cell_hint_t</a> = <a class="el" href="classThreads_1_1ThreadLocalStorage.html">Threads::ThreadLocalStorage</a>&lt; typename DoFHandlerType::active_cell_iterator &gt;</td></tr>
<tr class="separator:acd3baa8c298baae043c96dc5a2a81ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:abb3b315d38de9afa28ab46ca45c51a0e"><td class="memItemLeft" align="right" valign="top">std_cxx17::optional&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#abb3b315d38de9afa28ab46ca45c51a0e">get_reference_coordinates</a> (const typename DoFHandlerType::active_cell_iterator &amp;cell, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;point) const</td></tr>
<tr class="separator:abb3b315d38de9afa28ab46ca45c51a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:af8e6d4d5f831501d3b2067694dcc4142"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const DoFHandlerType, <a class="el" href="classFunctions_1_1FEFieldFunction.html">FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#af8e6d4d5f831501d3b2067694dcc4142">dh</a></td></tr>
<tr class="separator:af8e6d4d5f831501d3b2067694dcc4142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16c620c58be395b9c2a79484667ebd6"><td class="memItemLeft" align="right" valign="top">const VectorType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#ac16c620c58be395b9c2a79484667ebd6">data_vector</a></td></tr>
<tr class="separator:ac16c620c58be395b9c2a79484667ebd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1fe1814b55cbea129b17972634a02c4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#af1fe1814b55cbea129b17972634a02c4">mapping</a></td></tr>
<tr class="separator:af1fe1814b55cbea129b17972634a02c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca85e5eb53c2979fc1c4dabcfecc021c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a>&lt; dim, DoFHandlerType::space_dimension &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#aca85e5eb53c2979fc1c4dabcfecc021c">cache</a></td></tr>
<tr class="separator:aca85e5eb53c2979fc1c4dabcfecc021c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193ac0154cad97a0f1f26fe9640c0904"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFunctions_1_1FEFieldFunction.html#acd3baa8c298baae043c96dc5a2a81ec2">cell_hint_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a193ac0154cad97a0f1f26fe9640c0904">cell_hint</a></td></tr>
<tr class="separator:a193ac0154cad97a0f1f26fe9640c0904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8932e3ec9ed7b6f6d6a91c23f82e36d8"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#a8932e3ec9ed7b6f6d6a91c23f82e36d8">time</a></td></tr>
<tr class="separator:a8932e3ec9ed7b6f6d6a91c23f82e36d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Subscriptor functionality</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp8d6bc922eebec0b76272099aee4a220d"></a>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</td></tr>
<tr class="memitem:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaeb9ac67567aa7d837f25debd33cd4ce5">map_value_type</a> = decltype(<a class="el" href="group__Exceptions.html#ga73f9f8936b61e6e17ab2a82e9516e95b">counter_map</a>)::value_type</td></tr>
<tr class="separator:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacebdc2d11f8522e4d9e8b7d73ac3f491">map_iterator</a> = decltype(<a class="el" href="group__Exceptions.html#ga73f9f8936b61e6e17ab2a82e9516e95b">counter_map</a>)::iterator</td></tr>
<tr class="separator:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20658b60d6ef2d530fafa076efa9f503"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga20658b60d6ef2d530fafa076efa9f503">counter</a></td></tr>
<tr class="separator:ga20658b60d6ef2d530fafa076efa9f503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73f9f8936b61e6e17ab2a82e9516e95b"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga73f9f8936b61e6e17ab2a82e9516e95b">counter_map</a></td></tr>
<tr class="separator:ga73f9f8936b61e6e17ab2a82e9516e95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga094d5932c6c004c2a2b1b966950fb2f7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga094d5932c6c004c2a2b1b966950fb2f7">validity_pointers</a></td></tr>
<tr class="separator:ga094d5932c6c004c2a2b1b966950fb2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44e13f7984b31af8d7c54921175a75ff"><td class="memItemLeft" align="right" valign="top">const std::type_info *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga44e13f7984b31af8d7c54921175a75ff">object_info</a></td></tr>
<tr class="separator:ga44e13f7984b31af8d7c54921175a75ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned int version)</td></tr>
<tr class="separator:ga68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga300c593ea0f9422dcbce1445903e6c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga300c593ea0f9422dcbce1445903e6c12">check_no_subscribers</a> () const noexcept</td></tr>
<tr class="separator:ga300c593ea0f9422dcbce1445903e6c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e0d86893427a935e46d5bd6dcbc3f78"><td class="memItemLeft" align="right" valign="top">static std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7e0d86893427a935e46d5bd6dcbc3f78">mutex</a></td></tr>
<tr class="separator:ga7e0d86893427a935e46d5bd6dcbc3f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (int arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, typename DoFHandlerType = DoFHandler&lt;dim&gt;, typename VectorType = Vector&lt;double&gt;&gt;<br />
class Functions::FEFieldFunction&lt; dim, DoFHandlerType, VectorType &gt;</h3>

<p>This is an interpolation function for the given dof handler and the given solution vector. The points at which this function can be evaluated MUST be inside the domain of the dof handler, but except from this, no other requirement is given. This function is rather slow, as it needs to construct a quadrature object for the point (or set of points) where you want to evaluate your finite element function. In order to do so, it needs to find out where the points lie.</p>
<p>If you know in advance in which cell your points lie, you can accelerate things a bit, by calling <a class="el" href="classFunctions_1_1FEFieldFunction.html#a0206a45c90d523792eea8bd725d14788">set_active_cell()</a> before asking for values or gradients of the function. If you don't do this, and your points don't lie in the cell that is currently stored, the function <a class="el" href="namespaceGridTools.html#a2e10aeb1c8e76110a84b6945eac3aaf0">GridTools::find_active_cell_around_point</a> is called to find out where the point is. You can specify an optional mapping to use when looking for points in the grid. If you don't do so, this function uses a Q1 mapping.</p>
<p>Once the <a class="el" href="classFunctions_1_1FEFieldFunction.html">FEFieldFunction</a> knows where the points lie, it creates a quadrature formula for those points, and calls <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValues::get_function_values</a> or <a class="el" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">FEValues::get_function_gradients</a> with the given quadrature points.</p>
<p>If you only need the quadrature points but not the values of the finite element function (you might want this for the adjoint interpolation), you can also use the function <a class="el" href="classFunctions_1_1FEFieldFunction.html#ad3b170f82e34cc8a12347cd0528071a9">compute_point_locations()</a> alone.</p>
<p>An example of how to use this function is the following:</p>
<div class="fragment"><div class="line"><span class="comment">// Generate two triangulations</span></div>
<div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> tria_1;</div>
<div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> tria_2;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Read the triangulations from files, or build them up, or get them</span></div>
<div class="line"><span class="comment">// from some place. Assume that tria_2 is *entirely* included in tria_1.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Associate a dof handler and a solution to the first triangulation</span></div>
<div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dh1 (tria_1);</div>
<div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution_1;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// On this first domain, set up the various data structures,</span></div>
<div class="line"><span class="comment">// assemble matrices, solve the linear system, and get a Nobel</span></div>
<div class="line"><span class="comment">// prize for the work we have done here:</span></div>
<div class="line">[...]</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Then create a DoFHandler and solution vector for the second domain:</span></div>
<div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dh2 (tria_2);</div>
<div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution_2;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Finally, project the solution on the first domain onto the</span></div>
<div class="line"><span class="comment">// second domain, assuming that this does not require querying</span></div>
<div class="line"><span class="comment">// values from outside the first domain:</span></div>
<div class="line"><a class="code" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction&lt;dim&gt;</a> fe_function_1 (dh_1, solution_1);</div>
<div class="line"><a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a> (dh_2, constraints_2, quad,</div>
<div class="line">                      fe_function_1, solution_2);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Alternatively, we could have also interpolated it:</span></div>
<div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution_3;</div>
<div class="line"><a class="code" href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">VectorTools::interpolate</a> (dh_2, fe_function_1, solution_3);</div>
<div class="ttc" id="aclassDoFHandler_html"><div class="ttname"><a href="classDoFHandler.html">DoFHandler</a></div><div class="ttdef"><b>Definition:</b> <a href="dofs_2dof__handler_8h_source.html#l00314">dof_handler.h:315</a></div></div>
<div class="ttc" id="aclassFunctions_1_1FEFieldFunction_html"><div class="ttname"><a href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a></div><div class="ttdef"><b>Definition:</b> <a href="fe__field__function_8h_source.html#l00169">fe_field_function.h:170</a></div></div>
<div class="ttc" id="aclassTriangulation_html"><div class="ttname"><a href="classTriangulation.html">Triangulation</a></div><div class="ttdef"><b>Definition:</b> <a href="grid_2tria_8h_source.html#l01127">tria.h:1128</a></div></div>
<div class="ttc" id="aclassVector_html"><div class="ttname"><a href="classVector.html">Vector&lt; double &gt;</a></div></div>
<div class="ttc" id="anamespaceVectorTools_html_a761f008bdeb7d94a69205ae824deefad"><div class="ttname"><a href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">VectorTools::interpolate</a></div><div class="ttdeci">void interpolate(const Mapping&lt; dim, spacedim &gt; &amp;mapping, const DoFHandler&lt; dim, spacedim &gt; &amp;dof, const Function&lt; spacedim, typename VectorType::value_type &gt; &amp;function, VectorType &amp;vec, const ComponentMask &amp;component_mask=ComponentMask())</div></div>
<div class="ttc" id="anamespaceVectorTools_html_ac6b404bf03cb2a742b290421cc2789fe"><div class="ttname"><a href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a></div><div class="ttdeci">void project(const Mapping&lt; dim, spacedim &gt; &amp;mapping, const DoFHandler&lt; dim, spacedim &gt; &amp;dof, const AffineConstraints&lt; typename VectorType::value_type &gt; &amp;constraints, const Quadrature&lt; dim &gt; &amp;quadrature, const Function&lt; spacedim, typename VectorType::value_type &gt; &amp;function, VectorType &amp;vec, const bool enforce_zero_boundary=false, const Quadrature&lt; dim - 1 &gt; &amp;q_boundary=(dim &gt; 1 ? QGauss&lt; dim - 1 &gt;(2) :Quadrature&lt; dim - 1 &gt;(0)), const bool project_to_boundary_first=false)</div></div>
</div><!-- fragment --><p>The snippet of code above will work assuming that the second triangulation is entirely included in the first one.</p>
<p><a class="el" href="classFunctions_1_1FEFieldFunction.html">FEFieldFunction</a> is designed to be an easy way to get the results of your computations across different, possibly non matching, grids. No knowledge of the location of the points is assumed in this class, which makes it rely entirely on the <a class="el" href="namespaceGridTools.html#a2e10aeb1c8e76110a84b6945eac3aaf0">GridTools::find_active_cell_around_point</a> utility for its job. However the class can be fed an "educated guess" of where the points that will be computed actually are by using the <a class="el" href="classFunctions_1_1FEFieldFunction.html#a0206a45c90d523792eea8bd725d14788">FEFieldFunction::set_active_cell</a> method, so if you have a smart way to tell where your points are, you will save a lot of computational time by letting this class know.</p>
<h3>Using <a class="el" href="classFunctions_1_1FEFieldFunction.html">FEFieldFunction</a> with <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a></h3>
<p>When using this class with a parallel distributed triangulation object and evaluating the solution at a particular point, not every processor will own the cell at which the solution is evaluated. Rather, it may be that the cell in which this point is found is in fact a ghost or artificial cell (see <a class="el" href="DEALGlossary.html#GlossArtificialCell">GlossArtificialCell</a> and <a class="el" href="DEALGlossary.html#GlossGhostCell">GlossGhostCell</a>). The solution can be evaluated on ghost cells, but for artificial cells we have no access to the solution there and functions that evaluate the solution at such a point will trigger an exception of type <a class="el" href="group__Exceptions.html#ga98f7ffc57c76da1384a852920f756c1e">VectorTools::ExcPointNotAvailableHere</a>.</p>
<p>To deal with this situation, you will want to use code as follows when, for example, evaluating the solution at the origin (here using a parallel <a class="el" href="namespaceTrilinosWrappers.html">TrilinosWrappers</a> vector to hold the solution): </p><div class="fragment"><div class="line"><a class="code" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction&lt;dim,DoFHandler&lt;dim&gt;</a>,<a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>&gt;</div>
<div class="line">  solution_function (dof_handler, solution);</div>
<div class="line"><a class="code" href="classPoint.html">Point&lt;dim&gt;</a> origin = <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>();</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">double</span> solution_at_origin;</div>
<div class="line"><span class="keywordtype">bool</span>   point_found = <span class="keyword">true</span>;</div>
<div class="line"><span class="keywordflow">try</span></div>
<div class="line">  {</div>
<div class="line">    solution_at_origin = solution_function.value (origin);</div>
<div class="line">  }</div>
<div class="line"><span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="group__Exceptions.html#ga98f7ffc57c76da1384a852920f756c1e">VectorTools::ExcPointNotAvailableHere</a> &amp;)</div>
<div class="line">  {</div>
<div class="line">    point_found = <span class="keyword">false</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (point_found == <span class="keyword">true</span>)</div>
<div class="line">  ...do something...;</div>
<div class="ttc" id="aclassPoint_html"><div class="ttname"><a href="classPoint.html">Point</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2point_8h_source.html#l00110">point.h:111</a></div></div>
<div class="ttc" id="aclassTrilinosWrappers_1_1MPI_1_1Vector_html"><div class="ttname"><a href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a></div><div class="ttdef"><b>Definition:</b> <a href="trilinos__vector_8h_source.html#l00403">trilinos_vector.h:404</a></div></div>
<div class="ttc" id="agroup__Exceptions_html_ga98f7ffc57c76da1384a852920f756c1e"><div class="ttname"><a href="group__Exceptions.html#ga98f7ffc57c76da1384a852920f756c1e">VectorTools::ExcPointNotAvailableHere</a></div><div class="ttdeci">static ::ExceptionBase &amp; ExcPointNotAvailableHere()</div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="fe__field__function_8h_source.html#l00169">169</a> of file <a class="el" href="fe__field__function_8h_source.html">fe_field_function.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="acd3baa8c298baae043c96dc5a2a81ec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd3baa8c298baae043c96dc5a2a81ec2">&#9670;&nbsp;</a></span>cell_hint_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType  = DoFHandler&lt;dim&gt;, typename VectorType  = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::<a class="el" href="classFunctions_1_1FEFieldFunction.html#acd3baa8c298baae043c96dc5a2a81ec2">cell_hint_t</a> =  <a class="el" href="classThreads_1_1ThreadLocalStorage.html">Threads::ThreadLocalStorage</a>&lt; typename DoFHandlerType::active_cell_iterator&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Typedef holding the local cell_hint. </p>

<p class="definition">Definition at line <a class="el" href="fe__field__function_8h_source.html#l00450">450</a> of file <a class="el" href="fe__field__function_8h_source.html">fe_field_function.h</a>.</p>

</div>
</div>
<a id="a385ed76410d75f5f15304ccebaac220d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a385ed76410d75f5f15304ccebaac220d">&#9670;&nbsp;</a></span>time_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classFunction.html">Function</a>&lt; dim, VectorType::value_type  &gt;::<a class="el" href="classFunctionTime.html#a08db01814f31c975752a5ace5515718c">time_type</a> =  typename <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt;VectorType::value_type &gt;::real_type&gt;::<a class="el" href="classFunctionTime.html#a08db01814f31c975752a5ace5515718c">time_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The scalar-valued real type used for representing time. </p>

<p class="definition">Definition at line <a class="el" href="function_8h_source.html#l00169">169</a> of file <a class="el" href="function_8h_source.html">function.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6cea91369868d379fbd92beb0d368c99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cea91369868d379fbd92beb0d368c99">&#9670;&nbsp;</a></span>FEFieldFunction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType  = DoFHandler&lt;dim&gt;, typename VectorType  = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::<a class="el" href="classFunctions_1_1FEFieldFunction.html">FEFieldFunction</a> </td>
          <td>(</td>
          <td class="paramtype">const DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>data_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em> = <code><a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt;&#160;dim&#160;&gt;::<a class="el" href="classFunctions_1_1FEFieldFunction.html#af1fe1814b55cbea129b17972634a02c4">mapping</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a vector function. A smart pointers is stored to the dof handler, so you have to make sure that it make sense for the entire lifetime of this object. The number of components of this functions is equal to the number of components of the finite element object. If a mapping is specified, that is what is used to find out where the points lay. Otherwise the standard Q1 mapping is used. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0206a45c90d523792eea8bd725d14788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0206a45c90d523792eea8bd725d14788">&#9670;&nbsp;</a></span>set_active_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType  = DoFHandler&lt;dim&gt;, typename VectorType  = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::set_active_cell </td>
          <td>(</td>
          <td class="paramtype">const typename DoFHandlerType::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>newcell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the current cell. If you know in advance where your points lie, you can tell this object by calling this function. This will speed things up a little. </p>

</div>
</div>
<a id="a0d35f2610d0206df87f7288c9e05a43e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d35f2610d0206df87f7288c9e05a43e">&#9670;&nbsp;</a></span>vector_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType  = DoFHandler&lt;dim&gt;, typename VectorType  = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::vector_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get one vector value at the given point. It is inefficient to use single points. If you need more than one at a time, use the <a class="el" href="classFunctions_1_1FEFieldFunction.html#af59a2e4a5bd27b2b6b56c82bd2f924ae">vector_value_list()</a> function. For efficiency reasons, it is better if all the points lie on the same cell. This is not mandatory, however it does speed things up.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that lies on an artificial cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">Function&lt; dim, VectorType::value_type &gt;</a>.</p>

</div>
</div>
<a id="aebc602fce9e594832f34f687652c5c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebc602fce9e594832f34f687652c5c8e">&#9670;&nbsp;</a></span>value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType  = DoFHandler&lt;dim&gt;, typename VectorType  = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual VectorType::value_type <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the function at the given point. Unless there is only one component (i.e. the function is scalar), you should state the component you want to have evaluated; it defaults to zero, i.e. the first component. It is inefficient to use single points. If you need more than one at a time, use the <a class="el" href="classFunctions_1_1FEFieldFunction.html#af59a2e4a5bd27b2b6b56c82bd2f924ae">vector_value_list()</a> function. For efficiency reasons, it is better if all the points lie on the same cell. This is not mandatory, however it does speed things up.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that lies on an artificial cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">Function&lt; dim, VectorType::value_type &gt;</a>.</p>

</div>
</div>
<a id="aedce7554c62c46b23f1ea7324ad3c57f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedce7554c62c46b23f1ea7324ad3c57f">&#9670;&nbsp;</a></span>value_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType  = DoFHandler&lt;dim&gt;, typename VectorType  = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::value_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set <code>values</code> to the point values of the specified component of the function at the <code>points</code>. It is assumed that <code>values</code> already has the right size, i.e. the same size as the points array. This is rather efficient if all the points lie on the same cell. If this is not the case, things may slow down a bit.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that lies on an artificial cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#a562fc1114e95e702e6696721f71528db">Function&lt; dim, VectorType::value_type &gt;</a>.</p>

</div>
</div>
<a id="af59a2e4a5bd27b2b6b56c82bd2f924ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af59a2e4a5bd27b2b6b56c82bd2f924ae">&#9670;&nbsp;</a></span>vector_value_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType  = DoFHandler&lt;dim&gt;, typename VectorType  = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::vector_value_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set <code>values</code> to the point values of the function at the <code>points</code>. It is assumed that <code>values</code> already has the right size, i.e. the same size as the points array. This is rather efficient if all the points lie on the same cell. If this is not the case, things may slow down a bit.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that lies on an artificial cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#aa041dde994d40c068e00661197ac75a6">Function&lt; dim, VectorType::value_type &gt;</a>.</p>

</div>
</div>
<a id="a26fbc6dbe05ce5bbd7f1d0651ee0c3f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26fbc6dbe05ce5bbd7f1d0651ee0c3f8">&#9670;&nbsp;</a></span>vector_gradient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType  = DoFHandler&lt;dim&gt;, typename VectorType  = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::vector_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, typename VectorType::value_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the gradient of all components of the function at the given point. It is inefficient to use single points. If you need more than one at a time, use the <a class="el" href="classFunctions_1_1FEFieldFunction.html#af59a2e4a5bd27b2b6b56c82bd2f924ae">vector_value_list()</a> function. For efficiency reasons, it is better if all the points lie on the same cell. This is not mandatory, however it does speed things up.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that lies on an artificial cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#af4509a9d71dc1a1ca05cb6205161dc60">Function&lt; dim, VectorType::value_type &gt;</a>.</p>

</div>
</div>
<a id="a71ecd2b357e099a9e828e51da7cf86a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ecd2b357e099a9e828e51da7cf86a7">&#9670;&nbsp;</a></span>gradient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType  = DoFHandler&lt;dim&gt;, typename VectorType  = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;1, dim, typename VectorType::value_type&gt; <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the gradient of the specified component of the function at the given point. It is inefficient to use single points. If you need more than one at a time, use the <a class="el" href="classFunctions_1_1FEFieldFunction.html#af59a2e4a5bd27b2b6b56c82bd2f924ae">vector_value_list()</a> function. For efficiency reasons, it is better if all the points lie on the same cell. This is not mandatory, however it does speed things up.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that lies on an artificial cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#a4b0aadc89a827b39c20f12889aa88625">Function&lt; dim, VectorType::value_type &gt;</a>.</p>

</div>
</div>
<a id="a9ee53c98b2e7f8b308ac8a834c747305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ee53c98b2e7f8b308ac8a834c747305">&#9670;&nbsp;</a></span>vector_gradient_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType  = DoFHandler&lt;dim&gt;, typename VectorType  = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::vector_gradient_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, typename VectorType::value_type &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the gradient of all components of the function at all the given points. This is rather efficient if all the points lie on the same cell. If this is not the case, things may slow down a bit.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that lies on an artificial cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#a109f7bff0fb455c042086f98bd003ede">Function&lt; dim, VectorType::value_type &gt;</a>.</p>

</div>
</div>
<a id="aa6a0171b1d056283371bb0a3d75520d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6a0171b1d056283371bb0a3d75520d0">&#9670;&nbsp;</a></span>gradient_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType  = DoFHandler&lt;dim&gt;, typename VectorType  = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::gradient_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, typename VectorType::value_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the gradient of the specified component of the function at all the given points. This is rather efficient if all the points lie on the same cell. If this is not the case, things may slow down a bit.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that lies on an artificial cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#afcf557f137782b46e85461235d5bd47d">Function&lt; dim, VectorType::value_type &gt;</a>.</p>

</div>
</div>
<a id="a09e1c8c360549d87c3cbb5ecffe56795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e1c8c360549d87c3cbb5ecffe56795">&#9670;&nbsp;</a></span>laplacian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType  = DoFHandler&lt;dim&gt;, typename VectorType  = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual VectorType::value_type <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::laplacian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Laplacian of a given component at point <code>p</code>.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that lies on an artificial cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#a763c928e78dc33bbe50873128f06e153">Function&lt; dim, VectorType::value_type &gt;</a>.</p>

</div>
</div>
<a id="a717128e21bdb96c3a7651178c6266c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a717128e21bdb96c3a7651178c6266c0f">&#9670;&nbsp;</a></span>vector_laplacian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType  = DoFHandler&lt;dim&gt;, typename VectorType  = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::vector_laplacian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Laplacian of all components at point <code>p</code> and store them in <code>values</code>.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that lies on an artificial cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#a33430fb1069660fb8cfe599181aceefa">Function&lt; dim, VectorType::value_type &gt;</a>.</p>

</div>
</div>
<a id="ab345ab75df955b8edf5cc8a58e3a9de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab345ab75df955b8edf5cc8a58e3a9de4">&#9670;&nbsp;</a></span>laplacian_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType  = DoFHandler&lt;dim&gt;, typename VectorType  = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::laplacian_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Laplacian of one component at a set of points.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that lies on an artificial cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#aae80353c3a581fa918ea555c3e1c7353">Function&lt; dim, VectorType::value_type &gt;</a>.</p>

</div>
</div>
<a id="a8b9f3e529440ee0848829301109d12bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b9f3e529440ee0848829301109d12bc">&#9670;&nbsp;</a></span>vector_laplacian_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType  = DoFHandler&lt;dim&gt;, typename VectorType  = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::vector_laplacian_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Laplacians of all components at a set of points.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that lies on an artificial cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#a6582ff5ce8fddc37866077976df598f9">Function&lt; dim, VectorType::value_type &gt;</a>.</p>

</div>
</div>
<a id="ad3b170f82e34cc8a12347cd0528071a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b170f82e34cc8a12347cd0528071a9">&#9670;&nbsp;</a></span>compute_point_locations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType  = DoFHandler&lt;dim&gt;, typename VectorType  = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::compute_point_locations </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename DoFHandlerType::active_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>qpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>maps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a set of points located in the domain (or, in the case of a parallel <a class="el" href="classTriangulation.html">Triangulation</a>, in the locally owned part of the domain or on the ghost cells for the current processor), sort these points into buckets for each of the cells on which at least one of the points is located.</p>
<p>This function fills three output vectors: <code>cells</code>, <code>qpoints</code> and <code>maps</code>. The first is a list of the cells that contain the points, the second is a list of quadrature points matching each cell of the first list, and the third contains the index of the given quadrature points, i.e., <code>points</code>[maps[3][4]] ends up as the 5th quadrature point in the 4th cell.</p>
<dl class="section return"><dt>Returns</dt><dd>This function returns the number of cells that collectively contain the set of points give as <code>points</code>. This also equals the lengths of the output arrays.</dd></dl>
<p>This function simply calls <a class="el" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">GridTools::compute_point_locations</a> : using the original function avoids computing a new Cache at every function call. </p>

</div>
</div>
<a id="abb3b315d38de9afa28ab46ca45c51a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb3b315d38de9afa28ab46ca45c51a0e">&#9670;&nbsp;</a></span>get_reference_coordinates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType  = DoFHandler&lt;dim&gt;, typename VectorType  = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std_cxx17::optional&lt;<a class="el" href="classPoint.html">Point</a>&lt;dim&gt; &gt; <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::get_reference_coordinates </td>
          <td>(</td>
          <td class="paramtype">const typename DoFHandlerType::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a cell, return the reference coordinates of the given point within this cell if it indeed lies within the cell. Otherwise return an uninitialized std_cxx17::optional object. </p>

</div>
</div>
<a id="ad1b4f548be005a1ffeeca7a450b028d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b4f548be005a1ffeeca7a450b028d8">&#9670;&nbsp;</a></span>vector_values()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunction.html">Function</a>&lt; dim, VectorType::value_type  &gt;::vector_values </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; VectorType::value_type  &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For each component of the function, fill a vector of values, one for each point.</p>
<p>The default implementation of this function in <a class="el" href="classFunction.html">Function</a> calls <a class="el" href="classFunctions_1_1FEFieldFunction.html#aedce7554c62c46b23f1ea7324ad3c57f">value_list()</a> for each component. In order to improve performance, this can be reimplemented in derived classes to speed up performance. </p>

</div>
</div>
<a id="a4ddbeb5adda74140a00dfc8db3687b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ddbeb5adda74140a00dfc8db3687b4a">&#9670;&nbsp;</a></span>vector_gradients()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunction.html">Function</a>&lt; dim, VectorType::value_type  &gt;::vector_gradients </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, VectorType::value_type  &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For each component of the function, fill a vector of gradient values, one for each point.</p>
<p>The default implementation of this function in <a class="el" href="classFunction.html">Function</a> calls <a class="el" href="classFunctions_1_1FEFieldFunction.html#aedce7554c62c46b23f1ea7324ad3c57f">value_list()</a> for each component. In order to improve performance, this can be reimplemented in derived classes to speed up performance. </p>

</div>
</div>
<a id="a8aa2ec8f2270bdee842413805c4d7442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aa2ec8f2270bdee842413805c4d7442">&#9670;&nbsp;</a></span>hessian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt;2, dim, VectorType::value_type &gt; <a class="el" href="classFunction.html">Function</a>&lt; dim, VectorType::value_type  &gt;::hessian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Hessian of a given component at point <code>p</code>, that is the gradient of the gradient of the function. </p>

</div>
</div>
<a id="a94960fba14557566fa5df8745a721939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94960fba14557566fa5df8745a721939">&#9670;&nbsp;</a></span>vector_hessian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunction.html">Function</a>&lt; dim, VectorType::value_type  &gt;::vector_hessian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, VectorType::value_type  &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Hessian of all components at point <code>p</code> and store them in <code>values</code>. </p>

</div>
</div>
<a id="a2e69625d9daf07615270d65d97dfebde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e69625d9daf07615270d65d97dfebde">&#9670;&nbsp;</a></span>hessian_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunction.html">Function</a>&lt; dim, VectorType::value_type  &gt;::hessian_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, VectorType::value_type  &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Hessian of one component at a set of points. </p>

</div>
</div>
<a id="abc1b732264fb498528453312e24d2f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc1b732264fb498528453312e24d2f49">&#9670;&nbsp;</a></span>vector_hessian_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunction.html">Function</a>&lt; dim, VectorType::value_type  &gt;::vector_hessian_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, VectorType::value_type  &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Hessians of all components at a set of points. </p>

</div>
</div>
<a id="a45e07b63ee34bd7e7ab2492be5213377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e07b63ee34bd7e7ab2492be5213377">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t <a class="el" href="classFunction.html">Function</a>&lt; dim, VectorType::value_type  &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an estimate for the memory consumption, in bytes, of this object.</p>
<p>This function is virtual and can be overloaded by derived classes. </p>

</div>
</div>
<a id="ae7d37ddb04314b38cf67c6cba22923f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d37ddb04314b38cf67c6cba22923f6">&#9670;&nbsp;</a></span>get_time()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; Number &gt;::get_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the time variable. </p>

</div>
</div>
<a id="a3a583fd8f30db3549dbaa43b2592e2bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a583fd8f30db3549dbaa43b2592e2bc">&#9670;&nbsp;</a></span>set_time()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; Number &gt;::set_time </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>new_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the time to <code>new_time</code>, overwriting the old value. </p>

</div>
</div>
<a id="aeb592482f587dc3f0ee6e2267215a772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb592482f587dc3f0ee6e2267215a772">&#9670;&nbsp;</a></span>advance_time()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; Number &gt;::advance_time </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>delta_t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Advance the time by the given time step <code>delta_t</code>. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="af8e6d4d5f831501d3b2067694dcc4142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8e6d4d5f831501d3b2067694dcc4142">&#9670;&nbsp;</a></span>dh</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType  = DoFHandler&lt;dim&gt;, typename VectorType  = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;const DoFHandlerType, <a class="el" href="classFunctions_1_1FEFieldFunction.html">FEFieldFunction</a>&lt;dim, DoFHandlerType, VectorType&gt; &gt; <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::dh</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the dof handler. </p>

<p class="definition">Definition at line <a class="el" href="fe__field__function_8h_source.html#l00458">458</a> of file <a class="el" href="fe__field__function_8h_source.html">fe_field_function.h</a>.</p>

</div>
</div>
<a id="ac16c620c58be395b9c2a79484667ebd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac16c620c58be395b9c2a79484667ebd6">&#9670;&nbsp;</a></span>data_vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType  = DoFHandler&lt;dim&gt;, typename VectorType  = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const VectorType&amp; <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::data_vector</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A reference to the actual data vector. </p>

<p class="definition">Definition at line <a class="el" href="fe__field__function_8h_source.html#l00463">463</a> of file <a class="el" href="fe__field__function_8h_source.html">fe_field_function.h</a>.</p>

</div>
</div>
<a id="af1fe1814b55cbea129b17972634a02c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1fe1814b55cbea129b17972634a02c4">&#9670;&nbsp;</a></span>mapping</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType  = DoFHandler&lt;dim&gt;, typename VectorType  = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMapping.html">Mapping</a>&lt;dim&gt;&amp; <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::mapping</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A reference to the mapping being used. </p>

<p class="definition">Definition at line <a class="el" href="fe__field__function_8h_source.html#l00468">468</a> of file <a class="el" href="fe__field__function_8h_source.html">fe_field_function.h</a>.</p>

</div>
</div>
<a id="aca85e5eb53c2979fc1c4dabcfecc021c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca85e5eb53c2979fc1c4dabcfecc021c">&#9670;&nbsp;</a></span>cache</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType  = DoFHandler&lt;dim&gt;, typename VectorType  = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a>&lt;dim, DoFHandlerType::space_dimension&gt; <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::cache</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The Cache object </p>

<p class="definition">Definition at line <a class="el" href="fe__field__function_8h_source.html#l00473">473</a> of file <a class="el" href="fe__field__function_8h_source.html">fe_field_function.h</a>.</p>

</div>
</div>
<a id="a193ac0154cad97a0f1f26fe9640c0904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a193ac0154cad97a0f1f26fe9640c0904">&#9670;&nbsp;</a></span>cell_hint</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType  = DoFHandler&lt;dim&gt;, typename VectorType  = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFunctions_1_1FEFieldFunction.html#acd3baa8c298baae043c96dc5a2a81ec2">cell_hint_t</a> <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::cell_hint</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The latest cell hint. </p>

<p class="definition">Definition at line <a class="el" href="fe__field__function_8h_source.html#l00478">478</a> of file <a class="el" href="fe__field__function_8h_source.html">fe_field_function.h</a>.</p>

</div>
</div>
<a id="ad8063ed9dcbe58753504d9173475befe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8063ed9dcbe58753504d9173475befe">&#9670;&nbsp;</a></span>dimension</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int <a class="el" href="classFunction.html">Function</a>&lt; dim, VectorType::value_type  &gt;::dimension</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Export the value of the template parameter as a static member constant. Sometimes useful for some expression template programming. </p>

<p class="definition">Definition at line <a class="el" href="function_8h_source.html#l00159">159</a> of file <a class="el" href="function_8h_source.html">function.h</a>.</p>

</div>
</div>
<a id="a7248c7e11dc434fb7d16cdc5e41e3770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7248c7e11dc434fb7d16cdc5e41e3770">&#9670;&nbsp;</a></span>n_components</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int <a class="el" href="classFunction.html">Function</a>&lt; dim, VectorType::value_type  &gt;::n_components</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of vector components. </p>

<p class="definition">Definition at line <a class="el" href="function_8h_source.html#l00164">164</a> of file <a class="el" href="function_8h_source.html">function.h</a>.</p>

</div>
</div>
<a id="a8932e3ec9ed7b6f6d6a91c23f82e36d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8932e3ec9ed7b6f6d6a91c23f82e36d8">&#9670;&nbsp;</a></span>time</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; Number &gt;::time</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store the present time. </p>

<p class="definition">Definition at line <a class="el" href="function__time_8h_source.html#l00113">113</a> of file <a class="el" href="function__time_8h_source.html">function_time.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/numerics/<a class="el" href="fe__field__function_8h_source.html">fe_field_function.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
