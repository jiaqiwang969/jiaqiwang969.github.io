<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classOpenCASCADE_1_1NormalProjectionManifold.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: OpenCASCADE::NormalProjectionManifold&lt; dim, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.3.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.3.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a></li><li class="navelem"><a class="el" href="classOpenCASCADE_1_1NormalProjectionManifold.html">NormalProjectionManifold</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classOpenCASCADE_1_1NormalProjectionManifold-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">OpenCASCADE::NormalProjectionManifold&lt; dim, spacedim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__OpenCASCADE.html">OpenCASCADE</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="opencascade_2manifold__lib_8h_source.html">deal.II/opencascade/manifold_lib.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for OpenCASCADE::NormalProjectionManifold&lt; dim, spacedim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classOpenCASCADE_1_1NormalProjectionManifold__inherit__graph.svg" width="327" height="295"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a79eb483936cd38a0a9d42bf2071ee9ce"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> = std::array&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::vertices_per_face &gt;</td></tr>
<tr class="separator:a79eb483936cd38a0a9d42bf2071ee9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:gad9d83bbdbab6b71c1bc8a6a779725919"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__OpenCASCADE.html#gad9d83bbdbab6b71c1bc8a6a779725919">NormalProjectionManifold</a> (const TopoDS_Shape &amp;<a class="el" href="group__OpenCASCADE.html#ga61ad9cf8d0fad19115d3bf1dcc12c1b4">sh</a>, const <a class="el" href="classdouble.html">double</a> <a class="el" href="group__OpenCASCADE.html#gae1cf9d9cff4118bb451ecf4c1381af46">tolerance</a>=1e-7)</td></tr>
<tr class="separator:gad9d83bbdbab6b71c1bc8a6a779725919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga851251354ff0cd6e8d356917a98501a1"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__OpenCASCADE.html#ga851251354ff0cd6e8d356917a98501a1">clone</a> () const override</td></tr>
<tr class="separator:ga851251354ff0cd6e8d356917a98501a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7b0d16828cc077c45a2bd26b1d6544d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__OpenCASCADE.html#gac7b0d16828cc077c45a2bd26b1d6544d">project_to_manifold</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;surrounding_points, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;candidate) const override</td></tr>
<tr class="separator:gac7b0d16828cc077c45a2bd26b1d6544d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ade4bf6598dda23e36f95a46fa026e7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlatManifold.html#a6ade4bf6598dda23e36f95a46fa026e7">get_new_point</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;surrounding_points, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classdouble.html">double</a> &gt; &amp;weights) const override</td></tr>
<tr class="separator:a6ade4bf6598dda23e36f95a46fa026e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10bffbfe9f60ee0cf9d8bb9bfd7f8384"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlatManifold.html#a10bffbfe9f60ee0cf9d8bb9bfd7f8384">get_new_points</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;surrounding_points, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classdouble.html">double</a> &gt; &amp;weights, <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; new_points) const override</td></tr>
<tr class="separator:a10bffbfe9f60ee0cf9d8bb9bfd7f8384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5eec4132f6d653dea1380f7d587ecdf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlatManifold.html#ab5eec4132f6d653dea1380f7d587ecdf">get_tangent_vector</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;x1, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;x2) const override</td></tr>
<tr class="separator:ab5eec4132f6d653dea1380f7d587ecdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab60f221758b3a32a596dde96fc1188c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlatManifold.html#aab60f221758b3a32a596dde96fc1188c">normal_vector</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;face, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p) const override</td></tr>
<tr class="separator:aab60f221758b3a32a596dde96fc1188c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9103b626dc1f76b04b50fadfc9c7c4ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlatManifold.html#a9103b626dc1f76b04b50fadfc9c7c4ec">normal_vector</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 1 &gt;::face_iterator &amp;, const <a class="el" href="classPoint.html">Point</a>&lt; 1 &gt; &amp;) const</td></tr>
<tr class="separator:a9103b626dc1f76b04b50fadfc9c7c4ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b7dcec4d398a6b33610be305db9ae4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlatManifold.html#af2b7dcec4d398a6b33610be305db9ae4">normal_vector</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 2 &gt;::face_iterator &amp;, const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;) const</td></tr>
<tr class="separator:af2b7dcec4d398a6b33610be305db9ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67c2f7df3c4bb1ee15a92a41af36ea1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlatManifold.html#ae67c2f7df3c4bb1ee15a92a41af36ea1">normal_vector</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 3 &gt;::face_iterator &amp;, const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;) const</td></tr>
<tr class="separator:ae67c2f7df3c4bb1ee15a92a41af36ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d5d3986b7324130a632fc98d77cb20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlatManifold.html#a41d5d3986b7324130a632fc98d77cb20">normal_vector</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt;::face_iterator &amp;face, const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;p) const</td></tr>
<tr class="separator:a41d5d3986b7324130a632fc98d77cb20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95b06b088819df6a9305d0009495d3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#ad95b06b088819df6a9305d0009495d3d">normal_vector</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt;::face_iterator &amp;face, const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;p) const</td></tr>
<tr class="separator:ad95b06b088819df6a9305d0009495d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355608da9555e9e88ea4b2af47be1c26"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlatManifold.html#a355608da9555e9e88ea4b2af47be1c26">get_normals_at_vertices</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;face, typename <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::<a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;face_vertex_normals) const override</td></tr>
<tr class="separator:a355608da9555e9e88ea4b2af47be1c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f6a628e3e97bb5cefd2fde41f673ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlatManifold.html#ab3f6a628e3e97bb5cefd2fde41f673ca">get_normals_at_vertices</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1 &gt;::face_iterator &amp;, <a class="el" href="classManifold.html">Manifold</a>&lt; 1, 1 &gt;::<a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;) const</td></tr>
<tr class="separator:ab3f6a628e3e97bb5cefd2fde41f673ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264d0a0c579dc1988ad2f6d317fe9e7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlatManifold.html#a264d0a0c579dc1988ad2f6d317fe9e7f">get_normals_at_vertices</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 2 &gt;::face_iterator &amp;, <a class="el" href="classManifold.html">Manifold</a>&lt; 1, 2 &gt;::<a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;) const</td></tr>
<tr class="separator:a264d0a0c579dc1988ad2f6d317fe9e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316adb5d13fcbd3d77683dc6c7a3060c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlatManifold.html#a316adb5d13fcbd3d77683dc6c7a3060c">get_normals_at_vertices</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 3 &gt;::face_iterator &amp;, <a class="el" href="classManifold.html">Manifold</a>&lt; 1, 3 &gt;::<a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;) const</td></tr>
<tr class="separator:a316adb5d13fcbd3d77683dc6c7a3060c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b2d5e6c94695ee65997a7eead250ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlatManifold.html#af9b2d5e6c94695ee65997a7eead250ca">get_normals_at_vertices</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2 &gt;::face_iterator &amp;face, <a class="el" href="classManifold.html">Manifold</a>&lt; 2, 2 &gt;::<a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;face_vertex_normals) const</td></tr>
<tr class="separator:af9b2d5e6c94695ee65997a7eead250ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74d7995f4290eb6004ad3d0bdd58d75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlatManifold.html#ac74d7995f4290eb6004ad3d0bdd58d75">get_normals_at_vertices</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 3 &gt;::face_iterator &amp;, <a class="el" href="classManifold.html">Manifold</a>&lt; 2, 3 &gt;::<a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;) const</td></tr>
<tr class="separator:ac74d7995f4290eb6004ad3d0bdd58d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9b7a55616b7698372f957bc1fd08a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlatManifold.html#a6b9b7a55616b7698372f957bc1fd08a4">get_normals_at_vertices</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3 &gt;::face_iterator &amp;face, <a class="el" href="classManifold.html">Manifold</a>&lt; 3, 3 &gt;::<a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;face_vertex_normals) const</td></tr>
<tr class="separator:a6b9b7a55616b7698372f957bc1fd08a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae944375afbf9370708422e520c6969e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#ae944375afbf9370708422e520c6969e5">get_normals_at_vertices</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt;::face_iterator &amp;face, <a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;n) const</td></tr>
<tr class="separator:ae944375afbf9370708422e520c6969e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3477908d71618cfc0c2de81e8ad474"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a1e3477908d71618cfc0c2de81e8ad474">get_normals_at_vertices</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt;::face_iterator &amp;face, <a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;n) const</td></tr>
<tr class="separator:a1e3477908d71618cfc0c2de81e8ad474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774ebed8185bc73b049665b62df23e90"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlatManifold.html#a774ebed8185bc73b049665b62df23e90">get_periodicity</a> () const</td></tr>
<tr class="separator:a774ebed8185bc73b049665b62df23e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f1d301d7950f55b59e1c2982dfe942"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a73f1d301d7950f55b59e1c2982dfe942">get_new_point_on_quad</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 1 &gt;::quad_iterator &amp;) const</td></tr>
<tr class="separator:a73f1d301d7950f55b59e1c2982dfe942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1adb7e5b4a0feeeef7f9ec087e23d376"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a1adb7e5b4a0feeeef7f9ec087e23d376">get_new_point_on_quad</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 2 &gt;::quad_iterator &amp;) const</td></tr>
<tr class="separator:a1adb7e5b4a0feeeef7f9ec087e23d376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd7186dfb0ea938abda62e962d5f867"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a4bd7186dfb0ea938abda62e962d5f867">get_new_point_on_quad</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 3 &gt;::quad_iterator &amp;) const</td></tr>
<tr class="separator:a4bd7186dfb0ea938abda62e962d5f867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada653729888b24eb140a382512167163"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#ada653729888b24eb140a382512167163">get_new_point_on_hex</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt;::hex_iterator &amp;hex) const</td></tr>
<tr class="separator:ada653729888b24eb140a382512167163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a38fc3f140d54aa80195831a27c499"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#ae6a38fc3f140d54aa80195831a27c499">get_new_point_on_face</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 1 &gt;::face_iterator &amp;) const</td></tr>
<tr class="separator:ae6a38fc3f140d54aa80195831a27c499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bba395b8edbb4703d2e77689266436f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a9bba395b8edbb4703d2e77689266436f">get_new_point_on_face</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 2 &gt;::face_iterator &amp;) const</td></tr>
<tr class="separator:a9bba395b8edbb4703d2e77689266436f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd6859a4858667c7d37838276c8e8b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a4dd6859a4858667c7d37838276c8e8b2">get_new_point_on_face</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 3 &gt;::face_iterator &amp;) const</td></tr>
<tr class="separator:a4dd6859a4858667c7d37838276c8e8b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Computing normal vectors</div></td></tr>
<tr class="memitem:a2f8317a03ab0c13971ff53bcb38b49e9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a2f8317a03ab0c13971ff53bcb38b49e9">get_normals_at_vertices</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;face, <a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;face_vertex_normals) const</td></tr>
<tr class="separator:a2f8317a03ab0c13971ff53bcb38b49e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Computing the location of points.</div></td></tr>
<tr class="memitem:aace84e99db1f4767ce9e524170a1de2c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#aace84e99db1f4767ce9e524170a1de2c">get_intermediate_point</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p1, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p2, const <a class="el" href="classdouble.html">double</a> w) const</td></tr>
<tr class="separator:aace84e99db1f4767ce9e524170a1de2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af518522b81bdfe059b88bb557f7a60ba"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#af518522b81bdfe059b88bb557f7a60ba">get_new_point_on_line</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::line_iterator &amp;line) const</td></tr>
<tr class="separator:af518522b81bdfe059b88bb557f7a60ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a7a18b04151504883074c24108266f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a59a7a18b04151504883074c24108266f">get_new_point_on_quad</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::quad_iterator &amp;quad) const</td></tr>
<tr class="separator:a59a7a18b04151504883074c24108266f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d8365135405a1f057020d84a315ffa6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a8d8365135405a1f057020d84a315ffa6">get_new_point_on_hex</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::hex_iterator &amp;hex) const</td></tr>
<tr class="separator:a8d8365135405a1f057020d84a315ffa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79c3a0f002136b483b50722ea6690d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#ab79c3a0f002136b483b50722ea6690d9">get_new_point_on_face</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;face) const</td></tr>
<tr class="separator:ab79c3a0f002136b483b50722ea6690d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36b25e230fefc6eb32d53cb6e69cbba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#af36b25e230fefc6eb32d53cb6e69cbba">get_new_point_on_cell</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell) const</td></tr>
<tr class="separator:af36b25e230fefc6eb32d53cb6e69cbba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ga61ad9cf8d0fad19115d3bf1dcc12c1b4"><td class="memItemLeft" align="right" valign="top">const TopoDS_Shape&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__OpenCASCADE.html#ga61ad9cf8d0fad19115d3bf1dcc12c1b4">sh</a></td></tr>
<tr class="separator:ga61ad9cf8d0fad19115d3bf1dcc12c1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1cf9d9cff4118bb451ecf4c1381af46"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__OpenCASCADE.html#gae1cf9d9cff4118bb451ecf4c1381af46">tolerance</a></td></tr>
<tr class="separator:gae1cf9d9cff4118bb451ecf4c1381af46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:ga706fb7cb57be79fde16ef757d8d3ff59"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga706fb7cb57be79fde16ef757d8d3ff59">ExcPeriodicBox</a> (int arg1, <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; arg2, <a class="el" href="classdouble.html">double</a> arg3)</td></tr>
<tr class="separator:ga706fb7cb57be79fde16ef757d8d3ff59"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aacd26d33b025456553a8b952f68e7d72"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlatManifold.html#aacd26d33b025456553a8b952f68e7d72">periodicity</a></td></tr>
<tr class="separator:aacd26d33b025456553a8b952f68e7d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Subscriptor functionality</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp8d6bc922eebec0b76272099aee4a220d"></a>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</td></tr>
<tr class="memitem:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned int version)</td></tr>
<tr class="separator:ga68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20658b60d6ef2d530fafa076efa9f503"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga20658b60d6ef2d530fafa076efa9f503">counter</a></td></tr>
<tr class="separator:ga20658b60d6ef2d530fafa076efa9f503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73f9f8936b61e6e17ab2a82e9516e95b"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga73f9f8936b61e6e17ab2a82e9516e95b">counter_map</a></td></tr>
<tr class="separator:ga73f9f8936b61e6e17ab2a82e9516e95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga094d5932c6c004c2a2b1b966950fb2f7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga094d5932c6c004c2a2b1b966950fb2f7">validity_pointers</a></td></tr>
<tr class="separator:ga094d5932c6c004c2a2b1b966950fb2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44e13f7984b31af8d7c54921175a75ff"><td class="memItemLeft" align="right" valign="top">const std::type_info *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga44e13f7984b31af8d7c54921175a75ff">object_info</a></td></tr>
<tr class="separator:ga44e13f7984b31af8d7c54921175a75ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaeb9ac67567aa7d837f25debd33cd4ce5">map_value_type</a> = decltype(<a class="el" href="group__Exceptions.html#ga73f9f8936b61e6e17ab2a82e9516e95b">counter_map</a>)::value_type</td></tr>
<tr class="separator:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacebdc2d11f8522e4d9e8b7d73ac3f491">map_iterator</a> = decltype(<a class="el" href="group__Exceptions.html#ga73f9f8936b61e6e17ab2a82e9516e95b">counter_map</a>)::iterator</td></tr>
<tr class="separator:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e0d86893427a935e46d5bd6dcbc3f78"><td class="memItemLeft" align="right" valign="top">static std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7e0d86893427a935e46d5bd6dcbc3f78">mutex</a></td></tr>
<tr class="separator:ga7e0d86893427a935e46d5bd6dcbc3f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (int arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga300c593ea0f9422dcbce1445903e6c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga300c593ea0f9422dcbce1445903e6c12">check_no_subscribers</a> () const noexcept</td></tr>
<tr class="separator:ga300c593ea0f9422dcbce1445903e6c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int spacedim&gt;<br />
class OpenCASCADE::NormalProjectionManifold&lt; dim, spacedim &gt;</h3>

<p>A <a class="el" href="classManifold.html">Manifold</a> object based on <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> TopoDS_Shape where new points are first computed by averaging the surrounding points in the same way as <a class="el" href="classFlatManifold.html">FlatManifold</a> does, and are then projected in the normal direction using <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> utilities.</p>
<p>This class makes no assumptions on the shape you pass to it, and the topological dimension of the <a class="el" href="classManifold.html">Manifold</a> is inferred from the TopoDS_Shape itself. In debug mode there is a sanity check to make sure that the surrounding points (the ones used in <a class="el" href="group__OpenCASCADE.html#gac7b0d16828cc077c45a2bd26b1d6544d">project_to_manifold()</a>) actually live on the <a class="el" href="classManifold.html">Manifold</a>, i.e., calling <a class="el" href="namespaceOpenCASCADE.html#a94c26d2fd39062b95c4dc0394dc9a70c">OpenCASCADE::closest_point()</a> on those points leaves them untouched. If this is not the case, an ExcPointNotOnManifold is thrown.</p>
<p>This could happen, for example, if you are trying to use a shape of type TopoDS_Edge when projecting on a face. In this case, the vertices of the face would be collapsed to the edge, and your surrounding points would not be lying on the given shape, raising an exception. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2manifold__lib_8h_source.html#l00064">64</a> of file <a class="el" href="opencascade_2manifold__lib_8h_source.html">manifold_lib.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a79eb483936cd38a0a9d42bf2071ee9ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79eb483936cd38a0a9d42bf2071ee9ce">&#9670;&nbsp;</a></span>FaceVertexNormals</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::<a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> =  std::array&lt;<a class="el" href="classTensor.html">Tensor</a>&lt;1, spacedim&gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim&gt;::vertices_per_face&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Type keeping information about the normals at the vertices of a face of a cell. Thus, there are <code><a class="el" href="structGeometryInfo.html#aad8410f6471e4ac443b51f6c20809bfb">GeometryInfo&lt;dim&gt;::vertices_per_face</a></code> normal vectors, that define the tangent spaces of the boundary at the vertices. Note that the vectors stored in this object are not required to be normalized, nor to actually point outward, as one often will only want to check for orthogonality to define the tangent plane; if a function requires the normals to be normalized, then it must do so itself.</p>
<p>For obvious reasons, this type is not useful in 1d. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2grid_2manifold_8h_source.html#l00306">306</a> of file <a class="el" href="include_2deal_8II_2grid_2manifold_8h_source.html">manifold.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6ade4bf6598dda23e36f95a46fa026e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ade4bf6598dda23e36f95a46fa026e7">&#9670;&nbsp;</a></span>get_new_point()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classFlatManifold.html">FlatManifold</a>&lt; dim, spacedim &gt;::get_new_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>surrounding_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Let the new point be the average sum of surrounding vertices.</p>
<p>This particular implementation constructs the weighted average of the surrounding points, and then calls internally the function <a class="el" href="group__OpenCASCADE.html#gac7b0d16828cc077c45a2bd26b1d6544d">project_to_manifold()</a>. The reason why we do it this way, is to allow lazy programmers to implement only the <a class="el" href="group__OpenCASCADE.html#gac7b0d16828cc077c45a2bd26b1d6544d">project_to_manifold()</a> function for their own <a class="el" href="classManifold.html">Manifold</a> classes which are small (or trivial) perturbations of a flat manifold. This is the case whenever the coarse mesh is a decent approximation of the manifold geometry. In this case, the middle point of a cell is close to true middle point of the manifold, and a projection may suffice.</p>
<p>For most simple geometries, it is possible to get reasonable results by deriving your own <a class="el" href="classManifold.html">Manifold</a> class from <a class="el" href="classFlatManifold.html">FlatManifold</a>, and write a new interface only for the project_to_manifold function. You will have good approximations also with large deformations, as long as in the coarsest mesh size you are trying to refine, the middle point is not too far from the manifold mid point, i.e., as long as the coarse mesh size is small enough. </p>

<p>Reimplemented from <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a10bffbfe9f60ee0cf9d8bb9bfd7f8384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10bffbfe9f60ee0cf9d8bb9bfd7f8384">&#9670;&nbsp;</a></span>get_new_points()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFlatManifold.html">FlatManifold</a>&lt; dim, spacedim &gt;::get_new_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>surrounding_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt;&#160;</td>
          <td class="paramname"><em>new_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute a new set of points that interpolate between the given points <code>surrounding_points</code>. <code>weights</code> is a table with as many columns as <code>surrounding_points.size()</code>. The number of rows in <code>weights</code> must match the length of <code>new_points</code>.</p>
<p>For this particular implementation, the interpolation of the <code>surrounding_points</code> according to the <code>weights</code> is simply performed in Cartesian space. </p>

<p>Reimplemented from <a class="el" href="classManifold.html#a09b9fa8b80707d686b5929d0f27732a7">Manifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="ab5eec4132f6d653dea1380f7d587ecdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5eec4132f6d653dea1380f7d587ecdf">&#9670;&nbsp;</a></span>get_tangent_vector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;1, spacedim&gt; <a class="el" href="classFlatManifold.html">FlatManifold</a>&lt; dim, spacedim &gt;::get_tangent_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a vector that, at \(\mathbf x_1\), is tangential to the geodesic that connects two points \(\mathbf x_1,\mathbf x_2\). For the current class, we assume that the manifold is flat, so the geodesic is the straight line between the two points, and we return \(\mathbf x_2-\mathbf x_1\). The normalization of the vector is chosen so that it fits the convention described in <a class="el" href="classManifold.html#adff3c7c6851d64d1839964f7ebbfc787">Manifold::get_tangent_vector()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>If you use this class as a stepping stone to build a manifold that only "slightly" deviates from a flat manifold, by overloading the <a class="el" href="group__OpenCASCADE.html#gac7b0d16828cc077c45a2bd26b1d6544d">project_to_manifold()</a> function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>The first point that describes the geodesic, and the one at which the "direction" is to be evaluated. </td></tr>
    <tr><td class="paramname">x2</td><td>The second point that describes the geodesic. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A "direction" vector tangential to the geodesic. Here, this is \(\mathbf x_2-\mathbf x_1\), possibly modified by the periodicity of the domain as set in the constructor, to use the "shortest" connection between the points through the periodic boundary as necessary. </dd></dl>

<p>Reimplemented from <a class="el" href="classManifold.html#adff3c7c6851d64d1839964f7ebbfc787">Manifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="aab60f221758b3a32a596dde96fc1188c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab60f221758b3a32a596dde96fc1188c">&#9670;&nbsp;</a></span>normal_vector() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;1, spacedim&gt; <a class="el" href="classFlatManifold.html">FlatManifold</a>&lt; dim, spacedim &gt;::normal_vector </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the normal vector to the given face at point p taking into account that quadrilateral faces of hexahedral cells in 3d may not be planar. In those cases, the face is assumed to have a geometry described by a bilinear function, and the normal vector is computed by embedding this bilinear form into a Cartesian space with a flat metric. </p>

<p>Reimplemented from <a class="el" href="classManifold.html#a8f737627dc946fb68c097d6ec83419d4">Manifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a9103b626dc1f76b04b50fadfc9c7c4ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9103b626dc1f76b04b50fadfc9c7c4ec">&#9670;&nbsp;</a></span>normal_vector() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, 1 &gt; <a class="el" href="classFlatManifold.html">FlatManifold</a>&lt; 1, 1 &gt;::normal_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 1 &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00814">814</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="af2b7dcec4d398a6b33610be305db9ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b7dcec4d398a6b33610be305db9ae4">&#9670;&nbsp;</a></span>normal_vector() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, 2 &gt; <a class="el" href="classFlatManifold.html">FlatManifold</a>&lt; 1, 2 &gt;::normal_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 2 &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00825">825</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="ae67c2f7df3c4bb1ee15a92a41af36ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae67c2f7df3c4bb1ee15a92a41af36ea1">&#9670;&nbsp;</a></span>normal_vector() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, 3 &gt; <a class="el" href="classFlatManifold.html">FlatManifold</a>&lt; 1, 3 &gt;::normal_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 3 &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00836">836</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a41d5d3986b7324130a632fc98d77cb20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41d5d3986b7324130a632fc98d77cb20">&#9670;&nbsp;</a></span>normal_vector() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, 2 &gt; <a class="el" href="classFlatManifold.html">FlatManifold</a>&lt; 2, 2 &gt;::normal_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00847">847</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="ad95b06b088819df6a9305d0009495d3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad95b06b088819df6a9305d0009495d3d">&#9670;&nbsp;</a></span>normal_vector() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, 3 &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; 3, 3 &gt;::normal_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00166">166</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a355608da9555e9e88ea4b2af47be1c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a355608da9555e9e88ea4b2af47be1c26">&#9670;&nbsp;</a></span>get_normals_at_vertices() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFlatManifold.html">FlatManifold</a>&lt; dim, spacedim &gt;::get_normals_at_vertices </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::<a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;&#160;</td>
          <td class="paramname"><em>face_vertex_normals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the normal vectors to the boundary at each vertex of the given face taking into account that quadrilateral faces of hexahedral cells in 3d may not be planar. In those cases, the face is assumed to have a geometry described by a bilinear function, and the normal vector is computed by embedding this bilinear form into a Cartesian space with a flat metric. </p>

</div>
</div>
<a id="ab3f6a628e3e97bb5cefd2fde41f673ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f6a628e3e97bb5cefd2fde41f673ca">&#9670;&nbsp;</a></span>get_normals_at_vertices() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFlatManifold.html">FlatManifold</a>&lt; 1 &gt;::get_normals_at_vertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1 &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classManifold.html">Manifold</a>&lt; 1, 1 &gt;::<a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00727">727</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a264d0a0c579dc1988ad2f6d317fe9e7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a264d0a0c579dc1988ad2f6d317fe9e7f">&#9670;&nbsp;</a></span>get_normals_at_vertices() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFlatManifold.html">FlatManifold</a>&lt; 1, 2 &gt;::get_normals_at_vertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 2 &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classManifold.html">Manifold</a>&lt; 1, 2 &gt;::<a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00738">738</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a316adb5d13fcbd3d77683dc6c7a3060c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a316adb5d13fcbd3d77683dc6c7a3060c">&#9670;&nbsp;</a></span>get_normals_at_vertices() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFlatManifold.html">FlatManifold</a>&lt; 1, 3 &gt;::get_normals_at_vertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 3 &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classManifold.html">Manifold</a>&lt; 1, 3 &gt;::<a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00749">749</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="af9b2d5e6c94695ee65997a7eead250ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b2d5e6c94695ee65997a7eead250ca">&#9670;&nbsp;</a></span>get_normals_at_vertices() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFlatManifold.html">FlatManifold</a>&lt; 2 &gt;::get_normals_at_vertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2 &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classManifold.html">Manifold</a>&lt; 2, 2 &gt;::<a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;&#160;</td>
          <td class="paramname"><em>face_vertex_normals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00760">760</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="ac74d7995f4290eb6004ad3d0bdd58d75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74d7995f4290eb6004ad3d0bdd58d75">&#9670;&nbsp;</a></span>get_normals_at_vertices() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFlatManifold.html">FlatManifold</a>&lt; 2, 3 &gt;::get_normals_at_vertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 3 &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classManifold.html">Manifold</a>&lt; 2, 3 &gt;::<a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00775">775</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a6b9b7a55616b7698372f957bc1fd08a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b9b7a55616b7698372f957bc1fd08a4">&#9670;&nbsp;</a></span>get_normals_at_vertices() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFlatManifold.html">FlatManifold</a>&lt; 3 &gt;::get_normals_at_vertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3 &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classManifold.html">Manifold</a>&lt; 3, 3 &gt;::<a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;&#160;</td>
          <td class="paramname"><em>face_vertex_normals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00786">786</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a2f8317a03ab0c13971ff53bcb38b49e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f8317a03ab0c13971ff53bcb38b49e9">&#9670;&nbsp;</a></span>get_normals_at_vertices() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_normals_at_vertices </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;&#160;</td>
          <td class="paramname"><em>face_vertex_normals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the normal vectors to the boundary at each vertex of the given face embedded in the <a class="el" href="classManifold.html">Manifold</a>. It is not required that the normal vectors be normed somehow. Neither is it required that the normals actually point outward.</p>
<p>This function is needed to compute data for C1 mappings. The default implementation calls <a class="el" href="classFlatManifold.html#aab60f221758b3a32a596dde96fc1188c">normal_vector()</a> on each vertex.</p>
<p>Note that when computing normal vectors at a vertex where the boundary is not differentiable, you have to make sure that you compute the one-sided limits, i.e. limit with respect to points inside the given face. </p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00303">303</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="ae944375afbf9370708422e520c6969e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae944375afbf9370708422e520c6969e5">&#9670;&nbsp;</a></span>get_normals_at_vertices() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classManifold.html">Manifold</a>&lt; 2, 2 &gt;::get_normals_at_vertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00251">251</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a1e3477908d71618cfc0c2de81e8ad474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e3477908d71618cfc0c2de81e8ad474">&#9670;&nbsp;</a></span>get_normals_at_vertices() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classManifold.html">Manifold</a>&lt; 3, 3 &gt;::get_normals_at_vertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00273">273</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a774ebed8185bc73b049665b62df23e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a774ebed8185bc73b049665b62df23e90">&#9670;&nbsp;</a></span>get_periodicity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTensor.html">Tensor</a>&lt;1, spacedim&gt;&amp; <a class="el" href="classFlatManifold.html">FlatManifold</a>&lt; dim, spacedim &gt;::get_periodicity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the periodicity of this <a class="el" href="classManifold.html">Manifold</a>. </p>

</div>
</div>
<a id="ga706fb7cb57be79fde16ef757d8d3ff59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga706fb7cb57be79fde16ef757d8d3ff59">&#9670;&nbsp;</a></span>ExcPeriodicBox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a>&amp; <a class="el" href="classFlatManifold.html">FlatManifold</a>&lt; dim, spacedim &gt;::ExcPeriodicBox </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>arg3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>The message that will be printed by this exception reads: <div class="doxygen-generated-exception-message"> &lt;&lt; "The component number " &lt;&lt; arg1 &lt;&lt; " of the point [ " &lt;&lt; arg2 &lt;&lt; " ] is not in the interval [ 0, " &lt;&lt; arg3 &lt;&lt; "), bailing out." </div> </dd></dl>

</div>
</div>
<a id="aace84e99db1f4767ce9e524170a1de2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aace84e99db1f4767ce9e524170a1de2c">&#9670;&nbsp;</a></span>get_intermediate_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_intermediate_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an intermediate point between two given points. Overloading this function allows the default pair-wise reduction implementation of the method <a class="el" href="classFlatManifold.html#a6ade4bf6598dda23e36f95a46fa026e7">get_new_point()</a> that takes a <a class="el" href="classQuadrature.html">Quadrature</a> object as input to work properly.</p>
<p>An implementation of this function should returns a parametric curve on the manifold, joining the points <code>p1</code> and <code>p2</code>, with parameter <code>w</code> in the interval [0,1]. In particular <code>get_intermediate_point(p1, p2, 0.0)</code> should return <code>p1</code> and <code>get_intermediate_point(p1, p2, 1.0)</code> should return <code>p2</code>.</p>
<p>In its default implementation, this function calls the <a class="el" href="group__OpenCASCADE.html#gac7b0d16828cc077c45a2bd26b1d6544d">project_to_manifold()</a> method with the convex combination of <code>p1</code> and <code>p2</code>. User classes can get away by simply implementing the <a class="el" href="group__OpenCASCADE.html#gac7b0d16828cc077c45a2bd26b1d6544d">project_to_manifold()</a> method. </p>

<p>Reimplemented in <a class="el" href="classSphericalManifold.html#a71e38e3a474c01409683ca853f66f5eb">SphericalManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classChartManifold.html#af255b3dfb6c1f38eaece0e995a85ec86">ChartManifold&lt; dim, spacedim, chartdim &gt;</a>, <a class="el" href="classChartManifold.html#af255b3dfb6c1f38eaece0e995a85ec86">ChartManifold&lt; dim, spacedim, 2 &gt;</a>, <a class="el" href="classChartManifold.html#af255b3dfb6c1f38eaece0e995a85ec86">ChartManifold&lt; dim, spacedim, 1 &gt;</a>, <a class="el" href="classChartManifold.html#af255b3dfb6c1f38eaece0e995a85ec86">ChartManifold&lt; dim, dim, 3 &gt;</a>, <a class="el" href="classChartManifold.html#af255b3dfb6c1f38eaece0e995a85ec86">ChartManifold&lt; dim, dim, dim &gt;</a>, <a class="el" href="classChartManifold.html#af255b3dfb6c1f38eaece0e995a85ec86">ChartManifold&lt; dim, 3, 3 &gt;</a>, and <a class="el" href="classChartManifold.html#af255b3dfb6c1f38eaece0e995a85ec86">ChartManifold&lt; dim, spacedim_A+spacedim_B, chartdim_A+chartdim_B &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00052">52</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="af518522b81bdfe059b88bb557f7a60ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af518522b81bdfe059b88bb557f7a60ba">&#9670;&nbsp;</a></span>get_new_point_on_line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_line </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::line_iterator &amp;&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Return the point which shall become the new middle vertex of the two children of a regular line. In 2D, this line is a line at the boundary, while in 3d, it is bounding a face at the boundary (the lines therefore is also on the boundary).</p>
<p>The default implementation of this function passes its argument to the <a class="el" href="namespaceManifolds.html#aa3ae330e2a2d8030955d5a395f3f1d18">Manifolds::get_default_points_and_weights()</a> function, and then calls the <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> function. User derived classes can overload <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> or <a class="el" href="classManifold.html#a29c25e5d735160e0d846aab01d918e86">Manifold&lt;dim,spacedim&gt;::project_to_manifold()</a>, which is called by the default implementation of <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a>. </p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00318">318</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a59a7a18b04151504883074c24108266f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a7a18b04151504883074c24108266f">&#9670;&nbsp;</a></span>get_new_point_on_quad() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_quad </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::quad_iterator &amp;&#160;</td>
          <td class="paramname"><em>quad</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Return the point which shall become the common point of the four children of a quad at the boundary in three or more spatial dimensions. This function therefore is only useful in at least three dimensions and should not be called for lower dimensions.</p>
<p>This function is called after the four lines bounding the given <code>quad</code> are refined, so you may want to use the information provided by <code>quad-&gt;line(i)-&gt;child(j)</code>, <code>i=0...3</code>, <code>j=0,1</code>.</p>
<p>The default implementation of this function passes its argument to the <a class="el" href="namespaceManifolds.html#aa3ae330e2a2d8030955d5a395f3f1d18">Manifolds::get_default_points_and_weights()</a> function, and then calls the <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> function. User derived classes can overload <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> or <a class="el" href="classManifold.html#a29c25e5d735160e0d846aab01d918e86">Manifold&lt;dim,spacedim&gt;::project_to_manifold()</a>, which is called by the default implementation of <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a>. </p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00332">332</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a73f1d301d7950f55b59e1c2982dfe942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f1d301d7950f55b59e1c2982dfe942">&#9670;&nbsp;</a></span>get_new_point_on_quad() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; 1 &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; 1, 1 &gt;::get_new_point_on_quad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 1 &gt;::quad_iterator &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00419">419</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a1adb7e5b4a0feeeef7f9ec087e23d376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1adb7e5b4a0feeeef7f9ec087e23d376">&#9670;&nbsp;</a></span>get_new_point_on_quad() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; 1, 2 &gt;::get_new_point_on_quad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 2 &gt;::quad_iterator &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00430">430</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a4bd7186dfb0ea938abda62e962d5f867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd7186dfb0ea938abda62e962d5f867">&#9670;&nbsp;</a></span>get_new_point_on_quad() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; 1, 3 &gt;::get_new_point_on_quad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 3 &gt;::quad_iterator &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00441">441</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a8d8365135405a1f057020d84a315ffa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d8365135405a1f057020d84a315ffa6">&#9670;&nbsp;</a></span>get_new_point_on_hex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_hex </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::hex_iterator &amp;&#160;</td>
          <td class="paramname"><em>hex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Return the point which shall become the common point of the eight children of a hex in three or spatial dimensions. This function therefore is only useful in at least three dimensions and should not be called for lower dimensions.</p>
<p>This function is called after the all the bounding objects of the given <code>hex</code> are refined, so you may want to use the information provided by <code>hex-&gt;quad(i)-&gt;line(j)-&gt;child(k)</code>, <code>i=0...5</code>, <code>j=0...3</code>, <code>k=0,1</code>.</p>
<p>The default implementation of this function passes its argument to the <a class="el" href="namespaceManifolds.html#aa3ae330e2a2d8030955d5a395f3f1d18">Manifolds::get_default_points_and_weights()</a> function, and then calls the <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> function. User derived classes can overload <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> or <a class="el" href="classManifold.html#a29c25e5d735160e0d846aab01d918e86">Manifold&lt;dim,spacedim&gt;::project_to_manifold()</a>, which is called by the default implementation of <a class="el" href="classManifold.html#a1d482f3946086e2955c36969437c925d">Manifold&lt;dim,spacedim&gt;::get_new_point()</a>. </p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00452">452</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="ada653729888b24eb140a382512167163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada653729888b24eb140a382512167163">&#9670;&nbsp;</a></span>get_new_point_on_hex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; 3, 3 &gt;::get_new_point_on_hex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt;::hex_iterator &amp;&#160;</td>
          <td class="paramname"><em>hex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00463">463</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="ab79c3a0f002136b483b50722ea6690d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab79c3a0f002136b483b50722ea6690d9">&#9670;&nbsp;</a></span>get_new_point_on_face() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_face </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Depending on <code>dim=2</code> or <code>dim=3</code> this function calls the get_new_point_on_line or the get_new_point_on_quad function. It throws an exception for <code>dim=1</code>. This wrapper allows dimension independent programming. </p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00346">346</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="ae6a38fc3f140d54aa80195831a27c499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a38fc3f140d54aa80195831a27c499">&#9670;&nbsp;</a></span>get_new_point_on_face() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; 1 &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; 1, 1 &gt;::get_new_point_on_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 1 &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00386">386</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a9bba395b8edbb4703d2e77689266436f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bba395b8edbb4703d2e77689266436f">&#9670;&nbsp;</a></span>get_new_point_on_face() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; 1, 2 &gt;::get_new_point_on_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 2 &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00397">397</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a4dd6859a4858667c7d37838276c8e8b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dd6859a4858667c7d37838276c8e8b2">&#9670;&nbsp;</a></span>get_new_point_on_face() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; 1, 3 &gt;::get_new_point_on_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 3 &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00408">408</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="af36b25e230fefc6eb32d53cb6e69cbba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36b25e230fefc6eb32d53cb6e69cbba">&#9670;&nbsp;</a></span>get_new_point_on_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_cell </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Depending on <code>dim=1</code>, <code>dim=2</code> or <code>dim=3</code> this function calls the get_new_point_on_line, get_new_point_on_quad or the get_new_point_on_hex function. This wrapper allows dimension independent programming. </p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00366">366</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aacd26d33b025456553a8b952f68e7d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd26d33b025456553a8b952f68e7d72">&#9670;&nbsp;</a></span>periodicity</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTensor.html">Tensor</a>&lt;1, spacedim&gt; <a class="el" href="classFlatManifold.html">FlatManifold</a>&lt; dim, spacedim &gt;::periodicity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The periodicity of this <a class="el" href="classManifold.html">Manifold</a>. Periodicity affects the way a middle point is computed. It is assumed that if two points are more than half period distant, then the distance should be computed by crossing the periodicity boundary, i.e., the average is computed by adding a full period to the sum of the two. For example, if along direction 0 we have 2*pi periodicity, then the average of (2*pi-eps) and (eps) is not pi, but 2*pi (or zero), since, on a periodic manifold, these two points are at distance 2*eps and not (2*pi-eps).</p>
<p>A periodicity 0 along one direction means no periodicity. This is the default value for all directions. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2grid_2manifold_8h_source.html#l00794">794</a> of file <a class="el" href="include_2deal_8II_2grid_2manifold_8h_source.html">manifold.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/opencascade/<a class="el" href="opencascade_2manifold__lib_8h_source.html">manifold_lib.h</a></li>
<li>source/opencascade/<a class="el" href="opencascade_2manifold__lib_8cc_source.html">manifold_lib.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
