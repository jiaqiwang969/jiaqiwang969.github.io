<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classSparseBlockVanka.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: SparseBlockVanka&lt; number &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.3.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.3.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classSparseBlockVanka-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SparseBlockVanka&lt; number &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a> &#124; <a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__Matrices.html">Matrix classes</a> &raquo; <a class="el" href="group__Preconditioners.html">Preconditioners and Relaxation Operators</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="sparse__vanka_8h_source.html">deal.II/lac/sparse_vanka.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SparseBlockVanka&lt; number &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classSparseBlockVanka__inherit__graph.svg" width="210" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:gabb5808d854335ef644940e5925bdc9f0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Preconditioners.html#gabb5808d854335ef644940e5925bdc9f0">BlockingStrategy</a> { <a class="el" href="group__Preconditioners.html#ggabb5808d854335ef644940e5925bdc9f0ac7c19434398878a27c9b9a9344d036ab">index_intervals</a>
, <a class="el" href="group__Preconditioners.html#ggabb5808d854335ef644940e5925bdc9f0ae8aa2663e8d4a83673f782185c012c4b">adaptive</a>
 }</td></tr>
<tr class="separator:gabb5808d854335ef644940e5925bdc9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65584bab604c4378f3fa70689c5cc8a7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Preconditioners.html#ga65584bab604c4378f3fa70689c5cc8a7">size_type</a> = <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td></tr>
<tr class="separator:ga65584bab604c4378f3fa70689c5cc8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:gac01e0467c0af006f10315db7a91bf5a6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Preconditioners.html#gac01e0467c0af006f10315db7a91bf5a6">SparseBlockVanka</a> (const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;M, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;<a class="el" href="group__Preconditioners.html#gab1c1073cd133bb81b5875b341eb32925">selected</a>, const unsigned int <a class="el" href="group__Preconditioners.html#gafd45c7bd085f644e45e541af3822ad00">n_blocks</a>, const <a class="el" href="group__Preconditioners.html#gabb5808d854335ef644940e5925bdc9f0">BlockingStrategy</a> blocking_strategy, const <a class="el" href="classbool.html">bool</a> conserve_memory, const unsigned int n_threads=<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>())</td></tr>
<tr class="separator:gac01e0467c0af006f10315db7a91bf5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa8cdd87a01a0d331978494d4678f433"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Preconditioners.html#gaaa8cdd87a01a0d331978494d4678f433">SparseBlockVanka</a> (const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;M, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;<a class="el" href="group__Preconditioners.html#gab1c1073cd133bb81b5875b341eb32925">selected</a>, const unsigned int <a class="el" href="group__Preconditioners.html#gafd45c7bd085f644e45e541af3822ad00">n_blocks</a>, const <a class="el" href="group__Preconditioners.html#gabb5808d854335ef644940e5925bdc9f0">BlockingStrategy</a> blocking_strategy)</td></tr>
<tr class="separator:gaaa8cdd87a01a0d331978494d4678f433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3153b46e90a763ffcb18c1b25096e7b"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:gad3153b46e90a763ffcb18c1b25096e7b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Preconditioners.html#gad3153b46e90a763ffcb18c1b25096e7b">vmult</a> (<a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;src) const</td></tr>
<tr class="separator:gad3153b46e90a763ffcb18c1b25096e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7bc4e285829dc632eb4bd60be156a7f"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Preconditioners.html#gaa7bc4e285829dc632eb4bd60be156a7f">memory_consumption</a> () const</td></tr>
<tr class="separator:gaa7bc4e285829dc632eb4bd60be156a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e2ce1949e40a2f6d09fe4d870670988"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Preconditioners.html#ga6e2ce1949e40a2f6d09fe4d870670988">initialize</a> (const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;M, const <a class="el" href="classSparseVanka_1_1AdditionalData.html">AdditionalData</a> &amp;additional_data)</td></tr>
<tr class="separator:ga6e2ce1949e40a2f6d09fe4d870670988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9244a620a91b61ee03f70edbf2e52ba7"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:ga9244a620a91b61ee03f70edbf2e52ba7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Preconditioners.html#ga9244a620a91b61ee03f70edbf2e52ba7">Tvmult</a> (<a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;src) const</td></tr>
<tr class="separator:ga9244a620a91b61ee03f70edbf2e52ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1161f72e2921f4cf53584ddddca91665"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Preconditioners.html#gaf523ea3caee731b5679560ab716e10cd">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Preconditioners.html#ga1161f72e2921f4cf53584ddddca91665">m</a> () const</td></tr>
<tr class="separator:ga1161f72e2921f4cf53584ddddca91665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41b1fb0a899949cc4b31a61dc386ef9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Preconditioners.html#gaf523ea3caee731b5679560ab716e10cd">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Preconditioners.html#ga41b1fb0a899949cc4b31a61dc386ef9a">n</a> () const</td></tr>
<tr class="separator:ga41b1fb0a899949cc4b31a61dc386ef9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:gae7569b43f4519137cc98f30ada15e1ee"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:gae7569b43f4519137cc98f30ada15e1ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Preconditioners.html#gae7569b43f4519137cc98f30ada15e1ee">apply_preconditioner</a> (<a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;src, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; *const dof_mask=nullptr) const</td></tr>
<tr class="separator:gae7569b43f4519137cc98f30ada15e1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ga8897bf5c46e8f2cbae9c94afed06af41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Preconditioners.html#ga8897bf5c46e8f2cbae9c94afed06af41">compute_dof_masks</a> (const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;M, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;<a class="el" href="group__Preconditioners.html#gab1c1073cd133bb81b5875b341eb32925">selected</a>, const <a class="el" href="group__Preconditioners.html#gabb5808d854335ef644940e5925bdc9f0">BlockingStrategy</a> blocking_strategy)</td></tr>
<tr class="separator:ga8897bf5c46e8f2cbae9c94afed06af41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22bf9cb75f1304f8623aa24c2c5bc6cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Preconditioners.html#ga22bf9cb75f1304f8623aa24c2c5bc6cf">compute_inverses</a> ()</td></tr>
<tr class="separator:ga22bf9cb75f1304f8623aa24c2c5bc6cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68a3571b29d6b2068d66e4f950eeb2bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Preconditioners.html#ga68a3571b29d6b2068d66e4f950eeb2bb">compute_inverses</a> (const <a class="el" href="group__Preconditioners.html#gaf523ea3caee731b5679560ab716e10cd">size_type</a> begin, const <a class="el" href="group__Preconditioners.html#gaf523ea3caee731b5679560ab716e10cd">size_type</a> end)</td></tr>
<tr class="separator:ga68a3571b29d6b2068d66e4f950eeb2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2aff37f288ae7f9900f6c22128cf8026"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Preconditioners.html#ga2aff37f288ae7f9900f6c22128cf8026">compute_inverse</a> (const <a class="el" href="group__Preconditioners.html#gaf523ea3caee731b5679560ab716e10cd">size_type</a> row, std::vector&lt; <a class="el" href="group__Preconditioners.html#gaf523ea3caee731b5679560ab716e10cd">size_type</a> &gt; &amp;local_indices)</td></tr>
<tr class="separator:ga2aff37f288ae7f9900f6c22128cf8026"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:gafd45c7bd085f644e45e541af3822ad00"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Preconditioners.html#gafd45c7bd085f644e45e541af3822ad00">n_blocks</a></td></tr>
<tr class="separator:gafd45c7bd085f644e45e541af3822ad00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf50eedb7f428138af6378d798e8ba057"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Preconditioners.html#gaf50eedb7f428138af6378d798e8ba057">dof_masks</a></td></tr>
<tr class="separator:gaf50eedb7f428138af6378d798e8ba057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e8f09281aaf4fbfbf90093edbf02447"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;, <a class="el" href="classSparseVanka.html">SparseVanka</a>&lt; number &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Preconditioners.html#ga1e8f09281aaf4fbfbf90093edbf02447">matrix</a></td></tr>
<tr class="separator:ga1e8f09281aaf4fbfbf90093edbf02447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1c1073cd133bb81b5875b341eb32925"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Preconditioners.html#gab1c1073cd133bb81b5875b341eb32925">selected</a></td></tr>
<tr class="separator:gab1c1073cd133bb81b5875b341eb32925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga253f2afee116f7fff25ad542f0cb64b0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; float &gt;, <a class="el" href="classSparseVanka.html">SparseVanka</a>&lt; number &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Preconditioners.html#ga253f2afee116f7fff25ad542f0cb64b0">inverses</a></td></tr>
<tr class="separator:ga253f2afee116f7fff25ad542f0cb64b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1edfa7ce100331a4423d8e2c5133cc08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Preconditioners.html#gaf523ea3caee731b5679560ab716e10cd">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Preconditioners.html#ga1edfa7ce100331a4423d8e2c5133cc08">_m</a></td></tr>
<tr class="separator:ga1edfa7ce100331a4423d8e2c5133cc08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga187cb7f6f5003a746ab61627d075a931"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Preconditioners.html#gaf523ea3caee731b5679560ab716e10cd">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Preconditioners.html#ga187cb7f6f5003a746ab61627d075a931">_n</a></td></tr>
<tr class="separator:ga187cb7f6f5003a746ab61627d075a931"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename number&gt;<br />
class SparseBlockVanka&lt; number &gt;</h3>

<p>Block version of the sparse Vanka preconditioner. This class divides the matrix into blocks and works on the diagonal blocks only, which of course reduces the efficiency as preconditioner, but is perfectly parallelizable. The constructor takes a parameter into how many blocks the matrix shall be subdivided and then lets the underlying class do the work. Division of the matrix is done in several ways which are described in detail below.</p>
<p>This class is probably useless if you don't have a multiprocessor system, since then the amount of work per preconditioning step is the same as for the <code><a class="el" href="classSparseVanka.html">SparseVanka</a></code> class, but preconditioning properties are worse. On the other hand, if you have a multiprocessor system, the worse preconditioning quality (leading to more iterations of the linear solver) usually is well balanced by the increased speed of application due to the parallelization, leading to an overall decrease in elapsed wall-time for solving your linear system. It should be noted that the quality as preconditioner reduces with growing number of blocks, so there may be an optimal value (in terms of wall-time per linear solve) for the number of blocks.</p>
<p>To facilitate writing portable code, if the number of blocks into which the matrix is to be subdivided, is set to one, then this class acts just like the <code><a class="el" href="classSparseVanka.html">SparseVanka</a></code> class. You may therefore want to set the number of blocks equal to the number of processors you have.</p>
<p>Note that the parallelization is done if <code>deal.II</code> was configured for multithread use and that the number of threads which is spawned equals the number of blocks. This is reasonable since you will not want to set the number of blocks unnecessarily large, since, as mentioned, this reduces the preconditioning properties.</p>
<h3>Splitting the matrix into blocks</h3>
<p>Splitting the matrix into blocks is always done in a way such that the blocks are not necessarily of equal size, but such that the number of selected degrees of freedom for which a local system is to be solved is equal between blocks. The reason for this strategy to subdivision is load- balancing for multithreading. There are several possibilities to actually split the matrix into blocks, which are selected by the flag <code>blocking_strategy</code> that is passed to the constructor. By a block, we will in the sequel denote a list of indices of degrees of freedom; the algorithm will work on each block separately, i.e. the solutions of the local systems corresponding to a degree of freedom of one block will only be used to update the degrees of freedom belonging to the same block, but never to update degrees of freedom of other blocks. A block can be a consecutive list of indices, as in the first alternative below, or a nonconsecutive list of indices. Of course, we assume that the intersection of each two blocks is empty and that the union of all blocks equals the interval <code>[0,N)</code>, where <code>N</code> is the number of degrees of freedom of the system of equations.</p>
<ul>
<li>
<p class="startli"><code>index_intervals:</code> Here, we chose the blocks to be intervals <code>[a_i,a_{i+1</code>)}, i.e. consecutive degrees of freedom are usually also within the same block. This is a reasonable strategy, if the degrees of freedom have, for example, be re-numbered using the Cuthill-McKee algorithm, in which spatially neighboring degrees of freedom have neighboring indices. In that case, coupling in the matrix is usually restricted to the vicinity of the diagonal as well, and we can simply cut the matrix into blocks.</p>
<p class="interli">The bounds of the intervals, i.e. the <code>a_i</code> above, are chosen such that the number of degrees of freedom on which we shall work (i.e. usually the degrees of freedom corresponding to Lagrange multipliers) is about the same in each block; this does not mean, however, that the sizes of the blocks are equal, since the blocks also comprise the other degrees of freedom for which no local system is solved. In the extreme case, consider that all Lagrange multipliers are sorted to the end of the range of DoF indices, then the first block would be very large, since it comprises all other DoFs and some Lagrange multipliers, while all other blocks are rather small and comprise only Langrange multipliers. This strategy therefore does not only depend on the order in which the Lagrange DoFs are sorted, but also on the order in which the other DoFs are sorted. It is therefore necessary to note that this almost renders the capability as preconditioner useless if the degrees of freedom are numbered by component, i.e. all Lagrange multipliers en bloc.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><code>adaptive:</code> This strategy is a bit more clever in cases where the Langrange DoFs are clustered, as in the example above. It works as follows: it first groups the Lagrange DoFs into blocks, using the same strategy as above. However, instead of grouping the other DoFs into the blocks of Lagrange DoFs with nearest DoF index, it decides for each non-Lagrange DoF to put it into the block of Lagrange DoFs which write to this non-Lagrange DoF most often. This makes it possible to even sort the Lagrange DoFs to the end and still associate spatially neighboring non-Lagrange DoFs to the same blocks where the respective Lagrange DoFs are, since they couple to each other while spatially distant DoFs don't couple.</p>
<p class="endli">The additional computational effort to sorting the non-Lagrange DoFs is not very large compared with the inversion of the local systems and applying the preconditioner, so this strategy might be reasonable if you want to sort your degrees of freedom by component. If the degrees of freedom are not sorted by component, the results of the both strategies outlined above does not differ much. However, unlike the first strategy, the performance of the second strategy does not deteriorate if the DoFs are renumbered by component. </p>
</li>
</ul>
<h3>Typical results</h3>
<p>As a prototypical test case, we use a nonlinear problem from optimization, which leads to a series of saddle point problems, each of which is solved using GMRES with Vanka as preconditioner. The equation had approx. 850 degrees of freedom. With the non-blocked version <code><a class="el" href="classSparseVanka.html">SparseVanka</a></code> (or <code><a class="el" href="classSparseBlockVanka.html">SparseBlockVanka</a></code> with <code>n_blocks==1</code>), the following numbers of iterations is needed to solver the linear system in each nonlinear step: </p><pre class="fragment">*   101 68 64 53 35 21
* </pre><p>With four blocks, we need the following numbers of iterations </p><pre class="fragment">*   124 88 83 66 44 28
* </pre><p> As can be seen, more iterations are needed. However, in terms of computing time, the first version needs 72 seconds wall time (and 79 seconds CPU time, which is more than wall time since some other parts of the program were parallelized as well), while the second version needed 53 second wall time (and 110 seconds CPU time) on a four processor machine. The total time is in both cases dominated by the linear solvers. In this case, it is therefore worth while using the blocked version of the preconditioner if wall time is more important than CPU time.</p>
<p>The results with the block version above were obtained with the first blocking strategy and the degrees of freedom were not numbered by component. Using the second strategy does not much change the numbers of iterations (at most by one in each step) and they also do not change when the degrees of freedom are sorted by component, while the first strategy significantly deteriorated. </p>

<p class="definition">Definition at line <a class="el" href="sparse__vanka_8h_source.html#l00499">499</a> of file <a class="el" href="sparse__vanka_8h_source.html">sparse_vanka.h</a>.</p>
</div><hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/lac/<a class="el" href="sparse__vanka_8h_source.html">sparse_vanka.h</a></li>
<li>source/lac/<a class="el" href="sparse__vanka_8cc_source.html">sparse_vanka.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
