<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classTrilinosWrappers_1_1SparsityPattern.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: TrilinosWrappers::SparsityPattern Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.3.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.3.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceTrilinosWrappers.html">TrilinosWrappers</a></li><li class="navelem"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="classTrilinosWrappers_1_1SparsityPattern-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TrilinosWrappers::SparsityPattern Class Reference<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a> &#124; <a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__Matrices.html">Matrix classes</a> &raquo; <a class="el" href="group__Matrix1.html">Basic matrices</a> &#124; <a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__Sparsity.html">Sparsity patterns</a> &#124; <a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__Vectors.html">Vector classes</a> &#124; <a class="el" href="group__LAC.html">Linear algebra classes</a> &#124; <a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__Matrices.html">Matrix classes</a> &raquo; <a class="el" href="group__Preconditioners.html">Preconditioners and Relaxation Operators</a> &raquo; <a class="el" href="group__Exceptions.html">Exceptions and assertions</a> &raquo; <a class="el" href="group__TrilinosWrappers.html">TrilinosWrappers</a> &#124; <a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__Sparsity.html">Sparsity patterns</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="trilinos__sparsity__pattern_8h_source.html">deal.II/lac/trilinos_sparsity_pattern.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for TrilinosWrappers::SparsityPattern:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classTrilinosWrappers_1_1SparsityPattern__inherit__graph.svg" width="186" height="127"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a86ccc640efbc58b74436f554e5edef08"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> = ::<a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td></tr>
<tr class="separator:a86ccc640efbc58b74436f554e5edef08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b2dfb2472ca96c605cf1685c5bd071"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ac6b2dfb2472ca96c605cf1685c5bd071">const_iterator</a> = <a class="el" href="classTrilinosWrappers_1_1SparsityPatternIterators_1_1Iterator.html">SparsityPatternIterators::Iterator</a></td></tr>
<tr class="separator:ac6b2dfb2472ca96c605cf1685c5bd071"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Basic constructors and initialization</div></td></tr>
<tr class="memitem:a1e3d417090f12ad51343a170d11e1841"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a1e3d417090f12ad51343a170d11e1841">SparsityPattern</a> ()</td></tr>
<tr class="separator:a1e3d417090f12ad51343a170d11e1841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3646f098f0c942f72da148212a1819"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ace3646f098f0c942f72da148212a1819">SparsityPattern</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> m, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> n, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> n_entries_per_row=0)</td></tr>
<tr class="separator:ace3646f098f0c942f72da148212a1819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11df72241b9b3e9c690270dec120df5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ae11df72241b9b3e9c690270dec120df5">SparsityPattern</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> m, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> n, const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> &gt; &amp;n_entries_per_row)</td></tr>
<tr class="separator:ae11df72241b9b3e9c690270dec120df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec851eaaeffd3b67c31741f59a856003"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#aec851eaaeffd3b67c31741f59a856003">SparsityPattern</a> (<a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> &amp;&amp;other) noexcept</td></tr>
<tr class="separator:aec851eaaeffd3b67c31741f59a856003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3e1e19863631ed6dc013a5f627f8e6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a0f3e1e19863631ed6dc013a5f627f8e6">SparsityPattern</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> &amp;input_sparsity_pattern)</td></tr>
<tr class="separator:a0f3e1e19863631ed6dc013a5f627f8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a0c7875dd25bef3b8feac538fda1c6"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#af2a0c7875dd25bef3b8feac538fda1c6">~SparsityPattern</a> () override=default</td></tr>
<tr class="separator:af2a0c7875dd25bef3b8feac538fda1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc653a77d0c78d0f7905b3a8f5cb7ac4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#afc653a77d0c78d0f7905b3a8f5cb7ac4">reinit</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> m, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> n, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> n_entries_per_row=0)</td></tr>
<tr class="separator:afc653a77d0c78d0f7905b3a8f5cb7ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ee2428b936269e24b12a23c81c2971"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ac1ee2428b936269e24b12a23c81c2971">reinit</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> m, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> n, const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> &gt; &amp;n_entries_per_row)</td></tr>
<tr class="separator:ac1ee2428b936269e24b12a23c81c2971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f10ff6d940578bd0603de91fbabe54f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a9f10ff6d940578bd0603de91fbabe54f">copy_from</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> &amp;input_sparsity_pattern)</td></tr>
<tr class="separator:a9f10ff6d940578bd0603de91fbabe54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e71032d26253157b73afac0750b022"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:aa5e71032d26253157b73afac0750b022"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#aa5e71032d26253157b73afac0750b022">copy_from</a> (const SparsityPatternType &amp;nontrilinos_sparsity_pattern)</td></tr>
<tr class="separator:aa5e71032d26253157b73afac0750b022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af83efc6edec53e1104b1a18b4852dd78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#af83efc6edec53e1104b1a18b4852dd78">operator=</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> &amp;input_sparsity_pattern)</td></tr>
<tr class="separator:af83efc6edec53e1104b1a18b4852dd78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1799ef4b2431ad7ece54fd1766810dea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a1799ef4b2431ad7ece54fd1766810dea">clear</a> ()</td></tr>
<tr class="separator:a1799ef4b2431ad7ece54fd1766810dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15d36e4bfe7c97b55d155541e723284"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ad15d36e4bfe7c97b55d155541e723284">compress</a> ()</td></tr>
<tr class="separator:ad15d36e4bfe7c97b55d155541e723284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and initialization using an IndexSet description</div></td></tr>
<tr class="memitem:ac71f2bb0b9377af30a419a56d9775f31"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ac71f2bb0b9377af30a419a56d9775f31">SparsityPattern</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;parallel_partitioning, const MPI_Comm &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> n_entries_per_row=0)</td></tr>
<tr class="separator:ac71f2bb0b9377af30a419a56d9775f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac67dd2dc9f638aee4848fc00a5ae12"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#acac67dd2dc9f638aee4848fc00a5ae12">SparsityPattern</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;parallel_partitioning, const MPI_Comm &amp;communicator, const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> &gt; &amp;n_entries_per_row)</td></tr>
<tr class="separator:acac67dd2dc9f638aee4848fc00a5ae12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb99b2ea1f6f184ccbef7009bf3c2a13"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#acb99b2ea1f6f184ccbef7009bf3c2a13">SparsityPattern</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;row_parallel_partitioning, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;col_parallel_partitioning, const MPI_Comm &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> n_entries_per_row=0)</td></tr>
<tr class="separator:acb99b2ea1f6f184ccbef7009bf3c2a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c44e5e388d2b9a42a9e968de746461f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a2c44e5e388d2b9a42a9e968de746461f">SparsityPattern</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;row_parallel_partitioning, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;col_parallel_partitioning, const MPI_Comm &amp;communicator, const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> &gt; &amp;n_entries_per_row)</td></tr>
<tr class="separator:a2c44e5e388d2b9a42a9e968de746461f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae126b94fc7b75f938ad9c750d1352184"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ae126b94fc7b75f938ad9c750d1352184">SparsityPattern</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;row_parallel_partitioning, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;col_parallel_partitioning, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;writable_rows, const MPI_Comm &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> n_entries_per_row=0)</td></tr>
<tr class="separator:ae126b94fc7b75f938ad9c750d1352184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07258537f85162c220bd08cc0d45e09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ab07258537f85162c220bd08cc0d45e09">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;parallel_partitioning, const MPI_Comm &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> n_entries_per_row=0)</td></tr>
<tr class="separator:ab07258537f85162c220bd08cc0d45e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa500755e481b287781bd6b6f8aad64cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#aa500755e481b287781bd6b6f8aad64cd">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;parallel_partitioning, const MPI_Comm &amp;communicator, const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> &gt; &amp;n_entries_per_row)</td></tr>
<tr class="separator:aa500755e481b287781bd6b6f8aad64cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13406ea8005028cb9ae4329f995c2c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ad13406ea8005028cb9ae4329f995c2c8">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;row_parallel_partitioning, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;col_parallel_partitioning, const MPI_Comm &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> n_entries_per_row=0)</td></tr>
<tr class="separator:ad13406ea8005028cb9ae4329f995c2c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15eb08788778df9dbe75b448fdcabc69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a15eb08788778df9dbe75b448fdcabc69">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;row_parallel_partitioning, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;col_parallel_partitioning, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;writeable_rows, const MPI_Comm &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> n_entries_per_row=0)</td></tr>
<tr class="separator:a15eb08788778df9dbe75b448fdcabc69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb9b09f4fcb1a13fefee40e9f95bed5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#aacb9b09f4fcb1a13fefee40e9f95bed5">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;row_parallel_partitioning, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;col_parallel_partitioning, const MPI_Comm &amp;communicator, const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> &gt; &amp;n_entries_per_row)</td></tr>
<tr class="separator:aacb9b09f4fcb1a13fefee40e9f95bed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9c95633efce73ce7736c8f810ff5f1"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:ada9c95633efce73ce7736c8f810ff5f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ada9c95633efce73ce7736c8f810ff5f1">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;row_parallel_partitioning, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;col_parallel_partitioning, const SparsityPatternType &amp;nontrilinos_sparsity_pattern, const MPI_Comm &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classbool.html">bool</a> exchange_data=false)</td></tr>
<tr class="separator:ada9c95633efce73ce7736c8f810ff5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb92eb9a8f88aac094818586e6dd3026"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:adb92eb9a8f88aac094818586e6dd3026"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#adb92eb9a8f88aac094818586e6dd3026">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;parallel_partitioning, const SparsityPatternType &amp;nontrilinos_sparsity_pattern, const MPI_Comm &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classbool.html">bool</a> exchange_data=false)</td></tr>
<tr class="separator:adb92eb9a8f88aac094818586e6dd3026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Information on the sparsity pattern</div></td></tr>
<tr class="memitem:a935abd1908d1ed387625143f305daa2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a935abd1908d1ed387625143f305daa2b">is_compressed</a> () const</td></tr>
<tr class="separator:a935abd1908d1ed387625143f305daa2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cee9e81898214ced961dd7f83039c26"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a4cee9e81898214ced961dd7f83039c26">max_entries_per_row</a> () const</td></tr>
<tr class="separator:a4cee9e81898214ced961dd7f83039c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8bac57fd30db178feb6dc022b6cd49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#aca8bac57fd30db178feb6dc022b6cd49">n_rows</a> () const</td></tr>
<tr class="separator:aca8bac57fd30db178feb6dc022b6cd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9e1e9696ac8ebf46e111471c06f2b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a7a9e1e9696ac8ebf46e111471c06f2b1">n_cols</a> () const</td></tr>
<tr class="separator:a7a9e1e9696ac8ebf46e111471c06f2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9942b99f5b3d361dff7e53fc64b70ba4"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a9942b99f5b3d361dff7e53fc64b70ba4">local_size</a> () const</td></tr>
<tr class="separator:a9942b99f5b3d361dff7e53fc64b70ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea819a20d1ed86f583ae0ded100e924"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a>, <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a7ea819a20d1ed86f583ae0ded100e924">local_range</a> () const</td></tr>
<tr class="separator:a7ea819a20d1ed86f583ae0ded100e924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf60d4968439ee59816e3b7b55bd3ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#adbf60d4968439ee59816e3b7b55bd3ed">in_local_range</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> index) const</td></tr>
<tr class="separator:adbf60d4968439ee59816e3b7b55bd3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867d59927f51777f5420e290f755105c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a867d59927f51777f5420e290f755105c">n_nonzero_elements</a> () const</td></tr>
<tr class="separator:a867d59927f51777f5420e290f755105c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2993cee1717e5ed363efc93667a995ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a2993cee1717e5ed363efc93667a995ff">row_length</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> row) const</td></tr>
<tr class="separator:a2993cee1717e5ed363efc93667a995ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de65b796c44a6dcc51c6cd8af7cb9f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a4de65b796c44a6dcc51c6cd8af7cb9f9">bandwidth</a> () const</td></tr>
<tr class="separator:a4de65b796c44a6dcc51c6cd8af7cb9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add300e272c6507cd021dfa0cc9919420"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#add300e272c6507cd021dfa0cc9919420">empty</a> () const</td></tr>
<tr class="separator:add300e272c6507cd021dfa0cc9919420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793339eeff73a74d317a08cdd0c8c4ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a793339eeff73a74d317a08cdd0c8c4ff">exists</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> i, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> j) const</td></tr>
<tr class="separator:a793339eeff73a74d317a08cdd0c8c4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc28342549ed2b2b39543a1709820cff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#afc28342549ed2b2b39543a1709820cff">row_is_stored_locally</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> i) const</td></tr>
<tr class="separator:afc28342549ed2b2b39543a1709820cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32a20c0a31a67133750ecd45f8a498c"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#af32a20c0a31a67133750ecd45f8a498c">memory_consumption</a> () const</td></tr>
<tr class="separator:af32a20c0a31a67133750ecd45f8a498c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Adding entries</div></td></tr>
<tr class="memitem:a4a411ae74d053f5ab1b85e885d637cd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a4a411ae74d053f5ab1b85e885d637cd2">add</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> i, const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> j)</td></tr>
<tr class="separator:a4a411ae74d053f5ab1b85e885d637cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90cfaf7a56fb9c2c012e0cf692f57e41"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:a90cfaf7a56fb9c2c012e0cf692f57e41"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a90cfaf7a56fb9c2c012e0cf692f57e41">add_entries</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> row, ForwardIterator <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ac265d5f0b47e509bb072f5b510843374">begin</a>, ForwardIterator <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a5cb8a213b7d941e0c2bcef057187fa62">end</a>, const <a class="el" href="classbool.html">bool</a> indices_are_sorted=false)</td></tr>
<tr class="separator:a90cfaf7a56fb9c2c012e0cf692f57e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Access of underlying Trilinos data</div></td></tr>
<tr class="memitem:aea54c88d353d85742ff7b1555e2a18b6"><td class="memItemLeft" align="right" valign="top">const Epetra_FECrsGraph &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#aea54c88d353d85742ff7b1555e2a18b6">trilinos_sparsity_pattern</a> () const</td></tr>
<tr class="separator:aea54c88d353d85742ff7b1555e2a18b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7964bb2b0e2a104f9cc3ffca09ff73e1"><td class="memItemLeft" align="right" valign="top">const Epetra_Map &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a7964bb2b0e2a104f9cc3ffca09ff73e1">domain_partitioner</a> () const</td></tr>
<tr class="separator:a7964bb2b0e2a104f9cc3ffca09ff73e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadff4be4c08e05e21a85b419e20d715e"><td class="memItemLeft" align="right" valign="top">const Epetra_Map &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#aadff4be4c08e05e21a85b419e20d715e">range_partitioner</a> () const</td></tr>
<tr class="separator:aadff4be4c08e05e21a85b419e20d715e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc1fc61827040cef34f1168e9b85654"><td class="memItemLeft" align="right" valign="top">MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a5fc1fc61827040cef34f1168e9b85654">get_mpi_communicator</a> () const</td></tr>
<tr class="separator:a5fc1fc61827040cef34f1168e9b85654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Partitioners</div></td></tr>
<tr class="memitem:a160d8f260208908009d31833a40b1740"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a160d8f260208908009d31833a40b1740">locally_owned_domain_indices</a> () const</td></tr>
<tr class="separator:a160d8f260208908009d31833a40b1740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04337c1541b42be7a838f05e109f890"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#aa04337c1541b42be7a838f05e109f890">locally_owned_range_indices</a> () const</td></tr>
<tr class="separator:aa04337c1541b42be7a838f05e109f890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterators</div></td></tr>
<tr class="memitem:ac265d5f0b47e509bb072f5b510843374"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ac6b2dfb2472ca96c605cf1685c5bd071">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ac265d5f0b47e509bb072f5b510843374">begin</a> () const</td></tr>
<tr class="separator:ac265d5f0b47e509bb072f5b510843374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb8a213b7d941e0c2bcef057187fa62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ac6b2dfb2472ca96c605cf1685c5bd071">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a5cb8a213b7d941e0c2bcef057187fa62">end</a> () const</td></tr>
<tr class="separator:a5cb8a213b7d941e0c2bcef057187fa62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e070b5ada89c9bbb3d09ea8a854b857"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ac6b2dfb2472ca96c605cf1685c5bd071">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a6e070b5ada89c9bbb3d09ea8a854b857">begin</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> r) const</td></tr>
<tr class="separator:a6e070b5ada89c9bbb3d09ea8a854b857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac292d5930f1a30b8710e47ef8d2190d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ac6b2dfb2472ca96c605cf1685c5bd071">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ac292d5930f1a30b8710e47ef8d2190d5">end</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> r) const</td></tr>
<tr class="separator:ac292d5930f1a30b8710e47ef8d2190d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Input/Output</h2></td></tr>
<tr class="memitem:gaac42b285ad4243d4ad16d195fd4b5551"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; Epetra_Map &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaac42b285ad4243d4ad16d195fd4b5551">column_space_map</a></td></tr>
<tr class="separator:gaac42b285ad4243d4ad16d195fd4b5551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35f91d854cbcbfea97bf753ef967a704"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; Epetra_FECrsGraph &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga35f91d854cbcbfea97bf753ef967a704">graph</a></td></tr>
<tr class="separator:ga35f91d854cbcbfea97bf753ef967a704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7893dbc7f77cea41f743dc0fcdcf1761"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; Epetra_CrsGraph &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7893dbc7f77cea41f743dc0fcdcf1761">nonlocal_graph</a></td></tr>
<tr class="separator:ga7893dbc7f77cea41f743dc0fcdcf1761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc95297e71ae389ccc2eae891fa6874b"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gadc95297e71ae389ccc2eae891fa6874b">TrilinosWrappers::SparseMatrix</a></td></tr>
<tr class="separator:gadc95297e71ae389ccc2eae891fa6874b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1f9cdd2797ea0f1ebbec7878d2cd1be"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gab1f9cdd2797ea0f1ebbec7878d2cd1be">SparsityPatternIterators::Accessor</a></td></tr>
<tr class="separator:gab1f9cdd2797ea0f1ebbec7878d2cd1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga788687eb290f58f6accdff6098d5f492"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga788687eb290f58f6accdff6098d5f492">SparsityPatternIterators::Iterator</a></td></tr>
<tr class="separator:ga788687eb290f58f6accdff6098d5f492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c6fcea474532b8163853c37d4baa8fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga6c6fcea474532b8163853c37d4baa8fc">write_ascii</a> ()</td></tr>
<tr class="separator:ga6c6fcea474532b8163853c37d4baa8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bc8e9afc389934b74ad9de0232e3e34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga4bc8e9afc389934b74ad9de0232e3e34">print</a> (std::ostream &amp;out, const <a class="el" href="classbool.html">bool</a> write_extended_trilinos_info=false) const</td></tr>
<tr class="separator:ga4bc8e9afc389934b74ad9de0232e3e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga536d0aed80f9dbbdc3c852a55a339027"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga536d0aed80f9dbbdc3c852a55a339027">print_gnuplot</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:ga536d0aed80f9dbbdc3c852a55a339027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23285e3d83dc3080af284b52b06283f7"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga23285e3d83dc3080af284b52b06283f7">ExcTrilinosError</a> (int arg1)</td></tr>
<tr class="separator:ga23285e3d83dc3080af284b52b06283f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99ce8a113d6a82c2adaf91518572829a"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga99ce8a113d6a82c2adaf91518572829a">ExcInvalidIndex</a> (<a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> arg1, <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> arg2)</td></tr>
<tr class="separator:ga99ce8a113d6a82c2adaf91518572829a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89e7d450dad90efe8b1f56f526c94ca0"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga89e7d450dad90efe8b1f56f526c94ca0">ExcSourceEqualsDestination</a> ()</td></tr>
<tr class="separator:ga89e7d450dad90efe8b1f56f526c94ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19c75164a9be288f84a40844baa4a872"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga19c75164a9be288f84a40844baa4a872">ExcAccessToNonLocalElement</a> (<a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> arg1, <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> arg2, <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> arg3, <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> arg4)</td></tr>
<tr class="separator:ga19c75164a9be288f84a40844baa4a872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37a1f5cbf2d462ded59a999c0f14c55f"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga37a1f5cbf2d462ded59a999c0f14c55f">ExcAccessToNonPresentElement</a> (<a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> arg1, <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> arg2)</td></tr>
<tr class="separator:ga37a1f5cbf2d462ded59a999c0f14c55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Subscriptor functionality</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp8d6bc922eebec0b76272099aee4a220d"></a>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</td></tr>
<tr class="memitem:ga20658b60d6ef2d530fafa076efa9f503"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga20658b60d6ef2d530fafa076efa9f503">counter</a></td></tr>
<tr class="separator:ga20658b60d6ef2d530fafa076efa9f503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73f9f8936b61e6e17ab2a82e9516e95b"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga73f9f8936b61e6e17ab2a82e9516e95b">counter_map</a></td></tr>
<tr class="separator:ga73f9f8936b61e6e17ab2a82e9516e95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga094d5932c6c004c2a2b1b966950fb2f7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga094d5932c6c004c2a2b1b966950fb2f7">validity_pointers</a></td></tr>
<tr class="separator:ga094d5932c6c004c2a2b1b966950fb2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44e13f7984b31af8d7c54921175a75ff"><td class="memItemLeft" align="right" valign="top">const std::type_info *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga44e13f7984b31af8d7c54921175a75ff">object_info</a></td></tr>
<tr class="separator:ga44e13f7984b31af8d7c54921175a75ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned int version)</td></tr>
<tr class="separator:ga68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (int arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaeb9ac67567aa7d837f25debd33cd4ce5">map_value_type</a> = decltype(<a class="el" href="group__Exceptions.html#ga73f9f8936b61e6e17ab2a82e9516e95b">counter_map</a>)::value_type</td></tr>
<tr class="separator:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacebdc2d11f8522e4d9e8b7d73ac3f491">map_iterator</a> = decltype(<a class="el" href="group__Exceptions.html#ga73f9f8936b61e6e17ab2a82e9516e95b">counter_map</a>)::iterator</td></tr>
<tr class="separator:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e0d86893427a935e46d5bd6dcbc3f78"><td class="memItemLeft" align="right" valign="top">static std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7e0d86893427a935e46d5bd6dcbc3f78">mutex</a></td></tr>
<tr class="separator:ga7e0d86893427a935e46d5bd6dcbc3f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga300c593ea0f9422dcbce1445903e6c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga300c593ea0f9422dcbce1445903e6c12">check_no_subscribers</a> () const noexcept</td></tr>
<tr class="separator:ga300c593ea0f9422dcbce1445903e6c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class implements a wrapper class to use the Trilinos distributed sparsity pattern class Epetra_FECrsGraph. This class is designed to be used for construction of parallel Trilinos matrices. The functionality of this class is modeled after the existing sparsity pattern classes, with the difference that this class can work fully in parallel according to a partitioning of the sparsity pattern rows.</p>
<p>This class has many similarities to the <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>, since it can dynamically add elements to the pattern without any memory being previously reserved for it. However, it also has a method <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ad15d36e4bfe7c97b55d155541e723284">SparsityPattern::compress()</a>, that finalizes the pattern and enables its use with Trilinos sparse matrices. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8h_source.html#l00276">276</a> of file <a class="el" href="trilinos__sparsity__pattern_8h_source.html">trilinos_sparsity_pattern.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a86ccc640efbc58b74436f554e5edef08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86ccc640efbc58b74436f554e5edef08">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">TrilinosWrappers::SparsityPattern::size_type</a> =  ::<a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare type for container size. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8h_source.html#l00282">282</a> of file <a class="el" href="trilinos__sparsity__pattern_8h_source.html">trilinos_sparsity_pattern.h</a>.</p>

</div>
</div>
<a id="ac6b2dfb2472ca96c605cf1685c5bd071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6b2dfb2472ca96c605cf1685c5bd071">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ac6b2dfb2472ca96c605cf1685c5bd071">TrilinosWrappers::SparsityPattern::const_iterator</a> =  <a class="el" href="classTrilinosWrappers_1_1SparsityPatternIterators_1_1Iterator.html">SparsityPatternIterators::Iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare an alias for the iterator class. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8h_source.html#l00287">287</a> of file <a class="el" href="trilinos__sparsity__pattern_8h_source.html">trilinos_sparsity_pattern.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1e3d417090f12ad51343a170d11e1841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e3d417090f12ad51343a170d11e1841">&#9670;&nbsp;</a></span>SparsityPattern() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SparsityPattern::SparsityPattern </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor. Generates an empty (zero-size) sparsity pattern. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00083">83</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="ace3646f098f0c942f72da148212a1819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace3646f098f0c942f72da148212a1819">&#9670;&nbsp;</a></span>SparsityPattern() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SparsityPattern::SparsityPattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a>&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a sparsity pattern that is completely stored locally, having \(m\) rows and \(n\) columns. The resulting matrix will be completely stored locally, too.</p>
<p>It is possible to specify the number of columns entries per row using the optional <code>n_entries_per_row</code> argument. However, this value does not need to be accurate or even given at all, since one does usually not have this kind of information before building the sparsity pattern (the usual case when the function <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern()</a> is called). The entries are allocated dynamically in a similar manner as for the deal.II <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> classes. However, a good estimate will reduce the setup time of the sparsity pattern. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00098">98</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="ae11df72241b9b3e9c690270dec120df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae11df72241b9b3e9c690270dec120df5">&#9670;&nbsp;</a></span>SparsityPattern() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SparsityPattern::SparsityPattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a sparsity pattern that is completely stored locally, having \(m\) rows and \(n\) columns. The resulting matrix will be completely stored locally, too.</p>
<p>The vector <code>n_entries_per_row</code> specifies the number of entries in each row (an information usually not available, though). </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00107">107</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="aec851eaaeffd3b67c31741f59a856003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec851eaaeffd3b67c31741f59a856003">&#9670;&nbsp;</a></span>SparsityPattern() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SparsityPattern::SparsityPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor. Create a new sparse matrix by stealing the internal data. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00117">117</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="a0f3e1e19863631ed6dc013a5f627f8e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f3e1e19863631ed6dc013a5f627f8e6">&#9670;&nbsp;</a></span>SparsityPattern() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SparsityPattern::SparsityPattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>input_sparsity_pattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor. Sets the calling sparsity pattern to be the same as the input sparsity pattern. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00128">128</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="af2a0c7875dd25bef3b8feac538fda1c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2a0c7875dd25bef3b8feac538fda1c6">&#9670;&nbsp;</a></span>~SparsityPattern()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual TrilinosWrappers::SparsityPattern::~SparsityPattern </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. Made virtual so that one can use pointers to this class. </p>

</div>
</div>
<a id="ac71f2bb0b9377af30a419a56d9775f31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac71f2bb0b9377af30a419a56d9775f31">&#9670;&nbsp;</a></span>SparsityPattern() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SparsityPattern::SparsityPattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a>&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for a square sparsity pattern using an <a class="el" href="classIndexSet.html">IndexSet</a> and an <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> communicator for the description of the parallel partitioning. Moreover, the number of nonzero entries in the rows of the sparsity pattern can be specified. Note that this number does not need to be exact, and it is even allowed that the actual sparsity structure has more nonzero entries than specified in the constructor. However it is still advantageous to provide good estimates here since a good value will avoid repeated allocation of memory, which considerably increases the performance when creating the sparsity pattern. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00144">144</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="acac67dd2dc9f638aee4848fc00a5ae12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac67dd2dc9f638aee4848fc00a5ae12">&#9670;&nbsp;</a></span>SparsityPattern() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SparsityPattern::SparsityPattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as before, but now use the exact number of nonzeros in each m row. Since we know the number of elements in the sparsity pattern exactly in this case, we can already allocate the right amount of memory, which makes the creation process by the respective <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#afc653a77d0c78d0f7905b3a8f5cb7ac4">SparsityPattern::reinit</a> call considerably faster. However, this is a rather unusual situation, since knowing the number of entries in each row is usually connected to knowing the indices of nonzero entries, which the sparsity pattern is designed to describe. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00156">156</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="acb99b2ea1f6f184ccbef7009bf3c2a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb99b2ea1f6f184ccbef7009bf3c2a13">&#9670;&nbsp;</a></span>SparsityPattern() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SparsityPattern::SparsityPattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a>&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This constructor is similar to the one above, but it now takes two different index sets to describe the parallel partitioning of rows and columns. This interface is meant to be used for generating rectangular sparsity pattern. Note that there is no real parallelism along the columns &ndash; the processor that owns a certain row always owns all the column elements, no matter how far they might be spread out. The second Epetra_Map is only used to specify the number of columns and for internal arrangements when doing matrix-vector products with vectors based on that column map.</p>
<p>The number of columns entries per row is specified as the maximum number of entries argument. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00169">169</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="a2c44e5e388d2b9a42a9e968de746461f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c44e5e388d2b9a42a9e968de746461f">&#9670;&nbsp;</a></span>SparsityPattern() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SparsityPattern::SparsityPattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This constructor is similar to the one above, but it now takes two different index sets for rows and columns. This interface is meant to be used for generating rectangular matrices, where one map specifies the parallel distribution of rows and the second one specifies the distribution of degrees of freedom associated with matrix columns. This second map is however not used for the distribution of the columns themselves &ndash; rather, all column elements of a row are stored on the same processor. The vector <code>n_entries_per_row</code> specifies the number of entries in each row of the newly generated matrix. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00182">182</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="ae126b94fc7b75f938ad9c750d1352184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae126b94fc7b75f938ad9c750d1352184">&#9670;&nbsp;</a></span>SparsityPattern() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SparsityPattern::SparsityPattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>writable_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a>&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This constructor constructs general sparsity patterns, possible non- square ones. Constructing a sparsity pattern this way allows the user to explicitly specify the rows into which we are going to add elements. This set is required to be a superset of the first index set <code>row_parallel_partitioning</code> that includes also rows that are owned by another processor (ghost rows). Note that elements can only be added to rows specified by <code>writable_rows</code>.</p>
<p>This method is beneficial when the rows to which a processor is going to write can be determined before actually inserting elements into the matrix. For the typical <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> class used in deal.II, we know that a processor only will add row elements for what we call the locally relevant dofs (see <a class="el" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>). The other constructors methods use general Trilinos facilities that allow to add elements to arbitrary rows (as done by all the other reinit functions). However, this flexibility come at a cost, the most prominent being that adding elements into the same matrix from multiple threads in shared memory is not safe whenever <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> is used. For these settings, the current method is the one to choose: It will store the off-processor data as an additional sparsity pattern (that is then passed to the Trilinos matrix via the reinit method) which can be organized in such a way that thread-safety can be ensured (as long as the user makes sure to never write into the same matrix row simultaneously, of course). </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00196">196</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afc653a77d0c78d0f7905b3a8f5cb7ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc653a77d0c78d0f7905b3a8f5cb7ac4">&#9670;&nbsp;</a></span>reinit() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a>&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a sparsity pattern that is completely stored locally, having \(m\) rows and \(n\) columns. The resulting matrix will be completely stored locally.</p>
<p>The number of columns entries per row is specified as the maximum number of entries argument. This does not need to be an accurate number since the entries are allocated dynamically in a similar manner as for the deal.II <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> classes, but a good estimate will reduce the setup time of the sparsity pattern. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00212">212</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="ac1ee2428b936269e24b12a23c81c2971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ee2428b936269e24b12a23c81c2971">&#9670;&nbsp;</a></span>reinit() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a sparsity pattern that is completely stored locally, having \(m\) rows and \(n\) columns. The resulting matrix will be completely stored locally.</p>
<p>The vector <code>n_entries_per_row</code> specifies the number of entries in each row. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00225">225</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="a9f10ff6d940578bd0603de91fbabe54f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f10ff6d940578bd0603de91fbabe54f">&#9670;&nbsp;</a></span>copy_from() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPattern::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>input_sparsity_pattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy function. Sets the calling sparsity pattern to be the same as the input sparsity pattern. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00607">607</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="aa5e71032d26253157b73afac0750b022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5e71032d26253157b73afac0750b022">&#9670;&nbsp;</a></span>copy_from() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPattern::copy_from </td>
          <td>(</td>
          <td class="paramtype">const SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>nontrilinos_sparsity_pattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy function from one of the deal.II sparsity patterns. If used in parallel, this function uses an ad-hoc partitioning of the rows and columns. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00622">622</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="af83efc6edec53e1104b1a18b4852dd78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af83efc6edec53e1104b1a18b4852dd78">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> &amp; SparsityPattern::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>input_sparsity_pattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy operator. This operation is only allowed for empty objects, to avoid potentially very costly operations automatically synthesized by the compiler. Use <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a9f10ff6d940578bd0603de91fbabe54f">copy_from()</a> instead if you know that you really want to copy a sparsity pattern with non-trivial content. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00598">598</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="a1799ef4b2431ad7ece54fd1766810dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1799ef4b2431ad7ece54fd1766810dea">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPattern::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release all memory and return to a state just like after having called the default constructor.</p>
<p>This is a collective operation that needs to be called on all processors in order to avoid a dead lock. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00638">638</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="ad15d36e4bfe7c97b55d155541e723284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad15d36e4bfe7c97b55d155541e723284">&#9670;&nbsp;</a></span>compress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPattern::compress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In analogy to our own <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> class, this function compresses the sparsity pattern and allows the resulting pattern to be used for actually generating a (Trilinos-based) matrix. This function also exchanges non-local data that might have accumulated during the addition of new elements. This function must therefore be called once the structure is fixed. This is a collective operation, i.e., it needs to be run on all processors when used in parallel. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00659">659</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="ab07258537f85162c220bd08cc0d45e09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab07258537f85162c220bd08cc0d45e09">&#9670;&nbsp;</a></span>reinit() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a>&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinitialization function for generating a square sparsity pattern using an <a class="el" href="classIndexSet.html">IndexSet</a> and an <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> communicator for the description of the parallel partitioning and the number of nonzero entries in the rows of the sparsity pattern. Note that this number does not need to be exact, and it is even allowed that the actual sparsity structure has more nonzero entries than specified in the constructor. However it is still advantageous to provide good estimates here since this will considerably increase the performance when creating the sparsity pattern.</p>
<p>This function does not create any entries by itself, but provides the correct data structures that can be used by the respective <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a4a411ae74d053f5ab1b85e885d637cd2">add()</a> function. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00443">443</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="aa500755e481b287781bd6b6f8aad64cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa500755e481b287781bd6b6f8aad64cd">&#9670;&nbsp;</a></span>reinit() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as before, but now use the exact number of nonzeros in each m row. Since we know the number of elements in the sparsity pattern exactly in this case, we can already allocate the right amount of memory, which makes process of adding entries to the sparsity pattern considerably faster. However, this is a rather unusual situation, since knowing the number of entries in each row is usually connected to knowing the indices of nonzero entries, which the sparsity pattern is designed to describe. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00456">456</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="ad13406ea8005028cb9ae4329f995c2c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad13406ea8005028cb9ae4329f995c2c8">&#9670;&nbsp;</a></span>reinit() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a>&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This reinit function is similar to the one above, but it now takes two different index sets for rows and columns. This interface is meant to be used for generating rectangular sparsity pattern, where one index set describes the parallel partitioning of the dofs associated with the sparsity pattern rows and the other one of the sparsity pattern columns. Note that there is no real parallelism along the columns &ndash; the processor that owns a certain row always owns all the column elements, no matter how far they might be spread out. The second <a class="el" href="classIndexSet.html">IndexSet</a> is only used to specify the number of columns and for internal arrangements when doing matrix-vector products with vectors based on an EpetraMap based on that <a class="el" href="classIndexSet.html">IndexSet</a>.</p>
<p>The number of columns entries per row is specified by the argument <code>n_entries_per_row</code>. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00469">469</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="a15eb08788778df9dbe75b448fdcabc69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15eb08788778df9dbe75b448fdcabc69">&#9670;&nbsp;</a></span>reinit() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>writeable_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a>&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This reinit function is used to specify general matrices, possibly non- square ones. In addition to the arguments of the other reinit method above, it allows the user to explicitly specify the rows into which we are going to add elements. This set is a superset of the first index set <code>row_parallel_partitioning</code> that includes also rows that are owned by another processor (ghost rows).</p>
<p>This method is beneficial when the rows to which a processor is going to write can be determined before actually inserting elements into the matrix. For the typical <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> class used in deal.II, we know that a processor only will add row elements for what we call the locally relevant dofs (see <a class="el" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>). Trilinos matrices allow to add elements to arbitrary rows (as done by all the other reinit functions) and this is what all the other reinit methods do, too. However, this flexibility come at a cost, the most prominent being that adding elements into the same matrix from multiple threads in shared memory is not safe whenever <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> is used. For these settings, the current method is the one to choose: It will store the off-processor data as an additional sparsity pattern (that is then passed to the Trilinos matrix via the reinit method) which can be organized in such a way that thread-safety can be ensured (as long as the user makes sure to never write into the same matrix row simultaneously, of course). </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00509">509</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="aacb9b09f4fcb1a13fefee40e9f95bed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacb9b09f4fcb1a13fefee40e9f95bed5">&#9670;&nbsp;</a></span>reinit() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as before, but now using a vector <code>n_entries_per_row</code> for specifying the number of entries in each row of the sparsity pattern. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00489">489</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="ada9c95633efce73ce7736c8f810ff5f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada9c95633efce73ce7736c8f810ff5f1">&#9670;&nbsp;</a></span>reinit() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>nontrilinos_sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>exchange_data</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinit function. Takes one of the deal.II sparsity patterns and the parallel partitioning of the rows and columns specified by two index sets and a parallel communicator for initializing the current Trilinos sparsity pattern. The optional argument <code>exchange_data</code> can be used for reinitialization with a sparsity pattern that is not fully constructed. This feature is only implemented for input sparsity patterns of type <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00554">554</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="adb92eb9a8f88aac094818586e6dd3026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb92eb9a8f88aac094818586e6dd3026">&#9670;&nbsp;</a></span>reinit() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SparsityPattern::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>nontrilinos_sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>exchange_data</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinit function. Takes one of the deal.II sparsity patterns and a parallel partitioning of the rows and columns for initializing the current Trilinos sparsity pattern. The optional argument <code>exchange_data</code> can be used for reinitialization with a sparsity pattern that is not fully constructed. This feature is only implemented for input sparsity patterns of type <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00578">578</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="a935abd1908d1ed387625143f305daa2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a935abd1908d1ed387625143f305daa2b">&#9670;&nbsp;</a></span>is_compressed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TrilinosWrappers::SparsityPattern::is_compressed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the state of the sparsity pattern, i.e., whether <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ad15d36e4bfe7c97b55d155541e723284">compress()</a> needs to be called after an operation requiring data exchange. </p>

</div>
</div>
<a id="a4cee9e81898214ced961dd7f83039c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cee9e81898214ced961dd7f83039c26">&#9670;&nbsp;</a></span>max_entries_per_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int SparsityPattern::max_entries_per_row </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the maximum number of entries per row on the current processor. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00891">891</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="aca8bac57fd30db178feb6dc022b6cd49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca8bac57fd30db178feb6dc022b6cd49">&#9670;&nbsp;</a></span>n_rows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">SparsityPattern::size_type</a> SparsityPattern::n_rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of rows in this sparsity pattern. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00836">836</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="a7a9e1e9696ac8ebf46e111471c06f2b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a9e1e9696ac8ebf46e111471c06f2b1">&#9670;&nbsp;</a></span>n_cols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">SparsityPattern::size_type</a> SparsityPattern::n_cols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of columns in this sparsity pattern. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00845">845</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="a9942b99f5b3d361dff7e53fc64b70ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9942b99f5b3d361dff7e53fc64b70ba4">&#9670;&nbsp;</a></span>local_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int SparsityPattern::local_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the local dimension of the sparsity pattern, i.e. the number of rows stored on the present <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> process. In the sequential case, this number is the same as <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#aca8bac57fd30db178feb6dc022b6cd49">n_rows()</a>, but for parallel matrices it may be smaller.</p>
<p>To figure out which elements exactly are stored locally, use <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a7ea819a20d1ed86f583ae0ded100e924">local_range()</a>. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00859">859</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="a7ea819a20d1ed86f583ae0ded100e924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ea819a20d1ed86f583ae0ded100e924">&#9670;&nbsp;</a></span>local_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">SparsityPattern::size_type</a>, <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">SparsityPattern::size_type</a> &gt; SparsityPattern::local_range </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pair of indices indicating which rows of this sparsity pattern are stored locally. The first number is the index of the first row stored, the second the index of the one past the last one that is stored locally. If this is a sequential matrix, then the result will be the pair (0,<a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#aca8bac57fd30db178feb6dc022b6cd49">n_rows()</a>), otherwise it will be a pair (i,i+n), where <code>n=<a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a9942b99f5b3d361dff7e53fc64b70ba4">local_size()</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00869">869</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="adbf60d4968439ee59816e3b7b55bd3ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf60d4968439ee59816e3b7b55bd3ed">&#9670;&nbsp;</a></span>in_local_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TrilinosWrappers::SparsityPattern::in_local_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether <code>index</code> is in the local range or not, see also <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a7ea819a20d1ed86f583ae0ded100e924">local_range()</a>. </p>

</div>
</div>
<a id="a867d59927f51777f5420e290f755105c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a867d59927f51777f5420e290f755105c">&#9670;&nbsp;</a></span>n_nonzero_elements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">SparsityPattern::size_type</a> SparsityPattern::n_nonzero_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of nonzero elements of this sparsity pattern. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00881">881</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="a2993cee1717e5ed363efc93667a995ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2993cee1717e5ed363efc93667a995ff">&#9670;&nbsp;</a></span>row_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">SparsityPattern::size_type</a> SparsityPattern::row_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of entries in the given row.</p>
<p>In a parallel context, the row in question may of course not be stored on the current processor, and in that case it is not possible to query the number of entries in it. In that case, the returned value is <code>static_cast&lt;size_type&gt;(-1)</code>. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00901">901</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="a4de65b796c44a6dcc51c6cd8af7cb9f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4de65b796c44a6dcc51c6cd8af7cb9f9">&#9670;&nbsp;</a></span>bandwidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">SparsityPattern::size_type</a> SparsityPattern::bandwidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the bandwidth of the matrix represented by this structure. The bandwidth is the maximum of \(|i-j|\) for which the index pair \((i,j)\) represents a nonzero entry of the matrix. Consequently, the maximum bandwidth a \(n\times m\) matrix can have is \(\max\{n-1,m-1\}\). </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00810">810</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="add300e272c6507cd021dfa0cc9919420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add300e272c6507cd021dfa0cc9919420">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TrilinosWrappers::SparsityPattern::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the object is empty. It is empty if no memory is allocated, which is the same as when both dimensions are zero. </p>

</div>
</div>
<a id="a793339eeff73a74d317a08cdd0c8c4ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a793339eeff73a74d317a08cdd0c8c4ff">&#9670;&nbsp;</a></span>exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> SparsityPattern::exists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the index (<em>i,j</em>) exists in the sparsity pattern (i.e., it may be non-zero) or not. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00729">729</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="afc28342549ed2b2b39543a1709820cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc28342549ed2b2b39543a1709820cff">&#9670;&nbsp;</a></span>row_is_stored_locally()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> SparsityPattern::row_is_stored_locally </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether a given <code>row</code> is stored in the current object on this process. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00720">720</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="af32a20c0a31a67133750ecd45f8a498c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af32a20c0a31a67133750ecd45f8a498c">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t SparsityPattern::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. Currently not implemented for this class. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l01030">1030</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="a4a411ae74d053f5ab1b85e885d637cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a411ae74d053f5ab1b85e885d637cd2">&#9670;&nbsp;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparsityPattern::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add the element (<em>i,j</em>) to the sparsity pattern. </p>

</div>
</div>
<a id="a90cfaf7a56fb9c2c012e0cf692f57e41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90cfaf7a56fb9c2c012e0cf692f57e41">&#9670;&nbsp;</a></span>add_entries()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparsityPattern::add_entries </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>indices_are_sorted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add several elements in one row to the sparsity pattern. </p>

</div>
</div>
<a id="aea54c88d353d85742ff7b1555e2a18b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea54c88d353d85742ff7b1555e2a18b6">&#9670;&nbsp;</a></span>trilinos_sparsity_pattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Epetra_FECrsGraph&amp; TrilinosWrappers::SparsityPattern::trilinos_sparsity_pattern </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a const reference to the underlying Trilinos Epetra_CrsGraph data that stores the sparsity pattern. </p>

</div>
</div>
<a id="a7964bb2b0e2a104f9cc3ffca09ff73e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7964bb2b0e2a104f9cc3ffca09ff73e1">&#9670;&nbsp;</a></span>domain_partitioner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Epetra_Map &amp; SparsityPattern::domain_partitioner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a const reference to the underlying Trilinos Epetra_Map that sets the parallel partitioning of the domain space of this sparsity pattern, i.e., the partitioning of the vectors matrices based on this sparsity pattern are multiplied with. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00921">921</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="aadff4be4c08e05e21a85b419e20d715e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadff4be4c08e05e21a85b419e20d715e">&#9670;&nbsp;</a></span>range_partitioner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Epetra_Map &amp; SparsityPattern::range_partitioner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a const reference to the underlying Trilinos Epetra_Map that sets the partitioning of the range space of this sparsity pattern, i.e., the partitioning of the vectors that are result from matrix- vector products. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00932">932</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="a5fc1fc61827040cef34f1168e9b85654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fc1fc61827040cef34f1168e9b85654">&#9670;&nbsp;</a></span>get_mpi_communicator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPI_Comm SparsityPattern::get_mpi_communicator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> communicator object in use with this matrix. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparsity__pattern_8cc_source.html#l00943">943</a> of file <a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a>.</p>

</div>
</div>
<a id="a160d8f260208908009d31833a40b1740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a160d8f260208908009d31833a40b1740">&#9670;&nbsp;</a></span>locally_owned_domain_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> TrilinosWrappers::SparsityPattern::locally_owned_domain_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the partitioning of the domain space of this pattern, i.e., the partitioning of the vectors a matrix based on this sparsity pattern has to be multiplied with. </p>

</div>
</div>
<a id="aa04337c1541b42be7a838f05e109f890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa04337c1541b42be7a838f05e109f890">&#9670;&nbsp;</a></span>locally_owned_range_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> TrilinosWrappers::SparsityPattern::locally_owned_range_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the partitioning of the range space of this pattern, i.e., the partitioning of the vectors that are the result from matrix-vector products from a matrix based on this pattern. </p>

</div>
</div>
<a id="ac265d5f0b47e509bb072f5b510843374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac265d5f0b47e509bb072f5b510843374">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ac6b2dfb2472ca96c605cf1685c5bd071">const_iterator</a> TrilinosWrappers::SparsityPattern::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterator starting at the first entry. </p>

</div>
</div>
<a id="a5cb8a213b7d941e0c2bcef057187fa62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cb8a213b7d941e0c2bcef057187fa62">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ac6b2dfb2472ca96c605cf1685c5bd071">const_iterator</a> TrilinosWrappers::SparsityPattern::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Final iterator. </p>

</div>
</div>
<a id="a6e070b5ada89c9bbb3d09ea8a854b857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e070b5ada89c9bbb3d09ea8a854b857">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ac6b2dfb2472ca96c605cf1685c5bd071">const_iterator</a> TrilinosWrappers::SparsityPattern::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterator starting at the first entry of row <code>r</code>.</p>
<p>Note that if the given row is empty, i.e. does not contain any nonzero entries, then the iterator returned by this function equals <code>end(r)</code>. Note also that the iterator may not be dereferenceable in that case. </p>

</div>
</div>
<a id="ac292d5930f1a30b8710e47ef8d2190d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac292d5930f1a30b8710e47ef8d2190d5">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#ac6b2dfb2472ca96c605cf1685c5bd071">const_iterator</a> TrilinosWrappers::SparsityPattern::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html#a86ccc640efbc58b74436f554e5edef08">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Final iterator of row <code>r</code>. It points to the first element past the end of line <code>r</code>, or past the end of the entire sparsity pattern.</p>
<p>Note that the end iterator is not necessarily dereferenceable. This is in particular the case if it is the end iterator for the last row of a matrix. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/lac/<a class="el" href="trilinos__sparsity__pattern_8h_source.html">trilinos_sparsity_pattern.h</a></li>
<li>source/lac/<a class="el" href="trilinos__sparsity__pattern_8cc_source.html">trilinos_sparsity_pattern.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
