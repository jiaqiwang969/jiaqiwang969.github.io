<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classSparseMIC.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: SparseMIC&lt; number &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.3.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.3.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classSparseMIC-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SparseMIC&lt; number &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a> &#124; <a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__Matrices.html">Matrix classes</a> &raquo; <a class="el" href="group__Preconditioners.html">Preconditioners and Relaxation Operators</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="sparse__mic_8h_source.html">deal.II/lac/sparse_mic.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SparseMIC&lt; number &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classSparseMIC__inherit__graph.svg" width="239" height="276"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ga05828a9574736b4ff27feb73609ba1d7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Preconditioners.html#ga05828a9574736b4ff27feb73609ba1d7">size_type</a> = <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td></tr>
<tr class="separator:ga05828a9574736b4ff27feb73609ba1d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a620a3f4f3555a211bbea3be4443939"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Preconditioners.html#ga4a620a3f4f3555a211bbea3be4443939">AdditionalData</a> = typename <a class="el" href="classSparseLUDecomposition.html">SparseLUDecomposition</a>&lt; number &gt;::<a class="el" href="group__Preconditioners.html#ga4a620a3f4f3555a211bbea3be4443939">AdditionalData</a></td></tr>
<tr class="separator:ga4a620a3f4f3555a211bbea3be4443939"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ga4cc6d27c98cf0478c8a57a459e471df8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Preconditioners.html#ga4cc6d27c98cf0478c8a57a459e471df8">SparseMIC</a> ()</td></tr>
<tr class="separator:ga4cc6d27c98cf0478c8a57a459e471df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9624c4c32cfc6c3eeaa6a045a4afc21f"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Preconditioners.html#ga9624c4c32cfc6c3eeaa6a045a4afc21f">~SparseMIC</a> () override</td></tr>
<tr class="separator:ga9624c4c32cfc6c3eeaa6a045a4afc21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac82e3f7a7e669fbe1c2a3f9624f02586"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Preconditioners.html#gac82e3f7a7e669fbe1c2a3f9624f02586">clear</a> () override</td></tr>
<tr class="separator:gac82e3f7a7e669fbe1c2a3f9624f02586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49dab4dfd7aeb4394bc1bc2a90828203"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:ga49dab4dfd7aeb4394bc1bc2a90828203"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Preconditioners.html#ga49dab4dfd7aeb4394bc1bc2a90828203">initialize</a> (const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; somenumber &gt; &amp;matrix, const <a class="el" href="group__Preconditioners.html#ga4a620a3f4f3555a211bbea3be4443939">AdditionalData</a> &amp;parameters=<a class="el" href="group__Preconditioners.html#ga4a620a3f4f3555a211bbea3be4443939">AdditionalData</a>())</td></tr>
<tr class="separator:ga49dab4dfd7aeb4394bc1bc2a90828203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e3c0e1eeebeb2b3124c5af0895e91b4"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:ga5e3c0e1eeebeb2b3124c5af0895e91b4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Preconditioners.html#ga5e3c0e1eeebeb2b3124c5af0895e91b4">vmult</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;src) const</td></tr>
<tr class="separator:ga5e3c0e1eeebeb2b3124c5af0895e91b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6c10ad5b2938fde6b1bfc3c83e83000"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:gae6c10ad5b2938fde6b1bfc3c83e83000"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Preconditioners.html#gae6c10ad5b2938fde6b1bfc3c83e83000">Tvmult</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;src) const</td></tr>
<tr class="separator:gae6c10ad5b2938fde6b1bfc3c83e83000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5feb4b9d38d4a2cb13a2738bceeb1903"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Preconditioners.html#ga5feb4b9d38d4a2cb13a2738bceeb1903">memory_consumption</a> () const override</td></tr>
<tr class="separator:ga5feb4b9d38d4a2cb13a2738bceeb1903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfe20d0c20e2adb57d89210299254274"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:gacfe20d0c20e2adb57d89210299254274"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Preconditioners.html#gacfe20d0c20e2adb57d89210299254274">initialize</a> (const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; somenumber &gt; &amp;matrix, const <a class="el" href="group__Preconditioners.html#ga4a620a3f4f3555a211bbea3be4443939">AdditionalData</a> parameters)</td></tr>
<tr class="separator:gacfe20d0c20e2adb57d89210299254274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9e1942e50a699cf9417969df9c9aee3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Preconditioners.html#gad9e1942e50a699cf9417969df9c9aee3">empty</a> () const</td></tr>
<tr class="separator:gad9e1942e50a699cf9417969df9c9aee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71242d5c14a00bb6aba2c5af0c9065f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Preconditioners.html#ga71242d5c14a00bb6aba2c5af0c9065f1">m</a> () const</td></tr>
<tr class="separator:ga71242d5c14a00bb6aba2c5af0c9065f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b880c1fe466587f4199271ea2ecc316"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Preconditioners.html#ga6b880c1fe466587f4199271ea2ecc316">n</a> () const</td></tr>
<tr class="separator:ga6b880c1fe466587f4199271ea2ecc316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f5b7ebc0f720cddcc4b2407a0f37758"><td class="memTemplParams" colspan="2">template&lt;class OutVector , class InVector &gt; </td></tr>
<tr class="memitem:ga8f5b7ebc0f720cddcc4b2407a0f37758"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Preconditioners.html#ga8f5b7ebc0f720cddcc4b2407a0f37758">vmult_add</a> (OutVector &amp;dst, const InVector &amp;src) const</td></tr>
<tr class="separator:ga8f5b7ebc0f720cddcc4b2407a0f37758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ab34f131cd580d739a30eab32bba6a9"><td class="memTemplParams" colspan="2">template&lt;class OutVector , class InVector &gt; </td></tr>
<tr class="memitem:ga6ab34f131cd580d739a30eab32bba6a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Preconditioners.html#ga6ab34f131cd580d739a30eab32bba6a9">Tvmult_add</a> (OutVector &amp;dst, const InVector &amp;src) const</td></tr>
<tr class="separator:ga6ab34f131cd580d739a30eab32bba6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ga6330f751107c982da93e48f53d7273f1"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga6330f751107c982da93e48f53d7273f1">ExcStrengthenDiagonalTooSmall</a> ()</td></tr>
<tr class="separator:ga6330f751107c982da93e48f53d7273f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e50db529086ae94bbf5086dab2321de"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga1e50db529086ae94bbf5086dab2321de">ExcInvalidStrengthening</a> (<a class="el" href="classdouble.html">double</a> arg1)</td></tr>
<tr class="separator:ga1e50db529086ae94bbf5086dab2321de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacab9d1c4bdf6b0510853aac25a0f4ea6"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacab9d1c4bdf6b0510853aac25a0f4ea6">ExcDecompositionNotStable</a> (int arg1, <a class="el" href="classdouble.html">double</a> arg2)</td></tr>
<tr class="separator:gacab9d1c4bdf6b0510853aac25a0f4ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:ae7a9cef75f100f1d1d82f59fd95b0681"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ae7a9cef75f100f1d1d82f59fd95b0681">value_type</a> = number</td></tr>
<tr class="separator:ae7a9cef75f100f1d1d82f59fd95b0681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4466250db96cbf50504bc1473ffca9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#abf4466250db96cbf50504bc1473ffca9">real_type</a> = typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; number &gt;::<a class="el" href="classSparseMatrix.html#abf4466250db96cbf50504bc1473ffca9">real_type</a></td></tr>
<tr class="separator:abf4466250db96cbf50504bc1473ffca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ffd7b499914cd4964c3a8d0fd8b5672"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a0ffd7b499914cd4964c3a8d0fd8b5672">const_iterator</a> = <a class="el" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrixIterators::Iterator</a>&lt; number, true &gt;</td></tr>
<tr class="separator:a0ffd7b499914cd4964c3a8d0fd8b5672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac94776653684705604fea3dae0af35f4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ac94776653684705604fea3dae0af35f4">iterator</a> = <a class="el" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrixIterators::Iterator</a>&lt; number, false &gt;</td></tr>
<tr class="separator:ac94776653684705604fea3dae0af35f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ga9ce9bc8bd5842b1e3f67397663ba84e3"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:ga9ce9bc8bd5842b1e3f67397663ba84e3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga9ce9bc8bd5842b1e3f67397663ba84e3">copy_from</a> (const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; somenumber &gt; &amp;matrix)</td></tr>
<tr class="separator:ga9ce9bc8bd5842b1e3f67397663ba84e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fb0d0d0947c76e8ada6679a1e0b34e7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5fb0d0d0947c76e8ada6679a1e0b34e7">strengthen_diagonal_impl</a> ()</td></tr>
<tr class="separator:ga5fb0d0d0947c76e8ada6679a1e0b34e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56517361759a2e96a0aecc7fa5ab94e2"><td class="memItemLeft" align="right" valign="top">virtual number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga56517361759a2e96a0aecc7fa5ab94e2">get_strengthen_diagonal</a> (const number rowsum, const <a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> row) const</td></tr>
<tr class="separator:ga56517361759a2e96a0aecc7fa5ab94e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabeb44a5bc7f9a94d85c11a1e9cd25a14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gabeb44a5bc7f9a94d85c11a1e9cd25a14">prebuild_lower_bound</a> ()</td></tr>
<tr class="separator:gabeb44a5bc7f9a94d85c11a1e9cd25a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Modifying entries</div></td></tr>
<tr class="memitem:a9240d87b7695c58c41c93506a4723c08"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:a9240d87b7695c58c41c93506a4723c08"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a9240d87b7695c58c41c93506a4723c08">copy_from</a> (const ForwardIterator <a class="el" href="classSparseMatrix.html#a419e25c734b10802f9c7f59d652f84ca">begin</a>, const ForwardIterator <a class="el" href="classSparseMatrix.html#a24c613fbc2273dd9f16c716b1d4dc29f">end</a>)</td></tr>
<tr class="separator:a9240d87b7695c58c41c93506a4723c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad182785cbf271adb6a29fa470ecde8d7"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:ad182785cbf271adb6a29fa470ecde8d7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ad182785cbf271adb6a29fa470ecde8d7">copy_from</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; somenumber &gt; &amp;matrix)</td></tr>
<tr class="separator:ad182785cbf271adb6a29fa470ecde8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4b458133c76bb6b4966a5c89e2157c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a6b4b458133c76bb6b4966a5c89e2157c">copy_from</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a> &amp;matrix)</td></tr>
<tr class="separator:a6b4b458133c76bb6b4966a5c89e2157c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e77fcfbd1fa3ac83ef4ff2951b24ce3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a3e77fcfbd1fa3ac83ef4ff2951b24ce3">set</a> (const <a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> i, const <a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> j, const number value)</td></tr>
<tr class="separator:a3e77fcfbd1fa3ac83ef4ff2951b24ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fdc04dbbf9b8f0071b1f2da21d6e106"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a2fdc04dbbf9b8f0071b1f2da21d6e106"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a2fdc04dbbf9b8f0071b1f2da21d6e106">set</a> (const std::vector&lt; <a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> &gt; &amp;indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:a2fdc04dbbf9b8f0071b1f2da21d6e106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96779660698dc3fdd5640f860f14bec"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:ae96779660698dc3fdd5640f860f14bec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ae96779660698dc3fdd5640f860f14bec">set</a> (const std::vector&lt; <a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> &gt; &amp;row_indices, const std::vector&lt; <a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> &gt; &amp;col_indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:ae96779660698dc3fdd5640f860f14bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01efc87070a6730a10c4dc526bdb7701"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a01efc87070a6730a10c4dc526bdb7701"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a01efc87070a6730a10c4dc526bdb7701">set</a> (const <a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> row, const std::vector&lt; <a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> &gt; &amp;col_indices, const std::vector&lt; number2 &gt; &amp;values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:a01efc87070a6730a10c4dc526bdb7701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd783c07fc8b97262201d70a71b5667d"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:afd783c07fc8b97262201d70a71b5667d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#afd783c07fc8b97262201d70a71b5667d">set</a> (const <a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> row, const <a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> n_cols, const <a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> *col_indices, const number2 *values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:afd783c07fc8b97262201d70a71b5667d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabf7629046afdd9077f77f7746a7a3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#acabf7629046afdd9077f77f7746a7a3f">add</a> (const <a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> i, const <a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> j, const number value)</td></tr>
<tr class="separator:acabf7629046afdd9077f77f7746a7a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a987fd196ead89df045829bcc181a1"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:af4a987fd196ead89df045829bcc181a1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#af4a987fd196ead89df045829bcc181a1">add</a> (const std::vector&lt; <a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> &gt; &amp;indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:af4a987fd196ead89df045829bcc181a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538fb6831594e3bf994c9d44af68fccc"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a538fb6831594e3bf994c9d44af68fccc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a538fb6831594e3bf994c9d44af68fccc">add</a> (const std::vector&lt; <a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> &gt; &amp;row_indices, const std::vector&lt; <a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> &gt; &amp;col_indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:a538fb6831594e3bf994c9d44af68fccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae745cf2afd297c8acdfe33ace4d366f4"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:ae745cf2afd297c8acdfe33ace4d366f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ae745cf2afd297c8acdfe33ace4d366f4">add</a> (const <a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> row, const std::vector&lt; <a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> &gt; &amp;col_indices, const std::vector&lt; number2 &gt; &amp;values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:ae745cf2afd297c8acdfe33ace4d366f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac97efa0f970b0bcf40da82584f71d39c"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:ac97efa0f970b0bcf40da82584f71d39c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ac97efa0f970b0bcf40da82584f71d39c">add</a> (const <a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> row, const <a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> n_cols, const <a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> *col_indices, const number2 *values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true, const <a class="el" href="classbool.html">bool</a> col_indices_are_sorted=false)</td></tr>
<tr class="separator:ac97efa0f970b0bcf40da82584f71d39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157053c3502b33962ac736cc873a8dbd"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a157053c3502b33962ac736cc873a8dbd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a157053c3502b33962ac736cc873a8dbd">add</a> (const number factor, const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; somenumber &gt; &amp;matrix)</td></tr>
<tr class="separator:a157053c3502b33962ac736cc873a8dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb2ac677d0b2a212b289221ba4a43b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html">SparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#aebb2ac677d0b2a212b289221ba4a43b7">operator*=</a> (const number factor)</td></tr>
<tr class="separator:aebb2ac677d0b2a212b289221ba4a43b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99829ea532c57a8de890ee70b1faa24c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html">SparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a99829ea532c57a8de890ee70b1faa24c">operator/=</a> (const number factor)</td></tr>
<tr class="separator:a99829ea532c57a8de890ee70b1faa24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c1643ae82c4bd45a881c91d0066776"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a70c1643ae82c4bd45a881c91d0066776">symmetrize</a> ()</td></tr>
<tr class="separator:a70c1643ae82c4bd45a881c91d0066776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and initialization</div></td></tr>
<tr class="memitem:afa7ae4d32bda6035661c9cccfe185597"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">reinit</a> (const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;sparsity)</td></tr>
<tr class="separator:afa7ae4d32bda6035661c9cccfe185597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Information on the matrix</div></td></tr>
<tr class="memitem:a18c9e6f2bb89e5056fb0b7fe0efca566"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a18c9e6f2bb89e5056fb0b7fe0efca566">get_row_length</a> (const <a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> row) const</td></tr>
<tr class="separator:a18c9e6f2bb89e5056fb0b7fe0efca566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ebe386bfe100a9f26404bed7d10893"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a17ebe386bfe100a9f26404bed7d10893">n_nonzero_elements</a> () const</td></tr>
<tr class="separator:a17ebe386bfe100a9f26404bed7d10893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee6c3e34d4924f60ad89e3202c751f73"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#aee6c3e34d4924f60ad89e3202c751f73">n_actually_nonzero_elements</a> (const <a class="el" href="classdouble.html">double</a> threshold=0.) const</td></tr>
<tr class="separator:aee6c3e34d4924f60ad89e3202c751f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf185692775468ae7364a8909af2d80"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#aaaf185692775468ae7364a8909af2d80">get_sparsity_pattern</a> () const</td></tr>
<tr class="separator:aaaf185692775468ae7364a8909af2d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231105aa86cca488901d94b1e1b55ac7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a231105aa86cca488901d94b1e1b55ac7">compress</a> (::<a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>)</td></tr>
<tr class="separator:a231105aa86cca488901d94b1e1b55ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Entry Access</div></td></tr>
<tr class="memitem:a3871cf59e0e7c8bd18cabbcd3e02daa9"><td class="memItemLeft" align="right" valign="top">const number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a3871cf59e0e7c8bd18cabbcd3e02daa9">operator()</a> (const <a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> i, const <a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> j) const</td></tr>
<tr class="separator:a3871cf59e0e7c8bd18cabbcd3e02daa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96ad36bd86637f146fff43b3996536d"><td class="memItemLeft" align="right" valign="top">number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ac96ad36bd86637f146fff43b3996536d">operator()</a> (const <a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> i, const <a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> j)</td></tr>
<tr class="separator:ac96ad36bd86637f146fff43b3996536d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25229f70f1bfccd2437d587a000001e"><td class="memItemLeft" align="right" valign="top">number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#aa25229f70f1bfccd2437d587a000001e">el</a> (const <a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> i, const <a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> j) const</td></tr>
<tr class="separator:aa25229f70f1bfccd2437d587a000001e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d9466d88f725141780a95c41e79951"><td class="memItemLeft" align="right" valign="top">number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a49d9466d88f725141780a95c41e79951">diag_element</a> (const <a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> i) const</td></tr>
<tr class="separator:a49d9466d88f725141780a95c41e79951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159957553e3a4ca34cee51fdfa4cafa7"><td class="memItemLeft" align="right" valign="top">number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a159957553e3a4ca34cee51fdfa4cafa7">diag_element</a> (const <a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> i)</td></tr>
<tr class="separator:a159957553e3a4ca34cee51fdfa4cafa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Matrix norms</div></td></tr>
<tr class="memitem:aeb0010028e98a1e616d3ea1bed765f4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#abf4466250db96cbf50504bc1473ffca9">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#aeb0010028e98a1e616d3ea1bed765f4e">l1_norm</a> () const</td></tr>
<tr class="separator:aeb0010028e98a1e616d3ea1bed765f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64627cdd2dc0d8c8991996c029ba9ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#abf4466250db96cbf50504bc1473ffca9">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ae64627cdd2dc0d8c8991996c029ba9ca">linfty_norm</a> () const</td></tr>
<tr class="separator:ae64627cdd2dc0d8c8991996c029ba9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae403bf35656c6b5c075186b116e7f293"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#abf4466250db96cbf50504bc1473ffca9">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ae403bf35656c6b5c075186b116e7f293">frobenius_norm</a> () const</td></tr>
<tr class="separator:ae403bf35656c6b5c075186b116e7f293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Preconditioning methods</div></td></tr>
<tr class="memitem:a0b1f22866ffd7e47bfb32f62a1d3e711"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a0b1f22866ffd7e47bfb32f62a1d3e711"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a0b1f22866ffd7e47bfb32f62a1d3e711">precondition_Jacobi</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;src, const number omega=1.) const</td></tr>
<tr class="separator:a0b1f22866ffd7e47bfb32f62a1d3e711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f7ebdcc75ee730592c0bf23014405f"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:aa6f7ebdcc75ee730592c0bf23014405f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#aa6f7ebdcc75ee730592c0bf23014405f">precondition_SSOR</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;src, const number omega=1., const std::vector&lt; std::size_t &gt; &amp;pos_right_of_diagonal=std::vector&lt; std::size_t &gt;()) const</td></tr>
<tr class="separator:aa6f7ebdcc75ee730592c0bf23014405f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9ce0a2202ddc552f004523f3aef544"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:adc9ce0a2202ddc552f004523f3aef544"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#adc9ce0a2202ddc552f004523f3aef544">precondition_SOR</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;src, const number om=1.) const</td></tr>
<tr class="separator:adc9ce0a2202ddc552f004523f3aef544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967052ec6d13489bc529bb11515f89ea"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a967052ec6d13489bc529bb11515f89ea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a967052ec6d13489bc529bb11515f89ea">precondition_TSOR</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;src, const number om=1.) const</td></tr>
<tr class="separator:a967052ec6d13489bc529bb11515f89ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5439b4fc51d59a4cfa0f0829ee876763"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a5439b4fc51d59a4cfa0f0829ee876763"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a5439b4fc51d59a4cfa0f0829ee876763">SSOR</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const number omega=1.) const</td></tr>
<tr class="separator:a5439b4fc51d59a4cfa0f0829ee876763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ca15703f371cfa2b8281bb1eba0267"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a76ca15703f371cfa2b8281bb1eba0267"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a76ca15703f371cfa2b8281bb1eba0267">SOR</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const number om=1.) const</td></tr>
<tr class="separator:a76ca15703f371cfa2b8281bb1eba0267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8aa1eba02ee6d5180fbb8173b9967eb"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:ab8aa1eba02ee6d5180fbb8173b9967eb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ab8aa1eba02ee6d5180fbb8173b9967eb">TSOR</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const number om=1.) const</td></tr>
<tr class="separator:ab8aa1eba02ee6d5180fbb8173b9967eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94530f37331ed997e91d9458a1303f79"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a94530f37331ed997e91d9458a1303f79"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a94530f37331ed997e91d9458a1303f79">PSOR</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const std::vector&lt; <a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> &gt; &amp;permutation, const std::vector&lt; <a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> &gt; &amp;inverse_permutation, const number om=1.) const</td></tr>
<tr class="separator:a94530f37331ed997e91d9458a1303f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3514d4a24a63ce70fe7e9486ad1688a"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:aa3514d4a24a63ce70fe7e9486ad1688a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#aa3514d4a24a63ce70fe7e9486ad1688a">TPSOR</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const std::vector&lt; <a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> &gt; &amp;permutation, const std::vector&lt; <a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> &gt; &amp;inverse_permutation, const number om=1.) const</td></tr>
<tr class="separator:aa3514d4a24a63ce70fe7e9486ad1688a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa039cc30461321e4f54dd54e67e8ca36"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:aa039cc30461321e4f54dd54e67e8ca36"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#aa039cc30461321e4f54dd54e67e8ca36">Jacobi_step</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;b, const number om=1.) const</td></tr>
<tr class="separator:aa039cc30461321e4f54dd54e67e8ca36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72eaf0aedbda317c83cd6b3fe460d995"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a72eaf0aedbda317c83cd6b3fe460d995"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a72eaf0aedbda317c83cd6b3fe460d995">SOR_step</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;b, const number om=1.) const</td></tr>
<tr class="separator:a72eaf0aedbda317c83cd6b3fe460d995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36852dfbd7e9623dc96301d73fa2cf22"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a36852dfbd7e9623dc96301d73fa2cf22"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a36852dfbd7e9623dc96301d73fa2cf22">TSOR_step</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;b, const number om=1.) const</td></tr>
<tr class="separator:a36852dfbd7e9623dc96301d73fa2cf22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d92814be1b12c114a2e86f7c7c9410c"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a2d92814be1b12c114a2e86f7c7c9410c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a2d92814be1b12c114a2e86f7c7c9410c">SSOR_step</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;b, const number om=1.) const</td></tr>
<tr class="separator:a2d92814be1b12c114a2e86f7c7c9410c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterators</div></td></tr>
<tr class="memitem:a419e25c734b10802f9c7f59d652f84ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#a0ffd7b499914cd4964c3a8d0fd8b5672">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a419e25c734b10802f9c7f59d652f84ca">begin</a> () const</td></tr>
<tr class="separator:a419e25c734b10802f9c7f59d652f84ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0872bb70a86280328309c97c78bc39f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#ac94776653684705604fea3dae0af35f4">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ab0872bb70a86280328309c97c78bc39f">begin</a> ()</td></tr>
<tr class="separator:ab0872bb70a86280328309c97c78bc39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22cdd83806e88c53003d185ad639cd35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#a0ffd7b499914cd4964c3a8d0fd8b5672">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a22cdd83806e88c53003d185ad639cd35">begin</a> (const <a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> r) const</td></tr>
<tr class="separator:a22cdd83806e88c53003d185ad639cd35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc32c2ee41aa5e02b5838ed9e3423919"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#ac94776653684705604fea3dae0af35f4">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#abc32c2ee41aa5e02b5838ed9e3423919">begin</a> (const <a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> r)</td></tr>
<tr class="separator:abc32c2ee41aa5e02b5838ed9e3423919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c613fbc2273dd9f16c716b1d4dc29f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#a0ffd7b499914cd4964c3a8d0fd8b5672">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a24c613fbc2273dd9f16c716b1d4dc29f">end</a> () const</td></tr>
<tr class="separator:a24c613fbc2273dd9f16c716b1d4dc29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa99041df4c848c5b46180327c1e9b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#ac94776653684705604fea3dae0af35f4">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a1aa99041df4c848c5b46180327c1e9b5">end</a> ()</td></tr>
<tr class="separator:a1aa99041df4c848c5b46180327c1e9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8d50d7700dbd8560af071e146979c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#a0ffd7b499914cd4964c3a8d0fd8b5672">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#aac8d50d7700dbd8560af071e146979c0">end</a> (const <a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> r) const</td></tr>
<tr class="separator:aac8d50d7700dbd8560af071e146979c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5bd553a69c0374c72195d4eb0158696"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#ac94776653684705604fea3dae0af35f4">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ad5bd553a69c0374c72195d4eb0158696">end</a> (const <a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> r)</td></tr>
<tr class="separator:ad5bd553a69c0374c72195d4eb0158696"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ga84c2deaa9405117039d3cdbfbe35943b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga84c2deaa9405117039d3cdbfbe35943b">strengthen_diagonal</a></td></tr>
<tr class="separator:ga84c2deaa9405117039d3cdbfbe35943b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafc84f4c5e650a920c1627b9d3a7be5f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; const <a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaafc84f4c5e650a920c1627b9d3a7be5f">prebuilt_lower_bound</a></td></tr>
<tr class="separator:gaafc84f4c5e650a920c1627b9d3a7be5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:gae7c9b5fb4e57b864b327ea9f54dbd3d7"><td class="memItemLeft" align="right" valign="top">number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gae7c9b5fb4e57b864b327ea9f54dbd3d7">get_rowsum</a> (const <a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> row) const</td></tr>
<tr class="separator:gae7c9b5fb4e57b864b327ea9f54dbd3d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:gaae4981124fad9a18b17ce5241050cf5c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; number &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaae4981124fad9a18b17ce5241050cf5c">diag</a></td></tr>
<tr class="separator:gaae4981124fad9a18b17ce5241050cf5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga435307b1f00e2f4ec6b08842a424e550"><td class="memItemLeft" align="right" valign="top">std::vector&lt; number &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga435307b1f00e2f4ec6b08842a424e550">inv_diag</a></td></tr>
<tr class="separator:ga435307b1f00e2f4ec6b08842a424e550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf82ab8308e0a9b12f20a3c63b09b44ea"><td class="memItemLeft" align="right" valign="top">std::vector&lt; number &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf82ab8308e0a9b12f20a3c63b09b44ea">inner_sums</a></td></tr>
<tr class="separator:gaf82ab8308e0a9b12f20a3c63b09b44ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc2493b2e002e0a905a28321ab86c7a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparsityPattern.html">SparsityPattern</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gadc2493b2e002e0a905a28321ab86c7a3">own_sparsity</a></td></tr>
<tr class="separator:gadc2493b2e002e0a905a28321ab86c7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a92564bd74963776740615d7aa622fac3"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:a92564bd74963776740615d7aa622fac3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a92564bd74963776740615d7aa622fac3">sum</a> (const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; Number &gt; &amp;local, const MPI_Comm &amp;mpi_communicator, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; Number &gt; &amp;global)</td></tr>
<tr class="separator:a92564bd74963776740615d7aa622fac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Input/Output</h2></td></tr>
<tr class="memitem:ga345be12c610d63bb10f4fa6a1be14f9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="classSparsityPattern.html">SparsityPattern</a>, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga345be12c610d63bb10f4fa6a1be14f9e">cols</a></td></tr>
<tr class="separator:ga345be12c610d63bb10f4fa6a1be14f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7e5b9eb6ad7c45635d346de98b1c1e5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; number[]&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gab7e5b9eb6ad7c45635d346de98b1c1e5">val</a></td></tr>
<tr class="separator:gab7e5b9eb6ad7c45635d346de98b1c1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad183b90df780534d2143a45d97668de3"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gad183b90df780534d2143a45d97668de3">max_len</a></td></tr>
<tr class="separator:gad183b90df780534d2143a45d97668de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa84c2e29d3b520c53a9695b42b3941c5"><td class="memTemplParams" colspan="2">template&lt;class StreamType &gt; </td></tr>
<tr class="memitem:gaa84c2e29d3b520c53a9695b42b3941c5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa84c2e29d3b520c53a9695b42b3941c5">print</a> (StreamType &amp;out, const <a class="el" href="classbool.html">bool</a> across=false, const <a class="el" href="classbool.html">bool</a> diagonal_first=true) const</td></tr>
<tr class="separator:gaa84c2e29d3b520c53a9695b42b3941c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6456ebe393c32b076eae0b5c9811e0c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga6456ebe393c32b076eae0b5c9811e0c8">print_formatted</a> (std::ostream &amp;out, const unsigned int precision=3, const <a class="el" href="classbool.html">bool</a> scientific=true, const unsigned int width=0, const char *zero_string=&quot; &quot;, const <a class="el" href="classdouble.html">double</a> denominator=1.) const</td></tr>
<tr class="separator:ga6456ebe393c32b076eae0b5c9811e0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga737f5df58f2bf6ab275ed382ed725abb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga737f5df58f2bf6ab275ed382ed725abb">print_pattern</a> (std::ostream &amp;out, const <a class="el" href="classdouble.html">double</a> threshold=0.) const</td></tr>
<tr class="separator:ga737f5df58f2bf6ab275ed382ed725abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3141075e3ad6362fce005d2f1c8da699"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga3141075e3ad6362fce005d2f1c8da699">print_as_numpy_arrays</a> (std::ostream &amp;out, const unsigned int precision=9) const</td></tr>
<tr class="separator:ga3141075e3ad6362fce005d2f1c8da699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b32b99a054482f06fc026248c27bb74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga8b32b99a054482f06fc026248c27bb74">block_write</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:ga8b32b99a054482f06fc026248c27bb74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b670368c98d6392ff8c9284db0622b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga9b670368c98d6392ff8c9284db0622b2">block_read</a> (std::istream &amp;in)</td></tr>
<tr class="separator:ga9b670368c98d6392ff8c9284db0622b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1debf998b61291d913dfac4c8a22eaa7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga1debf998b61291d913dfac4c8a22eaa7">prepare_add</a> ()</td></tr>
<tr class="separator:ga1debf998b61291d913dfac4c8a22eaa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f68a9f93813ca167dc9f39624be2f5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga9f68a9f93813ca167dc9f39624be2f5b">prepare_set</a> ()</td></tr>
<tr class="separator:ga9f68a9f93813ca167dc9f39624be2f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad01aaf871a7d26eaddd5a9d0ea84a4a8"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gad01aaf871a7d26eaddd5a9d0ea84a4a8">ExcInvalidIndex</a> (int arg1, int arg2)</td></tr>
<tr class="separator:gad01aaf871a7d26eaddd5a9d0ea84a4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76e7ae46680e5cd2997ef6fef76fd5cc"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga76e7ae46680e5cd2997ef6fef76fd5cc">ExcDifferentSparsityPatterns</a> ()</td></tr>
<tr class="separator:ga76e7ae46680e5cd2997ef6fef76fd5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7af761909249424d7b97f97e3de11613"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7af761909249424d7b97f97e3de11613">ExcIteratorRange</a> (int arg1, int arg2)</td></tr>
<tr class="separator:ga7af761909249424d7b97f97e3de11613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ae47870d289b78147c2100b69163c8c"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga2ae47870d289b78147c2100b69163c8c">ExcSourceEqualsDestination</a> ()</td></tr>
<tr class="separator:ga2ae47870d289b78147c2100b69163c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Subscriptor functionality</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp8d6bc922eebec0b76272099aee4a220d"></a>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</td></tr>
<tr class="memitem:ga20658b60d6ef2d530fafa076efa9f503"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga20658b60d6ef2d530fafa076efa9f503">counter</a></td></tr>
<tr class="separator:ga20658b60d6ef2d530fafa076efa9f503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73f9f8936b61e6e17ab2a82e9516e95b"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga73f9f8936b61e6e17ab2a82e9516e95b">counter_map</a></td></tr>
<tr class="separator:ga73f9f8936b61e6e17ab2a82e9516e95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga094d5932c6c004c2a2b1b966950fb2f7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga094d5932c6c004c2a2b1b966950fb2f7">validity_pointers</a></td></tr>
<tr class="separator:ga094d5932c6c004c2a2b1b966950fb2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44e13f7984b31af8d7c54921175a75ff"><td class="memItemLeft" align="right" valign="top">const std::type_info *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga44e13f7984b31af8d7c54921175a75ff">object_info</a></td></tr>
<tr class="separator:ga44e13f7984b31af8d7c54921175a75ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned int version)</td></tr>
<tr class="separator:ga68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (int arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga300c593ea0f9422dcbce1445903e6c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga300c593ea0f9422dcbce1445903e6c12">check_no_subscribers</a> () const noexcept</td></tr>
<tr class="separator:ga300c593ea0f9422dcbce1445903e6c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned int version)</td></tr>
<tr class="separator:ga68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (int arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaeb9ac67567aa7d837f25debd33cd4ce5">map_value_type</a> = decltype(<a class="el" href="group__Exceptions.html#ga73f9f8936b61e6e17ab2a82e9516e95b">counter_map</a>)::<a class="el" href="classSparseMatrix.html#ae7a9cef75f100f1d1d82f59fd95b0681">value_type</a></td></tr>
<tr class="separator:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacebdc2d11f8522e4d9e8b7d73ac3f491">map_iterator</a> = decltype(<a class="el" href="group__Exceptions.html#ga73f9f8936b61e6e17ab2a82e9516e95b">counter_map</a>)::<a class="el" href="classSparseMatrix.html#ac94776653684705604fea3dae0af35f4">iterator</a></td></tr>
<tr class="separator:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e0d86893427a935e46d5bd6dcbc3f78"><td class="memItemLeft" align="right" valign="top">static std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7e0d86893427a935e46d5bd6dcbc3f78">mutex</a></td></tr>
<tr class="separator:ga7e0d86893427a935e46d5bd6dcbc3f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Multiplications</h2></td></tr>
<tr class="memitem:a7706b5f721efc5ea1966f5a5cdaad0e6"><td class="memTemplParams" colspan="2">template&lt;class OutVector , class InVector &gt; </td></tr>
<tr class="memitem:a7706b5f721efc5ea1966f5a5cdaad0e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a7706b5f721efc5ea1966f5a5cdaad0e6">vmult</a> (OutVector &amp;dst, const InVector &amp;src) const</td></tr>
<tr class="separator:a7706b5f721efc5ea1966f5a5cdaad0e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224a78133e7b655e3a2c26647097c2c7"><td class="memTemplParams" colspan="2">template&lt;class OutVector , class InVector &gt; </td></tr>
<tr class="memitem:a224a78133e7b655e3a2c26647097c2c7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a224a78133e7b655e3a2c26647097c2c7">Tvmult</a> (OutVector &amp;dst, const InVector &amp;src) const</td></tr>
<tr class="separator:a224a78133e7b655e3a2c26647097c2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d106dfe8792db57f2d6e60bdfe63e1"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a56d106dfe8792db57f2d6e60bdfe63e1"><td class="memTemplItemLeft" align="right" valign="top">somenumber&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a56d106dfe8792db57f2d6e60bdfe63e1">matrix_norm_square</a> (const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v) const</td></tr>
<tr class="separator:a56d106dfe8792db57f2d6e60bdfe63e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ded9134adf275ede256b92eefae8ed"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a03ded9134adf275ede256b92eefae8ed"><td class="memTemplItemLeft" align="right" valign="top">somenumber&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a03ded9134adf275ede256b92eefae8ed">matrix_scalar_product</a> (const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;u, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v) const</td></tr>
<tr class="separator:a03ded9134adf275ede256b92eefae8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7074c2cc7fd4ed760d5bf06594cf12"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a1a7074c2cc7fd4ed760d5bf06594cf12"><td class="memTemplItemLeft" align="right" valign="top">somenumber&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a1a7074c2cc7fd4ed760d5bf06594cf12">residual</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;x, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;b) const</td></tr>
<tr class="separator:a1a7074c2cc7fd4ed760d5bf06594cf12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38676dc8cd6d6c7b8aea3a335653a25f"><td class="memTemplParams" colspan="2">template&lt;typename numberB , typename numberC &gt; </td></tr>
<tr class="memitem:a38676dc8cd6d6c7b8aea3a335653a25f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a38676dc8cd6d6c7b8aea3a335653a25f">mmult</a> (<a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; numberC &gt; &amp;C, const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; numberB &gt; &amp;B, const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;V=<a class="el" href="classVector.html">Vector</a>&lt; number &gt;(), const <a class="el" href="classbool.html">bool</a> rebuild_sparsity_pattern=true) const</td></tr>
<tr class="separator:a38676dc8cd6d6c7b8aea3a335653a25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21044730f1f38257cc0397accb4d05e5"><td class="memTemplParams" colspan="2">template&lt;typename numberB , typename numberC &gt; </td></tr>
<tr class="memitem:a21044730f1f38257cc0397accb4d05e5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a21044730f1f38257cc0397accb4d05e5">Tmmult</a> (<a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; numberC &gt; &amp;C, const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; numberB &gt; &amp;B, const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;V=<a class="el" href="classVector.html">Vector</a>&lt; number &gt;(), const <a class="el" href="classbool.html">bool</a> rebuild_sparsity_pattern=true) const</td></tr>
<tr class="separator:a21044730f1f38257cc0397accb4d05e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename number&gt;<br />
class SparseMIC&lt; number &gt;</h3>

<p>Implementation of the Modified Incomplete Cholesky (MIC(0)) preconditioner for symmetric matrices. This class conforms to the state and usage specification in <a class="el" href="classSparseLUDecomposition.html">SparseLUDecomposition</a>.</p>
<h3>The decomposition</h3>
<p>Let a symmetric, positive-definite, sparse matrix \(A\) be in the form \(A = D - L - L^T\), where \(D\) is the diagonal part of \(A\) and \(-L\) is a strictly lower triangular matrix. The MIC(0) decomposition of the matrix \(A\) is defined by \(B = (X-L)X^{-1}(X-L^T)\), where \(X\) is a diagonal matrix defined by the condition \(\text{rowsum}(A) = \text{rowsum}(B)\). </p>

<p class="definition">Definition at line <a class="el" href="sparse__mic_8h_source.html#l00045">45</a> of file <a class="el" href="sparse__mic_8h_source.html">sparse_mic.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae7a9cef75f100f1d1d82f59fd95b0681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7a9cef75f100f1d1d82f59fd95b0681">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classSparseMatrix.html#ae7a9cef75f100f1d1d82f59fd95b0681">value_type</a> =  number</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Type of the matrix entries. This alias is analogous to <code>value_type</code> in the standard library containers. </p>

<p class="definition">Definition at line <a class="el" href="sparse__matrix_8h_source.html#l00507">507</a> of file <a class="el" href="sparse__matrix_8h_source.html">sparse_matrix.h</a>.</p>

</div>
</div>
<a id="abf4466250db96cbf50504bc1473ffca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4466250db96cbf50504bc1473ffca9">&#9670;&nbsp;</a></span>real_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classSparseMatrix.html#abf4466250db96cbf50504bc1473ffca9">real_type</a> =  typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt;number&gt;::<a class="el" href="classSparseMatrix.html#abf4466250db96cbf50504bc1473ffca9">real_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Declare a type that has holds real-valued numbers with the same precision as the template argument to this class. If the template argument of this class is a real data type, then real_type equals the template argument. If the template argument is a std::complex type then real_type equals the type underlying the complex numbers.</p>
<p>This alias is used to represent the return type of norms. </p>

<p class="definition">Definition at line <a class="el" href="sparse__matrix_8h_source.html#l00518">518</a> of file <a class="el" href="sparse__matrix_8h_source.html">sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a0ffd7b499914cd4964c3a8d0fd8b5672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ffd7b499914cd4964c3a8d0fd8b5672">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classSparseMatrix.html#a0ffd7b499914cd4964c3a8d0fd8b5672">const_iterator</a> =  <a class="el" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrixIterators::Iterator</a>&lt;number, true&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Typedef of an iterator class walking over all the nonzero entries of this matrix. This iterator cannot change the values of the matrix. </p>

<p class="definition">Definition at line <a class="el" href="sparse__matrix_8h_source.html#l00524">524</a> of file <a class="el" href="sparse__matrix_8h_source.html">sparse_matrix.h</a>.</p>

</div>
</div>
<a id="ac94776653684705604fea3dae0af35f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac94776653684705604fea3dae0af35f4">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classSparseMatrix.html#ac94776653684705604fea3dae0af35f4">iterator</a> =  <a class="el" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrixIterators::Iterator</a>&lt;number, false&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Typedef of an iterator class walking over all the nonzero entries of this matrix. This iterator <em>can</em> change the values of the matrix, but of course can't change the sparsity pattern as this is fixed once a sparse matrix is attached to it. </p>

<p class="definition">Definition at line <a class="el" href="sparse__matrix_8h_source.html#l00532">532</a> of file <a class="el" href="sparse__matrix_8h_source.html">sparse_matrix.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9240d87b7695c58c41c93506a4723c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9240d87b7695c58c41c93506a4723c08">&#9670;&nbsp;</a></span>copy_from() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is complete analogous to the <a class="el" href="group__Exceptions.html#ga96248eff3fbfa4270dfe21b0a4ea077b">SparsityPattern::copy_from()</a> function in that it allows to initialize a whole matrix in one step. See there for more information on argument types and their meaning. You can also find a small example on how to use this function there.</p>
<p>The only difference to the cited function is that the objects which the inner iterator points to need to be of type <code>std::pair&lt;unsigned int, value</code>, where <code>value</code> needs to be convertible to the element type of this class, as specified by the <code>number</code> template argument.</p>
<p>Previous content of the matrix is overwritten. Note that the entries specified by the input parameters need not necessarily cover all elements of the matrix. Elements not covered remain untouched. </p>

</div>
</div>
<a id="ad182785cbf271adb6a29fa470ecde8d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad182785cbf271adb6a29fa470ecde8d7">&#9670;&nbsp;</a></span>copy_from() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy the nonzero entries of a full matrix into this object. Previous content is deleted.</p>
<p>Note that the underlying sparsity pattern must be appropriate to hold the nonzero entries of the full matrix. This can be achieved using that version of <a class="el" href="group__Exceptions.html#ga96248eff3fbfa4270dfe21b0a4ea077b">SparsityPattern::copy_from()</a> that takes a <a class="el" href="classFullMatrix.html">FullMatrix</a> as argument. </p>

</div>
</div>
<a id="a6b4b458133c76bb6b4966a5c89e2157c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b4b458133c76bb6b4966a5c89e2157c">&#9670;&nbsp;</a></span>copy_from() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt;number&gt;&amp; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy the given Trilinos matrix to this one. The operation triggers an assertion if the sparsity patterns of the current object does not contain the location of a non-zero entry of the given argument.</p>
<p>This function assumes that the two matrices have the same sizes.</p>
<p>The function returns a reference to <code>*this</code>. </p>

</div>
</div>
<a id="afa7ae4d32bda6035661c9cccfe185597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa7ae4d32bda6035661c9cccfe185597">&#9670;&nbsp;</a></span>reinit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reinitialize the sparse matrix with the given sparsity pattern. The latter tells the matrix how many nonzero elements there need to be reserved.</p>
<p>Regarding memory allocation, the same applies as said above.</p>
<p>You have to make sure that the lifetime of the sparsity structure is at least as long as that of this matrix or as long as reinit(const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;) is not called with a new sparsity structure.</p>
<p>The elements of the matrix are set to zero by this function. </p>

</div>
</div>
<a id="a18c9e6f2bb89e5056fb0b7fe0efca566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18c9e6f2bb89e5056fb0b7fe0efca566">&#9670;&nbsp;</a></span>get_row_length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Preconditioners.html#ga7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::get_row_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of entries in a specific row. </p>

</div>
</div>
<a id="a17ebe386bfe100a9f26404bed7d10893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17ebe386bfe100a9f26404bed7d10893">&#9670;&nbsp;</a></span>n_nonzero_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::n_nonzero_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of nonzero elements of this matrix. Actually, it returns the number of entries in the sparsity pattern; if any of the entries should happen to be zero, it is counted anyway. </p>

</div>
</div>
<a id="aee6c3e34d4924f60ad89e3202c751f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee6c3e34d4924f60ad89e3202c751f73">&#9670;&nbsp;</a></span>n_actually_nonzero_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::n_actually_nonzero_elements </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>0.</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of actually nonzero elements of this matrix. It is possible to specify the parameter <code>threshold</code> in order to count only the elements that have absolute value greater than the threshold.</p>
<p>Note, that this function does (in contrary to <a class="el" href="classSparseMatrix.html#a17ebe386bfe100a9f26404bed7d10893">n_nonzero_elements()</a>) not count all entries of the sparsity pattern but only the ones that are nonzero (or whose absolute value is greater than threshold). </p>

</div>
</div>
<a id="aaaf185692775468ae7364a8909af2d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaf185692775468ae7364a8909af2d80">&#9670;&nbsp;</a></span>get_sparsity_pattern()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSparsityPattern.html">SparsityPattern</a>&amp; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::get_sparsity_pattern </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a (constant) reference to the underlying sparsity pattern of this matrix.</p>
<p>Though the return value is declared <code>const</code>, you should be aware that it may change if you call any nonconstant function of objects which operate on it. </p>

</div>
</div>
<a id="a231105aa86cca488901d94b1e1b55ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a231105aa86cca488901d94b1e1b55ac7">&#9670;&nbsp;</a></span>compress()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::compress </td>
          <td>(</td>
          <td class="paramtype">::<a class="el" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dummy function for compatibility with distributed, parallel matrices. </p>

</div>
</div>
<a id="a3e77fcfbd1fa3ac83ef4ff2951b24ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e77fcfbd1fa3ac83ef4ff2951b24ce3">&#9670;&nbsp;</a></span>set() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the element (<em>i,j</em>) to <code>value</code>. Throws an error if the entry does not exist or if <code>value</code> is not a finite number. Still, it is allowed to store zero values in non-existent fields. </p>

</div>
</div>
<a id="a2fdc04dbbf9b8f0071b1f2da21d6e106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fdc04dbbf9b8f0071b1f2da21d6e106">&#9670;&nbsp;</a></span>set() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set all elements given in a <a class="el" href="classFullMatrix.html">FullMatrix</a> into the sparse matrix locations given by <code>indices</code>. In other words, this function writes the elements in <code>full_matrix</code> into the calling matrix, using the local-to-global indexing specified by <code>indices</code> for both the rows and the columns of the matrix. This function assumes a quadratic sparse matrix and a quadratic full_matrix, the usual situation in FE calculations.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be set anyway or they should be filtered away (and not change the previous content in the respective element if it exists). The default value is <code>false</code>, i.e., even zero values are treated. </p>

</div>
</div>
<a id="ae96779660698dc3fdd5640f860f14bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae96779660698dc3fdd5640f860f14bec">&#9670;&nbsp;</a></span>set() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same function as before, but now including the possibility to use rectangular full_matrices and different local-to-global indexing on rows and columns, respectively. </p>

</div>
</div>
<a id="a01efc87070a6730a10c4dc526bdb7701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01efc87070a6730a10c4dc526bdb7701">&#9670;&nbsp;</a></span>set() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set several elements in the specified row of the matrix with column indices as given by <code>col_indices</code> to the respective value.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be set anyway or they should be filtered away (and not change the previous content in the respective element if it exists). The default value is <code>false</code>, i.e., even zero values are treated. </p>

</div>
</div>
<a id="afd783c07fc8b97262201d70a71b5667d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd783c07fc8b97262201d70a71b5667d">&#9670;&nbsp;</a></span>set() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> *&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number2 *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set several elements to values given by <code>values</code> in a given row in columns given by col_indices into the sparse matrix.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be inserted anyway or they should be filtered away. The default value is <code>false</code>, i.e., even zero values are inserted/replaced. </p>

</div>
</div>
<a id="acabf7629046afdd9077f77f7746a7a3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acabf7629046afdd9077f77f7746a7a3f">&#9670;&nbsp;</a></span>add() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add <code>value</code> to the element (<em>i,j</em>). Throws an error if the entry does not exist or if <code>value</code> is not a finite number. Still, it is allowed to store zero values in non-existent fields. </p>

</div>
</div>
<a id="af4a987fd196ead89df045829bcc181a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a987fd196ead89df045829bcc181a1">&#9670;&nbsp;</a></span>add() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add all elements given in a <a class="el" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> into sparse matrix locations given by <code>indices</code>. In other words, this function adds the elements in <code>full_matrix</code> to the respective entries in calling matrix, using the local-to-global indexing specified by <code>indices</code> for both the rows and the columns of the matrix. This function assumes a quadratic sparse matrix and a quadratic full_matrix, the usual situation in FE calculations.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be added anyway or these should be filtered away and only non-zero data is added. The default value is <code>true</code>, i.e., zero values won't be added into the matrix. </p>

</div>
</div>
<a id="a538fb6831594e3bf994c9d44af68fccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a538fb6831594e3bf994c9d44af68fccc">&#9670;&nbsp;</a></span>add() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same function as before, but now including the possibility to use rectangular full_matrices and different local-to-global indexing on rows and columns, respectively. </p>

</div>
</div>
<a id="ae745cf2afd297c8acdfe33ace4d366f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae745cf2afd297c8acdfe33ace4d366f4">&#9670;&nbsp;</a></span>add() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set several elements in the specified row of the matrix with column indices as given by <code>col_indices</code> to the respective value.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be added anyway or these should be filtered away and only non-zero data is added. The default value is <code>true</code>, i.e., zero values won't be added into the matrix. </p>

</div>
</div>
<a id="ac97efa0f970b0bcf40da82584f71d39c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac97efa0f970b0bcf40da82584f71d39c">&#9670;&nbsp;</a></span>add() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> *&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number2 *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>col_indices_are_sorted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add an array of values given by <code>values</code> in the given global matrix row at columns specified by col_indices in the sparse matrix.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be added anyway or these should be filtered away and only non-zero data is added. The default value is <code>true</code>, i.e., zero values won't be added into the matrix. </p>

</div>
</div>
<a id="a157053c3502b33962ac736cc873a8dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a157053c3502b33962ac736cc873a8dbd">&#9670;&nbsp;</a></span>add() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add <code>matrix</code> scaled by <code>factor</code> to this matrix, i.e. the matrix <code>factor*matrix</code> is added to <code>this</code>. This function throws an error if the sparsity patterns of the two involved matrices do not point to the same object, since in this case the operation is cheaper.</p>
<p>The source matrix may be a sparse matrix over an arbitrary underlying scalar type, as long as its data type is convertible to the data type of this matrix. </p>

</div>
</div>
<a id="aebb2ac677d0b2a212b289221ba4a43b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb2ac677d0b2a212b289221ba4a43b7">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&amp; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiply the entire matrix by a fixed factor. </p>

</div>
</div>
<a id="a99829ea532c57a8de890ee70b1faa24c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99829ea532c57a8de890ee70b1faa24c">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&amp; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Divide the entire matrix by a fixed factor. </p>

</div>
</div>
<a id="a70c1643ae82c4bd45a881c91d0066776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70c1643ae82c4bd45a881c91d0066776">&#9670;&nbsp;</a></span>symmetrize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::symmetrize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Symmetrize the matrix by forming the mean value between the existing matrix and its transpose, \(A = \frac 12(A+A^T)\).</p>
<p>This operation assumes that the underlying sparsity pattern represents a symmetric object. If this is not the case, then the result of this operation will not be a symmetric matrix, since it only explicitly symmetrizes by looping over the lower left triangular part for efficiency reasons; if there are entries in the upper right triangle, then these elements are missed in the symmetrization. Symmetrization of the sparsity pattern can be obtain by <a class="el" href="group__Sparsity.html#ga16c1ebb8fbefcdce0a313e7be27ad34d">SparsityPattern::symmetrize()</a>. </p>

</div>
</div>
<a id="a3871cf59e0e7c8bd18cabbcd3e02daa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3871cf59e0e7c8bd18cabbcd3e02daa9">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const number&amp; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the entry (<em>i,j</em>). This may be an expensive operation and you should always take care where to call this function. In order to avoid abuse, this function throws an exception if the required element does not exist in the matrix.</p>
<p>In case you want a function that returns zero instead (for entries that are not in the sparsity pattern of the matrix), use the <a class="el" href="classSparseMatrix.html#aa25229f70f1bfccd2437d587a000001e">el()</a> function.</p>
<p>If you are looping over all elements, consider using one of the iterator classes instead, since they are tailored better to a sparse matrix structure. </p>

</div>
</div>
<a id="ac96ad36bd86637f146fff43b3996536d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac96ad36bd86637f146fff43b3996536d">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">number&amp; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>In contrast to the one above, this function allows modifying the object. </p>

</div>
</div>
<a id="aa25229f70f1bfccd2437d587a000001e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25229f70f1bfccd2437d587a000001e">&#9670;&nbsp;</a></span>el()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">number <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::el </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is mostly like <a class="el" href="classSparseMatrix.html#a3871cf59e0e7c8bd18cabbcd3e02daa9">operator()()</a> in that it returns the value of the matrix entry (<em>i,j</em>). The only difference is that if this entry does not exist in the sparsity pattern, then instead of raising an exception, zero is returned. While this may be convenient in some cases, note that it is simple to write algorithms that are slow compared to an optimal solution, since the sparsity of the matrix is not used.</p>
<p>If you are looping over all elements, consider using one of the iterator classes instead, since they are tailored better to a sparse matrix structure. </p>

</div>
</div>
<a id="a49d9466d88f725141780a95c41e79951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d9466d88f725141780a95c41e79951">&#9670;&nbsp;</a></span>diag_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">number <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::diag_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the main diagonal element in the <em>i</em>th row. This function throws an error if the matrix is not quadratic.</p>
<p>This function is considerably faster than the <a class="el" href="classSparseMatrix.html#a3871cf59e0e7c8bd18cabbcd3e02daa9">operator()()</a>, since for quadratic matrices, the diagonal entry may be the first to be stored in each row and access therefore does not involve searching for the right column number. </p>

</div>
</div>
<a id="a159957553e3a4ca34cee51fdfa4cafa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a159957553e3a4ca34cee51fdfa4cafa7">&#9670;&nbsp;</a></span>diag_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">number&amp; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::diag_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but return a writeable reference. You're sure you know what you do? </p>

</div>
</div>
<a id="a7706b5f721efc5ea1966f5a5cdaad0e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7706b5f721efc5ea1966f5a5cdaad0e6">&#9670;&nbsp;</a></span>vmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;class OutVector , class InVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::vmult </td>
          <td>(</td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Matrix-vector multiplication: let <em>dst = M*src</em> with <em>M</em> being this matrix.</p>
<p>Note that while this function can operate on all vectors that offer iterator classes, it is only really effective for objects of type <a class="el" href="classVector.html">Vector</a>. For all classes for which iterating over elements, or random member access is expensive, this function is not efficient. In particular, if you want to multiply with <a class="el" href="classBlockVector.html">BlockVector</a> objects, you should consider using a <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a> as well.</p>
<p>Source and destination must not be the same vector.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a224a78133e7b655e3a2c26647097c2c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a224a78133e7b655e3a2c26647097c2c7">&#9670;&nbsp;</a></span>Tvmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;class OutVector , class InVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::Tvmult </td>
          <td>(</td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Matrix-vector multiplication: let <em>dst = M<sup>T</sup>*src</em> with <em>M</em> being this matrix. This function does the same as <a class="el" href="group__Preconditioners.html#ga5e3c0e1eeebeb2b3124c5af0895e91b4">vmult()</a> but takes the transposed matrix.</p>
<p>Note that while this function can operate on all vectors that offer iterator classes, it is only really effective for objects of type <a class="el" href="classVector.html">Vector</a>. For all classes for which iterating over elements, or random member access is expensive, this function is not efficient. In particular, if you want to multiply with <a class="el" href="classBlockVector.html">BlockVector</a> objects, you should consider using a <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a> as well.</p>
<p>Source and destination must not be the same vector. </p>

</div>
</div>
<a id="a56d106dfe8792db57f2d6e60bdfe63e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56d106dfe8792db57f2d6e60bdfe63e1">&#9670;&nbsp;</a></span>matrix_norm_square()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">somenumber <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::matrix_norm_square </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the square of the norm of the vector \(v\) with respect to the norm induced by this matrix, i.e. \(\left(v,Mv\right)\). This is useful, e.g. in the finite element context, where the \(L_2\) norm of a function equals the matrix norm with respect to the mass matrix of the vector representing the nodal values of the finite element function.</p>
<p>Obviously, the matrix needs to be quadratic for this operation, and for the result to actually be a norm it also needs to be either real symmetric or complex hermitian.</p>
<p>The underlying template types of both this matrix and the given vector should either both be real or complex-valued, but not mixed, for this function to make sense.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a03ded9134adf275ede256b92eefae8ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03ded9134adf275ede256b92eefae8ed">&#9670;&nbsp;</a></span>matrix_scalar_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">somenumber <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::matrix_scalar_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the matrix scalar product \(\left(u,Mv\right)\).</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a1a7074c2cc7fd4ed760d5bf06594cf12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7074c2cc7fd4ed760d5bf06594cf12">&#9670;&nbsp;</a></span>residual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">somenumber <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::residual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the residual of an equation <em>Mx=b</em>, where the residual is defined to be <em>r=b-Mx</em>. Write the residual into <code>dst</code>. The <em>l<sub>2</sub></em> norm of the residual vector is returned.</p>
<p>Source <em>x</em> and destination <em>dst</em> must not be the same vector.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a38676dc8cd6d6c7b8aea3a335653a25f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38676dc8cd6d6c7b8aea3a335653a25f">&#9670;&nbsp;</a></span>mmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename numberB , typename numberC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::mmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; numberC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; numberB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em> = <code><a class="el" href="classVector.html">Vector</a>&lt;&#160;number&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>rebuild_sparsity_pattern</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform the matrix-matrix multiplication <code>C = A * B</code>, or, if an optional vector argument is given, <code>C = A * diag(V) * B</code>, where <code>diag(V)</code> defines a diagonal matrix with the vector entries.</p>
<p>This function assumes that the calling matrix <code>A</code> and the argument <code>B</code> have compatible sizes. By default, the output matrix <code>C</code> will be resized appropriately.</p>
<p>By default, i.e., if the optional argument <code>rebuild_sparsity_pattern</code> is <code>true</code>, the sparsity pattern of the matrix C will be changed to ensure that all entries that result from the product \(AB\) can be stored in \(C\). This is an expensive operation, and if there is a way to predict the sparsity pattern up front, you should probably build it yourself before calling this function with <code>false</code> as last argument. In this case, the rebuilding of the sparsity pattern is bypassed.</p>
<p>When setting <code>rebuild_sparsity_pattern</code> to <code>true</code> (i.e., leaving it at the default value), it is important to realize that the matrix <code>C</code> passed as first argument still has to be initialized with a sparsity pattern (either at the time of creation of the <a class="el" href="classSparseMatrix.html">SparseMatrix</a> object, or via the <a class="el" href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">SparseMatrix::reinit()</a> function). This is because we could create a sparsity pattern inside the current function, and then associate <code>C</code> with it, but there would be no way to transfer ownership of this sparsity pattern to anyone once the current function finishes. Consequently, the function requires that <code>C</code> be already associated with a sparsity pattern object, and this object is then reset to fit the product of <code>A</code> and <code>B</code>.</p>
<p>As a consequence of this, however, it is also important to realize that the sparsity pattern of <code>C</code> is modified and that this would render invalid <em>all other <a class="el" href="classSparseMatrix.html">SparseMatrix</a> objects</em> that happen to <em>also</em> use that sparsity pattern object. </p>

</div>
</div>
<a id="a21044730f1f38257cc0397accb4d05e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21044730f1f38257cc0397accb4d05e5">&#9670;&nbsp;</a></span>Tmmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename numberB , typename numberC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::Tmmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; numberC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; numberB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em> = <code><a class="el" href="classVector.html">Vector</a>&lt;&#160;number&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>rebuild_sparsity_pattern</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform the matrix-matrix multiplication with the transpose of <code>this</code>, i.e., <code>C = A<sup>T</sup> * B</code>, or, if an optional vector argument is given, <code>C = A<sup>T</sup> * diag(V) * B</code>, where <code>diag(V)</code> defines a diagonal matrix with the vector entries.</p>
<p>This function assumes that the calling matrix <code>A</code> and <code>B</code> have compatible sizes. The size of <code>C</code> will be set within this function.</p>
<p>The content as well as the sparsity pattern of the matrix C will be changed by this function, so make sure that the sparsity pattern is not used somewhere else in your program. This is an expensive operation, so think twice before you use this function.</p>
<p>There is an optional flag <code>rebuild_sparsity_pattern</code> that can be used to bypass the creation of a new sparsity pattern and instead uses the sparsity pattern stored in <code>C</code>. In that case, make sure that it really fits. The default is to rebuild the sparsity pattern.</p>
<dl class="section note"><dt>Note</dt><dd>Rebuilding the sparsity pattern requires changing it. This means that all other matrices that are associated with this sparsity pattern will then have invalid entries. </dd></dl>

</div>
</div>
<a id="aeb0010028e98a1e616d3ea1bed765f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb0010028e98a1e616d3ea1bed765f4e">&#9670;&nbsp;</a></span>l1_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#abf4466250db96cbf50504bc1473ffca9">real_type</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::l1_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the \(l_1\)-norm of the matrix, that is \(|M|_1=\max_{\mathrm{all\ columns\ }j}\sum_{\mathrm{all\ rows\ } i} |M_{ij}|\), (max. sum of columns). This is the natural matrix norm that is compatible to the \(l_1\)-norm for vectors, i.e. \(|Mv|_1\leq |M|_1 |v|_1\). (cf. Haemmerlin- Hoffmann: Numerische Mathematik) </p>

</div>
</div>
<a id="ae64627cdd2dc0d8c8991996c029ba9ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae64627cdd2dc0d8c8991996c029ba9ca">&#9670;&nbsp;</a></span>linfty_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#abf4466250db96cbf50504bc1473ffca9">real_type</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::linfty_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the \(l_\infty\)-norm of the matrix, that is \(|M|_\infty=\max_{\mathrm{all\ rows\ }i}\sum_{\mathrm{all\ columns\ }j} |M_{ij}|\), (max. sum of rows). This is the natural matrix norm that is compatible to the \(l_\infty\)-norm of vectors, i.e. \(|Mv|_\infty \leq |M|_\infty |v|_\infty\). (cf. Haemmerlin-Hoffmann: Numerische Mathematik) </p>

</div>
</div>
<a id="ae403bf35656c6b5c075186b116e7f293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae403bf35656c6b5c075186b116e7f293">&#9670;&nbsp;</a></span>frobenius_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#abf4466250db96cbf50504bc1473ffca9">real_type</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::frobenius_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the frobenius norm of the matrix, i.e. the square root of the sum of squares of all entries in the matrix. </p>

</div>
</div>
<a id="a0b1f22866ffd7e47bfb32f62a1d3e711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b1f22866ffd7e47bfb32f62a1d3e711">&#9670;&nbsp;</a></span>precondition_Jacobi()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::precondition_Jacobi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>omega</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Apply the Jacobi preconditioner, which multiplies every element of the <code>src</code> vector by the inverse of the respective diagonal element and multiplies the result with the relaxation factor <code>omega</code>. </p>

</div>
</div>
<a id="aa6f7ebdcc75ee730592c0bf23014405f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6f7ebdcc75ee730592c0bf23014405f">&#9670;&nbsp;</a></span>precondition_SSOR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::precondition_SSOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>omega</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>pos_right_of_diagonal</em> = <code>std::vector&lt;&#160;std::size_t&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Apply SSOR preconditioning to <code>src</code> with damping <code>omega</code>. The optional argument <code>pos_right_of_diagonal</code> is supposed to provide an array where each entry specifies the position just right of the diagonal in the global array of nonzeros. </p>

</div>
</div>
<a id="adc9ce0a2202ddc552f004523f3aef544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc9ce0a2202ddc552f004523f3aef544">&#9670;&nbsp;</a></span>precondition_SOR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::precondition_SOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Apply SOR preconditioning matrix to <code>src</code>. </p>

</div>
</div>
<a id="a967052ec6d13489bc529bb11515f89ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a967052ec6d13489bc529bb11515f89ea">&#9670;&nbsp;</a></span>precondition_TSOR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::precondition_TSOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Apply transpose SOR preconditioning matrix to <code>src</code>. </p>

</div>
</div>
<a id="a5439b4fc51d59a4cfa0f0829ee876763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5439b4fc51d59a4cfa0f0829ee876763">&#9670;&nbsp;</a></span>SSOR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::SSOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>omega</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform SSOR preconditioning in-place. Apply the preconditioner matrix without copying to a second vector. <code>omega</code> is the relaxation parameter. </p>

</div>
</div>
<a id="a76ca15703f371cfa2b8281bb1eba0267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76ca15703f371cfa2b8281bb1eba0267">&#9670;&nbsp;</a></span>SOR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::SOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform an SOR preconditioning in-place. <code>omega</code> is the relaxation parameter. </p>

</div>
</div>
<a id="ab8aa1eba02ee6d5180fbb8173b9967eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8aa1eba02ee6d5180fbb8173b9967eb">&#9670;&nbsp;</a></span>TSOR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::TSOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform a transpose SOR preconditioning in-place. <code>omega</code> is the relaxation parameter. </p>

</div>
</div>
<a id="a94530f37331ed997e91d9458a1303f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94530f37331ed997e91d9458a1303f79">&#9670;&nbsp;</a></span>PSOR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::PSOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>permutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_permutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform a permuted SOR preconditioning in-place.</p>
<p>The standard SOR method is applied in the order prescribed by <code>permutation</code>, that is, first the row <code>permutation[0]</code>, then <code>permutation[1]</code> and so on. For efficiency reasons, the permutation as well as its inverse are required.</p>
<p><code>omega</code> is the relaxation parameter. </p>

</div>
</div>
<a id="aa3514d4a24a63ce70fe7e9486ad1688a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3514d4a24a63ce70fe7e9486ad1688a">&#9670;&nbsp;</a></span>TPSOR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::TPSOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>permutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_permutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform a transposed permuted SOR preconditioning in-place.</p>
<p>The transposed SOR method is applied in the order prescribed by <code>permutation</code>, that is, first the row <code>permutation[<a class="el" href="group__Preconditioners.html#ga71242d5c14a00bb6aba2c5af0c9065f1">m()</a>-1]</code>, then <code>permutation[<a class="el" href="group__Preconditioners.html#ga71242d5c14a00bb6aba2c5af0c9065f1">m()</a>-2]</code> and so on. For efficiency reasons, the permutation as well as its inverse are required.</p>
<p><code>omega</code> is the relaxation parameter. </p>

</div>
</div>
<a id="aa039cc30461321e4f54dd54e67e8ca36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa039cc30461321e4f54dd54e67e8ca36">&#9670;&nbsp;</a></span>Jacobi_step()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::Jacobi_step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Do one Jacobi step on <code>v</code>. Performs a direct Jacobi step with right hand side <code>b</code>. This function will need an auxiliary vector, which is acquired from <a class="el" href="classGrowingVectorMemory.html">GrowingVectorMemory</a>. </p>

</div>
</div>
<a id="a72eaf0aedbda317c83cd6b3fe460d995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72eaf0aedbda317c83cd6b3fe460d995">&#9670;&nbsp;</a></span>SOR_step()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::SOR_step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Do one SOR step on <code>v</code>. Performs a direct SOR step with right hand side <code>b</code>. </p>

</div>
</div>
<a id="a36852dfbd7e9623dc96301d73fa2cf22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36852dfbd7e9623dc96301d73fa2cf22">&#9670;&nbsp;</a></span>TSOR_step()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::TSOR_step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Do one adjoint SOR step on <code>v</code>. Performs a direct TSOR step with right hand side <code>b</code>. </p>

</div>
</div>
<a id="a2d92814be1b12c114a2e86f7c7c9410c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d92814be1b12c114a2e86f7c7c9410c">&#9670;&nbsp;</a></span>SSOR_step()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::SSOR_step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Do one SSOR step on <code>v</code>. Performs a direct SSOR step with right hand side <code>b</code> by performing TSOR after SOR. </p>

</div>
</div>
<a id="a419e25c734b10802f9c7f59d652f84ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a419e25c734b10802f9c7f59d652f84ca">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#a0ffd7b499914cd4964c3a8d0fd8b5672">const_iterator</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator pointing to the first element of the matrix.</p>
<p>Note the discussion in the general documentation of this class about the order in which elements are accessed. </p>

</div>
</div>
<a id="ab0872bb70a86280328309c97c78bc39f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0872bb70a86280328309c97c78bc39f">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#ac94776653684705604fea3dae0af35f4">iterator</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Like the function above, but for non-const matrices. </p>

</div>
</div>
<a id="a22cdd83806e88c53003d185ad639cd35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22cdd83806e88c53003d185ad639cd35">&#9670;&nbsp;</a></span>begin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#a0ffd7b499914cd4964c3a8d0fd8b5672">const_iterator</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator pointing to the first element of row <code>r</code>.</p>
<p>Note that if the given row is empty, i.e. does not contain any nonzero entries, then the iterator returned by this function equals <code>end(r)</code>. The returned iterator may not be dereferenceable in that case if neither row <code>r</code> nor any of the following rows contain any nonzero entries. </p>

</div>
</div>
<a id="abc32c2ee41aa5e02b5838ed9e3423919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc32c2ee41aa5e02b5838ed9e3423919">&#9670;&nbsp;</a></span>begin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#ac94776653684705604fea3dae0af35f4">iterator</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Like the function above, but for non-const matrices. </p>

</div>
</div>
<a id="a24c613fbc2273dd9f16c716b1d4dc29f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c613fbc2273dd9f16c716b1d4dc29f">&#9670;&nbsp;</a></span>end() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#a0ffd7b499914cd4964c3a8d0fd8b5672">const_iterator</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator pointing the element past the last one of this matrix. </p>

</div>
</div>
<a id="a1aa99041df4c848c5b46180327c1e9b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aa99041df4c848c5b46180327c1e9b5">&#9670;&nbsp;</a></span>end() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#ac94776653684705604fea3dae0af35f4">iterator</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Like the function above, but for non-const matrices. </p>

</div>
</div>
<a id="aac8d50d7700dbd8560af071e146979c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac8d50d7700dbd8560af071e146979c0">&#9670;&nbsp;</a></span>end() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#a0ffd7b499914cd4964c3a8d0fd8b5672">const_iterator</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator pointing the element past the last one of row <code>r</code> , or past the end of the entire sparsity pattern if none of the rows after <code>r</code> contain any entries at all.</p>
<p>Note that the end iterator is not necessarily dereferenceable. This is in particular the case if it is the end iterator for the last row of a matrix. </p>

</div>
</div>
<a id="ad5bd553a69c0374c72195d4eb0158696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5bd553a69c0374c72195d4eb0158696">&#9670;&nbsp;</a></span>end() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#ac94776653684705604fea3dae0af35f4">iterator</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Like the function above, but for non-const matrices. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a92564bd74963776740615d7aa622fac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92564bd74963776740615d7aa622fac3">&#9670;&nbsp;</a></span>sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>mpi_communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>global</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform an MPI sum of the entries of a <a class="el" href="classSparseMatrix.html">SparseMatrix</a>.</p>
<dl class="section note"><dt>Note</dt><dd><code>local</code> and <code>global</code> should have the same sparsity pattern and it should be the same for all MPI processes. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/lac/<a class="el" href="sparse__mic_8h_source.html">sparse_mic.h</a></li>
<li>source/lac/<a class="el" href="sparse__mic_8cc_source.html">sparse_mic.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
