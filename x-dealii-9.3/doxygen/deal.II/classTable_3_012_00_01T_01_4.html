<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classTable_3_012_00_01T_01_4.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Table&lt; 2, T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.3.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.3.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classTable_3_012_00_01T_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Table&lt; 2, T &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__utilities.html">Utility functions and classes</a> &raquo; <a class="el" href="group__data.html">Data storage primitives</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="table_8h_source.html">deal.II/base/table.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Table&lt; 2, T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classTable_3_012_00_01T_01_4__inherit__graph.svg" width="226" height="279"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a77d40d21c3ed4e9ae4dd18e67f26943b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a> = typename <a class="el" href="classTableBase.html">TableBase</a>&lt; 2, T &gt;::<a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a></td></tr>
<tr class="separator:a77d40d21c3ed4e9ae4dd18e67f26943b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7b072532d4db87d348361f5a37e356"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTable_3_012_00_01T_01_4.html#a4a7b072532d4db87d348361f5a37e356">value_type</a> = typename <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::<a class="el" href="classTable_3_012_00_01T_01_4.html#a4a7b072532d4db87d348361f5a37e356">value_type</a></td></tr>
<tr class="separator:a4a7b072532d4db87d348361f5a37e356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e8e44cff4a85432bc651d32332ae7a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTable_3_012_00_01T_01_4.html#aa9e8e44cff4a85432bc651d32332ae7a">reference</a> = typename <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::<a class="el" href="classTable_3_012_00_01T_01_4.html#aa9e8e44cff4a85432bc651d32332ae7a">reference</a></td></tr>
<tr class="separator:aa9e8e44cff4a85432bc651d32332ae7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6e1faa3693a2852ce94e24ea10070b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTable_3_012_00_01T_01_4.html#a1d6e1faa3693a2852ce94e24ea10070b">const_reference</a> = typename <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::<a class="el" href="classTable_3_012_00_01T_01_4.html#a1d6e1faa3693a2852ce94e24ea10070b">const_reference</a></td></tr>
<tr class="separator:a1d6e1faa3693a2852ce94e24ea10070b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7d21c3588eca7d92eacfcb820a04e8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTable_3_012_00_01T_01_4.html#ade7d21c3588eca7d92eacfcb820a04e8">const_iterator</a> = <a class="el" href="classMatrixTableIterators_1_1Iterator.html">MatrixTableIterators::Iterator</a>&lt; <a class="el" href="classTable.html">Table</a>&lt; 2, T &gt;, true, <a class="el" href="namespaceMatrixTableIterators.html#a071affcab0c2e4302df96f2d1540bd08a641fabb8e5e7d1d0333e2c9c384f959c">MatrixTableIterators::Storage::row_major</a> &gt;</td></tr>
<tr class="separator:ade7d21c3588eca7d92eacfcb820a04e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8400e38cef181be1023321ef1b75e85f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTable_3_012_00_01T_01_4.html#a8400e38cef181be1023321ef1b75e85f">iterator</a> = <a class="el" href="classMatrixTableIterators_1_1Iterator.html">MatrixTableIterators::Iterator</a>&lt; <a class="el" href="classTable.html">Table</a>&lt; 2, T &gt;, false, <a class="el" href="namespaceMatrixTableIterators.html#a071affcab0c2e4302df96f2d1540bd08a641fabb8e5e7d1d0333e2c9c384f959c">MatrixTableIterators::Storage::row_major</a> &gt;</td></tr>
<tr class="separator:a8400e38cef181be1023321ef1b75e85f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5d4570e8f82d77eb4b5fabd4d05e5ec4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTable_3_012_00_01T_01_4.html#a5d4570e8f82d77eb4b5fabd4d05e5ec4">Table</a> ()=default</td></tr>
<tr class="separator:a5d4570e8f82d77eb4b5fabd4d05e5ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61c1ac86f917852931108c15dd357f7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTable_3_012_00_01T_01_4.html#ae61c1ac86f917852931108c15dd357f7">Table</a> (const <a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a> size1, const <a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a> size2)</td></tr>
<tr class="separator:ae61c1ac86f917852931108c15dd357f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac528e5302ff82ce126b5f1c9feb0ff1e"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:ac528e5302ff82ce126b5f1c9feb0ff1e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTable_3_012_00_01T_01_4.html#ac528e5302ff82ce126b5f1c9feb0ff1e">Table</a> (const <a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a> size1, const <a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a> size2, InputIterator entries, const <a class="el" href="classbool.html">bool</a> C_style_indexing=true)</td></tr>
<tr class="separator:ac528e5302ff82ce126b5f1c9feb0ff1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac704f1707d5012c67a408affd77e9fb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTable_3_012_00_01T_01_4.html#ac704f1707d5012c67a408affd77e9fb6">reinit</a> (const <a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a> size1, const <a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a> size2, const <a class="el" href="classbool.html">bool</a> omit_default_initialization=false)</td></tr>
<tr class="separator:ac704f1707d5012c67a408affd77e9fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d107fbdde7c294c0240796a9ff9862b"><td class="memItemLeft" align="right" valign="top">::<a class="el" href="classinternal_1_1TableBaseAccessors_1_1Accessor.html">internal::TableBaseAccessors::Accessor</a>&lt; 2, T, true, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTable_3_012_00_01T_01_4.html#a7d107fbdde7c294c0240796a9ff9862b">operator[]</a> (const <a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a> i) const</td></tr>
<tr class="separator:a7d107fbdde7c294c0240796a9ff9862b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12fe800ef260e2ee4dc202991d2f273"><td class="memItemLeft" align="right" valign="top">::<a class="el" href="classinternal_1_1TableBaseAccessors_1_1Accessor.html">internal::TableBaseAccessors::Accessor</a>&lt; 2, T, false, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTable_3_012_00_01T_01_4.html#af12fe800ef260e2ee4dc202991d2f273">operator[]</a> (const <a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a> i)</td></tr>
<tr class="separator:af12fe800ef260e2ee4dc202991d2f273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b021a0a3b51f57bd9e7c7dfb35a6dab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::<a class="el" href="classTable_3_012_00_01T_01_4.html#a1d6e1faa3693a2852ce94e24ea10070b">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTable_3_012_00_01T_01_4.html#a8b021a0a3b51f57bd9e7c7dfb35a6dab">operator()</a> (const <a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a> i, const <a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a> j) const</td></tr>
<tr class="separator:a8b021a0a3b51f57bd9e7c7dfb35a6dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ee3eda5aab5475aa28dcc30978484e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::<a class="el" href="classTable_3_012_00_01T_01_4.html#aa9e8e44cff4a85432bc651d32332ae7a">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTable_3_012_00_01T_01_4.html#ab4ee3eda5aab5475aa28dcc30978484e">operator()</a> (const <a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a> i, const <a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a> j)</td></tr>
<tr class="separator:ab4ee3eda5aab5475aa28dcc30978484e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c6494184c94880a20b1d1918be44af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::<a class="el" href="classTable_3_012_00_01T_01_4.html#aa9e8e44cff4a85432bc651d32332ae7a">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTable_3_012_00_01T_01_4.html#a78c6494184c94880a20b1d1918be44af">operator()</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; 2 &gt; &amp;indices)</td></tr>
<tr class="separator:a78c6494184c94880a20b1d1918be44af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86e76442c1182bb1918c819a690853a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::<a class="el" href="classTable_3_012_00_01T_01_4.html#a1d6e1faa3693a2852ce94e24ea10070b">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTable_3_012_00_01T_01_4.html#ae86e76442c1182bb1918c819a690853a">operator()</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; 2 &gt; &amp;indices) const</td></tr>
<tr class="separator:ae86e76442c1182bb1918c819a690853a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6571f0cfc6041477a726c9e9570e5a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTable_3_012_00_01T_01_4.html#af6571f0cfc6041477a726c9e9570e5a2">n_rows</a> () const</td></tr>
<tr class="separator:af6571f0cfc6041477a726c9e9570e5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f97ae2549e1750fafce36ad0948cf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTable_3_012_00_01T_01_4.html#a00f97ae2549e1750fafce36ad0948cf2">n_cols</a> () const</td></tr>
<tr class="separator:a00f97ae2549e1750fafce36ad0948cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8eeab2cb49f5caf91b9c5d2ff07bef4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTable_3_012_00_01T_01_4.html#a8400e38cef181be1023321ef1b75e85f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTable_3_012_00_01T_01_4.html#af8eeab2cb49f5caf91b9c5d2ff07bef4">begin</a> ()</td></tr>
<tr class="separator:af8eeab2cb49f5caf91b9c5d2ff07bef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c8ea0a831b9f9dac4102e031b529a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTable_3_012_00_01T_01_4.html#ade7d21c3588eca7d92eacfcb820a04e8">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTable_3_012_00_01T_01_4.html#ac9c8ea0a831b9f9dac4102e031b529a7">begin</a> () const</td></tr>
<tr class="separator:ac9c8ea0a831b9f9dac4102e031b529a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce250a02fc2af7c5fcb16df76cc8f06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTable_3_012_00_01T_01_4.html#a8400e38cef181be1023321ef1b75e85f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTable_3_012_00_01T_01_4.html#a5ce250a02fc2af7c5fcb16df76cc8f06">end</a> ()</td></tr>
<tr class="separator:a5ce250a02fc2af7c5fcb16df76cc8f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55b129db04605236a765f59c096d461"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTable_3_012_00_01T_01_4.html#ade7d21c3588eca7d92eacfcb820a04e8">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTable_3_012_00_01T_01_4.html#ab55b129db04605236a765f59c096d461">end</a> () const</td></tr>
<tr class="separator:ab55b129db04605236a765f59c096d461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa998401367252589f5a4bdd7d8087380"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#aa998401367252589f5a4bdd7d8087380">operator==</a> (const <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt; &amp;T2) const</td></tr>
<tr class="separator:aa998401367252589f5a4bdd7d8087380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e75a7ccd3359dccbddc0934bc1bf27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#af0e75a7ccd3359dccbddc0934bc1bf27">reset_values</a> ()</td></tr>
<tr class="separator:af0e75a7ccd3359dccbddc0934bc1bf27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302ef67031a523602fd39911b968d6ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a302ef67031a523602fd39911b968d6ab">reinit</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;new_size, const <a class="el" href="classbool.html">bool</a> omit_default_initialization=false)</td></tr>
<tr class="separator:a302ef67031a523602fd39911b968d6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2204c132154b5d6bfd571eb85d8a58f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#af2204c132154b5d6bfd571eb85d8a58f">size</a> (const unsigned int i) const</td></tr>
<tr class="separator:af2204c132154b5d6bfd571eb85d8a58f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba8a3da6e403297e8d2b231e9d6c35f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#aaba8a3da6e403297e8d2b231e9d6c35f">size</a> () const</td></tr>
<tr class="separator:aaba8a3da6e403297e8d2b231e9d6c35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67161f19c760e98588bdecc560285d2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a67161f19c760e98588bdecc560285d2d">n_elements</a> () const</td></tr>
<tr class="separator:a67161f19c760e98588bdecc560285d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb7b890ac4bbcba1b6524b45af1cbfd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#abb7b890ac4bbcba1b6524b45af1cbfd9">empty</a> () const</td></tr>
<tr class="separator:abb7b890ac4bbcba1b6524b45af1cbfd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad54a19dddbed32640b977b4d7948b434"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#ad54a19dddbed32640b977b4d7948b434">fill</a> (InputIterator entries, const <a class="el" href="classbool.html">bool</a> C_style_indexing=true)</td></tr>
<tr class="separator:ad54a19dddbed32640b977b4d7948b434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a0d148a657080f22dc7c4f213c5a8ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a2a0d148a657080f22dc7c4f213c5a8ee">fill</a> (const T &amp;value)</td></tr>
<tr class="separator:a2a0d148a657080f22dc7c4f213c5a8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b90cda631253866e0f2fa02d714e6b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::<a class="el" href="classTable_3_012_00_01T_01_4.html#aa9e8e44cff4a85432bc651d32332ae7a">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a2b90cda631253866e0f2fa02d714e6b0">operator()</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;indices)</td></tr>
<tr class="separator:a2b90cda631253866e0f2fa02d714e6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2966017e02f461809ff90eb8f4c86ed3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::<a class="el" href="classTable_3_012_00_01T_01_4.html#a1d6e1faa3693a2852ce94e24ea10070b">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a2966017e02f461809ff90eb8f4c86ed3">operator()</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;indices) const</td></tr>
<tr class="separator:a2966017e02f461809ff90eb8f4c86ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140815b9435c997be48f439634afc4f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a140815b9435c997be48f439634afc4f5">swap</a> (<a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt; &amp;v)</td></tr>
<tr class="separator:a140815b9435c997be48f439634afc4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c63db9ae49e0e3b099f0244801016f2"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a2c63db9ae49e0e3b099f0244801016f2">memory_consumption</a> () const</td></tr>
<tr class="separator:a2c63db9ae49e0e3b099f0244801016f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee01f8890040d7b480fc0c72e19f6711"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#aee01f8890040d7b480fc0c72e19f6711">serialize</a> (Archive &amp;ar, const unsigned int version)</td></tr>
<tr class="separator:aee01f8890040d7b480fc0c72e19f6711"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a454e99550c3c0599f4bb56f951d53bc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::<a class="el" href="classTable_3_012_00_01T_01_4.html#aa9e8e44cff4a85432bc651d32332ae7a">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTable_3_012_00_01T_01_4.html#a454e99550c3c0599f4bb56f951d53bc7">el</a> (const <a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a> i, const <a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a> j)</td></tr>
<tr class="separator:a454e99550c3c0599f4bb56f951d53bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5b829de7138b91efd6b5bed195167d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::<a class="el" href="classTable_3_012_00_01T_01_4.html#a1d6e1faa3693a2852ce94e24ea10070b">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTable_3_012_00_01T_01_4.html#ade5b829de7138b91efd6b5bed195167d">el</a> (const <a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a> i, const <a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a> j) const</td></tr>
<tr class="separator:ade5b829de7138b91efd6b5bed195167d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8546237d4c76440bfaed5e1818cdd90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#ab8546237d4c76440bfaed5e1818cdd90">position</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;indices) const</td></tr>
<tr class="separator:ab8546237d4c76440bfaed5e1818cdd90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4474b545894de5a80f3fdacb9ead38c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::<a class="el" href="classTable_3_012_00_01T_01_4.html#aa9e8e44cff4a85432bc651d32332ae7a">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#ad4474b545894de5a80f3fdacb9ead38c">el</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;indices)</td></tr>
<tr class="separator:ad4474b545894de5a80f3fdacb9ead38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a9979fda00a9293c3fa6a6df97639e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::<a class="el" href="classTable_3_012_00_01T_01_4.html#a1d6e1faa3693a2852ce94e24ea10070b">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a40a9979fda00a9293c3fa6a6df97639e">el</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;indices) const</td></tr>
<tr class="separator:a40a9979fda00a9293c3fa6a6df97639e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a50beea2748a06b3abb8d65d5fe7aa8aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a50beea2748a06b3abb8d65d5fe7aa8aa">values</a></td></tr>
<tr class="separator:a50beea2748a06b3abb8d65d5fe7aa8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33df922c5081e1b69e73027cacdaa95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#af33df922c5081e1b69e73027cacdaa95">table_size</a></td></tr>
<tr class="separator:af33df922c5081e1b69e73027cacdaa95"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a3ff82292a9fb64fa10e9d6f4094797f2"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTable_3_012_00_01T_01_4.html#a3ff82292a9fb64fa10e9d6f4094797f2">MatrixTableIterators::AccessorBase&lt; Table&lt; 2, T &gt;, true, MatrixTableIterators::Storage::row_major &gt;</a></td></tr>
<tr class="separator:a3ff82292a9fb64fa10e9d6f4094797f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22863202a073994d1a6161469b46f16"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTable_3_012_00_01T_01_4.html#aa22863202a073994d1a6161469b46f16">MatrixTableIterators::AccessorBase&lt; Table&lt; 2, T &gt;, false, MatrixTableIterators::Storage::row_major &gt;</a></td></tr>
<tr class="separator:aa22863202a073994d1a6161469b46f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71dcf983f9c318121193dc2886779619"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTable_3_012_00_01T_01_4.html#a71dcf983f9c318121193dc2886779619">MatrixTableIterators::Accessor&lt; Table&lt; 2, T &gt;, false, MatrixTableIterators::Storage::row_major &gt;</a></td></tr>
<tr class="separator:a71dcf983f9c318121193dc2886779619"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Subscriptor functionality</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp8d6bc922eebec0b76272099aee4a220d"></a>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</td></tr>
<tr class="memitem:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaeb9ac67567aa7d837f25debd33cd4ce5">map_value_type</a> = decltype(<a class="el" href="group__Exceptions.html#ga73f9f8936b61e6e17ab2a82e9516e95b">counter_map</a>)::<a class="el" href="classTable_3_012_00_01T_01_4.html#a4a7b072532d4db87d348361f5a37e356">value_type</a></td></tr>
<tr class="separator:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacebdc2d11f8522e4d9e8b7d73ac3f491">map_iterator</a> = decltype(<a class="el" href="group__Exceptions.html#ga73f9f8936b61e6e17ab2a82e9516e95b">counter_map</a>)::<a class="el" href="classTable_3_012_00_01T_01_4.html#a8400e38cef181be1023321ef1b75e85f">iterator</a></td></tr>
<tr class="separator:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20658b60d6ef2d530fafa076efa9f503"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga20658b60d6ef2d530fafa076efa9f503">counter</a></td></tr>
<tr class="separator:ga20658b60d6ef2d530fafa076efa9f503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73f9f8936b61e6e17ab2a82e9516e95b"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga73f9f8936b61e6e17ab2a82e9516e95b">counter_map</a></td></tr>
<tr class="separator:ga73f9f8936b61e6e17ab2a82e9516e95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga094d5932c6c004c2a2b1b966950fb2f7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga094d5932c6c004c2a2b1b966950fb2f7">validity_pointers</a></td></tr>
<tr class="separator:ga094d5932c6c004c2a2b1b966950fb2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44e13f7984b31af8d7c54921175a75ff"><td class="memItemLeft" align="right" valign="top">const std::type_info *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga44e13f7984b31af8d7c54921175a75ff">object_info</a></td></tr>
<tr class="separator:ga44e13f7984b31af8d7c54921175a75ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e0d86893427a935e46d5bd6dcbc3f78"><td class="memItemLeft" align="right" valign="top">static std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7e0d86893427a935e46d5bd6dcbc3f78">mutex</a></td></tr>
<tr class="separator:ga7e0d86893427a935e46d5bd6dcbc3f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (int arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga300c593ea0f9422dcbce1445903e6c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga300c593ea0f9422dcbce1445903e6c12">check_no_subscribers</a> () const noexcept</td></tr>
<tr class="separator:ga300c593ea0f9422dcbce1445903e6c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class Table&lt; 2, T &gt;</h3>

<p>A class representing a two-dimensional table, i.e. a matrix of objects (not necessarily only numbers).</p>
<p>For the rationale of this class, and a description of the interface, see the base class. Since this serves as the base class of the full matrix classes in this library, and to keep a minimal compatibility with a predecessor class (<code>vector2d</code>), some additional functions are provided. </p>

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l01106">1106</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a77d40d21c3ed4e9ae4dd18e67f26943b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d40d21c3ed4e9ae4dd18e67f26943b">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTable.html">Table</a>&lt; 2, T &gt;::<a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a> =  typename <a class="el" href="classTableBase.html">TableBase</a>&lt;2, T&gt;::<a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Integer type used to count the number of elements in this container. </p>

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l01112">1112</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<a id="a4a7b072532d4db87d348361f5a37e356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a7b072532d4db87d348361f5a37e356">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTable.html">Table</a>&lt; 2, T &gt;::<a class="el" href="classTable_3_012_00_01T_01_4.html#a4a7b072532d4db87d348361f5a37e356">value_type</a> =  typename <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;T&gt;::<a class="el" href="classTable_3_012_00_01T_01_4.html#a4a7b072532d4db87d348361f5a37e356">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef for the values in the table. </p>

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l01117">1117</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<a id="aa9e8e44cff4a85432bc651d32332ae7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9e8e44cff4a85432bc651d32332ae7a">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTable.html">Table</a>&lt; 2, T &gt;::<a class="el" href="classTable_3_012_00_01T_01_4.html#aa9e8e44cff4a85432bc651d32332ae7a">reference</a> =  typename <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;T&gt;::<a class="el" href="classTable_3_012_00_01T_01_4.html#aa9e8e44cff4a85432bc651d32332ae7a">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef for the references in the table. </p>

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l01122">1122</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<a id="a1d6e1faa3693a2852ce94e24ea10070b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d6e1faa3693a2852ce94e24ea10070b">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTable.html">Table</a>&lt; 2, T &gt;::<a class="el" href="classTable_3_012_00_01T_01_4.html#a1d6e1faa3693a2852ce94e24ea10070b">const_reference</a> =  typename <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;T&gt;::<a class="el" href="classTable_3_012_00_01T_01_4.html#a1d6e1faa3693a2852ce94e24ea10070b">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef for the constant references in the table. </p>

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l01127">1127</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<a id="ade7d21c3588eca7d92eacfcb820a04e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade7d21c3588eca7d92eacfcb820a04e8">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTable.html">Table</a>&lt; 2, T &gt;::<a class="el" href="classTable_3_012_00_01T_01_4.html#ade7d21c3588eca7d92eacfcb820a04e8">const_iterator</a> =  MatrixTableIterators:: Iterator&lt;<a class="el" href="classTable.html">Table</a>&lt;2, T&gt;, true, <a class="el" href="namespaceMatrixTableIterators.html#a071affcab0c2e4302df96f2d1540bd08a641fabb8e5e7d1d0333e2c9c384f959c">MatrixTableIterators::Storage::row_major</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef for a constant iterator that traverses the table in column-major order. </p>

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l01133">1133</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<a id="a8400e38cef181be1023321ef1b75e85f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8400e38cef181be1023321ef1b75e85f">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTable.html">Table</a>&lt; 2, T &gt;::<a class="el" href="classTable_3_012_00_01T_01_4.html#a8400e38cef181be1023321ef1b75e85f">iterator</a> =  MatrixTableIterators:: Iterator&lt;<a class="el" href="classTable.html">Table</a>&lt;2, T&gt;, false, <a class="el" href="namespaceMatrixTableIterators.html#a071affcab0c2e4302df96f2d1540bd08a641fabb8e5e7d1d0333e2c9c384f959c">MatrixTableIterators::Storage::row_major</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef for an iterator that traverses the table in column-major order. </p>

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l01139">1139</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5d4570e8f82d77eb4b5fabd4d05e5ec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d4570e8f82d77eb4b5fabd4d05e5ec4">&#9670;&nbsp;</a></span>Table() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTable.html">Table</a>&lt; 2, T &gt;::<a class="el" href="classTable.html">Table</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default constructor. Set all dimensions to zero. </p>

</div>
</div>
<a id="ae61c1ac86f917852931108c15dd357f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae61c1ac86f917852931108c15dd357f7">&#9670;&nbsp;</a></span>Table() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTable.html">Table</a>&lt; 2, T &gt;::<a class="el" href="classTable.html">Table</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a>&#160;</td>
          <td class="paramname"><em>size1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a>&#160;</td>
          <td class="paramname"><em>size2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Pass down the given dimensions to the base class. </p>

</div>
</div>
<a id="ac528e5302ff82ce126b5f1c9feb0ff1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac528e5302ff82ce126b5f1c9feb0ff1e">&#9670;&nbsp;</a></span>Table() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTable.html">Table</a>&lt; 2, T &gt;::<a class="el" href="classTable.html">Table</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a>&#160;</td>
          <td class="paramname"><em>size1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a>&#160;</td>
          <td class="paramname"><em>size2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>C_style_indexing</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Create a table with a given size and initialize it from a set of iterators.</p>
<p>This function is entirely equivalent to creating a table <code>t</code> of the given size and then calling </p><div class="fragment"><div class="line">t.fill (entries, C_style_indexing);</div>
</div><!-- fragment --><p> on it, using the <a class="el" href="classTableBase.html#ad54a19dddbed32640b977b4d7948b434">TableBase::fill()</a> function where the arguments are explained in more detail. The point, however, is that that is only possible if the table can be changed after running the constructor, whereas calling the current constructor allows sizing and initializing an object right away so that it can be marked const.</p>
<p>Using this constructor, you can do things like this: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="classTableBase.html#a50beea2748a06b3abb8d65d5fe7aa8aa">values</a>[] = { 1, 2, 3, 4, 5, 6 };</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="classTable.html">Table&lt;2,double&gt;</a> t(2, 3, entries, <span class="keyword">true</span>);</div>
<div class="ttc" id="aclassTableBase_html_a50beea2748a06b3abb8d65d5fe7aa8aa"><div class="ttname"><a href="classTableBase.html#a50beea2748a06b3abb8d65d5fe7aa8aa">TableBase&lt; 2, T &gt;::values</a></div><div class="ttdeci">AlignedVector&lt; T &gt; values</div><div class="ttdef"><b>Definition:</b> <a href="table_8h_source.html#l00640">table.h:640</a></div></div>
<div class="ttc" id="aclassTable_html"><div class="ttname"><a href="classTable.html">Table&lt; 2, double &gt;</a></div></div>
</div><!-- fragment --><p> You can also initialize a table right from a file, using input iterators: </p><div class="fragment"><div class="line">std::ifstream input (<span class="stringliteral">&quot;myfile&quot;</span>);</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="classTable.html">Table&lt;2,double&gt;</a> t(2, 3,</div>
<div class="line">                        std::istream_iterator&lt;double&gt;(input),</div>
<div class="line">                        <span class="keyword">true</span>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size1</td><td>The size of this table in the first dimension. </td></tr>
    <tr><td class="paramname">size2</td><td>The size of this table in the second dimension. </td></tr>
    <tr><td class="paramname">entries</td><td>An iterator to a set of elements from which to initialize this table. It is assumed that iterator can be incremented and dereferenced a sufficient number of times to fill this table. </td></tr>
    <tr><td class="paramname">C_style_indexing</td><td>If true, run over elements of the table with the last index changing fastest as we dereference subsequent elements of the input range. If false, change the first index fastest. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac704f1707d5012c67a408affd77e9fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac704f1707d5012c67a408affd77e9fb6">&#9670;&nbsp;</a></span>reinit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTable.html">Table</a>&lt; 2, T &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a>&#160;</td>
          <td class="paramname"><em>size1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a>&#160;</td>
          <td class="paramname"><em>size2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_default_initialization</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinitialize the object. This function is mostly here for compatibility with the earlier <code>vector2d</code> class. Passes down to the base class by converting the arguments to the data type requested by the base class. </p>

</div>
</div>
<a id="a7d107fbdde7c294c0240796a9ff9862b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d107fbdde7c294c0240796a9ff9862b">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">::<a class="el" href="classinternal_1_1TableBaseAccessors_1_1Accessor.html">internal::TableBaseAccessors::Accessor</a>&lt;2, T, true, 1&gt; <a class="el" href="classTable.html">Table</a>&lt; 2, T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access operator. Generate an object that accesses the requested row of this two-dimensional table. Range checks are performed.</p>
<p>This version of the function only allows read access. </p>

</div>
</div>
<a id="af12fe800ef260e2ee4dc202991d2f273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af12fe800ef260e2ee4dc202991d2f273">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">::<a class="el" href="classinternal_1_1TableBaseAccessors_1_1Accessor.html">internal::TableBaseAccessors::Accessor</a>&lt;2, T, false, 1&gt; <a class="el" href="classTable.html">Table</a>&lt; 2, T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access operator. Generate an object that accesses the requested row of this two-dimensional table. Range checks are performed.</p>
<p>This version of the function allows read-write access. </p>

</div>
</div>
<a id="a8b021a0a3b51f57bd9e7c7dfb35a6dab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b021a0a3b51f57bd9e7c7dfb35a6dab">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;T&gt;::<a class="el" href="classTable_3_012_00_01T_01_4.html#a1d6e1faa3693a2852ce94e24ea10070b">const_reference</a> <a class="el" href="classTable.html">Table</a>&lt; 2, T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Direct access to one element of the table by specifying all indices at the same time. Range checks are performed.</p>
<p>This version of the function only allows read access. </p>

</div>
</div>
<a id="ab4ee3eda5aab5475aa28dcc30978484e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4ee3eda5aab5475aa28dcc30978484e">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;T&gt;::<a class="el" href="classTable_3_012_00_01T_01_4.html#aa9e8e44cff4a85432bc651d32332ae7a">reference</a> <a class="el" href="classTable.html">Table</a>&lt; 2, T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Direct access to one element of the table by specifying all indices at the same time. Range checks are performed.</p>
<p>This version of the function allows read-write access. </p>

</div>
</div>
<a id="a78c6494184c94880a20b1d1918be44af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78c6494184c94880a20b1d1918be44af">&#9670;&nbsp;</a></span>operator()() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;T&gt;::<a class="el" href="classTable_3_012_00_01T_01_4.html#aa9e8e44cff4a85432bc651d32332ae7a">reference</a> <a class="el" href="classTable.html">Table</a>&lt; 2, T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make the corresponding operator () from the <a class="el" href="classTableBase.html">TableBase</a> base class available also in this class. </p>

</div>
</div>
<a id="ae86e76442c1182bb1918c819a690853a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae86e76442c1182bb1918c819a690853a">&#9670;&nbsp;</a></span>operator()() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;T&gt;::<a class="el" href="classTable_3_012_00_01T_01_4.html#a1d6e1faa3693a2852ce94e24ea10070b">const_reference</a> <a class="el" href="classTable.html">Table</a>&lt; 2, T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make the corresponding operator () from the <a class="el" href="classTableBase.html">TableBase</a> base class available also in this class. </p>

</div>
</div>
<a id="af6571f0cfc6041477a726c9e9570e5a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6571f0cfc6041477a726c9e9570e5a2">&#9670;&nbsp;</a></span>n_rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a> <a class="el" href="classTable.html">Table</a>&lt; 2, T &gt;::n_rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of rows. This function really makes only sense since we have a two-dimensional object here. </p>

</div>
</div>
<a id="a00f97ae2549e1750fafce36ad0948cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00f97ae2549e1750fafce36ad0948cf2">&#9670;&nbsp;</a></span>n_cols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a> <a class="el" href="classTable.html">Table</a>&lt; 2, T &gt;::n_cols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of columns. This function really makes only sense since we have a two-dimensional object here. </p>

</div>
</div>
<a id="af8eeab2cb49f5caf91b9c5d2ff07bef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8eeab2cb49f5caf91b9c5d2ff07bef4">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTable_3_012_00_01T_01_4.html#a8400e38cef181be1023321ef1b75e85f">iterator</a> <a class="el" href="classTable.html">Table</a>&lt; 2, T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator pointing to the first entry. </p>

</div>
</div>
<a id="ac9c8ea0a831b9f9dac4102e031b529a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9c8ea0a831b9f9dac4102e031b529a7">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTable_3_012_00_01T_01_4.html#ade7d21c3588eca7d92eacfcb820a04e8">const_iterator</a> <a class="el" href="classTable.html">Table</a>&lt; 2, T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a constant iterator pointing to the first entry. </p>

</div>
</div>
<a id="a5ce250a02fc2af7c5fcb16df76cc8f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce250a02fc2af7c5fcb16df76cc8f06">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTable_3_012_00_01T_01_4.html#a8400e38cef181be1023321ef1b75e85f">iterator</a> <a class="el" href="classTable.html">Table</a>&lt; 2, T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator pointing to one past the last entry. </p>

</div>
</div>
<a id="ab55b129db04605236a765f59c096d461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55b129db04605236a765f59c096d461">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTable_3_012_00_01T_01_4.html#ade7d21c3588eca7d92eacfcb820a04e8">const_iterator</a> <a class="el" href="classTable.html">Table</a>&lt; 2, T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a constant iterator pointing to one past the last entry. </p>

</div>
</div>
<a id="a454e99550c3c0599f4bb56f951d53bc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a454e99550c3c0599f4bb56f951d53bc7">&#9670;&nbsp;</a></span>el() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;T&gt;::<a class="el" href="classTable_3_012_00_01T_01_4.html#aa9e8e44cff4a85432bc651d32332ae7a">reference</a> <a class="el" href="classTable.html">Table</a>&lt; 2, T &gt;::el </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a read-write reference to the element <code>(i,j)</code>.</p>
<p>This function does no bounds checking and is only to be used internally and in functions already checked.</p>
<p>These functions are mainly here for compatibility with a former implementation of these table classes for 2d arrays, then called <code>vector2d</code>. </p>

</div>
</div>
<a id="ade5b829de7138b91efd6b5bed195167d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5b829de7138b91efd6b5bed195167d">&#9670;&nbsp;</a></span>el() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;T&gt;::<a class="el" href="classTable_3_012_00_01T_01_4.html#a1d6e1faa3693a2852ce94e24ea10070b">const_reference</a> <a class="el" href="classTable.html">Table</a>&lt; 2, T &gt;::el </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the element <code>(i,j)</code> as a read-only reference.</p>
<p>This function does no bounds checking and is only to be used internally and in functions already checked.</p>
<p>We return the requested value as a constant reference rather than by value since this object may hold data types that may be large, and we don't know here whether copying is expensive or not.</p>
<p>These functions are mainly here for compatibility with a former implementation of these table classes for 2d arrays, then called <code>vector2d</code>. </p>

</div>
</div>
<a id="aa998401367252589f5a4bdd7d8087380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa998401367252589f5a4bdd7d8087380">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>T2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test for equality of two tables. </p>

</div>
</div>
<a id="af0e75a7ccd3359dccbddc0934bc1bf27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e75a7ccd3359dccbddc0934bc1bf27">&#9670;&nbsp;</a></span>reset_values()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::reset_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set all entries to their default value (i.e. copy them over with default constructed objects). Do not change the size of the table, though. </p>

</div>
</div>
<a id="a302ef67031a523602fd39911b968d6ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a302ef67031a523602fd39911b968d6ab">&#9670;&nbsp;</a></span>reinit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_default_initialization</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the dimensions of this object to the sizes given in the first argument, and allocate the required memory for table entries to accommodate these sizes. If <code>omit_default_initialization</code> is set to <code>false</code>, all elements of the table are set to a default constructed object for the element type. Otherwise the memory is left in an uninitialized or otherwise undefined state. </p>

</div>
</div>
<a id="af2204c132154b5d6bfd571eb85d8a58f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2204c132154b5d6bfd571eb85d8a58f">&#9670;&nbsp;</a></span>size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a> <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::size </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Size of the table in direction <code>i</code>. </p>

</div>
</div>
<a id="aaba8a3da6e403297e8d2b231e9d6c35f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba8a3da6e403297e8d2b231e9d6c35f">&#9670;&nbsp;</a></span>size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt;N&gt;&amp; <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the sizes of this object in each direction. </p>

</div>
</div>
<a id="a67161f19c760e98588bdecc560285d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67161f19c760e98588bdecc560285d2d">&#9670;&nbsp;</a></span>n_elements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a> <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::n_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of elements stored in this object, which is the product of the extensions in each dimension. </p>

</div>
</div>
<a id="abb7b890ac4bbcba1b6524b45af1cbfd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb7b890ac4bbcba1b6524b45af1cbfd9">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether the object is empty, i.e. one of the directions is zero. This is equivalent to <code><a class="el" href="classTableBase.html#a67161f19c760e98588bdecc560285d2d">n_elements()</a>==0</code>. </p>

</div>
</div>
<a id="ad54a19dddbed32640b977b4d7948b434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad54a19dddbed32640b977b4d7948b434">&#9670;&nbsp;</a></span>fill() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>C_style_indexing</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fill this table (which is assumed to already have the correct size) from a source given by dereferencing the given forward iterator (which could, for example, be a pointer to the first element of an array, or an inserting std::istream_iterator). The second argument denotes whether the elements pointed to are arranged in a way that corresponds to the last index running fastest or slowest. The default is to use C-style indexing where the last index runs fastest (as opposed to Fortran-style where the first index runs fastest when traversing multidimensional arrays. For example, if you try to fill an object of type <a class="el" href="classTable_3_012_00_01T_01_4.html">Table&lt;2,T&gt;</a>, then calling this function with the default value for the second argument will result in the equivalent of doing </p><div class="fragment"><div class="line"><a class="code" href="classTable_3_012_00_01T_01_4.html">Table&lt;2,T&gt;</a> t;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;t.<a class="code" href="classTableBase.html#af2204c132154b5d6bfd571eb85d8a58f">size</a>(0); ++i)</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;t.<a class="code" href="classTableBase.html#af2204c132154b5d6bfd571eb85d8a58f">size</a>(1); ++j)</div>
<div class="line">    t[i][j] = *entries++;</div>
<div class="ttc" id="aclassTableBase_html_af2204c132154b5d6bfd571eb85d8a58f"><div class="ttname"><a href="classTableBase.html#af2204c132154b5d6bfd571eb85d8a58f">TableBase::size</a></div><div class="ttdeci">size_type size(const unsigned int i) const</div></div>
<div class="ttc" id="aclassTable_3_012_00_01T_01_4_html"><div class="ttname"><a href="classTable_3_012_00_01T_01_4.html">Table&lt; 2, T &gt;</a></div><div class="ttdef"><b>Definition:</b> <a href="table_8h_source.html#l01106">table.h:1107</a></div></div>
</div><!-- fragment --><p> On the other hand, if the second argument to this function is false, then this would result in code of the following form: </p><div class="fragment"><div class="line"><a class="code" href="classTable_3_012_00_01T_01_4.html">Table&lt;2,T&gt;</a> t;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;t.<a class="code" href="classTableBase.html#af2204c132154b5d6bfd571eb85d8a58f">size</a>(1); ++j)</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;t.<a class="code" href="classTableBase.html#af2204c132154b5d6bfd571eb85d8a58f">size</a>(0); ++i)</div>
<div class="line">    t[i][j] = *entries++;</div>
</div><!-- fragment --><p> Note the switched order in which we fill the table elements by traversing the given set of iterators.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entries</td><td>An iterator to a set of elements from which to initialize this table. It is assumed that iterator can be incremented and dereferenced a sufficient number of times to fill this table. </td></tr>
    <tr><td class="paramname">C_style_indexing</td><td>If true, run over elements of the table with the last index changing fastest as we dereference subsequent elements of the input range. If false, change the first index fastest. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a0d148a657080f22dc7c4f213c5a8ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a0d148a657080f22dc7c4f213c5a8ee">&#9670;&nbsp;</a></span>fill() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fill all table entries with the same value. </p>

</div>
</div>
<a id="a2b90cda631253866e0f2fa02d714e6b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b90cda631253866e0f2fa02d714e6b0">&#9670;&nbsp;</a></span>operator()() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;T&gt;::<a class="el" href="classTable_3_012_00_01T_01_4.html#aa9e8e44cff4a85432bc651d32332ae7a">reference</a> <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a read-write reference to the indicated element. </p>

</div>
</div>
<a id="a2966017e02f461809ff90eb8f4c86ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2966017e02f461809ff90eb8f4c86ed3">&#9670;&nbsp;</a></span>operator()() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;T&gt;::<a class="el" href="classTable_3_012_00_01T_01_4.html#a1d6e1faa3693a2852ce94e24ea10070b">const_reference</a> <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the indicated element as a read-only reference.</p>
<p>We return the requested value as a constant reference rather than by value since this object may hold data types that may be large, and we don't know here whether copying is expensive or not. </p>

</div>
</div>
<a id="a140815b9435c997be48f439634afc4f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a140815b9435c997be48f439634afc4f5">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swap the contents of this table and the other table <code>v</code>. One could do this operation with a temporary variable and copying over the data elements, but this function is significantly more efficient since it only swaps the pointers to the data of the two vectors and therefore does not need to allocate temporary storage and move data around.</p>
<p>This function is analogous to the <code>swap</code> function of all C++ standard containers. Also, there is a global function <code>swap(u,v)</code> that simply calls <code>u.swap(v)</code>, again in analogy to standard functions. </p>

</div>
</div>
<a id="a2c63db9ae49e0e3b099f0244801016f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c63db9ae49e0e3b099f0244801016f2">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. </p>

</div>
</div>
<a id="aee01f8890040d7b480fc0c72e19f6711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee01f8890040d7b480fc0c72e19f6711">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write or read the data of this object to or from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. </p>

</div>
</div>
<a id="ab8546237d4c76440bfaed5e1818cdd90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8546237d4c76440bfaed5e1818cdd90">&#9670;&nbsp;</a></span>position()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTable_3_012_00_01T_01_4.html#a77d40d21c3ed4e9ae4dd18e67f26943b">size_type</a> <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::position </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the position of the indicated element within the array of elements stored one after the other. This function does no index checking. </p>

</div>
</div>
<a id="ad4474b545894de5a80f3fdacb9ead38c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4474b545894de5a80f3fdacb9ead38c">&#9670;&nbsp;</a></span>el() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;T&gt;::<a class="el" href="classTable_3_012_00_01T_01_4.html#aa9e8e44cff4a85432bc651d32332ae7a">reference</a> <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::el </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a read-write reference to the indicated element.</p>
<p>This function does no bounds checking and is only to be used internally and in functions already checked. </p>

</div>
</div>
<a id="a40a9979fda00a9293c3fa6a6df97639e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a9979fda00a9293c3fa6a6df97639e">&#9670;&nbsp;</a></span>el() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;T&gt;::<a class="el" href="classTable_3_012_00_01T_01_4.html#a1d6e1faa3693a2852ce94e24ea10070b">const_reference</a> <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::el </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the indicated element as a read-only reference.</p>
<p>This function does no bounds checking and is only to be used internally and in functions already checked.</p>
<p>We return the requested value as a constant reference rather than by value since this object may hold data types that may be large, and we don't know here whether copying is expensive or not. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a3ff82292a9fb64fa10e9d6f4094797f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ff82292a9fb64fa10e9d6f4094797f2">&#9670;&nbsp;</a></span>MatrixTableIterators::AccessorBase&lt; Table&lt; 2, T &gt;, true, MatrixTableIterators::Storage::row_major &gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class MatrixTableIterators:: AccessorBase&lt; <a class="el" href="classTable.html">Table</a>&lt; 2, T &gt;, true, <a class="el" href="namespaceMatrixTableIterators.html#a071affcab0c2e4302df96f2d1540bd08a641fabb8e5e7d1d0333e2c9c384f959c">MatrixTableIterators::Storage::row_major</a> &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l01326">1326</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<a id="aa22863202a073994d1a6161469b46f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa22863202a073994d1a6161469b46f16">&#9670;&nbsp;</a></span>MatrixTableIterators::AccessorBase&lt; Table&lt; 2, T &gt;, false, MatrixTableIterators::Storage::row_major &gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class MatrixTableIterators:: AccessorBase&lt; <a class="el" href="classTable.html">Table</a>&lt; 2, T &gt;, false, <a class="el" href="namespaceMatrixTableIterators.html#a071affcab0c2e4302df96f2d1540bd08a641fabb8e5e7d1d0333e2c9c384f959c">MatrixTableIterators::Storage::row_major</a> &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l01326">1326</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<a id="a71dcf983f9c318121193dc2886779619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71dcf983f9c318121193dc2886779619">&#9670;&nbsp;</a></span>MatrixTableIterators::Accessor&lt; Table&lt; 2, T &gt;, false, MatrixTableIterators::Storage::row_major &gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class MatrixTableIterators:: Accessor&lt; <a class="el" href="classTable.html">Table</a>&lt; 2, T &gt;, false, <a class="el" href="namespaceMatrixTableIterators.html#a071affcab0c2e4302df96f2d1540bd08a641fabb8e5e7d1d0333e2c9c384f959c">MatrixTableIterators::Storage::row_major</a> &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l01326">1326</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a50beea2748a06b3abb8d65d5fe7aa8aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50beea2748a06b3abb8d65d5fe7aa8aa">&#9670;&nbsp;</a></span>values</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;T&gt; <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::values</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Component-array. </p>

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00640">640</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<a id="af33df922c5081e1b69e73027cacdaa95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af33df922c5081e1b69e73027cacdaa95">&#9670;&nbsp;</a></span>table_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTableIndices.html">TableIndices</a>&lt;N&gt; <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::table_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Size in each direction of the table. </p>

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00645">645</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/base/<a class="el" href="table_8h_source.html">table.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
