<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_29.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-29 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.3.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.3.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">The step-29 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_4.html">step-4</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Problemsetting">Problem setting</a>
        <li><a href="#Thetestcase">The test case</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeDirichletBoundaryValuescodeclass">The <code>DirichletBoundaryValues</code> class</a>
        <li><a href="#ThecodeParameterReadercodeclass">The <code>ParameterReader</code> class</a>
      <ul>
        <li><a href="#codeParameterReaderdeclare_parameterscode"><code>ParameterReader::declare_parameters</code></a>
        <li><a href="#codeParameterReaderread_parameterscode"><code>ParameterReader::read_parameters</code></a>
      </ul>
        <li><a href="#ThecodeComputeIntensitycodeclass">The <code>ComputeIntensity</code> class</a>
        <li><a href="#ThecodeUltrasoundProblemcodeclass">The <code>UltrasoundProblem</code> class</a>
      <ul>
        <li><a href="#codeUltrasoundProblemmake_gridcode"><code>UltrasoundProblem::make_grid</code></a>
        <li><a href="#codeUltrasoundProblemsetup_systemcode"><code>UltrasoundProblem::setup_system</code></a>
        <li><a href="#codeUltrasoundProblemassemble_systemcode"><code>UltrasoundProblem::assemble_system</code></a>
        <li><a href="#codeUltrasoundProblemsolvecode"><code>UltrasoundProblem::solve</code></a>
        <li><a href="#codeUltrasoundProblemoutput_resultscode"><code>UltrasoundProblem::output_results</code></a>
        <li><a href="#codeUltrasoundProblemruncode"><code>UltrasoundProblem::run</code></a>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br  />
</p>
<p><em> This program was contributed by Moritz Allmaras at Texas A&amp;M University. Some of the work on this tutorial program has been funded by NSF under grant DMS-0604778. </em></p>
<p><b>Note:</b> In order to run this program, deal.II must be configured to use the UMFPACK sparse direct solver. Refer to the <a href="../../readme.html#umfpack">ReadMe</a> for instructions how to do this.</p>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>A question that comes up frequently is how to solve problems involving complex valued functions with deal.II. For many problems, instead of working with complex valued finite elements directly, it is often more convenient to split complex valued functions into their real and imaginary parts and use separate scalar finite element fields for discretizing each one of them. Basically this amounts to viewing a single complex valued equation as a system of two real valued equations. This short example demonstrates how this can be implemented in deal.II by using an <code>FE_system</code> object to stack two finite element fields representing real and imaginary parts. (The opposite approach, keeping everything complex-valued, is demonstrated in a different tutorial program: see <a class="el" href="step_58.html">step-58</a> for this.) When split into real and imaginary parts, the equations covered here fall into the class of vector-valued problems. A toplevel overview of this topic can be found in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module.</p>
<p>In addition to this discussion, we also discuss the <a class="el" href="classParameterHandler.html">ParameterHandler</a> class, which provides a convenient way for reading parameters from a configuration file at runtime without the need to recompile the program code.</p>
<p><a class="anchor" id="Problemsetting"></a></p><h3>Problem setting</h3>
<p>The original purpose of this program is to simulate the focusing properties of an ultrasound wave generated by a transducer lens with variable geometry. Recent applications in medical imaging use ultrasound waves not only for imaging purposes, but also to excite certain local effects in a material, like changes in optical properties, that can then be measured by other imaging techniques. A vital ingredient for these methods is the ability to focus the intensity of the ultrasound wave in a particular part of the material, ideally in a point, to be able to examine the properties of the material at that particular location.</p>
<p>To derive a model for this problem, we think of ultrasound as a pressure wave governed by the wave equation: </p><p class="formulaDsp">
\[ \frac{\partial^2 U}{\partial t^2} - c^2 \Delta U = 0 \]
</p>
<p> where \(c\) is the wave speed (that for simplicity we assume to be constant), \(U = U(x,t),\;x \in \Omega,\;t\in\mathrm{R}\). The boundary \(\Gamma=\partial\Omega\) is divided into two parts \(\Gamma_1\) and \(\Gamma_2=\Gamma\setminus\Gamma_1\), with \(\Gamma_1\) representing the transducer lens and \(\Gamma_2\) an absorbing boundary (that is, we want to choose boundary conditions on \(\Gamma_2\) in such a way that they imitate a larger domain). On \(\Gamma_1\), the transducer generates a wave of constant frequency \({\omega}&gt;0\) and constant amplitude (that we chose to be 1 here): </p><p class="formulaDsp">
\[ U(x,t) = \cos{\omega t}, \qquad x\in \Gamma_1 \]
</p>
<p>If there are no other (interior or boundary) sources, and since the only source has frequency \(\omega\), then the solution admits a separation of variables of the form \(U(x,t) = \textrm{Re}\left(u(x)\,e^{i\omega t})\right)\). The complex-valued function \(u(x)\) describes the spatial dependency of amplitude and phase (relative to the source) of the waves of frequency \({\omega}\), with the amplitude being the quantity that we are interested in. By plugging this form of the solution into the wave equation, we see that for \(u\) we have </p><p class="formulaDsp">
\begin{eqnarray*} -\omega^2 u(x) - c^2\Delta u(x) &amp;=&amp; 0, \qquad x\in\Omega,\\ u(x) &amp;=&amp; 1, \qquad x\in\Gamma_1. \end{eqnarray*}
</p>
<p>For finding suitable conditions on \(\Gamma_2\) that model an absorbing boundary, consider a wave of the form \(V(x,t)=e^{i(k\cdot x -\omega t)}\) with frequency \({\omega}\) traveling in direction \(k\in {\mathrm{R}^2}\). In order for \(V\) to solve the wave equation, \(|k|={\frac{\omega}{c}}\) must hold. Suppose that this wave hits the boundary in \(x_0\in\Gamma_2\) at a right angle, i.e. \(n=\frac{k}{|k|}\) with \(n\) denoting the outer unit normal of \(\Omega\) in \(x_0\). Then at \(x_0\), this wave satisfies the equation </p><p class="formulaDsp">
\[ c (n\cdot\nabla V) + \frac{\partial V}{\partial t} = (i\, c\, |k| - i\, \omega) V = 0. \]
</p>
<p> Hence, by enforcing the boundary condition </p><p class="formulaDsp">
\[ c (n\cdot\nabla U) + \frac{\partial U}{\partial t} = 0, \qquad x\in\Gamma_2, \]
</p>
<p> waves that hit the boundary \(\Gamma_2\) at a right angle will be perfectly absorbed. On the other hand, those parts of the wave field that do not hit a boundary at a right angle do not satisfy this condition and enforcing it as a boundary condition will yield partial reflections, i.e. only parts of the wave will pass through the boundary as if it wasn't here whereas the remaining fraction of the wave will be reflected back into the domain.</p>
<p>If we are willing to accept this as a sufficient approximation to an absorbing boundary we finally arrive at the following problem for \(u\): </p><p class="formulaDsp">
\begin{eqnarray*} -\omega^2 u - c^2\Delta u &amp;=&amp; 0, \qquad x\in\Omega,\\ c (n\cdot\nabla u) + i\,\omega\,u &amp;=&amp;0, \qquad x\in\Gamma_2,\\ u &amp;=&amp; 1, \qquad x\in\Gamma_1. \end{eqnarray*}
</p>
<p> This is a Helmholtz equation (similar to the one in <a class="el" href="step_7.html">step-7</a>, but this time with ''the bad sign'') with Dirichlet data on \(\Gamma_1\) and mixed boundary conditions on \(\Gamma_2\). Because of the condition on \(\Gamma_2\), we cannot just treat the equations for real and imaginary parts of \(u\) separately. What we can do however is to view the PDE for \(u\) as a system of two PDEs for the real and imaginary parts of \(u\), with the boundary condition on \(\Gamma_2\) representing the coupling terms between the two components of the system. This works along the following lines: Let \(v=\textrm{Re}\;u,\; w=\textrm{Im}\;u\), then in terms of \(v\) and \(w\) we have the following system: </p><p class="formulaDsp">
\begin{eqnarray*} \left.\begin{array}{ccc} -\omega^2 v - c^2\Delta v &amp;=&amp; 0 \quad\\ -\omega^2 w - c^2\Delta w &amp;=&amp; 0 \quad \end{array}\right\} &amp;\;&amp; x\in\Omega, \\ \left.\begin{array}{ccc} c (n\cdot\nabla v) - \omega\,w &amp;=&amp; 0 \quad\\ c (n\cdot\nabla w) + \omega\,v &amp;=&amp; 0 \quad \end{array}\right\} &amp;\;&amp; x\in\Gamma_2, \\ \left.\begin{array}{ccc} v &amp;=&amp; 1 \quad\\ w &amp;=&amp; 0 \quad \end{array}\right\} &amp;\;&amp; x\in\Gamma_1. \end{eqnarray*}
</p>
<p>For test functions \(\phi,\psi\) with \(\phi|_{\Gamma_1}=\psi|_{\Gamma_1}=0\), after the usual multiplication, integration over \(\Omega\) and applying integration by parts, we get the weak formulation </p><p class="formulaDsp">
\begin{eqnarray*} -\omega^2 \langle \phi, v \rangle_{\mathrm{L}^2(\Omega)} + c^2 \langle \nabla \phi, \nabla v \rangle_{\mathrm{L}^2(\Omega)} - c \omega \langle \phi, w \rangle_{\mathrm{L}^2(\Gamma_2)} &amp;=&amp; 0, \\ -\omega^2 \langle \psi, w \rangle_{\mathrm{L}^2(\Omega)} + c^2 \langle \nabla \psi, \nabla w \rangle_{\mathrm{L}^2(\Omega)} + c \omega \langle \psi, v \rangle_{\mathrm{L}^2(\Gamma_2)} &amp;=&amp; 0. \end{eqnarray*}
</p>
<p>We choose finite element spaces \(V_h\) and \(W_h\) with bases \(\{\phi_j\}_{j=1}^n, \{\psi_j\}_{j=1}^n\) and look for approximate solutions </p><p class="formulaDsp">
\[ v_h = \sum_{j=1}^n \alpha_j \phi_j, \;\; w_h = \sum_{j=1}^n \beta_j \psi_j. \]
</p>
<p> Plugging into the variational form yields the equation system </p><p class="formulaDsp">
\[ \renewcommand{\arraystretch}{2.0} \left.\begin{array}{ccc} \sum_{j=1}^n \left( -\omega^2 \langle \phi_i, \phi_j \rangle_{\mathrm{L}^2(\Omega)} + c^2 \langle \nabla \phi_i, \nabla \phi_j \rangle_{\mathrm{L}^2(\Omega)} \right) \alpha_j - \left( c\omega \langle \phi_i,\psi_j\rangle_{\mathrm{L}^2(\Gamma_2)}\right)\beta_j &amp;=&amp; 0 \\ \sum_{j=1}^n \left( -\omega^2 \langle \psi_i, \psi_j \rangle_{\mathrm{L}^2(\Omega)} + c^2 \langle \nabla \psi_i, \nabla \psi_j \rangle_{\mathrm{L}^2(\Omega)} \right)\beta_j + \left( c\omega \langle \psi_i,\phi_j\rangle_{\mathrm{L}^2(\Gamma_2)} \right)\alpha_j &amp;=&amp; 0 \end{array}\right\}\;\;\forall\; i =1,\ldots,n. \]
</p>
<p> In matrix notation: </p><p class="formulaDsp">
\[ \renewcommand{\arraystretch}{2.0} \left( \begin{array}{cc} -\omega^2 \langle \phi_i, \phi_j \rangle_{\mathrm{L}^2(\Omega)} + c^2 \langle \nabla \phi_i, \nabla \phi_j \rangle_{\mathrm{L}^2(\Omega)} &amp; -c\omega \langle \phi_i,\psi_j\rangle_{\mathrm{L}^2(\Gamma_2)} \\ c\omega \langle \psi_i,\phi_j\rangle_{\mathrm{L}^2(\Gamma_2)} &amp; -\omega^2 \langle \psi_{i}, \psi_j \rangle_{\mathrm{L}^2(\Omega)} + c^2 \langle \nabla \psi_{i}, \nabla \psi_j \rangle_{\mathrm{L}^2(\Omega)} \end{array} \right) \left( \begin{array}{c} \alpha \\ \beta \end{array} \right) = \left( \begin{array}{c} 0 \\ 0 \end{array} \right) \]
</p>
<p> (One should not be fooled by the right hand side being zero here, that is because we haven't included the Dirichlet boundary data yet.) Because of the alternating sign in the off-diagonal blocks, we can already see that this system is non-symmetric, in fact it is even indefinite. Of course, there is no necessity to choose the spaces \(V_h\) and \(W_h\) to be the same. However, we expect real and imaginary part of the solution to have similar properties and will therefore indeed take \(V_h=W_h\) in the implementation, and also use the same basis functions \(\phi_i = \psi_i\) for both spaces. The reason for the notation using different symbols is just that it allows us to distinguish between shape functions for \(v\) and \(w\), as this distinction plays an important role in the implementation.</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The test case</h3>
<p>For the computations, we will consider wave propagation in the unit square, with ultrasound generated by a transducer lens that is shaped like a segment of the circle with center at \((0.5, d)\) and a radius slightly greater than \(d\); this shape should lead to a focusing of the sound wave at the center of the circle. Varying \(d\) changes the "focus" of the lens and affects the spatial distribution of the intensity of \(u\), where our main concern is how well \(|u|=\sqrt{v^2+w^2}\) is focused.</p>
<p>In the program below, we will implement the complex-valued Helmholtz equations using the formulation with split real and imaginary parts. We will also discuss how to generate a domain that looks like a square with a slight bulge simulating the transducer (in the <code>UltrasoundProblem&lt;dim&gt;::make_grid()</code> function), and how to generate graphical output that not only contains the solution components \(v\) and \(w\), but also the magnitude \(\sqrt{v^2+w^2}\) directly in the output file (in <code>UltrasoundProblem&lt;dim&gt;::output_results()</code>). Finally, we use the <a class="el" href="classParameterHandler.html">ParameterHandler</a> class to easily read parameters like the focal distance \(d\), wave speed \(c\), frequency \(\omega\), and a number of other parameters from an input file at run-time, rather than fixing those parameters in the source code where we would have to re-compile every time we want to change parameters.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The following header files have all been discussed before:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="ttc" id="adof__tools_8h_html"><div class="ttname"><a href="dof__tools_8h.html">dof_tools.h</a></div></div>
<div class="ttc" id="adofs_2dof__handler_8h_html"><div class="ttname"><a href="dofs_2dof__handler_8h.html">dof_handler.h</a></div></div>
<div class="ttc" id="adynamic__sparsity__pattern_8h_html"><div class="ttname"><a href="dynamic__sparsity__pattern_8h.html">dynamic_sparsity_pattern.h</a></div></div>
<div class="ttc" id="afe_2fe__values_8h_html"><div class="ttname"><a href="fe_2fe__values_8h.html">fe_values.h</a></div></div>
<div class="ttc" id="afe__q_8h_html"><div class="ttname"><a href="fe__q_8h.html">fe_q.h</a></div></div>
<div class="ttc" id="afull__matrix_8h_html"><div class="ttname"><a href="full__matrix_8h.html">full_matrix.h</a></div></div>
<div class="ttc" id="afunction_8h_html"><div class="ttname"><a href="function_8h.html">function.h</a></div></div>
<div class="ttc" id="agrid_2manifold__lib_8h_html"><div class="ttname"><a href="grid_2manifold__lib_8h.html">manifold_lib.h</a></div></div>
<div class="ttc" id="agrid_2tria_8h_html"><div class="ttname"><a href="grid_2tria_8h.html">tria.h</a></div></div>
<div class="ttc" id="agrid__generator_8h_html"><div class="ttname"><a href="grid__generator_8h.html">grid_generator.h</a></div></div>
<div class="ttc" id="alogstream_8h_html"><div class="ttname"><a href="logstream_8h.html">logstream.h</a></div></div>
<div class="ttc" id="amatrix__tools_8h_html"><div class="ttname"><a href="matrix__tools_8h.html">matrix_tools.h</a></div></div>
<div class="ttc" id="anumerics_2data__out_8h_html"><div class="ttname"><a href="numerics_2data__out_8h.html">data_out.h</a></div></div>
<div class="ttc" id="aquadrature__lib_8h_html"><div class="ttname"><a href="quadrature__lib_8h.html">quadrature_lib.h</a></div></div>
<div class="ttc" id="asparse__matrix_8h_html"><div class="ttname"><a href="sparse__matrix_8h.html">sparse_matrix.h</a></div></div>
<div class="ttc" id="avector_8h_html"><div class="ttname"><a href="vector_8h.html">vector.h</a></div></div>
<div class="ttc" id="avector__tools_8h_html"><div class="ttname"><a href="vector__tools_8h.html">vector_tools.h</a></div></div>
</div><!-- fragment --><p>This header file contains the necessary declarations for the <a class="el" href="classParameterHandler.html">ParameterHandler</a> class that we will use to read our parameters from a configuration file :</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__handler_8h.html">deal.II/base/parameter_handler.h</a>&gt;</span></div>
<div class="ttc" id="aparameter__handler_8h_html"><div class="ttname"><a href="parameter__handler_8h.html">parameter_handler.h</a></div></div>
</div><!-- fragment --><p>For solving the linear system, we'll use the sparse LU-decomposition provided by UMFPACK (see the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class), for which the following header file is needed. Note that in order to compile this tutorial program, the deal.II-library needs to be built with UMFPACK support, which is enabled by default:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div>
<div class="ttc" id="asparse__direct_8h_html"><div class="ttname"><a href="sparse__direct_8h.html">sparse_direct.h</a></div></div>
</div><!-- fragment --><p>The <a class="el" href="classFESystem.html">FESystem</a> class allows us to stack several FE-objects to one compound, vector-valued finite element field. The necessary declarations for this class are provided in this header file :</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div>
<div class="ttc" id="afe__system_8h_html"><div class="ttname"><a href="fe__system_8h.html">fe_system.h</a></div></div>
</div><!-- fragment --><p>Finally, include the header file that declares the <a class="el" href="classTimer.html">Timer</a> class that we will use to determine how much time each of the operations of our program takes:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div>
<div class="ttc" id="atimer_8h_html"><div class="ttname"><a href="timer_8h.html">timer.h</a></div></div>
</div><!-- fragment --><p>As the last step at the beginning of this program, we put everything that is in this program into its namespace and, within it, make everything that is in the deal.II namespace globally available, without the need to prefix everything with <code>dealii</code><code>::</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step29</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
<div class="ttc" id="anamespacedealii_html"><div class="ttname"><a href="namespacedealii.html">dealii</a></div><div class="ttdef"><b>Definition:</b> <a href="namespace__dealii_8h_source.html#l00025">namespace_dealii.h:26</a></div></div>
</div><!-- fragment --><p><a class="anchor" id="ThecodeDirichletBoundaryValuescodeclass"></a> </p><h3>The <code>DirichletBoundaryValues</code> class</h3>
<p>First we define a class for the function representing the Dirichlet boundary values. This has been done many times before and therefore does not need much explanation.</p>
<p>Since there are two values \(v\) and \(w\) that need to be prescribed at the boundary, we have to tell the base class that this is a vector-valued function with two components, and the <code>vector_value</code> function and its cousin <code>vector_value_list</code> must return vectors with two entries. In our case the function is very simple, it just returns 1 for the real part \(v\) and 0 for the imaginary part \(w\) regardless of the point where it is evaluated.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>DirichletBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  DirichletBoundaryValues()</div>
<div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(2)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">vector_value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div>
<div class="line">                            <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>)<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>.size() == 2, <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>.size(), 2));</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(0) = 1;</div>
<div class="line">    <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(1) = 0;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span></div>
<div class="line">  <a class="code" href="classFunction.html#aa041dde994d40c068e00661197ac75a6">vector_value_list</a>(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div>
<div class="line">                    std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;  value_list)<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(value_list.size() == points.size(),</div>
<div class="line">           <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(value_list.size(), points.size()));</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; points.size(); ++p)</div>
<div class="line">      DirichletBoundaryValues&lt;dim&gt;::vector_value(points[p], value_list[p]);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="ttc" id="aclassFunction_html"><div class="ttname"><a href="classFunction.html">Function</a></div><div class="ttdef"><b>Definition:</b> <a href="function_8h_source.html#l00150">function.h:153</a></div></div>
<div class="ttc" id="aclassFunction_html_aa041dde994d40c068e00661197ac75a6"><div class="ttname"><a href="classFunction.html#aa041dde994d40c068e00661197ac75a6">Function::vector_value_list</a></div><div class="ttdeci">virtual void vector_value_list(const std::vector&lt; Point&lt; dim &gt;&gt; &amp;points, std::vector&lt; Vector&lt; RangeNumberType &gt;&gt; &amp;values) const</div></div>
<div class="ttc" id="aclassFunction_html_ae316ebc05d21989d573024f8a23c49cb"><div class="ttname"><a href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">Function::vector_value</a></div><div class="ttdeci">virtual void vector_value(const Point&lt; dim &gt; &amp;p, Vector&lt; RangeNumberType &gt; &amp;values) const</div></div>
<div class="ttc" id="aclassPoint_html"><div class="ttname"><a href="classPoint.html">Point</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2point_8h_source.html#l00110">point.h:111</a></div></div>
<div class="ttc" id="aclassVector_html"><div class="ttname"><a href="classVector.html">Vector&lt; double &gt;</a></div></div>
<div class="ttc" id="agroup__Exceptions_html_ga6060b2304b8600f5efa0d31eeda0207d"><div class="ttname"><a href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">StandardExceptions::ExcDimensionMismatch</a></div><div class="ttdeci">static ::ExceptionBase &amp; ExcDimensionMismatch(std::size_t arg1, std::size_t arg2)</div></div>
<div class="ttc" id="agroup__Exceptions_html_ga70a0bb353656e704acf927945277bbc6"><div class="ttname"><a href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a></div><div class="ttdeci">#define Assert(cond, exc)</div><div class="ttdef"><b>Definition:</b> <a href="include_2deal_8II_2base_2exceptions_8h_source.html#l01473">exceptions.h:1473</a></div></div>
<div class="ttc" id="anamespaceEvaluationFlags_html_a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58"><div class="ttname"><a href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a></div><div class="ttdeci">@ values</div><div class="ttdef"><b>Definition:</b> <a href="evaluation__flags_8h_source.html#l00051">evaluation_flags.h:51</a></div></div>
</div><!-- fragment --><p><a class="anchor" id="ThecodeParameterReadercodeclass"></a> </p><h3>The <code>ParameterReader</code> class</h3>
<p>The next class is responsible for preparing the <a class="el" href="classParameterHandler.html">ParameterHandler</a> object and reading parameters from an input file. It includes a function <code>declare_parameters</code> that declares all the necessary parameters and a <code>read_parameters</code> function that is called from outside to initiate the parameter reading process.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ParameterReader : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  ParameterReader(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;);</div>
<div class="line">  <span class="keywordtype">void</span> read_parameters(<span class="keyword">const</span> std::string &amp;);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">void</span>              declare_parameters();</div>
<div class="line">  <a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm;</div>
<div class="line">};</div>
<div class="ttc" id="aclassParameterHandler_html"><div class="ttname"><a href="classParameterHandler.html">ParameterHandler</a></div><div class="ttdef"><b>Definition:</b> <a href="parameter__handler_8h_source.html#l00840">parameter_handler.h:841</a></div></div>
<div class="ttc" id="aclassSubscriptor_html"><div class="ttname"><a href="classSubscriptor.html">Subscriptor</a></div><div class="ttdef"><b>Definition:</b> <a href="subscriptor_8h_source.html#l00061">subscriptor.h:62</a></div></div>
</div><!-- fragment --><p>The constructor stores a reference to the <a class="el" href="classParameterHandler.html">ParameterHandler</a> object that is passed to it:</p>
<div class="fragment"><div class="line">ParameterReader::ParameterReader(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;paramhandler)</div>
<div class="line">  : prm(paramhandler)</div>
<div class="line">{}</div>
</div><!-- fragment --><p><a class="anchor" id="codeParameterReaderdeclare_parameterscode"></a> </p><h4><code>ParameterReader::declare_parameters</code></h4>
<p>The <code>declare_parameters</code> function declares all the parameters that our <a class="el" href="classParameterHandler.html">ParameterHandler</a> object will be able to read from input files, along with their types, range conditions and the subsections they appear in. We will wrap all the entries that go into a section in a pair of braces to force the editor to indent them by one level, making it simpler to read which entries together form a section:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> ParameterReader::declare_parameters()</div>
<div class="line">{</div>
</div><!-- fragment --><p>Parameters for mesh and geometry include the number of global refinement steps that are applied to the initial coarse mesh and the focal distance \(d\) of the transducer lens. For the number of refinement steps, we allow integer values in the range \([0,\infty)\), where the omitted second argument to the <a class="el" href="classPatterns_1_1Integer.html">Patterns::Integer</a> object denotes the half-open interval. For the focal distance any number greater than zero is accepted:</p>
<div class="fragment"><div class="line">prm.enter_subsection(<span class="stringliteral">&quot;Mesh &amp; geometry parameters&quot;</span>);</div>
<div class="line">{</div>
<div class="line">  prm.declare_entry(<span class="stringliteral">&quot;Number of refinements&quot;</span>,</div>
<div class="line">                    <span class="stringliteral">&quot;6&quot;</span>,</div>
<div class="line">                    <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0),</div>
<div class="line">                    <span class="stringliteral">&quot;Number of global mesh refinement steps &quot;</span></div>
<div class="line">                    <span class="stringliteral">&quot;applied to initial coarse grid&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  prm.declare_entry(<span class="stringliteral">&quot;Focal distance&quot;</span>,</div>
<div class="line">                    <span class="stringliteral">&quot;0.3&quot;</span>,</div>
<div class="line">                    <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0),</div>
<div class="line">                    <span class="stringliteral">&quot;Distance of the focal point of the lens &quot;</span></div>
<div class="line">                    <span class="stringliteral">&quot;to the x-axis&quot;</span>);</div>
<div class="line">}</div>
<div class="line">prm.leave_subsection();</div>
<div class="ttc" id="aclassPatterns_1_1Double_html"><div class="ttname"><a href="classPatterns_1_1Double.html">Patterns::Double</a></div><div class="ttdef"><b>Definition:</b> <a href="patterns_8h_source.html#l00292">patterns.h:293</a></div></div>
<div class="ttc" id="aclassPatterns_1_1Integer_html"><div class="ttname"><a href="classPatterns_1_1Integer.html">Patterns::Integer</a></div><div class="ttdef"><b>Definition:</b> <a href="patterns_8h_source.html#l00189">patterns.h:190</a></div></div>
</div><!-- fragment --><p>The next subsection is devoted to the physical parameters appearing in the equation, which are the frequency \(\omega\) and wave speed \(c\). Again, both need to lie in the half-open interval \([0,\infty)\) represented by calling the <a class="el" href="classPatterns_1_1Double.html">Patterns::Double</a> class with only the left end-point as argument:</p>
<div class="fragment"><div class="line">prm.enter_subsection(<span class="stringliteral">&quot;Physical constants&quot;</span>);</div>
<div class="line">{</div>
<div class="line">  prm.declare_entry(<span class="stringliteral">&quot;c&quot;</span>, <span class="stringliteral">&quot;1.5e5&quot;</span>, <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0), <span class="stringliteral">&quot;Wave speed&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  prm.declare_entry(<span class="stringliteral">&quot;omega&quot;</span>, <span class="stringliteral">&quot;5.0e7&quot;</span>, <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0), <span class="stringliteral">&quot;Frequency&quot;</span>);</div>
<div class="line">}</div>
<div class="line">prm.leave_subsection();</div>
</div><!-- fragment --><p>Last but not least we would like to be able to change some properties of the output, like filename and format, through entries in the configuration file, which is the purpose of the last subsection:</p>
<div class="fragment"><div class="line">prm.enter_subsection(<span class="stringliteral">&quot;Output parameters&quot;</span>);</div>
<div class="line">{</div>
<div class="line">  prm.declare_entry(<span class="stringliteral">&quot;Output filename&quot;</span>,</div>
<div class="line">                    <span class="stringliteral">&quot;solution&quot;</span>,</div>
<div class="line">                    <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>(),</div>
<div class="line">                    <span class="stringliteral">&quot;Name of the output file (without extension)&quot;</span>);</div>
<div class="ttc" id="aclassPatterns_1_1Anything_html"><div class="ttname"><a href="classPatterns_1_1Anything.html">Patterns::Anything</a></div><div class="ttdef"><b>Definition:</b> <a href="patterns_8h_source.html#l01022">patterns.h:1023</a></div></div>
</div><!-- fragment --><p>Since different output formats may require different parameters for generating output (like for example, postscript output needs viewpoint angles, line widths, colors etc), it would be cumbersome if we had to declare all these parameters by hand for every possible output format supported in the library. Instead, each output format has a <code>FormatFlags::declare_parameters</code> function, which declares all the parameters specific to that format in an own subsection. The following call of <a class="el" href="group__Exceptions.html#ga1f2f1d644d9cb1c4d1714d5173d159f2">DataOutInterface&lt;1&gt;::declare_parameters</a> executes <code>declare_parameters</code> for all available output formats, so that for each format an own subsection will be created with parameters declared for that particular output format. (The actual value of the template parameter in the call, <code>&lt;1&gt;</code> above, does not matter here: the function does the same work independent of the dimension, but happens to be in a template-parameter-dependent class.) To find out what parameters there are for which output format, you can either consult the documentation of the <a class="el" href="namespaceDataOutBase.html">DataOutBase</a> class, or simply run this program without a parameter file present. It will then create a file with all declared parameters set to their default values, which can conveniently serve as a starting point for setting the parameters to the values you desire.</p>
<div class="fragment"><div class="line">    <a class="code" href="group__Exceptions.html#ga1f2f1d644d9cb1c4d1714d5173d159f2">DataOutInterface&lt;1&gt;::declare_parameters</a>(prm);</div>
<div class="line">  }</div>
<div class="line">  prm.leave_subsection();</div>
<div class="line">}</div>
<div class="ttc" id="agroup__Exceptions_html_ga1f2f1d644d9cb1c4d1714d5173d159f2"><div class="ttname"><a href="group__Exceptions.html#ga1f2f1d644d9cb1c4d1714d5173d159f2">DataOutInterface::declare_parameters</a></div><div class="ttdeci">static void declare_parameters(ParameterHandler &amp;prm)</div><div class="ttdef"><b>Definition:</b> <a href="data__out__base_8cc_source.html#l08214">data_out_base.cc:8214</a></div></div>
</div><!-- fragment --><p><a class="anchor" id="codeParameterReaderread_parameterscode"></a> </p><h4><code>ParameterReader::read_parameters</code></h4>
<p>This is the main function in the ParameterReader class. It gets called from outside, first declares all the parameters, and then reads them from the input file whose filename is provided by the caller. After the call to this function is complete, the <code>prm</code> object can be used to retrieve the values of the parameters read in from the file :</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> ParameterReader::read_parameters(<span class="keyword">const</span> std::string &amp;parameter_file)</div>
<div class="line">{</div>
<div class="line">  declare_parameters();</div>
<div class="line"> </div>
<div class="line">  prm.parse_input(parameter_file);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="ThecodeComputeIntensitycodeclass"></a> </p><h3>The <code>ComputeIntensity</code> class</h3>
<p>As mentioned in the introduction, the quantity that we are really after is the spatial distribution of the intensity of the ultrasound wave, which corresponds to \(|u|=\sqrt{v^2+w^2}\). Now we could just be content with having \(v\) and \(w\) in our output, and use a suitable visualization or postprocessing tool to derive \(|u|\) from the solution we computed. However, there is also a way to output data derived from the solution in deal.II, and we are going to make use of this mechanism here.</p>
<p>So far we have always used the <a class="el" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">DataOut::add_data_vector</a> function to add vectors containing output data to a <a class="el" href="classDataOut.html">DataOut</a> object. There is a special version of this function that in addition to the data vector has an additional argument of type <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>. What happens when this function is used for output is that at each point where output data is to be generated, the <a class="el" href="classDataPostprocessor.html#a07ebcf764cf911c6d78f21c32ea1d2d0">DataPostprocessor::evaluate_scalar_field()</a> or <a class="el" href="classDataPostprocessor.html#a1ba57b598d24d64365d469a854271c68">DataPostprocessor::evaluate_vector_field()</a> function of the specified <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> object is invoked to compute the output quantities from the values, the gradients and the second derivatives of the finite element function represented by the data vector (in the case of face related data, normal vectors are available as well). Hence, this allows us to output any quantity that can locally be derived from the values of the solution and its derivatives. Of course, the ultrasound intensity \(|u|\) is such a quantity and its computation doesn't even involve any derivatives of \(v\) or \(w\).</p>
<p>In practice, the <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> class only provides an interface to this functionality, and we need to derive our own class from it in order to implement the functions specified by the interface. In the most general case one has to implement several member functions but if the output quantity is a single scalar then some of this boilerplate code can be handled by a more specialized class, <a class="el" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a> and we can derive from that one instead. This is what the <code>ComputeIntensity</code> class does:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>ComputeIntensity : <span class="keyword">public</span> <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  ComputeIntensity();</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classDataPostprocessor.html#a1ba57b598d24d64365d469a854271c68">evaluate_vector_field</a>(</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div>
<div class="line">    std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;computed_quantities) <span class="keyword">const override</span>;</div>
<div class="line">};</div>
<div class="ttc" id="aclassDataPostprocessorScalar_html"><div class="ttname"><a href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a></div><div class="ttdef"><b>Definition:</b> <a href="data__postprocessor_8h_source.html#l00645">data_postprocessor.h:646</a></div></div>
<div class="ttc" id="aclassDataPostprocessor_html_a1ba57b598d24d64365d469a854271c68"><div class="ttname"><a href="classDataPostprocessor.html#a1ba57b598d24d64365d469a854271c68">DataPostprocessor::evaluate_vector_field</a></div><div class="ttdeci">virtual void evaluate_vector_field(const DataPostprocessorInputs::Vector&lt; dim &gt; &amp;input_data, std::vector&lt; Vector&lt; double &gt;&gt; &amp;computed_quantities) const</div><div class="ttdef"><b>Definition:</b> <a href="data__postprocessor_8cc_source.html#l00037">data_postprocessor.cc:37</a></div></div>
<div class="ttc" id="astructDataPostprocessorInputs_1_1Vector_html"><div class="ttname"><a href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector</a></div><div class="ttdef"><b>Definition:</b> <a href="data__postprocessor_8h_source.html#l00337">data_postprocessor.h:338</a></div></div>
</div><!-- fragment --><p>In the constructor, we need to call the constructor of the base class with two arguments. The first denotes the name by which the single scalar quantity computed by this class should be represented in output files. In our case, the postprocessor has \(|u|\) as output, so we use "Intensity".</p>
<p>The second argument is a set of flags that indicate which data is needed by the postprocessor in order to compute the output quantities. This can be any subset of update_values, update_gradients and update_hessians (and, in the case of face data, also update_normal_vectors), which are documented in UpdateFlags. Of course, computation of the derivatives requires additional resources, so only the flags for data that are really needed should be given here, just as we do when we use <a class="el" href="classFEValues.html">FEValues</a> objects. In our case, only the function values of \(v\) and \(w\) are needed to compute \(|u|\), so we're good with the update_values flag.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">ComputeIntensity&lt;dim&gt;::ComputeIntensity()</div>
<div class="line">  : <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;(<span class="stringliteral">&quot;Intensity&quot;</span>, <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>)</div>
<div class="line">{}</div>
<div class="ttc" id="afe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea"><div class="ttname"><a href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a></div><div class="ttdeci">@ update_values</div><div class="ttdoc">Shape function values.</div><div class="ttdef"><b>Definition:</b> <a href="fe__update__flags_8h_source.html#l00078">fe_update_flags.h:78</a></div></div>
</div><!-- fragment --><p>The actual postprocessing happens in the following function. Its input is an object that stores values of the function (which is here vector-valued) representing the data vector given to <a class="el" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">DataOut::add_data_vector</a>, evaluated at all evaluation points where we generate output, and some tensor objects representing derivatives (that we don't use here since \(|u|\) is computed from just \(v\) and \(w\)). The derived quantities are returned in the <code>computed_quantities</code> vector. Remember that this function may only use data for which the respective update flag is specified by <code>get_needed_update_flags</code>. For example, we may not use the derivatives here, since our implementation of <code>get_needed_update_flags</code> requests that only function values are provided.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> ComputeIntensity&lt;dim&gt;::evaluate_vector_field(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div>
<div class="line">  std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;               computed_quantities)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities.size() == inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size(),</div>
<div class="line">         <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities.size(),</div>
<div class="line">                              inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size()));</div>
<div class="ttc" id="astructDataPostprocessorInputs_1_1Vector_html_a8e034ae97f0447fb541bdb8ad0a4f599"><div class="ttname"><a href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">DataPostprocessorInputs::Vector::solution_values</a></div><div class="ttdeci">std::vector&lt;::Vector&lt; double &gt; &gt; solution_values</div><div class="ttdef"><b>Definition:</b> <a href="data__postprocessor_8h_source.html#l00348">data_postprocessor.h:348</a></div></div>
</div><!-- fragment --><p>The computation itself is straightforward: We iterate over each entry in the output vector and compute \(|u|\) from the corresponding values of \(v\) and \(w\). We do this by creating a complex number \(u\) and then calling <code><a class="el" href="numbers_8h.html#a0ebae11c64606a73e80a6328b1ab0802">std::abs()</a></code> on the result. (One may be tempted to call <code><a class="el" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">std::norm()</a></code>, but in a historical quirk, the C++ committee decided that <code><a class="el" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">std::norm()</a></code> should return the <em>square</em> of the absolute value &ndash; thereby not satisfying the properties mathematicians require of something called a "norm".)</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; computed_quantities.size(); i++)</div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities[i].size() == 1,</div>
<div class="line">             <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities[i].size(), 1));</div>
<div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i].size() == 2,</div>
<div class="line">             <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i].size(), 2));</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">const</span> std::complex&lt;double&gt; u(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i](0),</div>
<div class="line">                                   inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i](1));</div>
<div class="line"> </div>
<div class="line">      computed_quantities[i](0) = std::abs(u);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="ThecodeUltrasoundProblemcodeclass"></a> </p><h3>The <code>UltrasoundProblem</code> class</h3>
<p>Finally here is the main class of this program. It's member functions are very similar to the previous examples, in particular <a class="el" href="step_4.html">step-4</a>, and the list of member variables does not contain any major surprises either. The <a class="el" href="classParameterHandler.html">ParameterHandler</a> object that is passed to the constructor is stored as a reference to allow easy access to the parameters from all functions of the class. Since we are working with vector valued finite elements, the FE object we are using is of type <a class="el" href="classFESystem.html">FESystem</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>UltrasoundProblem</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  UltrasoundProblem(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;);</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">void</span> make_grid();</div>
<div class="line">  <span class="keywordtype">void</span> setup_system();</div>
<div class="line">  <span class="keywordtype">void</span> assemble_system();</div>
<div class="line">  <span class="keywordtype">void</span> solve();</div>
<div class="line">  <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div>
<div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div>
<div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>      fe;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div>
<div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div>
<div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       solution, system_rhs;</div>
<div class="line">};</div>
<div class="ttc" id="aclassDoFHandler_html"><div class="ttname"><a href="classDoFHandler.html">DoFHandler</a></div><div class="ttdef"><b>Definition:</b> <a href="dofs_2dof__handler_8h_source.html#l00314">dof_handler.h:315</a></div></div>
<div class="ttc" id="aclassFESystem_html"><div class="ttname"><a href="classFESystem.html">FESystem</a></div><div class="ttdef"><b>Definition:</b> <a href="fe__system_8h_source.html#l00215">fe_system.h:216</a></div></div>
<div class="ttc" id="aclassSparseMatrix_html"><div class="ttname"><a href="classSparseMatrix.html">SparseMatrix&lt; double &gt;</a></div></div>
<div class="ttc" id="aclassSparsityPattern_html"><div class="ttname"><a href="classSparsityPattern.html">SparsityPattern</a></div><div class="ttdef"><b>Definition:</b> <a href="sparsity__pattern_8h_source.html#l00868">sparsity_pattern.h:869</a></div></div>
<div class="ttc" id="aclassTriangulation_html"><div class="ttname"><a href="classTriangulation.html">Triangulation</a></div><div class="ttdef"><b>Definition:</b> <a href="grid_2tria_8h_source.html#l01127">tria.h:1128</a></div></div>
<div class="ttc" id="anamespaceWorkStream_1_1internal_1_1tbb__no__coloring_html_a8673698a405bf47aa24002aeb6d76d70"><div class="ttname"><a href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">WorkStream::internal::tbb_no_coloring::run</a></div><div class="ttdeci">void run(const Iterator &amp;begin, const typename identity&lt; Iterator &gt;::type &amp;end, Worker worker, Copier copier, const ScratchData &amp;sample_scratch_data, const CopyData &amp;sample_copy_data, const unsigned int queue_length, const unsigned int chunk_size)</div><div class="ttdef"><b>Definition:</b> <a href="work__stream_8h_source.html#l00691">work_stream.h:691</a></div></div>
<div class="ttc" id="ap4est__wrappers_8cc_html_ace00f2f80d9780ef9aa1007e1c22c6a4"><div class="ttname"><a href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a></div><div class="ttdeci">const ::parallel::distributed::Triangulation&lt; dim, spacedim &gt; * triangulation</div><div class="ttdef"><b>Definition:</b> <a href="p4est__wrappers_8cc_source.html#l00069">p4est_wrappers.cc:69</a></div></div>
</div><!-- fragment --><p>The constructor takes the <a class="el" href="classParameterHandler.html">ParameterHandler</a> object and stores it in a reference. It also initializes the DoF-Handler and the finite element system, which consists of two copies of the scalar Q1 field, one for \(v\) and one for \(w\):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">UltrasoundProblem&lt;dim&gt;::UltrasoundProblem(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;param)</div>
<div class="line">  : prm(param)</div>
<div class="line">  , dof_handler(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>)</div>
<div class="line">  , fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1), 2)</div>
<div class="line">{}</div>
<div class="ttc" id="aclassFE__Q_html"><div class="ttname"><a href="classFE__Q.html">FE_Q</a></div><div class="ttdef"><b>Definition:</b> <a href="fe__q_8h_source.html#l00548">fe_q.h:549</a></div></div>
</div><!-- fragment --><p><a class="anchor" id="codeUltrasoundProblemmake_gridcode"></a> </p><h4><code>UltrasoundProblem::make_grid</code></h4>
<p>Here we setup the grid for our domain. As mentioned in the exposition, the geometry is just a unit square (in 2d) with the part of the boundary that represents the transducer lens replaced by a sector of a circle.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::make_grid()</div>
<div class="line">{</div>
</div><!-- fragment --><p>First we generate some logging output and start a timer so we can compute execution time when this function is done:</p>
<div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Generating grid... &quot;</span>;</div>
<div class="line"><a class="code" href="classTimer.html">Timer</a> timer;</div>
<div class="ttc" id="aclassTimer_html"><div class="ttname"><a href="classTimer.html">Timer</a></div><div class="ttdef"><b>Definition:</b> <a href="timer_8h_source.html#l00118">timer.h:119</a></div></div>
</div><!-- fragment --><p>Then we query the values for the focal distance of the transducer lens and the number of mesh refinement steps from our <a class="el" href="classParameterHandler.html">ParameterHandler</a> object:</p>
<div class="fragment"><div class="line">prm.enter_subsection(<span class="stringliteral">&quot;Mesh &amp; geometry parameters&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>       focal_distance = prm.get_double(<span class="stringliteral">&quot;Focal distance&quot;</span>);</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_refinements = prm.get_integer(<span class="stringliteral">&quot;Number of refinements&quot;</span>);</div>
<div class="line"> </div>
<div class="line">prm.leave_subsection();</div>
</div><!-- fragment --><p>Next, two points are defined for position and focal point of the transducer lens, which is the center of the circle whose segment will form the transducer part of the boundary. Notice that this is the only point in the program where things are slightly different in 2D and 3D. Even though this tutorial only deals with the 2D case, the necessary additions to make this program functional in 3D are so minimal that we opt for including them:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> transducer =</div>
<div class="line">  (dim == 2) ? <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.0) : <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.5, 0.0);</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> focal_point = (dim == 2) ?</div>
<div class="line">                                 <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, focal_distance) :</div>
<div class="line">                                 <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.5, focal_distance);</div>
</div><!-- fragment --><p>As initial coarse grid we take a simple unit square with 5 subdivisions in each direction. The number of subdivisions is chosen so that the line segment \([0.4,0.6]\) that we want to designate as the transducer boundary is spanned by a single face. Then we step through all cells to find the faces where the transducer is to be located, which in fact is just the single edge from 0.4 to 0.6 on the x-axis. This is where we want the refinements to be made according to a circle shaped boundary, so we mark this edge with a different manifold indicator. Since we will Dirichlet boundary conditions on the transducer, we also change its boundary indicator.</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceGridGenerator.html#a358d5bd545bc115c8645d93fa79b64bc">GridGenerator::subdivided_hyper_cube</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, 5, 0, 1);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.cell_iterators())</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div>
<div class="line">    <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp;</div>
<div class="line">        ((face-&gt;center() - transducer).norm_square() &lt; 0.01))</div>
<div class="line">      {</div>
<div class="line">        face-&gt;set_boundary_id(1);</div>
<div class="line">        face-&gt;set_manifold_id(1);</div>
<div class="line">      }</div>
<div class="ttc" id="anamespaceGridGenerator_html_a358d5bd545bc115c8645d93fa79b64bc"><div class="ttname"><a href="namespaceGridGenerator.html#a358d5bd545bc115c8645d93fa79b64bc">GridGenerator::subdivided_hyper_cube</a></div><div class="ttdeci">void subdivided_hyper_cube(Triangulation&lt; dim, spacedim &gt; &amp;tria, const unsigned int repetitions, const double left=0., const double right=1., const bool colorize=false)</div></div>
</div><!-- fragment --><p>For the circle part of the transducer lens, a <a class="el" href="classSphericalManifold.html">SphericalManifold</a> object is used (which, of course, in 2D just represents a circle), with center computed as above.</p>
<div class="fragment"><div class="line"><a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.set_manifold(1, <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a>(focal_point));</div>
<div class="ttc" id="aclassSphericalManifold_html"><div class="ttname"><a href="classSphericalManifold.html">SphericalManifold</a></div><div class="ttdef"><b>Definition:</b> <a href="grid_2manifold__lib_8h_source.html#l00236">manifold_lib.h:237</a></div></div>
</div><!-- fragment --><p>Now global refinement is executed. Cells near the transducer location will be automatically refined according to the circle shaped boundary of the transducer lens:</p>
<div class="fragment"><div class="line"><a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.refine_global(n_refinements);</div>
</div><!-- fragment --><p>Lastly, we generate some more logging output. We stop the timer and query the number of CPU seconds elapsed since the beginning of the function:</p>
<div class="fragment"><div class="line">  timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  Number of active cells:  &quot;</span> &lt;&lt; <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.n_active_cells()</div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="aclassTimer_html_a4e3933a78790d7455daff5acab3f8432"><div class="ttname"><a href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">Timer::cpu_time</a></div><div class="ttdeci">double cpu_time() const</div><div class="ttdef"><b>Definition:</b> <a href="timer_8cc_source.html#l00236">timer.cc:236</a></div></div>
<div class="ttc" id="aclassTimer_html_a988f79aa183d9d5473c13106f5babe48"><div class="ttname"><a href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">Timer::stop</a></div><div class="ttdeci">double stop()</div><div class="ttdef"><b>Definition:</b> <a href="timer_8cc_source.html#l00194">timer.cc:194</a></div></div>
</div><!-- fragment --><p><a class="anchor" id="codeUltrasoundProblemsetup_systemcode"></a> </p><h4><code>UltrasoundProblem::setup_system</code></h4>
<p>Initialization of the system matrix, sparsity patterns and vectors are the same as in previous examples and therefore do not need further comment. As in the previous function, we also output the run time of what we do here:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::setup_system()</div>
<div class="line">{</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Setting up system... &quot;</span>;</div>
<div class="line">  <a class="code" href="classTimer.html">Timer</a> timer;</div>
<div class="line"> </div>
<div class="line">  dof_handler.distribute_dofs(fe);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.n_dofs(), dof_handler.n_dofs());</div>
<div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div>
<div class="line">  sparsity_pattern.copy_from(dsp);</div>
<div class="line"> </div>
<div class="line">  system_matrix.reinit(sparsity_pattern);</div>
<div class="line">  system_rhs.reinit(dof_handler.n_dofs());</div>
<div class="line">  solution.reinit(dof_handler.n_dofs());</div>
<div class="line"> </div>
<div class="line">  timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="aclassDynamicSparsityPattern_html"><div class="ttname"><a href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a></div><div class="ttdef"><b>Definition:</b> <a href="dynamic__sparsity__pattern_8h_source.html#l00318">dynamic_sparsity_pattern.h:319</a></div></div>
<div class="ttc" id="agroup__constraints_html_gaf78e864edbfba7e0a7477457bfb96b26"><div class="ttname"><a href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a></div><div class="ttdeci">void make_sparsity_pattern(const DoFHandler&lt; dim, spacedim &gt; &amp;dof_handler, SparsityPatternType &amp;sparsity_pattern, const AffineConstraints&lt; number &gt; &amp;constraints=AffineConstraints&lt; number &gt;(), const bool keep_constrained_dofs=true, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id)</div><div class="ttdef"><b>Definition:</b> <a href="dof__tools__sparsity_8cc_source.html#l00064">dof_tools_sparsity.cc:64</a></div></div>
</div><!-- fragment --><p><a class="anchor" id="codeUltrasoundProblemassemble_systemcode"></a> </p><h4><code>UltrasoundProblem::assemble_system</code></h4>
<p>As before, this function takes care of assembling the system matrix and right hand side vector:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::assemble_system()</div>
<div class="line">{</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Assembling system matrix... &quot;</span>;</div>
<div class="line">  <a class="code" href="classTimer.html">Timer</a> timer;</div>
</div><!-- fragment --><p>First we query wavespeed and frequency from the <a class="el" href="classParameterHandler.html">ParameterHandler</a> object and store them in local variables, as they will be used frequently throughout this function.</p>
<div class="fragment"><div class="line">prm.enter_subsection(<span class="stringliteral">&quot;Physical constants&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> omega = prm.get_double(<span class="stringliteral">&quot;omega&quot;</span>), c = prm.get_double(<span class="stringliteral">&quot;c&quot;</span>);</div>
<div class="line"> </div>
<div class="line">prm.leave_subsection();</div>
</div><!-- fragment --><p>As usual, for computing integrals ordinary Gauss quadrature rule is used. Since our bilinear form involves boundary integrals on \(\Gamma_2\), we also need a quadrature rule for surface integration on the faces, which are \(dim-1\) dimensional:</p>
<div class="fragment"><div class="line"><a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.degree + 1);</div>
<div class="line"><a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe.degree + 1);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = quadrature_formula.size(),</div>
<div class="line">                   n_face_q_points = face_quadrature_formula.size(),</div>
<div class="line">                   dofs_per_cell   = fe.n_dofs_per_cell();</div>
<div class="ttc" id="aclassQGauss_html"><div class="ttname"><a href="classQGauss.html">QGauss</a></div><div class="ttdef"><b>Definition:</b> <a href="quadrature__lib_8h_source.html#l00038">quadrature_lib.h:39</a></div></div>
</div><!-- fragment --><p>The <a class="el" href="classFEValues.html">FEValues</a> objects will evaluate the shape functions for us. For the part of the bilinear form that involves integration on \(\Omega\), we'll need the values and gradients of the shape functions, and of course the quadrature weights. For the terms involving the boundary integrals, only shape function values and the quadrature weights are necessary.</p>
<div class="fragment"><div class="line"><a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div>
<div class="line">                        quadrature_formula,</div>
<div class="line">                        <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div>
<div class="line">                          <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values(fe,</div>
<div class="line">                                 face_quadrature_formula,</div>
<div class="line">                                 <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="ttc" id="aclassFEFaceValues_html"><div class="ttname"><a href="classFEFaceValues.html">FEFaceValues</a></div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__values_8h_source.html#l04157">fe_values.h:4158</a></div></div>
<div class="ttc" id="aclassFEValues_html"><div class="ttname"><a href="classFEValues.html">FEValues</a></div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__values_8h_source.html#l03905">fe_values.h:3906</a></div></div>
<div class="ttc" id="afe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85"><div class="ttname"><a href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a></div><div class="ttdeci">@ update_JxW_values</div><div class="ttdoc">Transformed quadrature weights.</div><div class="ttdef"><b>Definition:</b> <a href="fe__update__flags_8h_source.html#l00129">fe_update_flags.h:129</a></div></div>
<div class="ttc" id="afe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20"><div class="ttname"><a href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a></div><div class="ttdeci">@ update_gradients</div><div class="ttdoc">Shape function gradients.</div><div class="ttdef"><b>Definition:</b> <a href="fe__update__flags_8h_source.html#l00084">fe_update_flags.h:84</a></div></div>
</div><!-- fragment --><p>As usual, the system matrix is assembled cell by cell, and we need a matrix for storing the local cell contributions as well as an index vector to transfer the cell contributions to the appropriate location in the global system matrix after.</p>
<div class="fragment"><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div>
<div class="line">std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.active_cell_iterators())</div>
<div class="line">  {</div>
<div class="ttc" id="aclassFullMatrix_html"><div class="ttname"><a href="classFullMatrix.html">FullMatrix&lt; double &gt;</a></div></div>
<div class="ttc" id="anamespaceLocalIntegrators_1_1Advection_html_a8bc7b8136646134f73a4193adefe15f8"><div class="ttname"><a href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">LocalIntegrators::Advection::cell_matrix</a></div><div class="ttdeci">void cell_matrix(FullMatrix&lt; double &gt; &amp;M, const FEValuesBase&lt; dim &gt; &amp;fe, const FEValuesBase&lt; dim &gt; &amp;fetest, const ArrayView&lt; const std::vector&lt; double &gt;&gt; &amp;velocity, const double factor=1.)</div><div class="ttdef"><b>Definition:</b> <a href="advection_8h_source.html#l00075">advection.h:75</a></div></div>
</div><!-- fragment --><p>On each cell, we first need to reset the local contribution matrix and request the <a class="el" href="classFEValues.html">FEValues</a> object to compute the shape functions for the current cell:</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a> = 0;</div>
<div class="line">fe_values.reinit(cell);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div>
<div class="line">      {</div>
</div><!-- fragment --><p>At this point, it is important to keep in mind that we are dealing with a finite element system with two components. Due to the way we constructed this <a class="el" href="classFESystem.html">FESystem</a>, namely as the Cartesian product of two scalar finite element fields, each shape function has only a single nonzero component (they are, in deal.II lingo, <a class="el" href="DEALGlossary.html#GlossPrimitive">primitive</a>). Hence, each shape function can be viewed as one of the \(\phi\)'s or \(\psi\)'s from the introduction, and similarly the corresponding degrees of freedom can be attributed to either \(\alpha\) or \(\beta\). As we iterate through all the degrees of freedom on the current cell however, they do not come in any particular order, and so we cannot decide right away whether the DoFs with index \(i\) and \(j\) belong to the real or imaginary part of our solution. On the other hand, if you look at the form of the system matrix in the introduction, this distinction is crucial since it will determine to which block in the system matrix the contribution of the current pair of DoFs will go and hence which quantity we need to compute from the given two shape functions. Fortunately, the <a class="el" href="classFESystem.html">FESystem</a> object can provide us with this information, namely it has a function <a class="el" href="classFiniteElement.html#a23200d54e40cd719a183d47b6cfb719f">FESystem::system_to_component_index</a>, that for each local DoF index returns a pair of integers of which the first indicates to which component of the system the DoF belongs. The second integer of the pair indicates which index the DoF has in the scalar base finite element field, but this information is not relevant here. If you want to know more about this function and the underlying scheme behind primitive vector valued elements, take a look at <a class="el" href="step_8.html">step-8</a> or the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module, where these topics are explained in depth.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (fe.system_to_component_index(i).first ==</div>
<div class="line">    fe.system_to_component_index(j).first)</div>
<div class="line">  {</div>
</div><!-- fragment --><p>If both DoFs \(i\) and \(j\) belong to same component, i.e. their shape functions are both \(\phi\)'s or both \(\psi\)'s, the contribution will end up in one of the diagonal blocks in our system matrix, and since the corresponding entries are computed by the same formula, we do not bother if they actually are \(\phi\) or \(\psi\) shape functions. We can simply compute the entry by iterating over all quadrature points and adding up their contributions, where values and gradients of the shape functions are supplied by our <a class="el" href="classFEValues.html">FEValues</a> object.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points;</div>
<div class="line">     ++q_point)</div>
<div class="line">  <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div>
<div class="line">    (((fe_values.shape_value(i, q_point) *</div>
<div class="line">       fe_values.shape_value(j, q_point)) *</div>
<div class="line">        (-omega * omega) +</div>
<div class="line">      (fe_values.shape_grad(i, q_point) *</div>
<div class="line">       fe_values.shape_grad(j, q_point)) *</div>
<div class="line">        c * c) *</div>
<div class="line">     fe_values.JxW(q_point));</div>
</div><!-- fragment --><p>You might think that we would have to specify which component of the shape function we'd like to evaluate when requesting shape function values or gradients from the <a class="el" href="classFEValues.html">FEValues</a> object. However, as the shape functions are primitive, they have only one nonzero component, and the <a class="el" href="classFEValues.html">FEValues</a> class is smart enough to figure out that we are definitely interested in this one nonzero component.</p>
<div class="fragment"><div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>We also have to add contributions due to boundary terms. To this end, we loop over all faces of the current cell and see if first it is at the boundary, and second has the correct boundary indicator associated with \(\Gamma_2\), the part of the boundary where we have absorbing boundary conditions:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_no : cell-&gt;face_indices())</div>
<div class="line">  <span class="keywordflow">if</span> (cell-&gt;face(face_no)-&gt;at_boundary() &amp;&amp;</div>
<div class="line">      (cell-&gt;face(face_no)-&gt;boundary_id() == 0))</div>
<div class="line">    {</div>
</div><!-- fragment --><p>These faces will certainly contribute to the off-diagonal blocks of the system matrix, so we ask the <a class="el" href="classFEFaceValues.html">FEFaceValues</a> object to provide us with the shape function values on this face:</p>
<div class="fragment"><div class="line">fe_face_values.reinit(cell, face_no);</div>
</div><!-- fragment --><p>Next, we loop through all DoFs of the current cell to find pairs that belong to different components and both have support on the current face_no:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div>
<div class="line">    <span class="keywordflow">if</span> ((fe.system_to_component_index(i).first !=</div>
<div class="line">         fe.system_to_component_index(j).first) &amp;&amp;</div>
<div class="line">        fe.has_support_on_face(i, face_no) &amp;&amp;</div>
<div class="line">        fe.has_support_on_face(j, face_no))</div>
</div><!-- fragment --><p>The check whether shape functions have support on a face is not strictly necessary: if we don't check for it we would simply add up terms to the local cell matrix that happen to be zero because at least one of the shape functions happens to be zero. However, we can save that work by adding the checks above.</p>
<p>In either case, these DoFs will contribute to the boundary integrals in the off-diagonal blocks of the system matrix. To compute the integral, we loop over all the quadrature points on the face and sum up the contribution weighted with the quadrature weights that the face quadrature rule provides. In contrast to the entries on the diagonal blocks, here it does matter which one of the shape functions is a \(\psi\) and which one is a \(\phi\), since that will determine the sign of the entry. We account for this by a simple conditional statement that determines the correct sign. Since we already checked that DoF \(i\) and \(j\) belong to different components, it suffices here to test for one of them to which component it belongs.</p>
<div class="fragment"><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_face_q_points;</div>
<div class="line">             ++q_point)</div>
<div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div>
<div class="line">            ((fe.system_to_component_index(i).first == 0) ? -1 :</div>
<div class="line">                                                            1) *</div>
<div class="line">            fe_face_values.shape_value(i, q_point) *</div>
<div class="line">            fe_face_values.shape_value(j, q_point) * c * omega *</div>
<div class="line">            fe_face_values.JxW(q_point);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now we are done with this cell and have to transfer its contributions from the local to the global system matrix. To this end, we first get a list of the global indices of the this cells DoFs...</p>
<div class="fragment"><div class="line">cell-&gt;get_dof_indices(local_dof_indices);</div>
</div><!-- fragment --><p>...and then add the entries to the system matrix one by one:</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div>
<div class="line">      system_matrix.add(local_dof_indices[i],</div>
<div class="line">                        local_dof_indices[j],</div>
<div class="line">                        <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j));</div>
<div class="line">}</div>
</div><!-- fragment --><p>The only thing left are the Dirichlet boundary values on \(\Gamma_1\), which is characterized by the boundary indicator 1. The Dirichlet values are provided by the <code>DirichletBoundaryValues</code> class we defined above:</p>
<div class="fragment"><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div>
<div class="line">  <a class="code" href="namespaceVectorTools.html#ab2562d41bb26f362043f9719a8cd9b87">VectorTools::interpolate_boundary_values</a>(dof_handler,</div>
<div class="line">                                           1,</div>
<div class="line">                                           DirichletBoundaryValues&lt;dim&gt;(),</div>
<div class="line">                                           boundary_values);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div>
<div class="line">                                     system_matrix,</div>
<div class="line">                                     solution,</div>
<div class="line">                                     system_rhs);</div>
<div class="line"> </div>
<div class="line">  timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceMatrixTools_html_a9ad0eb7a8662628534586716748d62fb"><div class="ttname"><a href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a></div><div class="ttdeci">void apply_boundary_values(const std::map&lt; types::global_dof_index, number &gt; &amp;boundary_values, SparseMatrix&lt; number &gt; &amp;matrix, Vector&lt; number &gt; &amp;solution, Vector&lt; number &gt; &amp;right_hand_side, const bool eliminate_columns=true)</div><div class="ttdef"><b>Definition:</b> <a href="matrix__tools_8cc_source.html#l00081">matrix_tools.cc:81</a></div></div>
<div class="ttc" id="anamespaceVectorTools_html_ab2562d41bb26f362043f9719a8cd9b87"><div class="ttname"><a href="namespaceVectorTools.html#ab2562d41bb26f362043f9719a8cd9b87">VectorTools::interpolate_boundary_values</a></div><div class="ttdeci">void interpolate_boundary_values(const Mapping&lt; dim, spacedim &gt; &amp;mapping, const DoFHandler&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; types::boundary_id, const Function&lt; spacedim, number &gt; * &gt; &amp;function_map, std::map&lt; types::global_dof_index, number &gt; &amp;boundary_values, const ComponentMask &amp;component_mask=ComponentMask())</div></div>
</div><!-- fragment --><p><a class="anchor" id="codeUltrasoundProblemsolvecode"></a> </p><h4><code>UltrasoundProblem::solve</code></h4>
<p>As already mentioned in the introduction, the system matrix is neither symmetric nor definite, and so it is not quite obvious how to come up with an iterative solver and a preconditioner that do a good job on this matrix. We chose instead to go a different way and solve the linear system with the sparse LU decomposition provided by UMFPACK. This is often a good first choice for 2D problems and works reasonably well even for a large number of DoFs. The deal.II interface to UMFPACK is given by the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class, which is very easy to use and allows us to solve our linear system with just 3 lines of code.</p>
<p>Note again that for compiling this example program, you need to have the deal.II library built with UMFPACK support.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::solve()</div>
<div class="line">{</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Solving linear system... &quot;</span>;</div>
<div class="line">  <a class="code" href="classTimer.html">Timer</a> timer;</div>
</div><!-- fragment --><p>The code to solve the linear system is short: First, we allocate an object of the right type. The following <code>initialize</code> call provides the matrix that we would like to invert to the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> object, and at the same time kicks off the LU-decomposition. Hence, this is also the point where most of the computational work in this program happens.</p>
<div class="fragment"><div class="line"><a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> A_direct;</div>
<div class="line">A_direct.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(system_matrix);</div>
<div class="ttc" id="aclassSparseDirectUMFPACK_html"><div class="ttname"><a href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a></div><div class="ttdef"><b>Definition:</b> <a href="sparse__direct_8h_source.html#l00087">sparse_direct.h:88</a></div></div>
<div class="ttc" id="aclassSparseDirectUMFPACK_html_a25b1d3c7dbb88158a76165a4a56a16d6"><div class="ttname"><a href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">SparseDirectUMFPACK::initialize</a></div><div class="ttdeci">void initialize(const SparsityPattern &amp;sparsity_pattern)</div><div class="ttdef"><b>Definition:</b> <a href="sparse__direct_8cc_source.html#l00049">sparse_direct.cc:49</a></div></div>
</div><!-- fragment --><p>After the decomposition, we can use <code>A_direct</code> like a matrix representing the inverse of our system matrix, so to compute the solution we just have to multiply with the right hand side vector:</p>
<div class="fragment"><div class="line">  A_direct.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a>(solution, system_rhs);</div>
<div class="line"> </div>
<div class="line">  timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="aclassSparseDirectUMFPACK_html_adc154e4830b0e16be265f10a5c8b7103"><div class="ttname"><a href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">SparseDirectUMFPACK::vmult</a></div><div class="ttdeci">void vmult(Vector&lt; double &gt; &amp;dst, const Vector&lt; double &gt; &amp;src) const</div><div class="ttdef"><b>Definition:</b> <a href="sparse__direct_8cc_source.html#l00762">sparse_direct.cc:762</a></div></div>
</div><!-- fragment --><p><a class="anchor" id="codeUltrasoundProblemoutput_resultscode"></a> </p><h4><code>UltrasoundProblem::output_results</code></h4>
<p>Here we output our solution \(v\) and \(w\) as well as the derived quantity \(|u|\) in the format specified in the parameter file. Most of the work for deriving \(|u|\) from \(v\) and \(w\) was already done in the implementation of the <code>ComputeIntensity</code> class, so that the output routine is rather straightforward and very similar to what is done in the previous tutorials.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Generating output... &quot;</span>;</div>
<div class="line">  <a class="code" href="classTimer.html">Timer</a> timer;</div>
</div><!-- fragment --><p>Define objects of our <code>ComputeIntensity</code> class and a <a class="el" href="classDataOut.html">DataOut</a> object:</p>
<div class="fragment"><div class="line">ComputeIntensity&lt;dim&gt; intensities;</div>
<div class="line"><a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a>          data_out;</div>
<div class="line"> </div>
<div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a>(dof_handler);</div>
<div class="ttc" id="aclassDataOut__DoFData_html_ac1eb26168177faa30ffbcf9cbb9c3cd5"><div class="ttname"><a href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">DataOut_DoFData::attach_dof_handler</a></div><div class="ttdeci">void attach_dof_handler(const DoFHandlerType &amp;)</div></div>
<div class="ttc" id="aclassDataOut_html"><div class="ttname"><a href="classDataOut.html">DataOut</a></div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__out_8h_source.html#l00147">data_out.h:150</a></div></div>
</div><!-- fragment --><p>Next we query the output-related parameters from the <a class="el" href="classParameterHandler.html">ParameterHandler</a>. The <a class="el" href="group__Exceptions.html#ga0a975649e4516ee7c7a67ae2f8dddd97">DataOut::parse_parameters</a> call acts as a counterpart to the <a class="el" href="group__Exceptions.html#ga1f2f1d644d9cb1c4d1714d5173d159f2">DataOutInterface&lt;1&gt;::declare_parameters</a> call in <code>ParameterReader::declare_parameters</code>. It collects all the output format related parameters from the <a class="el" href="classParameterHandler.html">ParameterHandler</a> and sets the corresponding properties of the <a class="el" href="classDataOut.html">DataOut</a> object accordingly.</p>
<div class="fragment"><div class="line">prm.enter_subsection(<span class="stringliteral">&quot;Output parameters&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> std::string output_filename = prm.get(<span class="stringliteral">&quot;Output filename&quot;</span>);</div>
<div class="line">data_out.<a class="code" href="group__Exceptions.html#ga0a975649e4516ee7c7a67ae2f8dddd97">parse_parameters</a>(prm);</div>
<div class="line"> </div>
<div class="line">prm.leave_subsection();</div>
<div class="ttc" id="agroup__Exceptions_html_ga0a975649e4516ee7c7a67ae2f8dddd97"><div class="ttname"><a href="group__Exceptions.html#ga0a975649e4516ee7c7a67ae2f8dddd97">DataOutInterface::parse_parameters</a></div><div class="ttdeci">void parse_parameters(ParameterHandler &amp;prm)</div><div class="ttdef"><b>Definition:</b> <a href="data__out__base_8cc_source.html#l08267">data_out_base.cc:8267</a></div></div>
</div><!-- fragment --><p>Now we put together the filename from the base name provided by the <a class="el" href="classParameterHandler.html">ParameterHandler</a> and the suffix which is provided by the <a class="el" href="classDataOut.html">DataOut</a> class (the default suffix is set to the right type that matches the one set in the .prm file through parse_parameters()):</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::string filename = output_filename + data_out.<a class="code" href="group__Exceptions.html#ga36120ca3f536c90709e135161030f16c">default_suffix</a>();</div>
<div class="line"> </div>
<div class="line">std::ofstream output(filename);</div>
<div class="ttc" id="agroup__Exceptions_html_ga36120ca3f536c90709e135161030f16c"><div class="ttname"><a href="group__Exceptions.html#ga36120ca3f536c90709e135161030f16c">DataOutInterface::default_suffix</a></div><div class="ttdeci">std::string default_suffix(const DataOutBase::OutputFormat output_format=DataOutBase::default_format) const</div><div class="ttdef"><b>Definition:</b> <a href="data__out__base_8cc_source.html#l08201">data_out_base.cc:8201</a></div></div>
</div><!-- fragment --><p>The solution vectors \(v\) and \(w\) are added to the <a class="el" href="classDataOut.html">DataOut</a> object in the usual way:</p>
<div class="fragment"><div class="line">std::vector&lt;std::string&gt; solution_names;</div>
<div class="line">solution_names.emplace_back(<span class="stringliteral">&quot;Re_u&quot;</span>);</div>
<div class="line">solution_names.emplace_back(<span class="stringliteral">&quot;Im_u&quot;</span>);</div>
<div class="line"> </div>
<div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a>(solution, solution_names);</div>
<div class="ttc" id="aclassDataOut__DoFData_html_ace4b76e565ba0701c4d32c26075ed3b9"><div class="ttname"><a href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">DataOut_DoFData::add_data_vector</a></div><div class="ttdeci">void add_data_vector(const VectorType &amp;data, const std::vector&lt; std::string &gt; &amp;names, const DataVectorType type=type_automatic, const std::vector&lt; DataComponentInterpretation::DataComponentInterpretation &gt; &amp;data_component_interpretation=std::vector&lt; DataComponentInterpretation::DataComponentInterpretation &gt;())</div><div class="ttdef"><b>Definition:</b> <a href="data__out__dof__data_8h_source.html#l01087">data_out_dof_data.h:1087</a></div></div>
</div><!-- fragment --><p>For the intensity, we just call <code>add_data_vector</code> again, but this with our <code>ComputeIntensity</code> object as the second argument, which effectively adds \(|u|\) to the output data:</p>
<div class="fragment"><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a>(solution, intensities);</div>
</div><!-- fragment --><p>The last steps are as before. Note that the actual output format is now determined by what is stated in the input file, i.e. one can change the output format without having to re-compile this program:</p>
<div class="fragment"><div class="line">  data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a>();</div>
<div class="line">  data_out.<a class="code" href="group__Exceptions.html#ga78e73ad285a8792ff0f9f227b82eb108">write</a>(output);</div>
<div class="line"> </div>
<div class="line">  timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="aclassDataOut_html_a5eb51872b8736849bb7e8d2007fae086"><div class="ttname"><a href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">DataOut::build_patches</a></div><div class="ttdeci">virtual void build_patches(const unsigned int n_subdivisions=0)</div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__out_8cc_source.html#l01085">data_out.cc:1085</a></div></div>
<div class="ttc" id="agroup__Exceptions_html_ga78e73ad285a8792ff0f9f227b82eb108"><div class="ttname"><a href="group__Exceptions.html#ga78e73ad285a8792ff0f9f227b82eb108">DataOutInterface::write</a></div><div class="ttdeci">void write(std::ostream &amp;out, const DataOutBase::OutputFormat output_format=DataOutBase::default_format) const</div><div class="ttdef"><b>Definition:</b> <a href="data__out__base_8cc_source.html#l08090">data_out_base.cc:8090</a></div></div>
</div><!-- fragment --><p><a class="anchor" id="codeUltrasoundProblemruncode"></a> </p><h4><code>UltrasoundProblem::run</code></h4>
<p>Here we simply execute our functions one after the other:</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">UltrasoundProblem&lt;dim&gt;::run</a>()</div>
<div class="line">  {</div>
<div class="line">    make_grid();</div>
<div class="line">    setup_system();</div>
<div class="line">    assemble_system();</div>
<div class="line">    solve();</div>
<div class="line">    output_results();</div>
<div class="line">  }</div>
<div class="line">} <span class="comment">// namespace Step29</span></div>
</div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h4>The <code>main</code> function</h4>
<p>Finally the <code>main</code> function of the program. It has the same structure as in almost all of the other tutorial programs. The only exception is that we define <a class="el" href="classParameterHandler.html">ParameterHandler</a> and <code>ParameterReader</code> objects, and let the latter read in the parameter values from a textfile called <code><a class="el" href="step_29.html">step-29</a>.prm</code>. The values so read are then handed over to an instance of the UltrasoundProblem class:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
<div class="line">      <span class="keyword">using namespace </span>Step29;</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div>
<div class="line">      ParameterReader  param(prm);</div>
<div class="line">      param.read_parameters(<span class="stringliteral">&quot;step-29.prm&quot;</span>);</div>
<div class="line"> </div>
<div class="line">      UltrasoundProblem&lt;2&gt; ultrasound_problem(prm);</div>
<div class="line">      ultrasound_problem.run();</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> <a class="anchor" id="Results"></a> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The current program reads its run-time parameters from an input file called <code>step-29.prm</code> that looks like this: </p><div class="fragment"><div class="line">subsection Mesh &amp; geometry parameters</div>
<div class="line"><span class="preprocessor">  # Distance of the focal point of the lens to the x-axis</span></div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Focal distance        = 0.3</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">  # Number of global mesh refinement steps applied to initial coarse grid</span></div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Number of refinements = 5</div>
<div class="line"><a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">subsection Physical constants</div>
<div class="line"><span class="preprocessor">  # Wave speed</span></div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> c     = 1.5e5</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">  # Frequency</span></div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> omega = 3.0e7</div>
<div class="line"><a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">subsection Output parameters</div>
<div class="line"><span class="preprocessor">  # Name of the output file (without extension)</span></div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Output file   = solution</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">  # A name for the output format to be used</span></div>
<div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Output format = <a class="code" href="group__Exceptions.html#gaa3cbced9f1d4ae661f13018f4c980aa1acff6079f78795530409873a79263ad7e">vtu</a></div>
<div class="line"><a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div>
<div class="ttc" id="agroup__CUDAWrappers_html_gabb7130e2cea54654455ca41ef304f939"><div class="ttname"><a href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">LinearAlgebra::CUDAWrappers::kernel::set</a></div><div class="ttdeci">__global__ void set(Number *val, const Number s, const size_type N)</div></div>
<div class="ttc" id="agroup__Exceptions_html_gaa3cbced9f1d4ae661f13018f4c980aa1acff6079f78795530409873a79263ad7e"><div class="ttname"><a href="group__Exceptions.html#gaa3cbced9f1d4ae661f13018f4c980aa1acff6079f78795530409873a79263ad7e">DataOutBase::vtu</a></div><div class="ttdeci">@ vtu</div><div class="ttdef"><b>Definition:</b> <a href="data__out__base_8h_source.html#l01608">data_out_base.h:1608</a></div></div>
<div class="ttc" id="anamespaceTrilinosWrappers_1_1internal_html_aee42c8e3004e2e81eac3c3356d3ec46b"><div class="ttname"><a href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">TrilinosWrappers::internal::end</a></div><div class="ttdeci">VectorType::value_type * end(VectorType &amp;V)</div><div class="ttdef"><b>Definition:</b> <a href="trilinos__sparse__matrix_8cc_source.html#l00067">trilinos_sparse_matrix.cc:67</a></div></div>
</div><!-- fragment --><p>As can be seen, we set \(d=0.3\), which amounts to a focus of the transducer lens at \(x=0.5\), \(y=0.3\). The coarse mesh is refined 5 times, resulting in 160x160 cells, and the output is written in vtu format. The parameter reader understands many more parameters pertaining in particular to the generation of output, but we need none of these parameters here and therefore stick with their default values.</p>
<p>Here's the console output of the program in debug mode:</p>
<div class="fragment"><div class="line">&gt; make <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div>
<div class="line">[ 66%] Built target @ref step_29 <span class="stringliteral">&quot;step-29&quot;</span></div>
<div class="line">[100%] Run @ref step_29 <span class="stringliteral">&quot;step-29&quot;</span> with Debug configuration</div>
<div class="line">Generating grid... done (0.820449s)</div>
<div class="line">  Number of active cells:  25600</div>
<div class="line">Setting up system... done (1.18392s)</div>
<div class="line">  Number of degrees of freedom: 51842</div>
<div class="line">Assembling system <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>... done (2.33291s)</div>
<div class="line">Solving linear system... done (1.34837s)</div>
<div class="line">Generating output... done (2.05782s)</div>
<div class="line">[100%] Built target <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div>
<div class="ttc" id="anamespaceLAPACKSupport_html_a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003"><div class="ttname"><a href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">LAPACKSupport::matrix</a></div><div class="ttdeci">@ matrix</div><div class="ttdoc">Contents is actually a matrix.</div><div class="ttdef"><b>Definition:</b> <a href="lapack__support_8h_source.html#l00058">lapack_support.h:58</a></div></div>
</div><!-- fragment --><p>(Of course, execution times will differ if you run the program locally.) The fact that most of the time is spent on assembling the system matrix and generating output is due to the many assertions that need to be checked in debug mode. In release mode these parts of the program run much faster whereas solving the linear system is hardly sped up at all:</p>
<div class="fragment"><div class="line">&gt; make <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div>
<div class="line">[ 66%] Built target @ref step_29 <span class="stringliteral">&quot;step-29&quot;</span></div>
<div class="line">Scanning dependencies of target <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div>
<div class="line">[100%] Run @ref step_29 <span class="stringliteral">&quot;step-29&quot;</span> with Release configuration</div>
<div class="line">DEAL::Generating grid... done (0.0144960s)</div>
<div class="line">DEAL::  Number of active cells:  25600</div>
<div class="line">DEAL::Setting up system... done (0.0356880s)</div>
<div class="line">DEAL::  Number of degrees of freedom: 51842</div>
<div class="line">DEAL::Assembling system <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>... done (0.0436570s)</div>
<div class="line">DEAL::Solving linear system... done (1.54733s)</div>
<div class="line">DEAL::Generating output... done (0.720528s)</div>
<div class="line">[100%] Built target <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div>
</div><!-- fragment --><p>The graphical output of the program looks as follows:</p>
<table align="center" class="doxtable">
<tr>
<td><img src="https://www.dealii.org/images/steps/developer/step-29.v.png" alt="v = Re(u)" class="inline"/>  </td><td><img src="https://www.dealii.org/images/steps/developer/step-29.w.png" alt="w = Im(u)" class="inline"/>   </td></tr>
<tr>
<td colspan="2"><img src="https://www.dealii.org/images/steps/developer/step-29.intensity.png" alt="|u|" class="inline"/>   </td></tr>
</table>
<p>The first two pictures show the real and imaginary parts of \(u\), whereas the last shows the intensity \(|u|\). One can clearly see that the intensity is focused around the focal point of the lens (0.5, 0.3), and that the focus is rather sharp in \(x\)-direction but more blurred in \(y\)-direction, which is a consequence of the geometry of the focusing lens, its finite aperture, and the wave nature of the problem.</p>
<p>Because colorful graphics are always fun, and to stress the focusing effects some more, here is another set of images highlighting how well the intensity is actually focused in \(x\)-direction:</p>
<table align="center" class="doxtable">
<tr>
<td><img src="https://www.dealii.org/images/steps/developer/step-29.surface.png" alt="|u|" class="inline"/>  </td><td><img src="https://www.dealii.org/images/steps/developer/step-29.contours.png" alt="|u|" class="inline"/>   </td></tr>
</table>
<p>As a final note, the structure of the program makes it easy to determine which parts of the program scale nicely as the mesh is refined and which parts don't. Here are the run times for 5, 6, and 7 global refinements:</p>
<div class="fragment"><div class="line">&gt; make <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div>
<div class="line">[ 66%] Built target @ref step_29 <span class="stringliteral">&quot;step-29&quot;</span></div>
<div class="line">[100%] Run @ref step_29 <span class="stringliteral">&quot;step-29&quot;</span> with Release configuration</div>
<div class="line">DEAL::Generating grid... done (0.0135260s)</div>
<div class="line">DEAL::  Number of active cells:  25600</div>
<div class="line">DEAL::Setting up system... done (0.0213910s)</div>
<div class="line">DEAL::  Number of degrees of freedom: 51842</div>
<div class="line">DEAL::Assembling system <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>... done (0.0414300s)</div>
<div class="line">DEAL::Solving linear system... done (1.56621s)</div>
<div class="line">DEAL::Generating output... done (0.729605s)</div>
<div class="line">[100%] Built target <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div>
<div class="line"> </div>
<div class="line">&gt; make <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div>
<div class="line">[ 66%] Built target @ref step_29 <span class="stringliteral">&quot;step-29&quot;</span></div>
<div class="line">[100%] Run @ref step_29 <span class="stringliteral">&quot;step-29&quot;</span> with Release configuration</div>
<div class="line">DEAL::Generating grid... done (0.0668490s)</div>
<div class="line">DEAL::  Number of active cells:  102400</div>
<div class="line">DEAL::Setting up system... done (0.109694s)</div>
<div class="line">DEAL::  Number of degrees of freedom: 206082</div>
<div class="line">DEAL::Assembling system <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>... done (0.160784s)</div>
<div class="line">DEAL::Solving linear system... done (7.86577s)</div>
<div class="line">DEAL::Generating output... done (2.89320s)</div>
<div class="line">[100%] Built target <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div>
<div class="line"> </div>
<div class="line">&gt; make <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div>
<div class="line">[ 66%] Built target @ref step_29 <span class="stringliteral">&quot;step-29&quot;</span></div>
<div class="line">[100%] Run @ref step_29 <span class="stringliteral">&quot;step-29&quot;</span> with Release configuration</div>
<div class="line">DEAL::Generating grid... done (0.293154s)</div>
<div class="line">DEAL::  Number of active cells:  409600</div>
<div class="line">DEAL::Setting up system... done (0.491301s)</div>
<div class="line">DEAL::  Number of degrees of freedom: 821762</div>
<div class="line">DEAL::Assembling system <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>... done (0.605386s)</div>
<div class="line">DEAL::Solving linear system... done (45.1989s)</div>
<div class="line">DEAL::Generating output... done (11.2292s)</div>
<div class="line">[100%] Built target <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div>
</div><!-- fragment --><p>Each time we refine the mesh once, so the number of cells and degrees of freedom roughly quadruples from each step to the next. As can be seen, generating the grid, setting up degrees of freedom, assembling the linear system, and generating output scale pretty closely to linear, whereas solving the linear system is an operation that requires 8 times more time each time the number of degrees of freedom is increased by a factor of 4, i.e. it is \({\cal O}(N^{3/2})\). This can be explained by the fact that (using optimal ordering) the bandwidth of a finite element matrix is \(B={\cal O}(N^{(dim-1)/dim})\), and the effort to solve a banded linear system using LU decomposition is \({\cal O}(BN)\). This also explains why the program does run in 3d as well (after changing the dimension on the <code>UltrasoundProblem</code> object), but scales very badly and takes extraordinary patience before it finishes solving the linear system on a mesh with appreciable resolution, even though all the other parts of the program scale very nicely.</p>
<p><a class="anchor" id="extensions"></a> <a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>An obvious possible extension for this program is to run it in 3d &mdash; after all, the world around us is three-dimensional, and ultrasound beams propagate in three-dimensional media. You can try this by simply changing the template parameter of the principal class in <code>main()</code> and running it. This won't get you very far, though: certainly not if you do 5 global refinement steps as set in the parameter file. You'll simply run out of memory as both the mesh (with its \((2^5)^3 \cdot 5^3=2^{15}\cdot 125 \approx 4\cdot 10^6\) cells) and in particular the sparse direct solver take too much memory. You can solve with 3 global refinement steps, however, if you have a bit of time: in early 2011, the direct solve takes about half an hour. What you'll notice, however, is that the solution is completely wrong: the mesh size is simply not small enough to resolve the solution's waves accurately, and you can see this in plots of the solution. Consequently, this is one of the cases where adaptivity is indispensable if you don't just want to throw a bigger (presumably parallel) machine at the problem.</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Copyright (C) 2007 - 2020 by the deal.II authors</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div>
<div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div>
<div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div>
<div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div>
<div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div>
<div class="line"><span class="comment"> * the top level directory of deal.II.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Author: Moritz Allmaras, Texas A&amp;M University, 2007</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__handler_8h.html">deal.II/base/parameter_handler.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>Step29</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keyword">class </span>DirichletBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    DirichletBoundaryValues()</div>
<div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(2)</div>
<div class="line">    {}</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div>
<div class="line">                              <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>)<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>.size() == 2, <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>.size(), 2));</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(0) = 1;</div>
<div class="line">      <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(1) = 0;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span></div>
<div class="line">    vector_value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div>
<div class="line">                      std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;  value_list)<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(value_list.size() == points.size(),</div>
<div class="line">             <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(value_list.size(), points.size()));</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; points.size(); ++p)</div>
<div class="line">        DirichletBoundaryValues&lt;dim&gt;::vector_value(points[p], value_list[p]);</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">class </span>ParameterReader : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    ParameterReader(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;);</div>
<div class="line">    <span class="keywordtype">void</span> read_parameters(<span class="keyword">const</span> std::string &amp;);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span>              declare_parameters();</div>
<div class="line">    <a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  ParameterReader::ParameterReader(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;paramhandler)</div>
<div class="line">    : prm(paramhandler)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> ParameterReader::declare_parameters()</div>
<div class="line">  {</div>
<div class="line">    prm.enter_subsection(<span class="stringliteral">&quot;Mesh &amp; geometry parameters&quot;</span>);</div>
<div class="line">    {</div>
<div class="line">      prm.declare_entry(<span class="stringliteral">&quot;Number of refinements&quot;</span>,</div>
<div class="line">                        <span class="stringliteral">&quot;6&quot;</span>,</div>
<div class="line">                        <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0),</div>
<div class="line">                        <span class="stringliteral">&quot;Number of global mesh refinement steps &quot;</span></div>
<div class="line">                        <span class="stringliteral">&quot;applied to initial coarse grid&quot;</span>);</div>
<div class="line"> </div>
<div class="line">      prm.declare_entry(<span class="stringliteral">&quot;Focal distance&quot;</span>,</div>
<div class="line">                        <span class="stringliteral">&quot;0.3&quot;</span>,</div>
<div class="line">                        <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0),</div>
<div class="line">                        <span class="stringliteral">&quot;Distance of the focal point of the lens &quot;</span></div>
<div class="line">                        <span class="stringliteral">&quot;to the x-axis&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">    prm.leave_subsection();</div>
<div class="line"> </div>
<div class="line">    prm.enter_subsection(<span class="stringliteral">&quot;Physical constants&quot;</span>);</div>
<div class="line">    {</div>
<div class="line">      prm.declare_entry(<span class="stringliteral">&quot;c&quot;</span>, <span class="stringliteral">&quot;1.5e5&quot;</span>, <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0), <span class="stringliteral">&quot;Wave speed&quot;</span>);</div>
<div class="line"> </div>
<div class="line">      prm.declare_entry(<span class="stringliteral">&quot;omega&quot;</span>, <span class="stringliteral">&quot;5.0e7&quot;</span>, <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0), <span class="stringliteral">&quot;Frequency&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">    prm.leave_subsection();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    prm.enter_subsection(<span class="stringliteral">&quot;Output parameters&quot;</span>);</div>
<div class="line">    {</div>
<div class="line">      prm.declare_entry(<span class="stringliteral">&quot;Output filename&quot;</span>,</div>
<div class="line">                        <span class="stringliteral">&quot;solution&quot;</span>,</div>
<div class="line">                        <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>(),</div>
<div class="line">                        <span class="stringliteral">&quot;Name of the output file (without extension)&quot;</span>);</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="group__Exceptions.html#ga1f2f1d644d9cb1c4d1714d5173d159f2">DataOutInterface&lt;1&gt;::declare_parameters</a>(prm);</div>
<div class="line">    }</div>
<div class="line">    prm.leave_subsection();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> ParameterReader::read_parameters(<span class="keyword">const</span> std::string &amp;parameter_file)</div>
<div class="line">  {</div>
<div class="line">    declare_parameters();</div>
<div class="line"> </div>
<div class="line">    prm.parse_input(parameter_file);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keyword">class </span>ComputeIntensity : <span class="keyword">public</span> <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    ComputeIntensity();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classDataPostprocessor.html#a1ba57b598d24d64365d469a854271c68">evaluate_vector_field</a>(</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div>
<div class="line">      std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;computed_quantities) <span class="keyword">const override</span>;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  ComputeIntensity&lt;dim&gt;::ComputeIntensity()</div>
<div class="line">    : <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;(<span class="stringliteral">&quot;Intensity&quot;</span>, <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> ComputeIntensity&lt;dim&gt;::evaluate_vector_field(</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div>
<div class="line">    std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;               computed_quantities)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities.size() == inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size(),</div>
<div class="line">           <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities.size(),</div>
<div class="line">                                inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size()));</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; computed_quantities.size(); i++)</div>
<div class="line">      {</div>
<div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities[i].size() == 1,</div>
<div class="line">               <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities[i].size(), 1));</div>
<div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i].size() == 2,</div>
<div class="line">               <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i].size(), 2));</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">const</span> std::complex&lt;double&gt; u(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i](0),</div>
<div class="line">                                     inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i](1));</div>
<div class="line"> </div>
<div class="line">        computed_quantities[i](0) = std::abs(u);</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keyword">class </span>UltrasoundProblem</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    UltrasoundProblem(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;);</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> make_grid();</div>
<div class="line">    <span class="keywordtype">void</span> setup_system();</div>
<div class="line">    <span class="keywordtype">void</span> assemble_system();</div>
<div class="line">    <span class="keywordtype">void</span> solve();</div>
<div class="line">    <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div>
<div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div>
<div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>      fe;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div>
<div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div>
<div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       solution, system_rhs;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  UltrasoundProblem&lt;dim&gt;::UltrasoundProblem(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;param)</div>
<div class="line">    : prm(param)</div>
<div class="line">    , dof_handler(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>)</div>
<div class="line">    , fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1), 2)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::make_grid()</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Generating grid... &quot;</span>;</div>
<div class="line">    <a class="code" href="classTimer.html">Timer</a> timer;</div>
<div class="line"> </div>
<div class="line">    prm.enter_subsection(<span class="stringliteral">&quot;Mesh &amp; geometry parameters&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       focal_distance = prm.get_double(<span class="stringliteral">&quot;Focal distance&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_refinements = prm.get_integer(<span class="stringliteral">&quot;Number of refinements&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    prm.leave_subsection();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> transducer =</div>
<div class="line">      (dim == 2) ? <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.0) : <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.5, 0.0);</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> focal_point = (dim == 2) ?</div>
<div class="line">                                     <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, focal_distance) :</div>
<div class="line">                                     <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.5, focal_distance);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <a class="code" href="namespaceGridGenerator.html#a358d5bd545bc115c8645d93fa79b64bc">GridGenerator::subdivided_hyper_cube</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, 5, 0, 1);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.cell_iterators())</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div>
<div class="line">        <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp;</div>
<div class="line">            ((face-&gt;center() - transducer).norm_square() &lt; 0.01))</div>
<div class="line">          {</div>
<div class="line">            face-&gt;set_boundary_id(1);</div>
<div class="line">            face-&gt;set_manifold_id(1);</div>
<div class="line">          }</div>
<div class="line">    <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.set_manifold(1, <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a>(focal_point));</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.refine_global(n_refinements);</div>
<div class="line"> </div>
<div class="line">    timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Number of active cells:  &quot;</span> &lt;&lt; <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.n_active_cells()</div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::setup_system()</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Setting up system... &quot;</span>;</div>
<div class="line">    <a class="code" href="classTimer.html">Timer</a> timer;</div>
<div class="line"> </div>
<div class="line">    dof_handler.distribute_dofs(fe);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.n_dofs(), dof_handler.n_dofs());</div>
<div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div>
<div class="line">    sparsity_pattern.copy_from(dsp);</div>
<div class="line"> </div>
<div class="line">    system_matrix.reinit(sparsity_pattern);</div>
<div class="line">    system_rhs.reinit(dof_handler.n_dofs());</div>
<div class="line">    solution.reinit(dof_handler.n_dofs());</div>
<div class="line"> </div>
<div class="line">    timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::assemble_system()</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Assembling system matrix... &quot;</span>;</div>
<div class="line">    <a class="code" href="classTimer.html">Timer</a> timer;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    prm.enter_subsection(<span class="stringliteral">&quot;Physical constants&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> omega = prm.get_double(<span class="stringliteral">&quot;omega&quot;</span>), c = prm.get_double(<span class="stringliteral">&quot;c&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    prm.leave_subsection();</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.degree + 1);</div>
<div class="line">    <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe.degree + 1);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = quadrature_formula.size(),</div>
<div class="line">                       n_face_q_points = face_quadrature_formula.size(),</div>
<div class="line">                       dofs_per_cell   = fe.n_dofs_per_cell();</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div>
<div class="line">                            quadrature_formula,</div>
<div class="line">                            <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div>
<div class="line">                              <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values(fe,</div>
<div class="line">                                     face_quadrature_formula,</div>
<div class="line">                                     <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div>
<div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.active_cell_iterators())</div>
<div class="line">      {</div>
<div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a> = 0;</div>
<div class="line">        fe_values.reinit(cell);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div>
<div class="line">          {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div>
<div class="line">              {</div>
<div class="line">                <span class="keywordflow">if</span> (fe.system_to_component_index(i).first ==</div>
<div class="line">                    fe.system_to_component_index(j).first)</div>
<div class="line">                  {</div>
<div class="line"> </div>
<div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points;</div>
<div class="line">                         ++q_point)</div>
<div class="line">                      <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div>
<div class="line">                        (((fe_values.shape_value(i, q_point) *</div>
<div class="line">                           fe_values.shape_value(j, q_point)) *</div>
<div class="line">                            (-omega * omega) +</div>
<div class="line">                          (fe_values.shape_grad(i, q_point) *</div>
<div class="line">                           fe_values.shape_grad(j, q_point)) *</div>
<div class="line">                            c * c) *</div>
<div class="line">                         fe_values.JxW(q_point));</div>
<div class="line"> </div>
<div class="line">                  }</div>
<div class="line">              }</div>
<div class="line">          }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_no : cell-&gt;face_indices())</div>
<div class="line">          <span class="keywordflow">if</span> (cell-&gt;face(face_no)-&gt;at_boundary() &amp;&amp;</div>
<div class="line">              (cell-&gt;face(face_no)-&gt;boundary_id() == 0))</div>
<div class="line">            {</div>
<div class="line">              fe_face_values.reinit(cell, face_no);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div>
<div class="line">                  <span class="keywordflow">if</span> ((fe.system_to_component_index(i).first !=</div>
<div class="line">                       fe.system_to_component_index(j).first) &amp;&amp;</div>
<div class="line">                      fe.has_support_on_face(i, face_no) &amp;&amp;</div>
<div class="line">                      fe.has_support_on_face(j, face_no))</div>
<div class="line"> </div>
<div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_face_q_points;</div>
<div class="line">                         ++q_point)</div>
<div class="line">                      <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div>
<div class="line">                        ((fe.system_to_component_index(i).first == 0) ? -1 :</div>
<div class="line">                                                                        1) *</div>
<div class="line">                        fe_face_values.shape_value(i, q_point) *</div>
<div class="line">                        fe_face_values.shape_value(j, q_point) * c * omega *</div>
<div class="line">                        fe_face_values.JxW(q_point);</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div>
<div class="line">            system_matrix.add(local_dof_indices[i],</div>
<div class="line">                              local_dof_indices[j],</div>
<div class="line">                              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j));</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    std::map&lt;types::global_dof_index, double&gt; boundary_values;</div>
<div class="line">    <a class="code" href="namespaceVectorTools.html#ab2562d41bb26f362043f9719a8cd9b87">VectorTools::interpolate_boundary_values</a>(dof_handler,</div>
<div class="line">                                             1,</div>
<div class="line">                                             DirichletBoundaryValues&lt;dim&gt;(),</div>
<div class="line">                                             boundary_values);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div>
<div class="line">                                       system_matrix,</div>
<div class="line">                                       solution,</div>
<div class="line">                                       system_rhs);</div>
<div class="line"> </div>
<div class="line">    timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::solve()</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Solving linear system... &quot;</span>;</div>
<div class="line">    <a class="code" href="classTimer.html">Timer</a> timer;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> A_direct;</div>
<div class="line">    A_direct.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(system_matrix);</div>
<div class="line"> </div>
<div class="line">    A_direct.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a>(solution, system_rhs);</div>
<div class="line"> </div>
<div class="line">    timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Generating output... &quot;</span>;</div>
<div class="line">    <a class="code" href="classTimer.html">Timer</a> timer;</div>
<div class="line"> </div>
<div class="line">    ComputeIntensity&lt;dim&gt; intensities;</div>
<div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a>          data_out;</div>
<div class="line"> </div>
<div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a>(dof_handler);</div>
<div class="line"> </div>
<div class="line">    prm.enter_subsection(<span class="stringliteral">&quot;Output parameters&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> std::string output_filename = prm.get(<span class="stringliteral">&quot;Output filename&quot;</span>);</div>
<div class="line">    data_out.<a class="code" href="group__Exceptions.html#ga0a975649e4516ee7c7a67ae2f8dddd97">parse_parameters</a>(prm);</div>
<div class="line"> </div>
<div class="line">    prm.leave_subsection();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> std::string filename = output_filename + data_out.<a class="code" href="group__Exceptions.html#ga36120ca3f536c90709e135161030f16c">default_suffix</a>();</div>
<div class="line"> </div>
<div class="line">    std::ofstream output(filename);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;std::string&gt; solution_names;</div>
<div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;Re_u&quot;</span>);</div>
<div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;Im_u&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a>(solution, solution_names);</div>
<div class="line"> </div>
<div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a>(solution, intensities);</div>
<div class="line"> </div>
<div class="line">    data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a>();</div>
<div class="line">    data_out.<a class="code" href="group__Exceptions.html#ga78e73ad285a8792ff0f9f227b82eb108">write</a>(output);</div>
<div class="line"> </div>
<div class="line">    timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">UltrasoundProblem&lt;dim&gt;::run</a>()</div>
<div class="line">  {</div>
<div class="line">    make_grid();</div>
<div class="line">    setup_system();</div>
<div class="line">    assemble_system();</div>
<div class="line">    solve();</div>
<div class="line">    output_results();</div>
<div class="line">  }</div>
<div class="line">} <span class="comment">// namespace Step29</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
<div class="line">      <span class="keyword">using namespace </span>Step29;</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div>
<div class="line">      ParameterReader  param(prm);</div>
<div class="line">      param.read_parameters(<span class="stringliteral">&quot;step-29.prm&quot;</span>);</div>
<div class="line"> </div>
<div class="line">      UltrasoundProblem&lt;2&gt; ultrasound_problem(prm);</div>
<div class="line">      ultrasound_problem.run();</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
