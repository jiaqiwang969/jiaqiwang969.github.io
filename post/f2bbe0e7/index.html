<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>machine learning for chaos system-基础知识 | DEAL-II-Fluid</title><meta name="description" content="学习资源: Udemy course: Recurrent Neural Networks in Python  Google Colab   如何从Colab导入文档  Github  Applications of Deep Neural Networks   Numpy Matrix arithmetic Tensor (aka. “arrays”)(note the name: Tenso"><meta name="keywords" content="chaos"><meta name="author" content="Jiaqi"><meta name="copyright" content="Jiaqi"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://deal-ii.com/post/f2bbe0e7/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><meta property="og:type" content="article"><meta property="og:title" content="machine learning for chaos system-基础知识"><meta property="og:url" content="http://deal-ii.com/post/f2bbe0e7/"><meta property="og:site_name" content="DEAL-II-Fluid"><meta property="og:description" content="学习资源: Udemy course: Recurrent Neural Networks in Python  Google Colab   如何从Colab导入文档  Github  Applications of Deep Neural Networks   Numpy Matrix arithmetic Tensor (aka. “arrays”)(note the name: Tenso"><meta property="og:image" content="https://i.loli.net/2020/12/13/KPc9zZ4hNn3CMta.png"><meta property="article:published_time" content="2020-12-11T04:58:34.000Z"><meta property="article:modified_time" content="2021-01-29T07:25:51.498Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="prev" title="machine learning for chaos system-测试篇" href="http://deal-ii.com/post/d03a598f/"><link rel="next" title="Dynamical system and chaos" href="http://deal-ii.com/post/845ed395/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2021-01-29 15:25:51'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/flink.min.css"><link rel="stylesheet" href="/gitcalendar/css/gitcalendar.css"/><meta name="generator" content="Hexo 5.3.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/Jiaqi-knight/imgBase@main/me.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">25</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">33</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">14</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 索引</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 工具</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/x-dealii-9.3"><i class="fa-fw fa-book"></i><span> deal.ii Library</span></a></li><li><a class="site-page" href="/x-fem"><i class="fa-fw fa-book"></i><span> FEM-learning</span></a></li><li><a class="site-page" href="/x-swirlflow/"><i class="fa-fw fa fa-book"></i><span> swirlflow</span></a></li><li><a class="site-page" href="/x-codepen/"><i class="fa-fw fa fa-magic"></i><span> codepen</span></a></li><li><a class="site-page" href="/x-gallery/"><i class="fa-fw fa fa-beer"></i><span> gallery</span></a></li><li><a class="site-page" href="/x-shadertoy/"><i class="fa-fw fa fa-star"></i><span> shadertoy</span></a></li><li><a class="site-page" href="/x-webgl1/"><i class="fa-fw fa fa-camera-retro"></i><span> webgl1</span></a></li><li><a class="site-page" href="/x-webgl2/"><i class="fa-fw fa fa-camera-retro"></i><span> webgl2</span></a></li><li><a class="site-page" href="/x-markdown/"><i class="fa-fw fa fa-tree"></i><span> Vditor</span></a></li><li><a class="site-page" href="/x-DNN/"><i class="fa-fw fa fa-heartbeat"></i><span> DNN</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90"><span class="toc-number">1.</span> <span class="toc-text">学习资源:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Numpy"><span class="toc-number">2.</span> <span class="toc-text">Numpy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Matplotlib"><span class="toc-number">3.</span> <span class="toc-text">Matplotlib</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pandas"><span class="toc-number">4.</span> <span class="toc-text">Pandas</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scipy-power-version-of-numpy"><span class="toc-number">5.</span> <span class="toc-text">Scipy(power version of numpy)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scikit-Learn"><span class="toc-number">6.</span> <span class="toc-text">Scikit-Learn</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The-Steps-of-a-Machine-Learning-Script"><span class="toc-number">7.</span> <span class="toc-text">The Steps of a Machine Learning Script</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Outline"><span class="toc-number"></span> <span class="toc-text">Outline</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#What-is-machine-learning"><span class="toc-number">1.</span> <span class="toc-text">What is machine learning</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Classfication-and-Regression"><span class="toc-number">2.</span> <span class="toc-text">Classfication and Regression</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Loss"><span class="toc-number">3.</span> <span class="toc-text">Loss</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Minimizing-Cost"><span class="toc-number">4.</span> <span class="toc-text">Minimizing Cost</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gradient-Descent"><span class="toc-number">5.</span> <span class="toc-text">Gradient Descent</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number"></span> <span class="toc-text"> </span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AAnetwork-2-3-1"><span class="toc-number">1.</span> <span class="toc-text">构建一个network(2,3,1)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97backprogation"><span class="toc-number">2.</span> <span class="toc-text">如何计算backprogation?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8Ecost-function%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%81%87%E8%AE%BE"><span class="toc-number">3.</span> <span class="toc-text">对于cost function的两个假设</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The-backprogation-algorithm"><span class="toc-number">4.</span> <span class="toc-text">The backprogation algorithm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The-backprogation-algorithm-with-a-set-of-training-examples"><span class="toc-number">5.</span> <span class="toc-text">The backprogation algorithm with a set of training examples</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Better-choice-of-cost-function-the-cross-entropy"><span class="toc-number">6.</span> <span class="toc-text">Better choice of cost function: the cross-entropy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%9CRegularization%E2%80%9D-methods-L1-and-L2-regularization-dropout-and-artificial-expansion-of-the-traning-data"><span class="toc-number">7.</span> <span class="toc-text">“Regularization” methods (L1 and L2 regularization, dropout, and artificial expansion of the traning data)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Aritificial-Neural-Networks-ANNS"><span class="toc-number">8.</span> <span class="toc-text">Aritificial Neural Networks(ANNS)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reasons-for-the-disappearance-of-the-gradient"><span class="toc-number">9.</span> <span class="toc-text">Reasons for the disappearance of the gradient:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reasons-for-gradient-explosion"><span class="toc-number">10.</span> <span class="toc-text">Reasons for gradient explosion:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#How-to-solve-it"><span class="toc-number">11.</span> <span class="toc-text">How to solve it?</span></a></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/12/13/KPc9zZ4hNn3CMta.png)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">DEAL-II-Fluid</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 索引</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 工具</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/x-dealii-9.3"><i class="fa-fw fa-book"></i><span> deal.ii Library</span></a></li><li><a class="site-page" href="/x-fem"><i class="fa-fw fa-book"></i><span> FEM-learning</span></a></li><li><a class="site-page" href="/x-swirlflow/"><i class="fa-fw fa fa-book"></i><span> swirlflow</span></a></li><li><a class="site-page" href="/x-codepen/"><i class="fa-fw fa fa-magic"></i><span> codepen</span></a></li><li><a class="site-page" href="/x-gallery/"><i class="fa-fw fa fa-beer"></i><span> gallery</span></a></li><li><a class="site-page" href="/x-shadertoy/"><i class="fa-fw fa fa-star"></i><span> shadertoy</span></a></li><li><a class="site-page" href="/x-webgl1/"><i class="fa-fw fa fa-camera-retro"></i><span> webgl1</span></a></li><li><a class="site-page" href="/x-webgl2/"><i class="fa-fw fa fa-camera-retro"></i><span> webgl2</span></a></li><li><a class="site-page" href="/x-markdown/"><i class="fa-fw fa fa-tree"></i><span> Vditor</span></a></li><li><a class="site-page" href="/x-DNN/"><i class="fa-fw fa fa-heartbeat"></i><span> DNN</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">machine learning for chaos system-基础知识</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-12-11 12:58:34"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-12-11</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2021-01-29 15:25:51"><i class="fas fa-history fa-fw"></i> 更新于 2021-01-29</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%84%9F%E6%82%9F/">学习与感悟</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h3 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源:"></a>学习资源:</h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.udemy.com/course/deep-learning-recurrent-neural-networks-in-python/learn/lecture/5335868?start=0#overview">Udemy course: Recurrent Neural Networks in Python</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://colab.research.google.com/notebooks/intro.ipynb#recent=true">Google Colab</a></p>
<p>  <a target="_blank" rel="noopener" href="https://colab.research.google.com/drive/1fMpsJhSfZ_2BN3XeAt6yLQdKPfNvTlmU?usp=sharing">如何从Colab导入文档</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/lazyprogrammer">Github</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://sites.wustl.edu/jeffheaton/t81-558/">Applications of Deep Neural Networks</a></p>
</li>
</ul>
<h3 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h3><ul>
<li>Matrix arithmetic</li>
<li>Tensor (aka. “arrays”)(note the name: Tensorflow)</li>
<li>1-D tensor(vector), 2-D tensor(matix)</li>
<li>Arithmetic: +,-,*,/</li>
<li>Matrix multiply == dot/inner product (np.dot)</li>
<li>Element-wise multiply(*)</li>
</ul>
<h3 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h3><ul>
<li>Line charts</li>
<li>Scatter plots</li>
</ul>
<h3 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h3><ul>
<li>Loading in tabular data</li>
</ul>
<h3 id="Scipy-power-version-of-numpy"><a href="#Scipy-power-version-of-numpy" class="headerlink" title="Scipy(power version of numpy)"></a>Scipy(power version of numpy)</h3><ul>
<li>Satistics, optimization, linear algebra, signal processing</li>
</ul>
<h3 id="Scikit-Learn"><a href="#Scikit-Learn" class="headerlink" title="Scikit-Learn"></a>Scikit-Learn</h3><ul>
<li>basic machine learning</li>
<li>Classification and regression</li>
<li>Machine learning as geometry rather than magic</li>
<li>Shape of data(X and Y)</li>
</ul>
<h3 id="The-Steps-of-a-Machine-Learning-Script"><a href="#The-Steps-of-a-Machine-Learning-Script" class="headerlink" title="The Steps of a Machine Learning Script"></a>The Steps of a Machine Learning Script</h3><ul>
<li>Load in the data<ol>
<li>X and Y</li>
<li>Typically use Pandas unless the data is to complex</li>
</ol>
</li>
<li>Split into train/test sets (sometimes)<ol>
<li>Sometimes “test” and “validation” are used interchangebly, and the “true test set” is something else- don’t get frazzled over this.</li>
</ol>
</li>
<li>Build a model<ol>
<li>OOP (object oriented programming)</li>
<li>Tensorflow 2.0 standard is Keras API, very similar to Scikit-learn</li>
</ol>
</li>
<li>Fit the model(gradinet descent)<ol>
<li>model.fit(X,Y)</li>
</ol>
</li>
<li>Evaluate the model</li>
<li>Make predictions<ol>
<li>model.predict(X)</li>
</ol>
</li>
</ul>
<h2 id="Outline"><a href="#Outline" class="headerlink" title="Outline"></a>Outline</h2><h3 id="What-is-machine-learning"><a href="#What-is-machine-learning" class="headerlink" title="What is machine learning"></a>What is machine learning</h3><p>look for patterns for data and make better prediction in furture.</p>
<p>traning a nueral network is just to find a weight of minimum of cost function.</p>
<h3 id="Classfication-and-Regression"><a href="#Classfication-and-Regression" class="headerlink" title="Classfication and Regression"></a>Classfication and Regression</h3><p>Classfication:</p>
<ul>
<li>predict a category/ lable</li>
<li>yes or not / dog or cat</li>
<li>SVM</li>
</ul>
<p>Regression: (more features,nonlinear makes problem complicated)</p>
<ul>
<li>Fit a line or curve</li>
</ul>
<p><em>ŷ</em> = <em>mx</em> + <em>b</em></p>
<p>The Decision Rule</p>
<ul>
<li>sigmoid functions</li>
</ul>
<p><em>ŷ</em> = <em>σ</em>(<em>a</em>), <em>a</em> = <em>w</em>1<em>x</em>1 + <em>w</em>2<em>x</em>2 + <em>b</em></p>
<p>Probabilistic Interpretation</p>
<p><em>p</em>(<em>y</em> = 1|<em>x</em>) = <em>σ</em>(<em>a</em>)</p>
<p>Logistic Regression with &gt;2 Inputs</p>
<ul>
<li>What if we have &gt; 2 input?</li>
<li>Use matrices/ vectors</li>
</ul>
<p>$p(y= 1| x)=\sigma(w^T x + b)= \sigma (\sum_{d=1}^D w_d x_d +b)$</p>
<p><strong>Sigmoid neurons are similar to perceptrons, but modified so that small changes in their weights and bias cause only a small change in their output.</strong></p>
<script type="math/tex; mode=display">
\triangle output:\approx \sum_j {\partial output\over \partial w_j}\triangle w_j +{\partial output \over \partial b}\triangle b</script><p>Those say that $\triangle output$ is a linear function of the changes $\triangle w_j$ and $\triangle b$ in the weights and bias. make it much easier to figure out how changing the weights and biases will change the output.</p>
<p>sigmoid function is defined by:</p>
<script type="math/tex; mode=display">
\sigma(z)= {1\over 1+ e^{-z}}</script><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/12/14/EqZYNKJznyhsPRC.png" alt="https://i.loli.net/2020/12/13/pjS2kOK9HsB1weT.png" style="zoom:50%;" /></p>
<p>ReLU may be even more biological plausible than sigmoid;</p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/12/15/pRlCeYALUZmhbVT.png" alt="pRlCeYALUZmhbVT"></p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/12/13/pjS2kOK9HsB1weT.png" alt="https://i.loli.net/2020/12/13/pjS2kOK9HsB1weT.png"></p>
<p>In Tnesorflow 2.0</p>
<ul>
<li>Is mostly an exercise in “API hunting”</li>
<li>The actual math isn’t written in code (by you)</li>
<li>Your job is to find the function that implements the math in question</li>
<li>tf.keras.layers.Dense(Output_size)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model &#x3D; tf.keras.models.Sequential([    tf.keras.layers.Input(shape&#x3D;(D,)),    tf.keras.layers.Dense(1, activation&#x3D;&#39;sigmoid&#39;)])</span><br></pre></td></tr></table></figure>
<ul>
<li>cost function</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.compile (optimizer &#x3D; &#39;adam&#39;,                             loss &#x3D; &#39;binary_crossentropy&#39;,                             metrics &#x3D; [&#39;accuracy&#39;])</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/12/13/TpoVjywRnrqxOMX.png" alt="https://i.loli.net/2020/12/13/TpoVjywRnrqxOMX.png"></p>
<ul>
<li>Accuracy</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.compile(optimizer&#x3D;&#39;adam&#39;,                            loss &#x3D; &#39;binary_crossentropy&#39;,                            metrics &#x3D; [&#39;accuracy&#39;])</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
accuracy = {\# correct\over \# total}</script><ul>
<li>Training / Fitting</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r &#x3D; model.fit (X_train, y_train,                             validation_data &#x3D; (X_test, y_test),                             epochs&#x3D;100)plt.plot(r.history[&#39;loss&#39;],label&#x3D;&#39;loss&#39;)plt.plot(r.history[&#39;val_loss&#39;],label&#x3D;&#39;val_loss&#39;)</span><br></pre></td></tr></table></figure>
<p>To be conclude,</p>
<ul>
<li>Prediction = Round( <em>σ</em>(<em>Wx</em> + <em>b</em>) )</li>
<li>Implemented with Keras <em>Dense</em> layer</li>
<li><em>compile()</em> to specify optimizer (adam), loss (binary cross entropy), metrics(accuracy)</li>
<li><em>fit()</em> returns a history object, so we can plot loss per iteration</li>
</ul>
<h3 id="Loss"><a href="#Loss" class="headerlink" title="Loss"></a>Loss</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.<span class="built_in">compile</span> (optimizer = tf.keras.optimizers.SGD(<span class="number">0.001</span>, <span class="number">0.9</span>), loss=<span class="string">&#x27;mse&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>MSE = mean squared error</li>
</ul>
<p>$MSE={1\over N} \sum_{i=1}^N (y_i -\hat{y_i})^2$</p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/12/13/ovTb9lGDyKBLEWH.png" alt="https://i.loli.net/2020/12/13/ovTb9lGDyKBLEWH.png"></p>
<h3 id="Minimizing-Cost"><a href="#Minimizing-Cost" class="headerlink" title="Minimizing Cost"></a>Minimizing Cost</h3><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/12/13/ivJCbIKwQyXa1lW.png" alt="https://i.loli.net/2020/12/13/ivJCbIKwQyXa1lW.png"></p>
<p>The multidimensional equivalnet of <em>derivative</em>  is the <strong>gradient</strong></p>
<p>$\nabla_w J =({\partial J\over \partial w_1},{\partial J\over \partial w_2},…,{\partial J \over \partial w_D})$</p>
<p>$Set: \nabla_w J =0, solve \space for \space w$</p>
<p>TensorFlow done this for us by <em>automatic differentitation</em></p>
<ul>
<li>Tensorflow automatically finds the gradient of loss wrt all tour model weights</li>
<li>Tensorflow uses the gradients to train your model</li>
</ul>
<h3 id="Gradient-Descent"><a href="#Gradient-Descent" class="headerlink" title="Gradient Descent"></a>Gradient Descent</h3><ul>
<li>In most cases, it is not possible to solve for $anbla J=0$, using training <em>iterative</em> instead. (Linear Regression is the exception.)</li>
<li>gradient descent algorithm is inside the Keras <strong>fit</strong> function:</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">w,b = randomly initialized</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span> (epochs):</span><br><span class="line">    w = w - \eta * \nabla_w J</span><br><span class="line">    b = b - \eta * \nabla_b J</span><br><span class="line"><span class="comment"># \eta is called learning rate</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/12/13/6DtZx4F1NLkhCyq.png" alt="https://i.loli.net/2020/12/13/6DtZx4F1NLkhCyq.png"></p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/12/13/3QxRBDhT6oa4FnK.png" alt="https://i.loli.net/2020/12/13/3QxRBDhT6oa4FnK.png"></p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/12/13/h8V9EMfx7uadzYk.png" alt="https://i.loli.net/2020/12/13/h8V9EMfx7uadzYk.png"></p>
<p><strong>The aim of our traning algorithm will be to minimize the cost $C(w,b)$ as a fucntion of the weights and biases.</strong> In other words, we want to find a set of weights and biases which make the cost as small as possible. </p>
<p>Gradient descent can be viewed as a way of taking small steps in the direction which does the most to immediately decrease C.</p>
<p><strong>Stochastic gradient descent(SGD)</strong> used to speed uop learning.</p>
<p>The idea is to estimate the gradient $\nabla C$ by computing $\nabla C_x$ for a small sample of randomly chosen training inputs. By averaging over this small sample it turns out that we can quickly get a good estimate of the true gradient $\nabla C$/</p>
<script type="math/tex; mode=display">
{\sum_{j=1}^m \nabla C_{X_j}\over m} \approx {\sum_x \nabla C_x\over n}=\nabla C</script><script type="math/tex; mode=display">
w_k \rightarrow w_k' = w_k - {\eta\over m} \sum_j {\partial C_{X_j}\over \partial w_k}\\\\
b_l \rightarrow b_l' = b_l - {\eta\over m}\sum_j {\partial C_{X_j}\over \partial b_l}</script><p>The Cauchy-Schwarz inequality:</p>
<p>for all vectors u and v of an inner product space, it is true that:</p>
<script type="math/tex; mode=display">
|<u,v>|^2\leq <u,u>\cdot <v,v></script><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h3 id="构建一个network-2-3-1"><a href="#构建一个network-2-3-1" class="headerlink" title="构建一个network(2,3,1)"></a><strong>构建一个network(2,3,1)</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Network</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, sizes</span>):</span></span><br><span class="line">  	self.num_layers = <span class="built_in">len</span>(sizes)</span><br><span class="line">    self.sizes = sizes</span><br><span class="line">    self.biases = [np.random.randn(y,<span class="number">1</span>) <span class="keyword">for</span> y <span class="keyword">in</span> sizes[<span class="number">1</span>:]]</span><br><span class="line">    self.weights= [np.random.randn(y,x)</span><br><span class="line">                   <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(sizes[:-<span class="number">1</span>], sizes[<span class="number">1</span>:])]</span><br><span class="line">net = Network([<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Out:</span></span><br><span class="line"><span class="comment"># The biases and weights in the Network object are all initialized randomly</span></span><br><span class="line"><span class="comment"># using the Numpy np.random.randn function to generate Gaussian distributions with mean 0 and standard deviation 1</span></span><br><span class="line">biases=  [array([[-<span class="number">1.53072684</span>],</span><br><span class="line">        			  [-<span class="number">0.08241161</span>],</span><br><span class="line">        			  [-<span class="number">1.59648056</span>]]), </span><br><span class="line">          array([[-<span class="number">0.85710365</span>]])]</span><br><span class="line">weights= [array([[ <span class="number">1.08006753</span>, -<span class="number">0.59936474</span>], <span class="comment">#	代表虚线</span></span><br><span class="line">        			  [-<span class="number">0.57578445</span>, -<span class="number">0.50663782</span>],</span><br><span class="line">        			  [ <span class="number">1.16481607</span>,  <span class="number">0.06044497</span>]]),</span><br><span class="line">          array([[ <span class="number">0.5560195</span> , -<span class="number">2.12356058</span>,  <span class="number">2.19147343</span>]])]</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/12/14/bz14P5MGuQdlUnv.png" alt="network"></p>
<p>接下来，就要计算每一层的输出：</p>
<script type="math/tex; mode=display">
a'=\sigma(wa+b)</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span>(<span class="params">z</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span>/(<span class="number">1.0</span>+np.exp(-z))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">feedforward</span>(<span class="params">self, a</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return the output of the network if &quot;a&quot; is input.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> b, w <span class="keyword">in</span> <span class="built_in">zip</span>(self.biases, self.weights):</span><br><span class="line">            a = sigmoid(np.dot(w, a)+b)</span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SGD</span>(<span class="params">self, training_data, epochs, mini_batch_size, eta,</span></span></span><br><span class="line"><span class="function"><span class="params">        test_data=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Train the neural network using mini-batch stochastic</span></span><br><span class="line"><span class="string">    gradient descent.  The &quot;training_data&quot; is a list of tuples</span></span><br><span class="line"><span class="string">    &quot;(x, y)&quot; representing the training inputs and the desired</span></span><br><span class="line"><span class="string">    outputs.  The other non-optional parameters are</span></span><br><span class="line"><span class="string">    self-explanatory.  If &quot;test_data&quot; is provided then the</span></span><br><span class="line"><span class="string">    network will be evaluated against the test data after each</span></span><br><span class="line"><span class="string">    epoch, and partial progress printed out.  This is useful for</span></span><br><span class="line"><span class="string">    tracking progress, but slows things down substantially.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;eta is the learning rate. If the optional argument test_data is       </span></span><br><span class="line"><span class="string">    supplied, then the program will evaluate the network after each </span></span><br><span class="line"><span class="string">    epoch of training, and print out partial progress. This is useful </span></span><br><span class="line"><span class="string">    for tracking progress, but slows things down substantially.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> test_data: n_test = <span class="built_in">len</span>(test_data)</span><br><span class="line">    n = <span class="built_in">len</span>(training_data)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> xrange(epochs):</span><br><span class="line">        random.shuffle(training_data) <span class="comment">#洗牌</span></span><br><span class="line">        mini_batches = [</span><br><span class="line">            training_data[k:k+mini_batch_size]</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> xrange(<span class="number">0</span>, n, mini_batch_size)]</span><br><span class="line">        <span class="comment">#for each mini_batch we apply a single step of gradient  	descent,which updates the network weights and biases according to a single iteration of gradient descent.</span></span><br><span class="line">        <span class="keyword">for</span> mini_batch <span class="keyword">in</span> mini_batches:</span><br><span class="line">            self.update_mini_batch(mini_batch, eta)</span><br><span class="line">        <span class="keyword">if</span> test_data:</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&quot;Epoch &#123;0&#125;: &#123;1&#125; / &#123;2&#125;&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">                j, self.evaluate(test_data), n_test)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&quot;Epoch &#123;0&#125; complete&quot;</span>.<span class="built_in">format</span>(j)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_mini_batch</span>(<span class="params">self, mini_batch, eta</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Update the network&#x27;s weights and biases by applying</span></span><br><span class="line"><span class="string">    gradient descent using backpropagation to a single mini batch.</span></span><br><span class="line"><span class="string">    The &quot;mini_batch&quot; is a list of tuples &quot;(x, y)&quot;, and &quot;eta&quot;</span></span><br><span class="line"><span class="string">    is the learning rate.&quot;&quot;&quot;</span></span><br><span class="line">    nabla_b = [np.zeros(b.shape) <span class="keyword">for</span> b <span class="keyword">in</span> self.biases]</span><br><span class="line">    nabla_w = [np.zeros(w.shape) <span class="keyword">for</span> w <span class="keyword">in</span> self.weights]</span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> mini_batch:</span><br><span class="line">        <span class="comment"># the backpropagation algorithm,which is a fast way of computing the gradient of the cost function.</span></span><br><span class="line">        delta_nabla_b, delta_nabla_w = self.backprop(x, y) </span><br><span class="line">        nabla_b = [nb+dnb <span class="keyword">for</span> nb, dnb <span class="keyword">in</span> <span class="built_in">zip</span>(nabla_b, delta_nabla_b)]</span><br><span class="line">        nabla_w = [nw+dnw <span class="keyword">for</span> nw, dnw <span class="keyword">in</span> <span class="built_in">zip</span>(nabla_w, delta_nabla_w)]</span><br><span class="line">    self.weights =[w-(eta/<span class="built_in">len</span>(mini_batch))*nw </span><br><span class="line">                    <span class="keyword">for</span> w, nw <span class="keyword">in</span> <span class="built_in">zip</span>(self.weights, nabla_w)]</span><br><span class="line">    self.biases = [b-(eta/<span class="built_in">len</span>(mini_batch))*nb </span><br><span class="line">                   <span class="keyword">for</span> b, nb <span class="keyword">in</span> <span class="built_in">zip</span>(self.biases, nabla_b)]</span><br></pre></td></tr></table></figure>
<p>具体代码可以在github上找到：<a target="_blank" rel="noopener" href="https://github.com/mnielsen/neural-networks-and-deep-learning/blob/master/src/network.py">地址</a> <a target="_blank" rel="noopener" href="https://github.com/MichalDanielDobrzanski/DeepLearningPython35">python3.5版本</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Finished training network.</span><br><span class="line">Best validation accuracy of 98.98% obtained at iteration 234999</span><br><span class="line">Corresponding <span class="built_in">test</span> accuracy of 99.07%</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="如何计算backprogation"><a href="#如何计算backprogation" class="headerlink" title="如何计算backprogation?"></a><strong>如何计算<em>backprogation</em>?</strong></h3><p>​    该算法的核心是快速计算相对于每一个weight w 和每一个bias b的cost function 的偏导数：</p>
<script type="math/tex; mode=display">
\partial C/\partial w</script><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/12/14/XOm8TjJzvhHct2C.png" alt="weight"></p>
<p>先给weights一个标记，如上图所示。</p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/12/14/hAx5IEbPdw7nJLW.png" alt="basis" style="zoom:50%;" /></p>
<p>同时，还有basis的标签。</p>
<p>这样我们就有了输入输出之间的联系：</p>
<script type="math/tex; mode=display">
a_j^l = \sigma(\sum_k w_{jk}^l a_k^{l-1}+b_j^l)</script><p>写成矩阵的形式，或者说爱因斯坦简化形式：</p>
<script type="math/tex; mode=display">
a^l = \sigma(w^l a^{l-1}+b^l)= \sigma(z)</script><p>突然发现，这个$w_{jk}^l$其实就是所谓的三阶张量呀，但这个张量没层数量可能不相同！怪不得叫tensorflow。</p>
<h3 id="对于cost-function的两个假设"><a href="#对于cost-function的两个假设" class="headerlink" title="对于cost function的两个假设"></a><strong>对于cost function的两个假设</strong></h3><ul>
<li><p>the cost function 为单个训练集的平均，即</p>
<script type="math/tex; mode=display">
C={1\over n}\sum_x C_x</script></li>
<li><p>the cost is a function of the outputs a:</p>
</li>
</ul>
<script type="math/tex; mode=display">
cost C = C(a^L(z))</script><p>例如，quadratic cost:</p>
<script type="math/tex; mode=display">
C = {1\over 2}\left\Vert y-d^L\right\Vert    = {1\over 2}\sum_j(y_j -a_j^L)^2</script><p>接着，引入中间变量，<em>error</em> $\delta_j^l$</p>
<script type="math/tex; mode=display">
\delta_j^l = {\partial C \over \partial z_j^l }</script><p>我们将得到四个关于误差的表达式<strong><em>(chain rule)</em></strong>：</p>
<p><strong>An equation for the error in the output layer</strong>, $\delat^L$:</p>
<script type="math/tex; mode=display">
\delta_j^L = \sum_k {\partial C \over \partial a_k^L}{d a_k^L \over dz_j^L}={\partial C \over \partial a_j^L}{d a_j^L \over dz_j^L}</script><p>​    简写为Hadmard product形式：</p>
<script type="math/tex; mode=display">
\delta^L = \nabla_a C \odot \sigma'(z^L)</script><p>   简写为矩阵形式：</p>
<script type="math/tex; mode=display">
\delta^L = \Sigma'(z^L)\nabla_a C\\\\
\Sigma' =diag(\sigma)</script><p>$\sigma’(z_j^L)$无非就是sigma函数的的在$z_j^l$的导数，计算得到$z_j^l$后，在其附近添加一个差值，利用差分非常好求。C是给定的一个形式，例如上面的quadratic cost，那对a求导也非常容易，得:</p>
<script type="math/tex; mode=display">
{\partial C \over \partial a_j^L} = (a_j^L - y_j)</script><p>​    y是标签的值，a是训练的得到的值。</p>
<p><strong>An equation for the error $\delta^l$ in terms of the error in the next layer</strong>, $\delat^{l+1}$:</p>
<script type="math/tex; mode=display">
\delta^l = {\partial C\over \partial z_j^l}\\\\
= \sum_k {\partial C\over \partial z_k^{l+1}}{\partial z_k^{l+1}\over \partial z_j^l} \\\\
= \sum_k {\partial z_k^{k+1}\over \partial z_j^l}\delta_k^{l+1}</script><script type="math/tex; mode=display">
z_k^{l+1} = \sum_j w_{kj}^{l+1}a_j^l + b_k^{l+1} =\sum_j w_{kj}^{l+1}\sigma(z_j^l)+b_k^{l+1}</script><p>Differentiating, we obtain</p>
<script type="math/tex; mode=display">
{\partial z_k^{l+1}\over \partial z_j^l} = w_{kj}^{l+1} {d a_j^l \over dz_j^L}</script><p>Substituting back we obtain:</p>
<script type="math/tex; mode=display">
\delta_j^l = \sum_k w_{kj}^{l+1} \delta_k^{l+1}\sigma'(z_j^l)</script><p>矩阵形式：</p>
<script type="math/tex; mode=display">
\delta^l = \Sigma'(z^l)(w^{l+1})^T \delta^{l+1}</script><p>其中，$(w^{l+1})^T$ is the transpose of the weight matrix $w^{l+1}$ for the $(l+1)^{th}$ layer. 假定我们知道上一$l+1$层的误差$\delta^{l+1}$。When we apply the transpose weight matrix, $(w^{l+1})^T$, we can think intuitively of this as moving the error <em>backward</em> through the network, giving us some sort of meaure of the error at the output of the l layer.</p>
<p>如此，通过计算L层的误差，然后通过迭代就可以倒退回每一层的误差。</p>
<script type="math/tex; mode=display">
\delta^l = \Sigma'(z^l)(w^{l+1})^T ...\Sigma'(z^{L-1})(w^L)^T\Sigma'(z^L)\nabla_a C</script><p>如果将其在RNN上应用，类似于dynamical system里也有类似累积的效果，每一层相当于每一个时间步。误差类比于流动稳定性。流动在某个临界条件会发生不稳定性，往往这个临界点是我们非常关心的。。。。后面如何和chaotic系统结合还有待思考🤔貌似一个是正问题，一个是逆问题。</p>
<ul>
<li>后面MIT的课程上，通过forward propagation dual number 来求解。ODE关联，优化问题。都是梯度下架问题。在ODE问题中，用隐式算法，同样会涉及逆问题。最后，貌似都转化为同一个问题。</li>
</ul>
<p><strong>An equation for the rate of change of the cost with respect to any bias in the network</strong>:</p>
<script type="math/tex; mode=display">
{\partial C\over \partial b_j^l} = \delta_j^l</script><p>通过这个公式，我们就获得了b的偏导数。</p>
<p><strong>An equation for the rate of change of the cost with respect to any weight in the net work</strong>:</p>
<script type="math/tex; mode=display">
{\partial C \over \partial w_{jk}^l} = a_k^{l-1}\delta_j^l</script><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/12/14/24ALMmlORrDUseg.png" alt="24ALMmlORrDUseg" style="zoom:50%;" /></p>
<p>When $a_in$ is small, the gradient terms ${\partial C \over \partial w}$ will also tend to be small, it learns slowly. — <strong>low-activation</strong></p>
<p>Besides, consider the term $\sigma’(z_j^L)$ become very flat when approach to 0 or 1, it also learns slowly. — <strong>saturated</strong></p>
<h3 id="The-backprogation-algorithm"><a href="#The-backprogation-algorithm" class="headerlink" title="The backprogation algorithm"></a><strong>The backprogation algorithm</strong></h3><ol>
<li><p>Input x: Set the corresponding activation $a^1$ for the input layer.</p>
</li>
<li><p>Feedforward: For each l=2,3,…,L compute $z^l = w^l a^{l-1}+b^l$ and $a^l=\sigma(z^l)$.</p>
</li>
<li><p>Output error $\delta^L$: Compute the vector $\delta^L = \nabla_a C \odot \sigma’(z^L).$</p>
</li>
<li><p>Backpropagate the error: For each l = L-1,L-2,…,2 compute </p>
<script type="math/tex; mode=display">
\delta^l = \Sigma'(z^l)(w^{l+1})^T \delta^{l+1}</script></li>
<li><p>Output: The gradient of the cost function is given by</p>
<script type="math/tex; mode=display">
{\partial C\over \partial b_j^l} = \delta_j^l</script><script type="math/tex; mode=display">
{\partial C \over \partial w_{jk}^l} = a_k^{l-1}\delta_j^l</script></li>
</ol>
<h3 id="The-backprogation-algorithm-with-a-set-of-training-examples"><a href="#The-backprogation-algorithm-with-a-set-of-training-examples" class="headerlink" title="The backprogation algorithm with a set of training examples"></a><strong>The backprogation algorithm with a set of training examples</strong></h3><p>​    计算过程不变，只不过最终梯度下架为计算的平均值。</p>
<script type="math/tex; mode=display">
w^l \rightarrow w^l - {\eta\over m} \sum_x \delta^{x,l}(a^{x,l-1})^T\\\\
b^l \rightarrow b^l - {\eta\over m} \sum_x \delta^{x,l}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Network</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_mini_batch</span>(<span class="params">self, mini_batch, eta</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Update the network&#x27;s weights and biases by applying</span></span><br><span class="line"><span class="string">        gradient descent using backpropagation to a single mini batch.</span></span><br><span class="line"><span class="string">        The &quot;mini_batch&quot; is a list of tuples &quot;(x, y)&quot;, and &quot;eta&quot;</span></span><br><span class="line"><span class="string">        is the learning rate.&quot;&quot;&quot;</span></span><br><span class="line">        nabla_b = [np.zeros(b.shape) <span class="keyword">for</span> b <span class="keyword">in</span> self.biases]</span><br><span class="line">        nabla_w = [np.zeros(w.shape) <span class="keyword">for</span> w <span class="keyword">in</span> self.weights]</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> mini_batch:</span><br><span class="line">            delta_nabla_b, delta_nabla_w = self.backprop(x, y)</span><br><span class="line">            nabla_b = [nb+dnb <span class="keyword">for</span> nb, dnb <span class="keyword">in</span> <span class="built_in">zip</span>(nabla_b, delta_nabla_b)]</span><br><span class="line">            nabla_w = [nw+dnw <span class="keyword">for</span> nw, dnw <span class="keyword">in</span> <span class="built_in">zip</span>(nabla_w, delta_nabla_w)]</span><br><span class="line">        self.weights = [w-(eta/<span class="built_in">len</span>(mini_batch))*nw </span><br><span class="line">                        <span class="keyword">for</span> w, nw <span class="keyword">in</span> <span class="built_in">zip</span>(self.weights, nabla_w)]</span><br><span class="line">        self.biases = [b-(eta/<span class="built_in">len</span>(mini_batch))*nb </span><br><span class="line">                       <span class="keyword">for</span> b, nb <span class="keyword">in</span> <span class="built_in">zip</span>(self.biases, nabla_b)]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Network</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">...</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">backprop</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return a tuple &quot;(nabla_b, nabla_w)&quot; representing the</span></span><br><span class="line"><span class="string">        gradient for the cost function C_x.  &quot;nabla_b&quot; and</span></span><br><span class="line"><span class="string">        &quot;nabla_w&quot; are layer-by-layer lists of numpy arrays, similar</span></span><br><span class="line"><span class="string">        to &quot;self.biases&quot; and &quot;self.weights&quot;.&quot;&quot;&quot;</span></span><br><span class="line">        nabla_b = [np.zeros(b.shape) <span class="keyword">for</span> b <span class="keyword">in</span> self.biases]</span><br><span class="line">        nabla_w = [np.zeros(w.shape) <span class="keyword">for</span> w <span class="keyword">in</span> self.weights]</span><br><span class="line">        <span class="comment"># feedforward</span></span><br><span class="line">        activation = x</span><br><span class="line">        activations = [x] <span class="comment"># list to store all the activations, layer by layer</span></span><br><span class="line">        zs = [] <span class="comment"># list to store all the z vectors, layer by layer</span></span><br><span class="line">        <span class="keyword">for</span> b, w <span class="keyword">in</span> <span class="built_in">zip</span>(self.biases, self.weights):</span><br><span class="line">            z = np.dot(w, activation)+b</span><br><span class="line">            zs.append(z)</span><br><span class="line">            activation = sigmoid(z)</span><br><span class="line">            activations.append(activation)</span><br><span class="line">        <span class="comment"># backward pass</span></span><br><span class="line">        delta = self.cost_derivative(activations[-<span class="number">1</span>], y) * \</span><br><span class="line">            sigmoid_prime(zs[-<span class="number">1</span>])</span><br><span class="line">        nabla_b[-<span class="number">1</span>] = delta</span><br><span class="line">        nabla_w[-<span class="number">1</span>] = np.dot(delta, activations[-<span class="number">2</span>].transpose())</span><br><span class="line">        <span class="comment"># Note that the variable l in the loop below is used a little</span></span><br><span class="line">        <span class="comment"># differently to the notation in Chapter 2 of the book.  Here,</span></span><br><span class="line">        <span class="comment"># l = 1 means the last layer of neurons, l = 2 is the</span></span><br><span class="line">        <span class="comment"># second-last layer, and so on.  It&#x27;s a renumbering of the</span></span><br><span class="line">        <span class="comment"># scheme in the book, used here to take advantage of the fact</span></span><br><span class="line">        <span class="comment"># that Python can use negative indices in lists.</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> xrange(<span class="number">2</span>, self.num_layers):</span><br><span class="line">            z = zs[-l]</span><br><span class="line">            sp = sigmoid_prime(z)</span><br><span class="line">            delta = np.dot(self.weights[-l+<span class="number">1</span>].transpose(), delta) * sp</span><br><span class="line">            nabla_b[-l] = delta</span><br><span class="line">            nabla_w[-l] = np.dot(delta, activations[-l-<span class="number">1</span>].transpose())</span><br><span class="line">        <span class="keyword">return</span> (nabla_b, nabla_w)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cost_derivative</span>(<span class="params">self, output_activations, y</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return the vector of partial derivatives \partial C_x /</span></span><br><span class="line"><span class="string">        \partial a for the output activations.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> (output_activations-y) </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span>(<span class="params">z</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;The sigmoid function.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span>/(<span class="number">1.0</span>+np.exp(-z))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid_prime</span>(<span class="params">z</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Derivative of the sigmoid function.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> sigmoid(z)*(<span class="number">1</span>-sigmoid(z))</span><br></pre></td></tr></table></figure>
<p>learning rate is low, means that the partial derivatives of the cost function, $\partial C/\partial w$ and $\partial C / \partial b$ is small.</p>
<h3 id="Better-choice-of-cost-function-the-cross-entropy"><a href="#Better-choice-of-cost-function-the-cross-entropy" class="headerlink" title="Better choice of cost function: the cross-entropy"></a><strong>Better choice of cost function: the cross-entropy</strong></h3><script type="math/tex; mode=display">
C = -{1\over n} \sum_x\sum_y [y_j ln a_j^L +(1-y_j)ln(1-a_j^L)]</script><p>对单个输入的神经网络来说，</p>
<script type="math/tex; mode=display">
C = - [ylna +(1-y)ln(1-a)]+const</script><script type="math/tex; mode=display">
{\partial C\over \partial w_j} = x_j (a-y)\\\\
{\partial C\over \partial b} = (a-y)</script><p>则带来的好处是：</p>
<p>训练误差越大，则学习速度越快！</p>
<h3 id="“Regularization”-methods-L1-and-L2-regularization-dropout-and-artificial-expansion-of-the-traning-data"><a href="#“Regularization”-methods-L1-and-L2-regularization-dropout-and-artificial-expansion-of-the-traning-data" class="headerlink" title="“Regularization” methods (L1 and L2 regularization, dropout, and artificial expansion of the traning data)"></a><strong>“Regularization” methods (L1 and L2 regularization, dropout, and artificial expansion of the traning data)</strong></h3><p>过拟合问题。</p>
<p><strong>regularized cross-entropy</strong></p>
<script type="math/tex; mode=display">
C = -{1\over n} \sum_x\sum_y [y_j ln a_j^L +(1-y_j)ln(1-a_j^L)] + {\lambda \over 2n}\sum_w w^2</script><script type="math/tex; mode=display">
{\partial C\over \partial w}= {\partial C_0 \over \partial w}+{\lambda \over n} w\\\\
{\partial C\over \partial b}= {\partial C_0\over \partial b}</script><p>The effect of regularization is to make it so the network prefers to learn small weights, all other things being equal. <strong>Regularization can be viewed as a way of compromising between finding small weights and minimizing the original cost function.</strong></p>
<script type="math/tex; mode=display">
w \rightarrow (1-{\eta \lambda\over n})w -{\eta\over m}\sum_x {\partial C_x \over \partial w}</script><script type="math/tex; mode=display">
b \rightarrow b - {\eta \over m} \sum_x {\partial C_x \over \partial b}</script><p><strong>L1 regularization</strong></p>
<script type="math/tex; mode=display">
C = C_0 + {\lambda \over n} \sum_w |w|\\\\
{\partial C\over \partial w}= {\partial C_0\over \partial w}+{\lambda \over n} sgn(w)</script><script type="math/tex; mode=display">
w \rightarrow w' = w-{\eta \lambda \over n}sgn(w)-\eta{\partial C_0 \over \partial w}</script><p>相比L2 regularization, </p>
<script type="math/tex; mode=display">
w \rightarrow w' = w - {\eta \lambda\over n} w - \eta {\partial C_0\over \partial w}</script><p>In both expressions, the effect of regularization is to shrink the weights. This accords with our intuition that both kinds of regularization penalize large weights(罚函数)。In L1 regularization, the weights shrink by a constant amount toward 0. In L2 regularization, the weights shrink by an amount which is proportion to w. And so when a particular weight has a large magnitude, |w|, L1 regularization shrinks the weight much less than L2 regularization does. By contrast, when |w| is small, L1 regularization shrinks the weight much more than L2 regularization. z最终</p>
<p>在这两个表达式中，正则化的效果都是缩小权重。这符合我们的直觉，即两种正则化都会惩罚较大的权重。但是权重缩减的方式是不同的。在L1正则化中，权重保持不变。在L2正则化中，权重与w成比例。因此，当|w|较大时，L1正则化比L2正则化缩小的慢。相比之下，当|w|较小，L1正则化比L2正则化压缩权重更多。最终结果是，L1正则化倾向于将网络的权重集中在相对少量的高重要性连接中，而其他权重则趋向于零。</p>
<p><strong>Dropout</strong></p>
<p>modify the network itself.</p>
<p><strong>改进代码执行：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;network2.py</span></span><br><span class="line"><span class="string">~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">An improved version of network.py, implementing the stochastic</span></span><br><span class="line"><span class="string">gradient descent learning algorithm for a feedforward neural network.</span></span><br><span class="line"><span class="string">Improvements include the addition of the cross-entropy cost function,</span></span><br><span class="line"><span class="string">regularization, and better initialization of network weights.  Note</span></span><br><span class="line"><span class="string">that I have focused on making the code simple, easily readable, and</span></span><br><span class="line"><span class="string">easily modifiable.  It is not optimized, and omits many desirable</span></span><br><span class="line"><span class="string">features.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### Libraries</span></span><br><span class="line"><span class="comment"># Standard library</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Third-party libraries</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#### Define the quadratic and cross-entropy cost functions</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuadraticCost</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod </span><span class="comment"># just as ordinary but now pass self</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fn</span>(<span class="params">a, y</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return the cost associated with an output ``a`` and desired output</span></span><br><span class="line"><span class="string">        ``y``.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span>*np.linalg.norm(a-y)**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delta</span>(<span class="params">z, a, y</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return the error delta from the output layer.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> (a-y) * sigmoid_prime(z)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrossEntropyCost</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fn</span>(<span class="params">a, y</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return the cost associated with an output ``a`` and desired output</span></span><br><span class="line"><span class="string">        ``y``.  Note that np.nan_to_num is used to ensure numerical</span></span><br><span class="line"><span class="string">        stability.  In particular, if both ``a`` and ``y`` have a 1.0</span></span><br><span class="line"><span class="string">        in the same slot, then the expression (1-y)*np.log(1-a)</span></span><br><span class="line"><span class="string">        returns nan.  The np.nan_to_num ensures that that is converted</span></span><br><span class="line"><span class="string">        to the correct value (0.0).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> np.<span class="built_in">sum</span>(np.nan_to_num(-y*np.log(a)-(<span class="number">1</span>-y)*np.log(<span class="number">1</span>-a)))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delta</span>(<span class="params">z, a, y</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return the error delta from the output layer.  Note that the</span></span><br><span class="line"><span class="string">        parameter ``z`` is not used by the method.  It is included in</span></span><br><span class="line"><span class="string">        the method&#x27;s parameters in order to make the interface</span></span><br><span class="line"><span class="string">        consistent with the delta method for other cost classes.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> (a-y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#### Main Network class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Network</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, sizes, cost=CrossEntropyCost</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;The list ``sizes`` contains the number of neurons in the respective</span></span><br><span class="line"><span class="string">        layers of the network.  For example, if the list was [2, 3, 1]</span></span><br><span class="line"><span class="string">        then it would be a three-layer network, with the first layer</span></span><br><span class="line"><span class="string">        containing 2 neurons, the second layer 3 neurons, and the</span></span><br><span class="line"><span class="string">        third layer 1 neuron.  The biases and weights for the network</span></span><br><span class="line"><span class="string">        are initialized randomly, using</span></span><br><span class="line"><span class="string">        ``self.default_weight_initializer`` (see docstring for that</span></span><br><span class="line"><span class="string">        method).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.num_layers = <span class="built_in">len</span>(sizes)</span><br><span class="line">        self.sizes = sizes</span><br><span class="line">        self.default_weight_initializer()</span><br><span class="line">        self.cost=cost</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">default_weight_initializer</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Initialize each weight using a Gaussian distribution with mean 0</span></span><br><span class="line"><span class="string">        and standard deviation 1 over the square root of the number of</span></span><br><span class="line"><span class="string">        weights connecting to the same neuron.  Initialize the biases</span></span><br><span class="line"><span class="string">        using a Gaussian distribution with mean 0 and standard</span></span><br><span class="line"><span class="string">        deviation 1.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Note that the first layer is assumed to be an input layer, and</span></span><br><span class="line"><span class="string">        by convention we won&#x27;t set any biases for those neurons, since</span></span><br><span class="line"><span class="string">        biases are only ever used in computing the outputs from later</span></span><br><span class="line"><span class="string">        layers.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.biases = [np.random.randn(y, <span class="number">1</span>) <span class="keyword">for</span> y <span class="keyword">in</span> self.sizes[<span class="number">1</span>:]]</span><br><span class="line">        self.weights = [np.random.randn(y, x)/np.sqrt(x)</span><br><span class="line">                        <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(self.sizes[:-<span class="number">1</span>], self.sizes[<span class="number">1</span>:])]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">large_weight_initializer</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Initialize the weights using a Gaussian distribution with mean 0</span></span><br><span class="line"><span class="string">        and standard deviation 1.  Initialize the biases using a</span></span><br><span class="line"><span class="string">        Gaussian distribution with mean 0 and standard deviation 1.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Note that the first layer is assumed to be an input layer, and</span></span><br><span class="line"><span class="string">        by convention we won&#x27;t set any biases for those neurons, since</span></span><br><span class="line"><span class="string">        biases are only ever used in computing the outputs from later</span></span><br><span class="line"><span class="string">        layers.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This weight and bias initializer uses the same approach as in</span></span><br><span class="line"><span class="string">        Chapter 1, and is included for purposes of comparison.  It</span></span><br><span class="line"><span class="string">        will usually be better to use the default weight initializer</span></span><br><span class="line"><span class="string">        instead.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.biases = [np.random.randn(y, <span class="number">1</span>) <span class="keyword">for</span> y <span class="keyword">in</span> self.sizes[<span class="number">1</span>:]]</span><br><span class="line">        self.weights = [np.random.randn(y, x)</span><br><span class="line">                        <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(self.sizes[:-<span class="number">1</span>], self.sizes[<span class="number">1</span>:])]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">feedforward</span>(<span class="params">self, a</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return the output of the network if ``a`` is input.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> b, w <span class="keyword">in</span> <span class="built_in">zip</span>(self.biases, self.weights):</span><br><span class="line">            a = sigmoid(np.dot(w, a)+b)</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">SGD</span>(<span class="params">self, training_data, epochs, mini_batch_size, eta,</span></span></span><br><span class="line"><span class="function"><span class="params">            lmbda = <span class="number">0.0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            evaluation_data=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            monitor_evaluation_cost=<span class="literal">False</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            monitor_evaluation_accuracy=<span class="literal">False</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            monitor_training_cost=<span class="literal">False</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            monitor_training_accuracy=<span class="literal">False</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Train the neural network using mini-batch stochastic gradient</span></span><br><span class="line"><span class="string">        descent.  The ``training_data`` is a list of tuples ``(x, y)``</span></span><br><span class="line"><span class="string">        representing the training inputs and the desired outputs.  The</span></span><br><span class="line"><span class="string">        other non-optional parameters are self-explanatory, as is the</span></span><br><span class="line"><span class="string">        regularization parameter ``lmbda``.  The method also accepts</span></span><br><span class="line"><span class="string">        ``evaluation_data``, usually either the validation or test</span></span><br><span class="line"><span class="string">        data.  We can monitor the cost and accuracy on either the</span></span><br><span class="line"><span class="string">        evaluation data or the training data, by setting the</span></span><br><span class="line"><span class="string">        appropriate flags.  The method returns a tuple containing four</span></span><br><span class="line"><span class="string">        lists: the (per-epoch) costs on the evaluation data, the</span></span><br><span class="line"><span class="string">        accuracies on the evaluation data, the costs on the training</span></span><br><span class="line"><span class="string">        data, and the accuracies on the training data.  All values are</span></span><br><span class="line"><span class="string">        evaluated at the end of each training epoch.  So, for example,</span></span><br><span class="line"><span class="string">        if we train for 30 epochs, then the first element of the tuple</span></span><br><span class="line"><span class="string">        will be a 30-element list containing the cost on the</span></span><br><span class="line"><span class="string">        evaluation data at the end of each epoch. Note that the lists</span></span><br><span class="line"><span class="string">        are empty if the corresponding flag is not set.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> evaluation_data: n_data = <span class="built_in">len</span>(evaluation_data)</span><br><span class="line">        n = <span class="built_in">len</span>(training_data)</span><br><span class="line">        evaluation_cost, evaluation_accuracy = [], []</span><br><span class="line">        training_cost, training_accuracy = [], []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(epochs):</span><br><span class="line">            random.shuffle(training_data)</span><br><span class="line">            mini_batches = [</span><br><span class="line">                training_data[k:k+mini_batch_size]</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> xrange(<span class="number">0</span>, n, mini_batch_size)]</span><br><span class="line">            <span class="keyword">for</span> mini_batch <span class="keyword">in</span> mini_batches:</span><br><span class="line">                self.update_mini_batch(</span><br><span class="line">                    mini_batch, eta, lmbda, <span class="built_in">len</span>(training_data))</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&quot;Epoch %s training complete&quot;</span> % j</span><br><span class="line">            <span class="keyword">if</span> monitor_training_cost:</span><br><span class="line">                cost = self.total_cost(training_data, lmbda)</span><br><span class="line">                training_cost.append(cost)</span><br><span class="line">                <span class="built_in">print</span> <span class="string">&quot;Cost on training data: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(cost)</span><br><span class="line">            <span class="keyword">if</span> monitor_training_accuracy:</span><br><span class="line">                accuracy = self.accuracy(training_data, convert=<span class="literal">True</span>)</span><br><span class="line">                training_accuracy.append(accuracy)</span><br><span class="line">                <span class="built_in">print</span> <span class="string">&quot;Accuracy on training data: &#123;&#125; / &#123;&#125;&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">                    accuracy, n)</span><br><span class="line">            <span class="keyword">if</span> monitor_evaluation_cost:</span><br><span class="line">                cost = self.total_cost(evaluation_data, lmbda, convert=<span class="literal">True</span>)</span><br><span class="line">                evaluation_cost.append(cost)</span><br><span class="line">                <span class="built_in">print</span> <span class="string">&quot;Cost on evaluation data: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(cost)</span><br><span class="line">            <span class="keyword">if</span> monitor_evaluation_accuracy:</span><br><span class="line">                accuracy = self.accuracy(evaluation_data)</span><br><span class="line">                evaluation_accuracy.append(accuracy)</span><br><span class="line">                <span class="built_in">print</span> <span class="string">&quot;Accuracy on evaluation data: &#123;&#125; / &#123;&#125;&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">                    self.accuracy(evaluation_data), n_data)</span><br><span class="line">            <span class="built_in">print</span></span><br><span class="line">        <span class="keyword">return</span> evaluation_cost, evaluation_accuracy, \</span><br><span class="line">            training_cost, training_accuracy</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_mini_batch</span>(<span class="params">self, mini_batch, eta, lmbda, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Update the network&#x27;s weights and biases by applying gradient</span></span><br><span class="line"><span class="string">        descent using backpropagation to a single mini batch.  The</span></span><br><span class="line"><span class="string">        ``mini_batch`` is a list of tuples ``(x, y)``, ``eta`` is the</span></span><br><span class="line"><span class="string">        learning rate, ``lmbda`` is the regularization parameter, and</span></span><br><span class="line"><span class="string">        ``n`` is the total size of the training data set.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nabla_b = [np.zeros(b.shape) <span class="keyword">for</span> b <span class="keyword">in</span> self.biases]</span><br><span class="line">        nabla_w = [np.zeros(w.shape) <span class="keyword">for</span> w <span class="keyword">in</span> self.weights]</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> mini_batch:</span><br><span class="line">            delta_nabla_b, delta_nabla_w = self.backprop(x, y)</span><br><span class="line">            nabla_b = [nb+dnb <span class="keyword">for</span> nb, dnb <span class="keyword">in</span> <span class="built_in">zip</span>(nabla_b, delta_nabla_b)]</span><br><span class="line">            nabla_w = [nw+dnw <span class="keyword">for</span> nw, dnw <span class="keyword">in</span> <span class="built_in">zip</span>(nabla_w, delta_nabla_w)]</span><br><span class="line">        self.weights = [(<span class="number">1</span>-eta*(lmbda/n))*w-(eta/<span class="built_in">len</span>(mini_batch))*nw <span class="comment">#L2</span></span><br><span class="line">                        <span class="keyword">for</span> w, nw <span class="keyword">in</span> <span class="built_in">zip</span>(self.weights, nabla_w)]</span><br><span class="line">        self.biases = [b-(eta/<span class="built_in">len</span>(mini_batch))*nb</span><br><span class="line">                       <span class="keyword">for</span> b, nb <span class="keyword">in</span> <span class="built_in">zip</span>(self.biases, nabla_b)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backprop</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return a tuple ``(nabla_b, nabla_w)`` representing the</span></span><br><span class="line"><span class="string">        gradient for the cost function C_x.  ``nabla_b`` and</span></span><br><span class="line"><span class="string">        ``nabla_w`` are layer-by-layer lists of numpy arrays, similar</span></span><br><span class="line"><span class="string">        to ``self.biases`` and ``self.weights``.&quot;&quot;&quot;</span></span><br><span class="line">        nabla_b = [np.zeros(b.shape) <span class="keyword">for</span> b <span class="keyword">in</span> self.biases]</span><br><span class="line">        nabla_w = [np.zeros(w.shape) <span class="keyword">for</span> w <span class="keyword">in</span> self.weights]</span><br><span class="line">        <span class="comment"># feedforward</span></span><br><span class="line">        activation = x</span><br><span class="line">        activations = [x] <span class="comment"># list to store all the activations, layer by layer</span></span><br><span class="line">        zs = [] <span class="comment"># list to store all the z vectors, layer by layer</span></span><br><span class="line">        <span class="keyword">for</span> b, w <span class="keyword">in</span> <span class="built_in">zip</span>(self.biases, self.weights):</span><br><span class="line">            z = np.dot(w, activation)+b</span><br><span class="line">            zs.append(z)</span><br><span class="line">            activation = sigmoid(z)</span><br><span class="line">            activations.append(activation)</span><br><span class="line">        <span class="comment"># backward pass</span></span><br><span class="line">        delta = (self.cost).delta(zs[-<span class="number">1</span>], activations[-<span class="number">1</span>], y)</span><br><span class="line">        nabla_b[-<span class="number">1</span>] = delta</span><br><span class="line">        nabla_w[-<span class="number">1</span>] = np.dot(delta, activations[-<span class="number">2</span>].transpose())</span><br><span class="line">        <span class="comment"># Note that the variable l in the loop below is used a little</span></span><br><span class="line">        <span class="comment"># differently to the notation in Chapter 2 of the book.  Here,</span></span><br><span class="line">        <span class="comment"># l = 1 means the last layer of neurons, l = 2 is the</span></span><br><span class="line">        <span class="comment"># second-last layer, and so on.  It&#x27;s a renumbering of the</span></span><br><span class="line">        <span class="comment"># scheme in the book, used here to take advantage of the fact</span></span><br><span class="line">        <span class="comment"># that Python can use negative indices in lists.</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> xrange(<span class="number">2</span>, self.num_layers):</span><br><span class="line">            z = zs[-l]</span><br><span class="line">            sp = sigmoid_prime(z)</span><br><span class="line">            delta = np.dot(self.weights[-l+<span class="number">1</span>].transpose(), delta) * sp</span><br><span class="line">            nabla_b[-l] = delta</span><br><span class="line">            nabla_w[-l] = np.dot(delta, activations[-l-<span class="number">1</span>].transpose())</span><br><span class="line">        <span class="keyword">return</span> (nabla_b, nabla_w)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accuracy</span>(<span class="params">self, data, convert=<span class="literal">False</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return the number of inputs in ``data`` for which the neural</span></span><br><span class="line"><span class="string">        network outputs the correct result. The neural network&#x27;s</span></span><br><span class="line"><span class="string">        output is assumed to be the index of whichever neuron in the</span></span><br><span class="line"><span class="string">        final layer has the highest activation.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        The flag ``convert`` should be set to False if the data set is</span></span><br><span class="line"><span class="string">        validation or test data (the usual case), and to True if the</span></span><br><span class="line"><span class="string">        data set is the training data. The need for this flag arises</span></span><br><span class="line"><span class="string">        due to differences in the way the results ``y`` are</span></span><br><span class="line"><span class="string">        represented in the different data sets.  In particular, it</span></span><br><span class="line"><span class="string">        flags whether we need to convert between the different</span></span><br><span class="line"><span class="string">        representations.  It may seem strange to use different</span></span><br><span class="line"><span class="string">        representations for the different data sets.  Why not use the</span></span><br><span class="line"><span class="string">        same representation for all three data sets?  It&#x27;s done for</span></span><br><span class="line"><span class="string">        efficiency reasons -- the program usually evaluates the cost</span></span><br><span class="line"><span class="string">        on the training data and the accuracy on other data sets.</span></span><br><span class="line"><span class="string">        These are different types of computations, and using different</span></span><br><span class="line"><span class="string">        representations speeds things up.  More details on the</span></span><br><span class="line"><span class="string">        representations can be found in</span></span><br><span class="line"><span class="string">        mnist_loader.load_data_wrapper.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> convert:</span><br><span class="line">            results = [(np.argmax(self.feedforward(x)), np.argmax(y))</span><br><span class="line">                       <span class="keyword">for</span> (x, y) <span class="keyword">in</span> data]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            results = [(np.argmax(self.feedforward(x)), y)</span><br><span class="line">                        <span class="keyword">for</span> (x, y) <span class="keyword">in</span> data]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(<span class="built_in">int</span>(x == y) <span class="keyword">for</span> (x, y) <span class="keyword">in</span> results)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total_cost</span>(<span class="params">self, data, lmbda, convert=<span class="literal">False</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return the total cost for the data set ``data``.  The flag</span></span><br><span class="line"><span class="string">        ``convert`` should be set to False if the data set is the</span></span><br><span class="line"><span class="string">        training data (the usual case), and to True if the data set is</span></span><br><span class="line"><span class="string">        the validation or test data.  See comments on the similar (but</span></span><br><span class="line"><span class="string">        reversed) convention for the ``accuracy`` method, above.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cost = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> data:</span><br><span class="line">            a = self.feedforward(x)</span><br><span class="line">            <span class="keyword">if</span> convert: y = vectorized_result(y)</span><br><span class="line">            cost += self.cost.fn(a, y)/<span class="built_in">len</span>(data)</span><br><span class="line">        cost += <span class="number">0.5</span>*(lmbda/<span class="built_in">len</span>(data))*<span class="built_in">sum</span>(</span><br><span class="line">            np.linalg.norm(w)**<span class="number">2</span> <span class="keyword">for</span> w <span class="keyword">in</span> self.weights)</span><br><span class="line">        <span class="keyword">return</span> cost</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span>(<span class="params">self, filename</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Save the neural network to the file ``filename``.&quot;&quot;&quot;</span></span><br><span class="line">        data = &#123;<span class="string">&quot;sizes&quot;</span>: self.sizes,</span><br><span class="line">                <span class="string">&quot;weights&quot;</span>: [w.tolist() <span class="keyword">for</span> w <span class="keyword">in</span> self.weights],</span><br><span class="line">                <span class="string">&quot;biases&quot;</span>: [b.tolist() <span class="keyword">for</span> b <span class="keyword">in</span> self.biases],</span><br><span class="line">                <span class="string">&quot;cost&quot;</span>: <span class="built_in">str</span>(self.cost.__name__)&#125;</span><br><span class="line">        f = <span class="built_in">open</span>(filename, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">        json.dump(data, f)</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">#### Loading a Network</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load</span>(<span class="params">filename</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Load a neural network from the file ``filename``.  Returns an</span></span><br><span class="line"><span class="string">    instance of Network.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    f = <span class="built_in">open</span>(filename, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">    data = json.load(f)</span><br><span class="line">    f.close()</span><br><span class="line">    cost = <span class="built_in">getattr</span>(sys.modules[__name__], data[<span class="string">&quot;cost&quot;</span>])</span><br><span class="line">    net = Network(data[<span class="string">&quot;sizes&quot;</span>], cost=cost)</span><br><span class="line">    net.weights = [np.array(w) <span class="keyword">for</span> w <span class="keyword">in</span> data[<span class="string">&quot;weights&quot;</span>]]</span><br><span class="line">    net.biases = [np.array(b) <span class="keyword">for</span> b <span class="keyword">in</span> data[<span class="string">&quot;biases&quot;</span>]]</span><br><span class="line">    <span class="keyword">return</span> net</span><br><span class="line"></span><br><span class="line"><span class="comment">#### Miscellaneous functions</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vectorized_result</span>(<span class="params">j</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return a 10-dimensional unit vector with a 1.0 in the j&#x27;th position</span></span><br><span class="line"><span class="string">    and zeroes elsewhere.  This is used to convert a digit (0...9)</span></span><br><span class="line"><span class="string">    into a corresponding desired output from the neural network.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    e = np.zeros((<span class="number">10</span>, <span class="number">1</span>))</span><br><span class="line">    e[j] = <span class="number">1.0</span></span><br><span class="line">    <span class="keyword">return</span> e</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span>(<span class="params">z</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;The sigmoid function.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span>/(<span class="number">1.0</span>+np.exp(-z))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid_prime</span>(<span class="params">z</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Derivative of the sigmoid function.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> sigmoid(z)*(<span class="number">1</span>-sigmoid(z))</span><br></pre></td></tr></table></figure>
<p><strong>Tensorflow 执行代码：</strong><a target="_blank" rel="noopener" href="https://www.udemy.com/course/deep-learning-recurrent-neural-networks-in-python/learn/lecture/21514820#content">参考</a></p>
<p>Classfication:</p>
<p><a target="_blank" rel="noopener" href="https://colab.research.google.com/drive/1M_otG1koa2qwix4-ScwZUzF_NB9rg4vD?usp=sharing">https://colab.research.google.com/drive/1M_otG1koa2qwix4-ScwZUzF_NB9rg4vD?usp=sharing</a></p>
<p>Regression:</p>
<p><a target="_blank" rel="noopener" href="https://colab.research.google.com/drive/1k-sj3NP0YNoaIXVNdaXF9WtyY9sMqosR#scrollTo=x5BY2x58MBrt">https://colab.research.google.com/drive/1k-sj3NP0YNoaIXVNdaXF9WtyY9sMqosR#scrollTo=x5BY2x58MBrt</a></p>
<h3 id="Aritificial-Neural-Networks-ANNS"><a href="#Aritificial-Neural-Networks-ANNS" class="headerlink" title="Aritificial Neural Networks(ANNS)"></a>Aritificial Neural Networks(ANNS)</h3><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/12/13/KPc9zZ4hNn3CMta.png" alt="https://i.loli.net/2020/12/13/KPc9zZ4hNn3CMta.png"></p>
<p><strong>Feedforward neural networks</strong></p>
<p>the signal just goes from left to right, we call it a “feedforward” neural network </p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/12/13/JOzT1kxHw9KvEQy.png" alt="https://i.loli.net/2020/12/13/JOzT1kxHw9KvEQy.png"></p>
<p>Different neural will find different features with inputs</p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/12/13/zKkhGtpC2fgbrvU.png" alt="https://i.loli.net/2020/12/13/zKkhGtpC2fgbrvU.png"></p>
<ul>
<li>a line : ax+b</li>
<li>a neuron: $\sigma(w^T x+b)$</li>
<li>Multiple Neurons per Layer:</li>
</ul>
<p>$z_j = \sigma(w_j^T x+ b_j),for  \space j=1…M$</p>
<p>Vectorize the neuron:</p>
<p>$Z=\sigma(W^T x +b)$</p>
<p>这一个单元：将M个特征的信息通过DxM的矩阵W转化到D个特征，然后非常类似于着色器里的sigma函数操作。整个过程一气呵成，GPU的作用可见一斑。</p>
<p><strong>Each neural network layer is a “feature transform”</strong></p>
<p>这种转化在neural network一层一层的迭代：</p>
<p>$z^{(1)} = \sigma(W^{(1)T}x + b^{(1)})\\$$z^{(2)}=\sigma(W^{2}T)z^{(1)}+b^{(2)})$</p>
<p>$z^{(3)}=\sigma(W^{(3)T}z^{(2)}+b^{3})$</p>
<p>…</p>
<p>$p(y=1|x)=\sigma(W^{(L)T}z^{(L-1)}+b^{(L)})$</p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/12/13/k1sSbpq6CTvflh2.png" alt="https://i.loli.net/2020/12/13/k1sSbpq6CTvflh2.png"></p>
<p><strong>The Geometric Picture</strong></p>
<ul>
<li>The neuron is nice and interpretable<ul>
<li>Large weights = important feature</li>
<li>Small weights = not import feature</li>
</ul>
</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/12/13/ke3L6GMTpzJC5o7.png" alt="https://i.loli.net/2020/12/13/ke3L6GMTpzJC5o7.png"></p>
<p>$\hat{y} = ax^2 + bx + c, \\ Let: x_1 =x, x_2= x^2\\ Then: \hat{y} = w_1 x_1 + w_2 x_2 +b$</p>
<p>It’s nonlinear because of the <strong>sigmoid</strong></p>
<p>$W^{(2)T} \sigma(W^{(1)T}x+b^{(1)})+b^{(2)}$</p>
<p><strong>Convolutional Neural Networks (CNNs)</strong></p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/12/15/sHe25ZzqSg4FtI1.png" alt="sHe25ZzqSg4FtI1"></p>
<script type="math/tex; mode=display">
\sigma(b+\sum_{l=0}^4\sum_{m=0}^4 w_{l,m}a_{j+l,k+m})</script><p>更适合图像。</p>
<p><strong>Recurrent Neural Networks(RNNs)</strong>- for sequence</p>
<p>a later neuron may connect back to an earlier neuron to created a recurrent connection</p>
<p><strong><em><a target="_blank" rel="noopener" href="https://vinodsblog.com/2019/01/07/deep-learning-introduction-to-recurrent-neural-networks/">Recurrent Neural Networks：</a></em></strong></p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/12/15/bs2FvGAeqjaTSch.png" alt="bs2FvGAeqjaTSch"></p>
<script type="math/tex; mode=display">
h_t = \sigma(W_{xh}^T x_t + W_{hh}^T h_{t-1}+b_h)\\\\
\hat{y}_t = \sigma(W_o^T h_t + b_o)</script><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/12/15/zkrQYxSlXnGqf8m.png" alt="zkrQYxSlXnGqf8m"></p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/12/15/VK1gY5P6dJcBWHN.png" alt="VK1gY5P6dJcBWHN"></p>
<p>A recurrent neural network is a class of artificial neural networks where connections between nodes form a directed graph along a temporal sequence. This allows it to exhibit temporal dynamic behavior. Derived from feedforward neural networks, RNNs can use their internal state to process variable length sequences of inputs. This makes them applicable to tasks such as unsegmented, connected handwriting recognition or speech recognition.</p>
<p>The main use of RNNs are when using google or Facebook these interfaces are able to predict the next word that you are about to type. RNNs have loops to allow information to persist. This reduces the complexity of parameters, unlike other neural networks. These neural nets are considered to be fairly good for modeling sequence data. RNNs keep track of a hidden state, that encodes information about the history of the system dynamics.</p>
<p>RNNs have the potential to overcome these scalability problems and be applied to high-dimensional spatio-temporal dynamics.</p>
<p>Recurrent neural networks are a linear architectural variant of recursive networks. They have a “memory” thus it differs from other neural networks. This memory remembers all the information about, what has been calculated in the previous state. It uses the same parameters for each input as it performs the same task on all the inputs or hidden layers to produce the output.</p>
<p>One of the biggest uniqueness RNNs have is “UAP- Universal Approximation Property” thus they can approximate virtually any dynamical system. This unique property forces us to say recurrent neural networks have something magical about them.</p>
<p>RNNs model has been proven to perform extremely well on temporal data. It has several variants including <strong>LSTMs</strong> (long short-term memory), <strong>GRUs</strong> (gated recurrent unit) and <strong>Bidirectional RNNs.</strong> Building models for natural language, audio files, and other sequence data got a lot easier with sequence algorithms.</p>
<p><a target="_blank" rel="noopener" href="https://www.programmersought.com/article/93865613569/"><strong>Vanishing and Exploding Gradient Problem</strong>-limited</a></p>
<p>This problem sent the major set back for RNNs to get popularity. Values in RNNs can explode or vanish due to a simple reason for remembering previous values. Previous values are good enough to confuse them and cause current values to keep increasing or decreasing &amp; take-over algorithm. Indefinite loops get formed that brings whole network halt.</p>
<p>For example, neurons might get stuck in the loop where it keeps multiplying the previous number to new number which can go to infinity if all numbers are more than one or get stuck at zero if any number is zero.</p>
<p><strong>If the weight is small, multiply it all the time, it will become small. Otherwise it will become very large.</strong>这样深度神经网络的训练也会失效。从深度网络的角度来讲，不同的层学习的速度差异很大，表现为网络中靠近输出的层学习的情况很好，靠近输入的层学习的很慢，有时甚至训练了很久，前几层的权值和刚开始随机初始化的值差不多。因此，梯度消失、爆炸，其根本原因在于反向传播训练法则backpropagation (BPTT)**，属于先天不足。</p>
<h3 id="Reasons-for-the-disappearance-of-the-gradient"><a href="#Reasons-for-the-disappearance-of-the-gradient" class="headerlink" title="Reasons for the disappearance of the gradient:"></a>Reasons for the disappearance of the gradient:</h3><ol>
<li>Neural network</li>
<li>The initialization weight is too small</li>
<li>Activation function sigmoid (Relu)</li>
</ol>
<h3 id="Reasons-for-gradient-explosion"><a href="#Reasons-for-gradient-explosion" class="headerlink" title="Reasons for gradient explosion:"></a>Reasons for gradient explosion:</h3><ol>
<li>Neural network</li>
<li>The initialization weight is too large</li>
</ol>
<h3 id="How-to-solve-it"><a href="#How-to-solve-it" class="headerlink" title="How to solve it?"></a>How to solve it?</h3><ol>
<li>Pre-training + fine-tuning</li>
</ol>
<p>其基本思想是每次训练一层隐节点，训练时将上一层隐节点的输出作为输入，而本层隐节点的输出作为下一层隐节点的 输入，此过程就是逐层“预训练”；在训练完成后，再对整个网络进行“微调”</p>
<ol>
<li>Gradient shear, regular</li>
</ol>
<p>梯度剪切这种方案主要是针对梯度爆炸问题，其思想是设置一个梯度阀值。</p>
<ol>
<li><strong>Long Short-Term Memory</strong> (LSTM)</li>
</ol>
<p>LSTMs employ gates that effectively <strong>remember</strong> and <strong>forget</strong> information thus alleviating the problem of vanishing gradients，可以缓解Vanishing and Exploding Gradient Problem。复杂的门可以接下来更新的时候“记住”前几次训练的“残留记忆”。</p>
<p>中间的具体对应关系参考下面的建模方法的图c，有点复杂： $$<br>g<em>t^f=\delta_f (W_f[h</em>{t-1},o<em>t]+b_f) , \space\space g_t^i =\delta_i (W_i[h</em>{t-1},o<em>t]+b_i)\\<br>\tilde{c}_t = tanh(W_c[h</em>{t-1},o<em>t]+b_t), \space c_t = g_t^f \odot c</em>{t-1} +g<em>t^i \odot \tilde{c}_t\\<br>g_t^o = \delta_h(W_h[h</em>{t-1},o_t]+b_h), \space\space h_t =g_t^o \odot tanh(c_t)</p>
<p>$$ 有点像电路板，<em>gtf</em>, <em>gti</em>, <em>gto</em>分别代表forget, input, output gates. <em>ot</em> is the observable input at time t, <em>ht</em> is the hidden state, <em>ct</em> is the cell state, W is weight matrices, b is biases. The symbol ⊙ denotes the element-wise product. <em>δ</em> is <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Sigmoid_function">Sigmoid function</a>. The dimension of the hidden state <em>dh</em> (number of hidden units) controls the capacity of the cell to encode history information. The hidden-to-output functional form <em>fho</em> is given by a linear layer: <em>ôt</em> + 1 = <em>Woht</em>, <em>Wo</em> ∈ <em>Rd</em>0 × <em>dh</em></p>
<p><strong>Reservior Computing</strong></p>
<p><strong>Reservoir computing</strong> is a framework for computation derived from <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Recurrent_neural_network">recurrent neural network</a> theory that maps input signals into higher dimensional computational spaces through the dynamics of a fixed, non-linear system called a reservoir.<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Reservoir_computing#cite_note-:4-1">[1]</a> After the input signal is fed into the reservoir, which is treated as a “black box,” a simple readout mechanism is trained to read the state of the reservoir and map it to the desired output.<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Reservoir_computing#cite_note-:4-1">[1]</a> The first key benefit of this framework is that training is performed only at the readout stage, as the reservoir dynamics are fixed.<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Reservoir_computing#cite_note-:4-1">[1]</a> The second is that the computational power of naturally available systems, both classical and quantum mechanical, can be utilized to reduce the effective computational cost.<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Reservoir_computing#cite_note-2">[2]</a></p>
<p><strong>建模方法</strong></p>
<p>机器学习预测时间序列。给定等间隔1/<em>trianglet</em>采样，可观测序列<em>o</em> ∈ <em>Rdo</em> ,{<em>o</em>1, …, <em>oT</em>}。输入前一个时间点的状态<em>ht</em> ∈ <em>Rdh</em>. <em>ht</em> = <em>fhh</em>(<em>ot</em>, <em>ht</em> − 1), <em>ôt</em> + 1 = <em>fho</em>(<em>ht</em>) <em>fhh</em> is hidden-to-hidden mapping, <em>fho</em> is the hidden-to-output mapping. 下面这四种模型都是这种结构，只是对f的实现和参数有所差异。参见：<sup><a href="#fn_4" id="reffn_4">4</a></sup></p>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/Jiaqi-knight/imgBase@main/2020-12-1182528.png" alt="https://cdn.jsdelivr.net/gh/Jiaqi-knight/imgBase@main/2020-12-1182528.png"></p>
<p>示意图</p>
<p><a target="_blank" rel="noopener" href="https://github.com/pvlachas/char-rnn">具体算法请参考</a></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Jiaqi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://deal-ii.com/post/f2bbe0e7/">http://deal-ii.com/post/f2bbe0e7/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://deal-ii.com" target="_blank">DEAL-II-Fluid</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/machine-learning/">machine learning</a><a class="post-meta__tags" href="/tags/chao-s-theory/">chao's theory</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/03/30/ULzlsMHcmNjKaQt.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/d03a598f/"><img class="prev-cover" data-src="https://i.loli.net/2020/12/13/CRJOLzqKD6FlQWx.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">machine learning for chaos system-测试篇</div></div></a></div><div class="next-post pull-right"><a href="/post/845ed395/"><img class="next-cover" data-src="https://cdn.jsdelivr.net/gh/Jiaqi-knight/imgBase@main/chaoblogcover.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Dynamical system and chaos</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/post/47358f5f/" title="machine learning for chaos system-应用"><img class="relatedPosts_cover" data-src="https://npg.copernicus.org/articles/27/373/2020/npg-27-373-2020-avatar-web.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-11</div><div class="relatedPosts_title">machine learning for chaos system-应用</div></div></a></div><div class="relatedPosts_item"><a href="/post/d03a598f/" title="machine learning for chaos system-测试篇"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/12/13/CRJOLzqKD6FlQWx.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-11</div><div class="relatedPosts_title">machine learning for chaos system-测试篇</div></div></a></div><div class="relatedPosts_item"><a href="/post/9864ea21/" title="machine learning for chaos system-执行篇"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/12/22/d7YjSwNqreOA91K.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-22</div><div class="relatedPosts_title">machine learning for chaos system-执行篇</div></div></a></div><div class="relatedPosts_item"><a href="/post/845ed395/" title="Dynamical system and chaos"><img class="relatedPosts_cover" data-src="https://cdn.jsdelivr.net/gh/Jiaqi-knight/imgBase@main/chaoblogcover.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-11</div><div class="relatedPosts_title">Dynamical system and chaos</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headling"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div class="comments-items-1" data-name="Valine"><div class="vcomment" id="vcomment"></div><script>function loadvaline () {  
  var requestSetting = function (from,set) {
    var from = from
    var setting = set.split(',').filter(function(item){
    return from.indexOf(item) > -1
    });
    setting = setting.length == 0 ? from :setting;
    return setting
  }

  var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
  var requiredFields = requestSetting(['nick','mail'],'nick,mail')

  function initValine () {
    window.valine = new Valine({
      el:'#vcomment',
      appId: 'lJ3vEzEWaeVa6HpWNNbPrauw-gzGzoHsz',
      appKey: '16FI6zgDXwvw71g04yhHnnW0',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: guestInfo,
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      requiredFields: requiredFields
    });
  }
  loadScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || false) {
  window.addEventListener('load', loadvaline)
}
else {
  function loadOtherComment () {
    loadvaline()
  }
}</script></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021  <i id="heartbeat" class="fa fas fa-heartbeat"></i> Jiaqi</div><div class="framework-info"><span>驱动 </span><a target="_blank" rel="noopener" href="https://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div><head><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></head></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/calendar.js"></script><script src="/js/languages.js"></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><script src="/gitcalendar/js/gitcalendar.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"right","width":120,"height":260},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>